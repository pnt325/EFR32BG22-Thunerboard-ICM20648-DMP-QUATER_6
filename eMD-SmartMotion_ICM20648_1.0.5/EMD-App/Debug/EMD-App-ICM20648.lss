
EMD-App-ICM20648.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001daac  00400000  00400000  00010000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0041daac  0041daac  0002daac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000d08  20000000  0041dab4  00030000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          000012a4  20000d08  0041e7c0  00030d08  2**3
                  ALLOC
  4 .stack        00003004  20001fac  0041fa64  00030d08  2**0
                  ALLOC
  5 .ARM.attributes 00000030  00000000  00000000  00030d08  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00030d38  2**0
                  CONTENTS, READONLY
  7 .debug_info   000396ff  00000000  00000000  00030d91  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00006392  00000000  00000000  0006a490  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001a58  00000000  00000000  00070822  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  0001bd43  00000000  00000000  0007227a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000180db  00000000  00000000  0008dfbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00061178  00000000  00000000  000a6098  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000ed44  00000000  00000000  00107210  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000018a8  00000000  00000000  00115f54  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00007e90  00000000  00000000  001177fc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	b0 4f 00 20 45 45 40 00 15 46 40 00 15 46 40 00     .O. EE@..F@..F@.
  400010:	15 46 40 00 15 46 40 00 15 46 40 00 00 00 00 00     .F@..F@..F@.....
	...
  40002c:	15 46 40 00 15 46 40 00 00 00 00 00 15 46 40 00     .F@..F@......F@.
  40003c:	6d 32 40 00 15 46 40 00 15 46 40 00 15 46 40 00     m2@..F@..F@..F@.
  40004c:	15 46 40 00 15 46 40 00 15 46 40 00 15 46 40 00     .F@..F@..F@..F@.
  40005c:	15 46 40 00 8d 2f 40 00 15 46 40 00 00 00 00 00     .F@../@..F@.....
  40006c:	35 07 40 00 4d 07 40 00 15 46 40 00 15 46 40 00     5.@.M.@..F@..F@.
  40007c:	15 46 40 00 15 46 40 00 15 46 40 00 15 46 40 00     .F@..F@..F@..F@.
  40008c:	15 46 40 00 15 46 40 00 15 46 40 00 15 46 40 00     .F@..F@..F@..F@.
  40009c:	21 32 40 00 15 46 40 00 15 46 40 00 15 46 40 00     !2@..F@..F@..F@.
  4000ac:	15 46 40 00 15 46 40 00 15 46 40 00 15 46 40 00     .F@..F@..F@..F@.
	...
  4000fc:	15 46 40 00 15 46 40 00 15 46 40 00 00 00 00 00     .F@..F@..F@.....
	...

00400148 <__do_global_dtors_aux>:
  400148:	b510      	push	{r4, lr}
  40014a:	4c05      	ldr	r4, [pc, #20]	; (400160 <__do_global_dtors_aux+0x18>)
  40014c:	7823      	ldrb	r3, [r4, #0]
  40014e:	b933      	cbnz	r3, 40015e <__do_global_dtors_aux+0x16>
  400150:	4b04      	ldr	r3, [pc, #16]	; (400164 <__do_global_dtors_aux+0x1c>)
  400152:	b113      	cbz	r3, 40015a <__do_global_dtors_aux+0x12>
  400154:	4804      	ldr	r0, [pc, #16]	; (400168 <__do_global_dtors_aux+0x20>)
  400156:	f3af 8000 	nop.w
  40015a:	2301      	movs	r3, #1
  40015c:	7023      	strb	r3, [r4, #0]
  40015e:	bd10      	pop	{r4, pc}
  400160:	20000d08 	.word	0x20000d08
  400164:	00000000 	.word	0x00000000
  400168:	0041dab4 	.word	0x0041dab4

0040016c <frame_dummy>:
  40016c:	4b0c      	ldr	r3, [pc, #48]	; (4001a0 <frame_dummy+0x34>)
  40016e:	b143      	cbz	r3, 400182 <frame_dummy+0x16>
  400170:	480c      	ldr	r0, [pc, #48]	; (4001a4 <frame_dummy+0x38>)
  400172:	490d      	ldr	r1, [pc, #52]	; (4001a8 <frame_dummy+0x3c>)
  400174:	b510      	push	{r4, lr}
  400176:	f3af 8000 	nop.w
  40017a:	480c      	ldr	r0, [pc, #48]	; (4001ac <frame_dummy+0x40>)
  40017c:	6803      	ldr	r3, [r0, #0]
  40017e:	b923      	cbnz	r3, 40018a <frame_dummy+0x1e>
  400180:	bd10      	pop	{r4, pc}
  400182:	480a      	ldr	r0, [pc, #40]	; (4001ac <frame_dummy+0x40>)
  400184:	6803      	ldr	r3, [r0, #0]
  400186:	b933      	cbnz	r3, 400196 <frame_dummy+0x2a>
  400188:	4770      	bx	lr
  40018a:	4b09      	ldr	r3, [pc, #36]	; (4001b0 <frame_dummy+0x44>)
  40018c:	2b00      	cmp	r3, #0
  40018e:	d0f7      	beq.n	400180 <frame_dummy+0x14>
  400190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400194:	4718      	bx	r3
  400196:	4b06      	ldr	r3, [pc, #24]	; (4001b0 <frame_dummy+0x44>)
  400198:	2b00      	cmp	r3, #0
  40019a:	d0f5      	beq.n	400188 <frame_dummy+0x1c>
  40019c:	4718      	bx	r3
  40019e:	bf00      	nop
  4001a0:	00000000 	.word	0x00000000
  4001a4:	0041dab4 	.word	0x0041dab4
  4001a8:	20000d0c 	.word	0x20000d0c
  4001ac:	0041dab4 	.word	0x0041dab4
  4001b0:	00000000 	.word	0x00000000

004001b4 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  4001b4:	b480      	push	{r7}
  4001b6:	b085      	sub	sp, #20
  4001b8:	af00      	add	r7, sp, #0
  4001ba:	60f8      	str	r0, [r7, #12]
  4001bc:	60b9      	str	r1, [r7, #8]
  4001be:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4001c0:	687b      	ldr	r3, [r7, #4]
  4001c2:	2b00      	cmp	r3, #0
  4001c4:	d003      	beq.n	4001ce <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  4001c6:	68fb      	ldr	r3, [r7, #12]
  4001c8:	68ba      	ldr	r2, [r7, #8]
  4001ca:	665a      	str	r2, [r3, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
	}
}
  4001cc:	e002      	b.n	4001d4 <pio_pull_up+0x20>
		p_pio->PIO_PUDR = ul_mask;
  4001ce:	68fb      	ldr	r3, [r7, #12]
  4001d0:	68ba      	ldr	r2, [r7, #8]
  4001d2:	661a      	str	r2, [r3, #96]	; 0x60
}
  4001d4:	bf00      	nop
  4001d6:	3714      	adds	r7, #20
  4001d8:	46bd      	mov	sp, r7
  4001da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001de:	4770      	bx	lr

004001e0 <pio_clear>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_clear(Pio *p_pio, const uint32_t ul_mask)
{
  4001e0:	b480      	push	{r7}
  4001e2:	b083      	sub	sp, #12
  4001e4:	af00      	add	r7, sp, #0
  4001e6:	6078      	str	r0, [r7, #4]
  4001e8:	6039      	str	r1, [r7, #0]
	p_pio->PIO_CODR = ul_mask;
  4001ea:	687b      	ldr	r3, [r7, #4]
  4001ec:	683a      	ldr	r2, [r7, #0]
  4001ee:	635a      	str	r2, [r3, #52]	; 0x34
}
  4001f0:	bf00      	nop
  4001f2:	370c      	adds	r7, #12
  4001f4:	46bd      	mov	sp, r7
  4001f6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001fa:	4770      	bx	lr

004001fc <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  4001fc:	b480      	push	{r7}
  4001fe:	b087      	sub	sp, #28
  400200:	af00      	add	r7, sp, #0
  400202:	60f8      	str	r0, [r7, #12]
  400204:	60b9      	str	r1, [r7, #8]
  400206:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  400208:	68fb      	ldr	r3, [r7, #12]
  40020a:	687a      	ldr	r2, [r7, #4]
  40020c:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40020e:	68bb      	ldr	r3, [r7, #8]
  400210:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  400214:	d02b      	beq.n	40026e <pio_set_peripheral+0x72>
  400216:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  40021a:	d805      	bhi.n	400228 <pio_set_peripheral+0x2c>
  40021c:	2b00      	cmp	r3, #0
  40021e:	d03f      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  400220:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  400224:	d00a      	beq.n	40023c <pio_set_peripheral+0x40>
  400226:	e037      	b.n	400298 <pio_set_peripheral+0x9c>
  400228:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  40022c:	d038      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  40022e:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  400232:	d035      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  400234:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  400238:	d032      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  40023a:	e02d      	b.n	400298 <pio_set_peripheral+0x9c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40023c:	68fb      	ldr	r3, [r7, #12]
  40023e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400240:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400242:	68fb      	ldr	r3, [r7, #12]
  400244:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400246:	687b      	ldr	r3, [r7, #4]
  400248:	43d9      	mvns	r1, r3
  40024a:	697b      	ldr	r3, [r7, #20]
  40024c:	400b      	ands	r3, r1
  40024e:	401a      	ands	r2, r3
  400250:	68fb      	ldr	r3, [r7, #12]
  400252:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400254:	68fb      	ldr	r3, [r7, #12]
  400256:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400258:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  40025a:	68fb      	ldr	r3, [r7, #12]
  40025c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40025e:	687b      	ldr	r3, [r7, #4]
  400260:	43d9      	mvns	r1, r3
  400262:	697b      	ldr	r3, [r7, #20]
  400264:	400b      	ands	r3, r1
  400266:	401a      	ands	r2, r3
  400268:	68fb      	ldr	r3, [r7, #12]
  40026a:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  40026c:	e014      	b.n	400298 <pio_set_peripheral+0x9c>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40026e:	68fb      	ldr	r3, [r7, #12]
  400270:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400272:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400274:	687a      	ldr	r2, [r7, #4]
  400276:	697b      	ldr	r3, [r7, #20]
  400278:	431a      	orrs	r2, r3
  40027a:	68fb      	ldr	r3, [r7, #12]
  40027c:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40027e:	68fb      	ldr	r3, [r7, #12]
  400280:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400282:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400284:	68fb      	ldr	r3, [r7, #12]
  400286:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400288:	687b      	ldr	r3, [r7, #4]
  40028a:	43d9      	mvns	r1, r3
  40028c:	697b      	ldr	r3, [r7, #20]
  40028e:	400b      	ands	r3, r1
  400290:	401a      	ands	r2, r3
  400292:	68fb      	ldr	r3, [r7, #12]
  400294:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400296:	bf00      	nop
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  400298:	68fb      	ldr	r3, [r7, #12]
  40029a:	687a      	ldr	r2, [r7, #4]
  40029c:	605a      	str	r2, [r3, #4]
  40029e:	e000      	b.n	4002a2 <pio_set_peripheral+0xa6>
		return;
  4002a0:	bf00      	nop
}
  4002a2:	371c      	adds	r7, #28
  4002a4:	46bd      	mov	sp, r7
  4002a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002aa:	4770      	bx	lr

004002ac <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  4002ac:	b580      	push	{r7, lr}
  4002ae:	b084      	sub	sp, #16
  4002b0:	af00      	add	r7, sp, #0
  4002b2:	60f8      	str	r0, [r7, #12]
  4002b4:	60b9      	str	r1, [r7, #8]
  4002b6:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  4002b8:	68b9      	ldr	r1, [r7, #8]
  4002ba:	68f8      	ldr	r0, [r7, #12]
  4002bc:	4b19      	ldr	r3, [pc, #100]	; (400324 <pio_set_input+0x78>)
  4002be:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  4002c0:	687b      	ldr	r3, [r7, #4]
  4002c2:	f003 0301 	and.w	r3, r3, #1
  4002c6:	461a      	mov	r2, r3
  4002c8:	68b9      	ldr	r1, [r7, #8]
  4002ca:	68f8      	ldr	r0, [r7, #12]
  4002cc:	4b16      	ldr	r3, [pc, #88]	; (400328 <pio_set_input+0x7c>)
  4002ce:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  4002d0:	687b      	ldr	r3, [r7, #4]
  4002d2:	f003 030a 	and.w	r3, r3, #10
  4002d6:	2b00      	cmp	r3, #0
  4002d8:	d003      	beq.n	4002e2 <pio_set_input+0x36>
		p_pio->PIO_IFER = ul_mask;
  4002da:	68fb      	ldr	r3, [r7, #12]
  4002dc:	68ba      	ldr	r2, [r7, #8]
  4002de:	621a      	str	r2, [r3, #32]
  4002e0:	e002      	b.n	4002e8 <pio_set_input+0x3c>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  4002e2:	68fb      	ldr	r3, [r7, #12]
  4002e4:	68ba      	ldr	r2, [r7, #8]
  4002e6:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  4002e8:	687b      	ldr	r3, [r7, #4]
  4002ea:	f003 0302 	and.w	r3, r3, #2
  4002ee:	2b00      	cmp	r3, #0
  4002f0:	d004      	beq.n	4002fc <pio_set_input+0x50>
		p_pio->PIO_IFSCDR = ul_mask;
  4002f2:	68fb      	ldr	r3, [r7, #12]
  4002f4:	68ba      	ldr	r2, [r7, #8]
  4002f6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  4002fa:	e008      	b.n	40030e <pio_set_input+0x62>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  4002fc:	687b      	ldr	r3, [r7, #4]
  4002fe:	f003 0308 	and.w	r3, r3, #8
  400302:	2b00      	cmp	r3, #0
  400304:	d003      	beq.n	40030e <pio_set_input+0x62>
			p_pio->PIO_IFSCER = ul_mask;
  400306:	68fb      	ldr	r3, [r7, #12]
  400308:	68ba      	ldr	r2, [r7, #8]
  40030a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  40030e:	68fb      	ldr	r3, [r7, #12]
  400310:	68ba      	ldr	r2, [r7, #8]
  400312:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  400314:	68fb      	ldr	r3, [r7, #12]
  400316:	68ba      	ldr	r2, [r7, #8]
  400318:	601a      	str	r2, [r3, #0]
}
  40031a:	bf00      	nop
  40031c:	3710      	adds	r7, #16
  40031e:	46bd      	mov	sp, r7
  400320:	bd80      	pop	{r7, pc}
  400322:	bf00      	nop
  400324:	004004dd 	.word	0x004004dd
  400328:	004001b5 	.word	0x004001b5

0040032c <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  40032c:	b580      	push	{r7, lr}
  40032e:	b084      	sub	sp, #16
  400330:	af00      	add	r7, sp, #0
  400332:	60f8      	str	r0, [r7, #12]
  400334:	60b9      	str	r1, [r7, #8]
  400336:	607a      	str	r2, [r7, #4]
  400338:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
  40033a:	68b9      	ldr	r1, [r7, #8]
  40033c:	68f8      	ldr	r0, [r7, #12]
  40033e:	4b12      	ldr	r3, [pc, #72]	; (400388 <pio_set_output+0x5c>)
  400340:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  400342:	69ba      	ldr	r2, [r7, #24]
  400344:	68b9      	ldr	r1, [r7, #8]
  400346:	68f8      	ldr	r0, [r7, #12]
  400348:	4b10      	ldr	r3, [pc, #64]	; (40038c <pio_set_output+0x60>)
  40034a:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40034c:	683b      	ldr	r3, [r7, #0]
  40034e:	2b00      	cmp	r3, #0
  400350:	d003      	beq.n	40035a <pio_set_output+0x2e>
		p_pio->PIO_MDER = ul_mask;
  400352:	68fb      	ldr	r3, [r7, #12]
  400354:	68ba      	ldr	r2, [r7, #8]
  400356:	651a      	str	r2, [r3, #80]	; 0x50
  400358:	e002      	b.n	400360 <pio_set_output+0x34>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  40035a:	68fb      	ldr	r3, [r7, #12]
  40035c:	68ba      	ldr	r2, [r7, #8]
  40035e:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  400360:	687b      	ldr	r3, [r7, #4]
  400362:	2b00      	cmp	r3, #0
  400364:	d003      	beq.n	40036e <pio_set_output+0x42>
		p_pio->PIO_SODR = ul_mask;
  400366:	68fb      	ldr	r3, [r7, #12]
  400368:	68ba      	ldr	r2, [r7, #8]
  40036a:	631a      	str	r2, [r3, #48]	; 0x30
  40036c:	e002      	b.n	400374 <pio_set_output+0x48>
	} else {
		p_pio->PIO_CODR = ul_mask;
  40036e:	68fb      	ldr	r3, [r7, #12]
  400370:	68ba      	ldr	r2, [r7, #8]
  400372:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  400374:	68fb      	ldr	r3, [r7, #12]
  400376:	68ba      	ldr	r2, [r7, #8]
  400378:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
  40037a:	68fb      	ldr	r3, [r7, #12]
  40037c:	68ba      	ldr	r2, [r7, #8]
  40037e:	601a      	str	r2, [r3, #0]
}
  400380:	bf00      	nop
  400382:	3710      	adds	r7, #16
  400384:	46bd      	mov	sp, r7
  400386:	bd80      	pop	{r7, pc}
  400388:	004004dd 	.word	0x004004dd
  40038c:	004001b5 	.word	0x004001b5

00400390 <pio_configure>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask, const uint32_t ul_attribute)
{
  400390:	b590      	push	{r4, r7, lr}
  400392:	b087      	sub	sp, #28
  400394:	af02      	add	r7, sp, #8
  400396:	60f8      	str	r0, [r7, #12]
  400398:	60b9      	str	r1, [r7, #8]
  40039a:	607a      	str	r2, [r7, #4]
  40039c:	603b      	str	r3, [r7, #0]
	/* Configure pins */
	switch (ul_type) {
  40039e:	68bb      	ldr	r3, [r7, #8]
  4003a0:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4003a4:	d01e      	beq.n	4003e4 <pio_configure+0x54>
  4003a6:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4003aa:	d806      	bhi.n	4003ba <pio_configure+0x2a>
  4003ac:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4003b0:	d00a      	beq.n	4003c8 <pio_configure+0x38>
  4003b2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  4003b6:	d007      	beq.n	4003c8 <pio_configure+0x38>
  4003b8:	e03a      	b.n	400430 <pio_configure+0xa0>
  4003ba:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  4003be:	d017      	beq.n	4003f0 <pio_configure+0x60>
  4003c0:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4003c4:	d014      	beq.n	4003f0 <pio_configure+0x60>
  4003c6:	e033      	b.n	400430 <pio_configure+0xa0>
	case PIO_PERIPH_B:
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	case PIO_PERIPH_C:
	case PIO_PERIPH_D:
#endif
		pio_set_peripheral(p_pio, ul_type, ul_mask);
  4003c8:	687a      	ldr	r2, [r7, #4]
  4003ca:	68b9      	ldr	r1, [r7, #8]
  4003cc:	68f8      	ldr	r0, [r7, #12]
  4003ce:	4b1c      	ldr	r3, [pc, #112]	; (400440 <pio_configure+0xb0>)
  4003d0:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_attribute & PIO_PULLUP));
  4003d2:	683b      	ldr	r3, [r7, #0]
  4003d4:	f003 0301 	and.w	r3, r3, #1
  4003d8:	461a      	mov	r2, r3
  4003da:	6879      	ldr	r1, [r7, #4]
  4003dc:	68f8      	ldr	r0, [r7, #12]
  4003de:	4b19      	ldr	r3, [pc, #100]	; (400444 <pio_configure+0xb4>)
  4003e0:	4798      	blx	r3
		break;
  4003e2:	e027      	b.n	400434 <pio_configure+0xa4>

	case PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_attribute);
  4003e4:	683a      	ldr	r2, [r7, #0]
  4003e6:	6879      	ldr	r1, [r7, #4]
  4003e8:	68f8      	ldr	r0, [r7, #12]
  4003ea:	4b17      	ldr	r3, [pc, #92]	; (400448 <pio_configure+0xb8>)
  4003ec:	4798      	blx	r3
		break;
  4003ee:	e021      	b.n	400434 <pio_configure+0xa4>

	case PIO_OUTPUT_0:
	case PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  4003f0:	68bb      	ldr	r3, [r7, #8]
  4003f2:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4003f6:	bf0c      	ite	eq
  4003f8:	2301      	moveq	r3, #1
  4003fa:	2300      	movne	r3, #0
  4003fc:	b2db      	uxtb	r3, r3
  4003fe:	461a      	mov	r2, r3
				(ul_attribute & PIO_OPENDRAIN) ? 1 : 0,
  400400:	683b      	ldr	r3, [r7, #0]
  400402:	f003 0304 	and.w	r3, r3, #4
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  400406:	2b00      	cmp	r3, #0
  400408:	bf14      	ite	ne
  40040a:	2301      	movne	r3, #1
  40040c:	2300      	moveq	r3, #0
  40040e:	b2db      	uxtb	r3, r3
  400410:	4619      	mov	r1, r3
				(ul_attribute & PIO_PULLUP) ? 1 : 0);
  400412:	683b      	ldr	r3, [r7, #0]
  400414:	f003 0301 	and.w	r3, r3, #1
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  400418:	2b00      	cmp	r3, #0
  40041a:	bf14      	ite	ne
  40041c:	2301      	movne	r3, #1
  40041e:	2300      	moveq	r3, #0
  400420:	b2db      	uxtb	r3, r3
  400422:	9300      	str	r3, [sp, #0]
  400424:	460b      	mov	r3, r1
  400426:	6879      	ldr	r1, [r7, #4]
  400428:	68f8      	ldr	r0, [r7, #12]
  40042a:	4c08      	ldr	r4, [pc, #32]	; (40044c <pio_configure+0xbc>)
  40042c:	47a0      	blx	r4
		break;
  40042e:	e001      	b.n	400434 <pio_configure+0xa4>

	default:
		return 0;
  400430:	2300      	movs	r3, #0
  400432:	e000      	b.n	400436 <pio_configure+0xa6>
	}

	return 1;
  400434:	2301      	movs	r3, #1
}
  400436:	4618      	mov	r0, r3
  400438:	3714      	adds	r7, #20
  40043a:	46bd      	mov	sp, r7
  40043c:	bd90      	pop	{r4, r7, pc}
  40043e:	bf00      	nop
  400440:	004001fd 	.word	0x004001fd
  400444:	004001b5 	.word	0x004001b5
  400448:	004002ad 	.word	0x004002ad
  40044c:	0040032d 	.word	0x0040032d

00400450 <pio_configure_interrupt>:
 * \param ul_mask Interrupt source bit map.
 * \param ul_attr Interrupt source attributes.
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
  400450:	b480      	push	{r7}
  400452:	b085      	sub	sp, #20
  400454:	af00      	add	r7, sp, #0
  400456:	60f8      	str	r0, [r7, #12]
  400458:	60b9      	str	r1, [r7, #8]
  40045a:	607a      	str	r2, [r7, #4]
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  40045c:	687b      	ldr	r3, [r7, #4]
  40045e:	f003 0310 	and.w	r3, r3, #16
  400462:	2b00      	cmp	r3, #0
  400464:	d020      	beq.n	4004a8 <pio_configure_interrupt+0x58>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  400466:	68fb      	ldr	r3, [r7, #12]
  400468:	68ba      	ldr	r2, [r7, #8]
  40046a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  40046e:	687b      	ldr	r3, [r7, #4]
  400470:	f003 0320 	and.w	r3, r3, #32
  400474:	2b00      	cmp	r3, #0
  400476:	d004      	beq.n	400482 <pio_configure_interrupt+0x32>
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  400478:	68fb      	ldr	r3, [r7, #12]
  40047a:	68ba      	ldr	r2, [r7, #8]
  40047c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  400480:	e003      	b.n	40048a <pio_configure_interrupt+0x3a>
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  400482:	68fb      	ldr	r3, [r7, #12]
  400484:	68ba      	ldr	r2, [r7, #8]
  400486:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  40048a:	687b      	ldr	r3, [r7, #4]
  40048c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  400490:	2b00      	cmp	r3, #0
  400492:	d004      	beq.n	40049e <pio_configure_interrupt+0x4e>
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  400494:	68fb      	ldr	r3, [r7, #12]
  400496:	68ba      	ldr	r2, [r7, #8]
  400498:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
	}
}
  40049c:	e008      	b.n	4004b0 <pio_configure_interrupt+0x60>
			p_pio->PIO_LSR = ul_mask;
  40049e:	68fb      	ldr	r3, [r7, #12]
  4004a0:	68ba      	ldr	r2, [r7, #8]
  4004a2:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
}
  4004a6:	e003      	b.n	4004b0 <pio_configure_interrupt+0x60>
		p_pio->PIO_AIMDR = ul_mask;
  4004a8:	68fb      	ldr	r3, [r7, #12]
  4004aa:	68ba      	ldr	r2, [r7, #8]
  4004ac:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
}
  4004b0:	bf00      	nop
  4004b2:	3714      	adds	r7, #20
  4004b4:	46bd      	mov	sp, r7
  4004b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004ba:	4770      	bx	lr

004004bc <pio_enable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  4004bc:	b480      	push	{r7}
  4004be:	b083      	sub	sp, #12
  4004c0:	af00      	add	r7, sp, #0
  4004c2:	6078      	str	r0, [r7, #4]
  4004c4:	6039      	str	r1, [r7, #0]
	p_pio->PIO_ISR;
  4004c6:	687b      	ldr	r3, [r7, #4]
  4004c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
	p_pio->PIO_IER = ul_mask;
  4004ca:	687b      	ldr	r3, [r7, #4]
  4004cc:	683a      	ldr	r2, [r7, #0]
  4004ce:	641a      	str	r2, [r3, #64]	; 0x40
}
  4004d0:	bf00      	nop
  4004d2:	370c      	adds	r7, #12
  4004d4:	46bd      	mov	sp, r7
  4004d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004da:	4770      	bx	lr

004004dc <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  4004dc:	b480      	push	{r7}
  4004de:	b083      	sub	sp, #12
  4004e0:	af00      	add	r7, sp, #0
  4004e2:	6078      	str	r0, [r7, #4]
  4004e4:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  4004e6:	687b      	ldr	r3, [r7, #4]
  4004e8:	683a      	ldr	r2, [r7, #0]
  4004ea:	645a      	str	r2, [r3, #68]	; 0x44
}
  4004ec:	bf00      	nop
  4004ee:	370c      	adds	r7, #12
  4004f0:	46bd      	mov	sp, r7
  4004f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004f6:	4770      	bx	lr

004004f8 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  4004f8:	b480      	push	{r7}
  4004fa:	b083      	sub	sp, #12
  4004fc:	af00      	add	r7, sp, #0
  4004fe:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  400500:	687b      	ldr	r3, [r7, #4]
  400502:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  400504:	4618      	mov	r0, r3
  400506:	370c      	adds	r7, #12
  400508:	46bd      	mov	sp, r7
  40050a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40050e:	4770      	bx	lr

00400510 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  400510:	b480      	push	{r7}
  400512:	b083      	sub	sp, #12
  400514:	af00      	add	r7, sp, #0
  400516:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  400518:	687b      	ldr	r3, [r7, #4]
  40051a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  40051c:	4618      	mov	r0, r3
  40051e:	370c      	adds	r7, #12
  400520:	46bd      	mov	sp, r7
  400522:	f85d 7b04 	ldr.w	r7, [sp], #4
  400526:	4770      	bx	lr

00400528 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  400528:	b480      	push	{r7}
  40052a:	b083      	sub	sp, #12
  40052c:	af00      	add	r7, sp, #0
  40052e:	4603      	mov	r3, r0
  400530:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  400532:	4909      	ldr	r1, [pc, #36]	; (400558 <NVIC_EnableIRQ+0x30>)
  400534:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400538:	095b      	lsrs	r3, r3, #5
  40053a:	79fa      	ldrb	r2, [r7, #7]
  40053c:	f002 021f 	and.w	r2, r2, #31
  400540:	2001      	movs	r0, #1
  400542:	fa00 f202 	lsl.w	r2, r0, r2
  400546:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40054a:	bf00      	nop
  40054c:	370c      	adds	r7, #12
  40054e:	46bd      	mov	sp, r7
  400550:	f85d 7b04 	ldr.w	r7, [sp], #4
  400554:	4770      	bx	lr
  400556:	bf00      	nop
  400558:	e000e100 	.word	0xe000e100

0040055c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  40055c:	b480      	push	{r7}
  40055e:	b083      	sub	sp, #12
  400560:	af00      	add	r7, sp, #0
  400562:	4603      	mov	r3, r0
  400564:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  400566:	4909      	ldr	r1, [pc, #36]	; (40058c <NVIC_DisableIRQ+0x30>)
  400568:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40056c:	095b      	lsrs	r3, r3, #5
  40056e:	79fa      	ldrb	r2, [r7, #7]
  400570:	f002 021f 	and.w	r2, r2, #31
  400574:	2001      	movs	r0, #1
  400576:	fa00 f202 	lsl.w	r2, r0, r2
  40057a:	3320      	adds	r3, #32
  40057c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  400580:	bf00      	nop
  400582:	370c      	adds	r7, #12
  400584:	46bd      	mov	sp, r7
  400586:	f85d 7b04 	ldr.w	r7, [sp], #4
  40058a:	4770      	bx	lr
  40058c:	e000e100 	.word	0xe000e100

00400590 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  400590:	b480      	push	{r7}
  400592:	b083      	sub	sp, #12
  400594:	af00      	add	r7, sp, #0
  400596:	4603      	mov	r3, r0
  400598:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40059a:	4909      	ldr	r1, [pc, #36]	; (4005c0 <NVIC_ClearPendingIRQ+0x30>)
  40059c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005a0:	095b      	lsrs	r3, r3, #5
  4005a2:	79fa      	ldrb	r2, [r7, #7]
  4005a4:	f002 021f 	and.w	r2, r2, #31
  4005a8:	2001      	movs	r0, #1
  4005aa:	fa00 f202 	lsl.w	r2, r0, r2
  4005ae:	3360      	adds	r3, #96	; 0x60
  4005b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  4005b4:	bf00      	nop
  4005b6:	370c      	adds	r7, #12
  4005b8:	46bd      	mov	sp, r7
  4005ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4005be:	4770      	bx	lr
  4005c0:	e000e100 	.word	0xe000e100

004005c4 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  4005c4:	b480      	push	{r7}
  4005c6:	b083      	sub	sp, #12
  4005c8:	af00      	add	r7, sp, #0
  4005ca:	4603      	mov	r3, r0
  4005cc:	6039      	str	r1, [r7, #0]
  4005ce:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  4005d0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005d4:	2b00      	cmp	r3, #0
  4005d6:	da0b      	bge.n	4005f0 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4005d8:	490d      	ldr	r1, [pc, #52]	; (400610 <NVIC_SetPriority+0x4c>)
  4005da:	79fb      	ldrb	r3, [r7, #7]
  4005dc:	f003 030f 	and.w	r3, r3, #15
  4005e0:	3b04      	subs	r3, #4
  4005e2:	683a      	ldr	r2, [r7, #0]
  4005e4:	b2d2      	uxtb	r2, r2
  4005e6:	0112      	lsls	r2, r2, #4
  4005e8:	b2d2      	uxtb	r2, r2
  4005ea:	440b      	add	r3, r1
  4005ec:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
  4005ee:	e009      	b.n	400604 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4005f0:	4908      	ldr	r1, [pc, #32]	; (400614 <NVIC_SetPriority+0x50>)
  4005f2:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005f6:	683a      	ldr	r2, [r7, #0]
  4005f8:	b2d2      	uxtb	r2, r2
  4005fa:	0112      	lsls	r2, r2, #4
  4005fc:	b2d2      	uxtb	r2, r2
  4005fe:	440b      	add	r3, r1
  400600:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  400604:	bf00      	nop
  400606:	370c      	adds	r7, #12
  400608:	46bd      	mov	sp, r7
  40060a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40060e:	4770      	bx	lr
  400610:	e000ed00 	.word	0xe000ed00
  400614:	e000e100 	.word	0xe000e100

00400618 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  400618:	b580      	push	{r7, lr}
  40061a:	b084      	sub	sp, #16
  40061c:	af00      	add	r7, sp, #0
  40061e:	6078      	str	r0, [r7, #4]
  400620:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  400622:	6878      	ldr	r0, [r7, #4]
  400624:	4b26      	ldr	r3, [pc, #152]	; (4006c0 <pio_handler_process+0xa8>)
  400626:	4798      	blx	r3
  400628:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  40062a:	6878      	ldr	r0, [r7, #4]
  40062c:	4b25      	ldr	r3, [pc, #148]	; (4006c4 <pio_handler_process+0xac>)
  40062e:	4798      	blx	r3
  400630:	4602      	mov	r2, r0
  400632:	68fb      	ldr	r3, [r7, #12]
  400634:	4013      	ands	r3, r2
  400636:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  400638:	68fb      	ldr	r3, [r7, #12]
  40063a:	2b00      	cmp	r3, #0
  40063c:	d03c      	beq.n	4006b8 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  40063e:	2300      	movs	r3, #0
  400640:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  400642:	e034      	b.n	4006ae <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  400644:	4a20      	ldr	r2, [pc, #128]	; (4006c8 <pio_handler_process+0xb0>)
  400646:	68bb      	ldr	r3, [r7, #8]
  400648:	011b      	lsls	r3, r3, #4
  40064a:	4413      	add	r3, r2
  40064c:	681a      	ldr	r2, [r3, #0]
  40064e:	683b      	ldr	r3, [r7, #0]
  400650:	429a      	cmp	r2, r3
  400652:	d126      	bne.n	4006a2 <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  400654:	4a1c      	ldr	r2, [pc, #112]	; (4006c8 <pio_handler_process+0xb0>)
  400656:	68bb      	ldr	r3, [r7, #8]
  400658:	011b      	lsls	r3, r3, #4
  40065a:	4413      	add	r3, r2
  40065c:	3304      	adds	r3, #4
  40065e:	681a      	ldr	r2, [r3, #0]
  400660:	68fb      	ldr	r3, [r7, #12]
  400662:	4013      	ands	r3, r2
  400664:	2b00      	cmp	r3, #0
  400666:	d01c      	beq.n	4006a2 <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  400668:	4a17      	ldr	r2, [pc, #92]	; (4006c8 <pio_handler_process+0xb0>)
  40066a:	68bb      	ldr	r3, [r7, #8]
  40066c:	011b      	lsls	r3, r3, #4
  40066e:	4413      	add	r3, r2
  400670:	330c      	adds	r3, #12
  400672:	681b      	ldr	r3, [r3, #0]
  400674:	4914      	ldr	r1, [pc, #80]	; (4006c8 <pio_handler_process+0xb0>)
  400676:	68ba      	ldr	r2, [r7, #8]
  400678:	0112      	lsls	r2, r2, #4
  40067a:	440a      	add	r2, r1
  40067c:	6810      	ldr	r0, [r2, #0]
  40067e:	4912      	ldr	r1, [pc, #72]	; (4006c8 <pio_handler_process+0xb0>)
  400680:	68ba      	ldr	r2, [r7, #8]
  400682:	0112      	lsls	r2, r2, #4
  400684:	440a      	add	r2, r1
  400686:	3204      	adds	r2, #4
  400688:	6812      	ldr	r2, [r2, #0]
  40068a:	4611      	mov	r1, r2
  40068c:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40068e:	4a0e      	ldr	r2, [pc, #56]	; (4006c8 <pio_handler_process+0xb0>)
  400690:	68bb      	ldr	r3, [r7, #8]
  400692:	011b      	lsls	r3, r3, #4
  400694:	4413      	add	r3, r2
  400696:	3304      	adds	r3, #4
  400698:	681b      	ldr	r3, [r3, #0]
  40069a:	43db      	mvns	r3, r3
  40069c:	68fa      	ldr	r2, [r7, #12]
  40069e:	4013      	ands	r3, r2
  4006a0:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  4006a2:	68bb      	ldr	r3, [r7, #8]
  4006a4:	3301      	adds	r3, #1
  4006a6:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  4006a8:	68bb      	ldr	r3, [r7, #8]
  4006aa:	2b06      	cmp	r3, #6
  4006ac:	d803      	bhi.n	4006b6 <pio_handler_process+0x9e>
		while (status != 0) {
  4006ae:	68fb      	ldr	r3, [r7, #12]
  4006b0:	2b00      	cmp	r3, #0
  4006b2:	d1c7      	bne.n	400644 <pio_handler_process+0x2c>
		if (pio_capture_handler) {
			pio_capture_handler(p_pio);
		}
	}
#endif
}
  4006b4:	e000      	b.n	4006b8 <pio_handler_process+0xa0>
				break;
  4006b6:	bf00      	nop
}
  4006b8:	bf00      	nop
  4006ba:	3710      	adds	r7, #16
  4006bc:	46bd      	mov	sp, r7
  4006be:	bd80      	pop	{r7, pc}
  4006c0:	004004f9 	.word	0x004004f9
  4006c4:	00400511 	.word	0x00400511
  4006c8:	20000d24 	.word	0x20000d24

004006cc <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4006cc:	b580      	push	{r7, lr}
  4006ce:	b086      	sub	sp, #24
  4006d0:	af00      	add	r7, sp, #0
  4006d2:	60f8      	str	r0, [r7, #12]
  4006d4:	60b9      	str	r1, [r7, #8]
  4006d6:	607a      	str	r2, [r7, #4]
  4006d8:	603b      	str	r3, [r7, #0]
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4006da:	4b13      	ldr	r3, [pc, #76]	; (400728 <pio_handler_set+0x5c>)
  4006dc:	681b      	ldr	r3, [r3, #0]
  4006de:	2b06      	cmp	r3, #6
  4006e0:	d901      	bls.n	4006e6 <pio_handler_set+0x1a>
		return 1;
  4006e2:	2301      	movs	r3, #1
  4006e4:	e01c      	b.n	400720 <pio_handler_set+0x54>

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  4006e6:	4b10      	ldr	r3, [pc, #64]	; (400728 <pio_handler_set+0x5c>)
  4006e8:	681b      	ldr	r3, [r3, #0]
  4006ea:	011b      	lsls	r3, r3, #4
  4006ec:	4a0f      	ldr	r2, [pc, #60]	; (40072c <pio_handler_set+0x60>)
  4006ee:	4413      	add	r3, r2
  4006f0:	617b      	str	r3, [r7, #20]
	pSource->id = ul_id;
  4006f2:	697b      	ldr	r3, [r7, #20]
  4006f4:	68ba      	ldr	r2, [r7, #8]
  4006f6:	601a      	str	r2, [r3, #0]
	pSource->mask = ul_mask;
  4006f8:	697b      	ldr	r3, [r7, #20]
  4006fa:	687a      	ldr	r2, [r7, #4]
  4006fc:	605a      	str	r2, [r3, #4]
	pSource->attr = ul_attr;
  4006fe:	697b      	ldr	r3, [r7, #20]
  400700:	683a      	ldr	r2, [r7, #0]
  400702:	609a      	str	r2, [r3, #8]
	pSource->handler = p_handler;
  400704:	697b      	ldr	r3, [r7, #20]
  400706:	6a3a      	ldr	r2, [r7, #32]
  400708:	60da      	str	r2, [r3, #12]
	gs_ul_nb_sources++;
  40070a:	4b07      	ldr	r3, [pc, #28]	; (400728 <pio_handler_set+0x5c>)
  40070c:	681b      	ldr	r3, [r3, #0]
  40070e:	3301      	adds	r3, #1
  400710:	4a05      	ldr	r2, [pc, #20]	; (400728 <pio_handler_set+0x5c>)
  400712:	6013      	str	r3, [r2, #0]

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  400714:	683a      	ldr	r2, [r7, #0]
  400716:	6879      	ldr	r1, [r7, #4]
  400718:	68f8      	ldr	r0, [r7, #12]
  40071a:	4b05      	ldr	r3, [pc, #20]	; (400730 <pio_handler_set+0x64>)
  40071c:	4798      	blx	r3

	return 0;
  40071e:	2300      	movs	r3, #0
}
  400720:	4618      	mov	r0, r3
  400722:	3718      	adds	r7, #24
  400724:	46bd      	mov	sp, r7
  400726:	bd80      	pop	{r7, pc}
  400728:	20000d94 	.word	0x20000d94
  40072c:	20000d24 	.word	0x20000d24
  400730:	00400451 	.word	0x00400451

00400734 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  400734:	b580      	push	{r7, lr}
  400736:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  400738:	210b      	movs	r1, #11
  40073a:	4802      	ldr	r0, [pc, #8]	; (400744 <PIOA_Handler+0x10>)
  40073c:	4b02      	ldr	r3, [pc, #8]	; (400748 <PIOA_Handler+0x14>)
  40073e:	4798      	blx	r3
}
  400740:	bf00      	nop
  400742:	bd80      	pop	{r7, pc}
  400744:	400e0e00 	.word	0x400e0e00
  400748:	00400619 	.word	0x00400619

0040074c <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40074c:	b580      	push	{r7, lr}
  40074e:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  400750:	210c      	movs	r1, #12
  400752:	4802      	ldr	r0, [pc, #8]	; (40075c <PIOB_Handler+0x10>)
  400754:	4b02      	ldr	r3, [pc, #8]	; (400760 <PIOB_Handler+0x14>)
  400756:	4798      	blx	r3
}
  400758:	bf00      	nop
  40075a:	bd80      	pop	{r7, pc}
  40075c:	400e1000 	.word	0x400e1000
  400760:	00400619 	.word	0x00400619

00400764 <pio_handler_set_priority>:
 * \param p_pio PIO controller base address.
 * \param ul_irqn NVIC line number.
 * \param ul_priority PIO controller interrupts priority.
 */
void pio_handler_set_priority(Pio *p_pio, IRQn_Type ul_irqn, uint32_t ul_priority)
{
  400764:	b580      	push	{r7, lr}
  400766:	b086      	sub	sp, #24
  400768:	af00      	add	r7, sp, #0
  40076a:	60f8      	str	r0, [r7, #12]
  40076c:	460b      	mov	r3, r1
  40076e:	607a      	str	r2, [r7, #4]
  400770:	72fb      	strb	r3, [r7, #11]
	uint32_t bitmask = 0;
  400772:	2300      	movs	r3, #0
  400774:	617b      	str	r3, [r7, #20]

	bitmask = pio_get_interrupt_mask(p_pio);
  400776:	68f8      	ldr	r0, [r7, #12]
  400778:	4b13      	ldr	r3, [pc, #76]	; (4007c8 <pio_handler_set_priority+0x64>)
  40077a:	4798      	blx	r3
  40077c:	6178      	str	r0, [r7, #20]
	pio_disable_interrupt(p_pio, 0xFFFFFFFF);
  40077e:	f04f 31ff 	mov.w	r1, #4294967295
  400782:	68f8      	ldr	r0, [r7, #12]
  400784:	4b11      	ldr	r3, [pc, #68]	; (4007cc <pio_handler_set_priority+0x68>)
  400786:	4798      	blx	r3
	pio_get_interrupt_status(p_pio);
  400788:	68f8      	ldr	r0, [r7, #12]
  40078a:	4b11      	ldr	r3, [pc, #68]	; (4007d0 <pio_handler_set_priority+0x6c>)
  40078c:	4798      	blx	r3
	NVIC_DisableIRQ(ul_irqn);
  40078e:	f997 300b 	ldrsb.w	r3, [r7, #11]
  400792:	4618      	mov	r0, r3
  400794:	4b0f      	ldr	r3, [pc, #60]	; (4007d4 <pio_handler_set_priority+0x70>)
  400796:	4798      	blx	r3
	NVIC_ClearPendingIRQ(ul_irqn);
  400798:	f997 300b 	ldrsb.w	r3, [r7, #11]
  40079c:	4618      	mov	r0, r3
  40079e:	4b0e      	ldr	r3, [pc, #56]	; (4007d8 <pio_handler_set_priority+0x74>)
  4007a0:	4798      	blx	r3
	NVIC_SetPriority(ul_irqn, ul_priority);
  4007a2:	f997 300b 	ldrsb.w	r3, [r7, #11]
  4007a6:	6879      	ldr	r1, [r7, #4]
  4007a8:	4618      	mov	r0, r3
  4007aa:	4b0c      	ldr	r3, [pc, #48]	; (4007dc <pio_handler_set_priority+0x78>)
  4007ac:	4798      	blx	r3
	NVIC_EnableIRQ(ul_irqn);
  4007ae:	f997 300b 	ldrsb.w	r3, [r7, #11]
  4007b2:	4618      	mov	r0, r3
  4007b4:	4b0a      	ldr	r3, [pc, #40]	; (4007e0 <pio_handler_set_priority+0x7c>)
  4007b6:	4798      	blx	r3
	pio_enable_interrupt(p_pio, bitmask);
  4007b8:	6979      	ldr	r1, [r7, #20]
  4007ba:	68f8      	ldr	r0, [r7, #12]
  4007bc:	4b09      	ldr	r3, [pc, #36]	; (4007e4 <pio_handler_set_priority+0x80>)
  4007be:	4798      	blx	r3
}
  4007c0:	bf00      	nop
  4007c2:	3718      	adds	r7, #24
  4007c4:	46bd      	mov	sp, r7
  4007c6:	bd80      	pop	{r7, pc}
  4007c8:	00400511 	.word	0x00400511
  4007cc:	004004dd 	.word	0x004004dd
  4007d0:	004004f9 	.word	0x004004f9
  4007d4:	0040055d 	.word	0x0040055d
  4007d8:	00400591 	.word	0x00400591
  4007dc:	004005c5 	.word	0x004005c5
  4007e0:	00400529 	.word	0x00400529
  4007e4:	004004bd 	.word	0x004004bd

004007e8 <tc_init>:
 */
void tc_init(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_mode)
{
  4007e8:	b480      	push	{r7}
  4007ea:	b087      	sub	sp, #28
  4007ec:	af00      	add	r7, sp, #0
  4007ee:	60f8      	str	r0, [r7, #12]
  4007f0:	60b9      	str	r1, [r7, #8]
  4007f2:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4007f4:	68fa      	ldr	r2, [r7, #12]
  4007f6:	68bb      	ldr	r3, [r7, #8]
  4007f8:	019b      	lsls	r3, r3, #6
  4007fa:	4413      	add	r3, r2
  4007fc:	617b      	str	r3, [r7, #20]

	/*  Disable TC clock. */
	tc_channel->TC_CCR = TC_CCR_CLKDIS;
  4007fe:	697b      	ldr	r3, [r7, #20]
  400800:	2202      	movs	r2, #2
  400802:	601a      	str	r2, [r3, #0]

	/*  Disable interrupts. */
	tc_channel->TC_IDR = 0xFFFFFFFF;
  400804:	697b      	ldr	r3, [r7, #20]
  400806:	f04f 32ff 	mov.w	r2, #4294967295
  40080a:	629a      	str	r2, [r3, #40]	; 0x28

	/*  Clear status register. */
	tc_channel->TC_SR;
  40080c:	697b      	ldr	r3, [r7, #20]
  40080e:	6a1b      	ldr	r3, [r3, #32]

	/*  Set mode. */
	tc_channel->TC_CMR = ul_mode;
  400810:	697b      	ldr	r3, [r7, #20]
  400812:	687a      	ldr	r2, [r7, #4]
  400814:	605a      	str	r2, [r3, #4]
}
  400816:	bf00      	nop
  400818:	371c      	adds	r7, #28
  40081a:	46bd      	mov	sp, r7
  40081c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400820:	4770      	bx	lr

00400822 <tc_start>:
 * \param[in] ul_channel Channel to configure
 */
void tc_start(
		Tc *p_tc,
		uint32_t ul_channel)
{
  400822:	b480      	push	{r7}
  400824:	b083      	sub	sp, #12
  400826:	af00      	add	r7, sp, #0
  400828:	6078      	str	r0, [r7, #4]
  40082a:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
  40082c:	687a      	ldr	r2, [r7, #4]
  40082e:	683b      	ldr	r3, [r7, #0]
  400830:	019b      	lsls	r3, r3, #6
  400832:	4413      	add	r3, r2
  400834:	2205      	movs	r2, #5
  400836:	601a      	str	r2, [r3, #0]
}
  400838:	bf00      	nop
  40083a:	370c      	adds	r7, #12
  40083c:	46bd      	mov	sp, r7
  40083e:	f85d 7b04 	ldr.w	r7, [sp], #4
  400842:	4770      	bx	lr

00400844 <tc_read_cv>:
 * \return The counter value.
 */
uint32_t tc_read_cv(
		Tc *p_tc,
		uint32_t ul_channel)
{
  400844:	b480      	push	{r7}
  400846:	b083      	sub	sp, #12
  400848:	af00      	add	r7, sp, #0
  40084a:	6078      	str	r0, [r7, #4]
  40084c:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	return p_tc->TC_CHANNEL[ul_channel].TC_CV;
  40084e:	687a      	ldr	r2, [r7, #4]
  400850:	683b      	ldr	r3, [r7, #0]
  400852:	019b      	lsls	r3, r3, #6
  400854:	4413      	add	r3, r2
  400856:	3310      	adds	r3, #16
  400858:	681b      	ldr	r3, [r3, #0]
}
  40085a:	4618      	mov	r0, r3
  40085c:	370c      	adds	r7, #12
  40085e:	46bd      	mov	sp, r7
  400860:	f85d 7b04 	ldr.w	r7, [sp], #4
  400864:	4770      	bx	lr

00400866 <tc_read_rc>:
 * \return The Register C (RC) value.
 */
uint32_t tc_read_rc(
		Tc *p_tc,
		uint32_t ul_channel)
{
  400866:	b480      	push	{r7}
  400868:	b083      	sub	sp, #12
  40086a:	af00      	add	r7, sp, #0
  40086c:	6078      	str	r0, [r7, #4]
  40086e:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	return p_tc->TC_CHANNEL[ul_channel].TC_RC;
  400870:	687a      	ldr	r2, [r7, #4]
  400872:	683b      	ldr	r3, [r7, #0]
  400874:	019b      	lsls	r3, r3, #6
  400876:	4413      	add	r3, r2
  400878:	331c      	adds	r3, #28
  40087a:	681b      	ldr	r3, [r3, #0]
}
  40087c:	4618      	mov	r0, r3
  40087e:	370c      	adds	r7, #12
  400880:	46bd      	mov	sp, r7
  400882:	f85d 7b04 	ldr.w	r7, [sp], #4
  400886:	4770      	bx	lr

00400888 <tc_write_rc>:
 */
void tc_write_rc(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_value)
{
  400888:	b480      	push	{r7}
  40088a:	b085      	sub	sp, #20
  40088c:	af00      	add	r7, sp, #0
  40088e:	60f8      	str	r0, [r7, #12]
  400890:	60b9      	str	r1, [r7, #8]
  400892:	607a      	str	r2, [r7, #4]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_RC = ul_value;
  400894:	68fa      	ldr	r2, [r7, #12]
  400896:	68bb      	ldr	r3, [r7, #8]
  400898:	019b      	lsls	r3, r3, #6
  40089a:	4413      	add	r3, r2
  40089c:	331c      	adds	r3, #28
  40089e:	687a      	ldr	r2, [r7, #4]
  4008a0:	601a      	str	r2, [r3, #0]
}
  4008a2:	bf00      	nop
  4008a4:	3714      	adds	r7, #20
  4008a6:	46bd      	mov	sp, r7
  4008a8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4008ac:	4770      	bx	lr

004008ae <tc_enable_interrupt>:
 */
void tc_enable_interrupt(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_sources)
{
  4008ae:	b480      	push	{r7}
  4008b0:	b087      	sub	sp, #28
  4008b2:	af00      	add	r7, sp, #0
  4008b4:	60f8      	str	r0, [r7, #12]
  4008b6:	60b9      	str	r1, [r7, #8]
  4008b8:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4008ba:	68fa      	ldr	r2, [r7, #12]
  4008bc:	68bb      	ldr	r3, [r7, #8]
  4008be:	019b      	lsls	r3, r3, #6
  4008c0:	4413      	add	r3, r2
  4008c2:	617b      	str	r3, [r7, #20]
	tc_channel->TC_IER = ul_sources;
  4008c4:	697b      	ldr	r3, [r7, #20]
  4008c6:	687a      	ldr	r2, [r7, #4]
  4008c8:	625a      	str	r2, [r3, #36]	; 0x24
}
  4008ca:	bf00      	nop
  4008cc:	371c      	adds	r7, #28
  4008ce:	46bd      	mov	sp, r7
  4008d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4008d4:	4770      	bx	lr

004008d6 <tc_get_interrupt_mask>:
 * \return The TC interrupt mask value.
 */
uint32_t tc_get_interrupt_mask(
		Tc *p_tc,
		uint32_t ul_channel)
{
  4008d6:	b480      	push	{r7}
  4008d8:	b085      	sub	sp, #20
  4008da:	af00      	add	r7, sp, #0
  4008dc:	6078      	str	r0, [r7, #4]
  4008de:	6039      	str	r1, [r7, #0]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4008e0:	687a      	ldr	r2, [r7, #4]
  4008e2:	683b      	ldr	r3, [r7, #0]
  4008e4:	019b      	lsls	r3, r3, #6
  4008e6:	4413      	add	r3, r2
  4008e8:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_IMR;
  4008ea:	68fb      	ldr	r3, [r7, #12]
  4008ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  4008ee:	4618      	mov	r0, r3
  4008f0:	3714      	adds	r7, #20
  4008f2:	46bd      	mov	sp, r7
  4008f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4008f8:	4770      	bx	lr

004008fa <tc_get_status>:
 * \return The current TC status.
 */
uint32_t tc_get_status(
		Tc *p_tc,
		uint32_t ul_channel)
{
  4008fa:	b480      	push	{r7}
  4008fc:	b085      	sub	sp, #20
  4008fe:	af00      	add	r7, sp, #0
  400900:	6078      	str	r0, [r7, #4]
  400902:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
			
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  400904:	687a      	ldr	r2, [r7, #4]
  400906:	683b      	ldr	r3, [r7, #0]
  400908:	019b      	lsls	r3, r3, #6
  40090a:	4413      	add	r3, r2
  40090c:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_SR;
  40090e:	68fb      	ldr	r3, [r7, #12]
  400910:	6a1b      	ldr	r3, [r3, #32]
}
  400912:	4618      	mov	r0, r3
  400914:	3714      	adds	r7, #20
  400916:	46bd      	mov	sp, r7
  400918:	f85d 7b04 	ldr.w	r7, [sp], #4
  40091c:	4770      	bx	lr

0040091e <tc_find_mck_divisor>:
		uint32_t ul_freq,
		uint32_t ul_mck,
		uint32_t *p_uldiv,
		uint32_t *p_ultcclks,
		uint32_t ul_boardmck)
{
  40091e:	b480      	push	{r7}
  400920:	b08d      	sub	sp, #52	; 0x34
  400922:	af00      	add	r7, sp, #0
  400924:	60f8      	str	r0, [r7, #12]
  400926:	60b9      	str	r1, [r7, #8]
  400928:	607a      	str	r2, [r7, #4]
  40092a:	603b      	str	r3, [r7, #0]
	const uint32_t divisors[5] = { 2, 8, 32, 128,
  40092c:	2302      	movs	r3, #2
  40092e:	613b      	str	r3, [r7, #16]
  400930:	2308      	movs	r3, #8
  400932:	617b      	str	r3, [r7, #20]
  400934:	2320      	movs	r3, #32
  400936:	61bb      	str	r3, [r7, #24]
  400938:	2380      	movs	r3, #128	; 0x80
  40093a:	61fb      	str	r3, [r7, #28]
			ul_boardmck / FREQ_SLOW_CLOCK_EXT };
  40093c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40093e:	0bdb      	lsrs	r3, r3, #15
	const uint32_t divisors[5] = { 2, 8, 32, 128,
  400940:	623b      	str	r3, [r7, #32]
	uint32_t ul_index;
	uint32_t ul_high, ul_low;

	/*  Satisfy frequency bound. */
	for (ul_index = 0;
  400942:	2300      	movs	r3, #0
  400944:	62fb      	str	r3, [r7, #44]	; 0x2c
  400946:	e01a      	b.n	40097e <tc_find_mck_divisor+0x60>
			ul_index < (sizeof(divisors) / sizeof(divisors[0]));
			ul_index++) {
		ul_high = ul_mck / divisors[ul_index];
  400948:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40094a:	009b      	lsls	r3, r3, #2
  40094c:	f107 0230 	add.w	r2, r7, #48	; 0x30
  400950:	4413      	add	r3, r2
  400952:	f853 3c20 	ldr.w	r3, [r3, #-32]
  400956:	68ba      	ldr	r2, [r7, #8]
  400958:	fbb2 f3f3 	udiv	r3, r2, r3
  40095c:	62bb      	str	r3, [r7, #40]	; 0x28
		ul_low  = ul_high / TC_DIV_FACTOR;
  40095e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  400960:	0c1b      	lsrs	r3, r3, #16
  400962:	627b      	str	r3, [r7, #36]	; 0x24
		if (ul_freq > ul_high) {
  400964:	68fa      	ldr	r2, [r7, #12]
  400966:	6abb      	ldr	r3, [r7, #40]	; 0x28
  400968:	429a      	cmp	r2, r3
  40096a:	d901      	bls.n	400970 <tc_find_mck_divisor+0x52>
			return 0;
  40096c:	2300      	movs	r3, #0
  40096e:	e023      	b.n	4009b8 <tc_find_mck_divisor+0x9a>
		} else if (ul_freq >= ul_low) {
  400970:	68fa      	ldr	r2, [r7, #12]
  400972:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400974:	429a      	cmp	r2, r3
  400976:	d206      	bcs.n	400986 <tc_find_mck_divisor+0x68>
			ul_index++) {
  400978:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40097a:	3301      	adds	r3, #1
  40097c:	62fb      	str	r3, [r7, #44]	; 0x2c
	for (ul_index = 0;
  40097e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  400980:	2b04      	cmp	r3, #4
  400982:	d9e1      	bls.n	400948 <tc_find_mck_divisor+0x2a>
  400984:	e000      	b.n	400988 <tc_find_mck_divisor+0x6a>
			break;
  400986:	bf00      	nop
		}
	}
	if (ul_index >= (sizeof(divisors) / sizeof(divisors[0]))) {
  400988:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40098a:	2b04      	cmp	r3, #4
  40098c:	d901      	bls.n	400992 <tc_find_mck_divisor+0x74>
		return 0;
  40098e:	2300      	movs	r3, #0
  400990:	e012      	b.n	4009b8 <tc_find_mck_divisor+0x9a>
	}

	/*  Store results. */
	if (p_uldiv) {
  400992:	687b      	ldr	r3, [r7, #4]
  400994:	2b00      	cmp	r3, #0
  400996:	d008      	beq.n	4009aa <tc_find_mck_divisor+0x8c>
		*p_uldiv = divisors[ul_index];
  400998:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40099a:	009b      	lsls	r3, r3, #2
  40099c:	f107 0230 	add.w	r2, r7, #48	; 0x30
  4009a0:	4413      	add	r3, r2
  4009a2:	f853 2c20 	ldr.w	r2, [r3, #-32]
  4009a6:	687b      	ldr	r3, [r7, #4]
  4009a8:	601a      	str	r2, [r3, #0]
	}

	if (p_ultcclks) {
  4009aa:	683b      	ldr	r3, [r7, #0]
  4009ac:	2b00      	cmp	r3, #0
  4009ae:	d002      	beq.n	4009b6 <tc_find_mck_divisor+0x98>
		*p_ultcclks = ul_index;
  4009b0:	683b      	ldr	r3, [r7, #0]
  4009b2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  4009b4:	601a      	str	r2, [r3, #0]
	}

	return 1;
  4009b6:	2301      	movs	r3, #1
}
  4009b8:	4618      	mov	r0, r3
  4009ba:	3734      	adds	r7, #52	; 0x34
  4009bc:	46bd      	mov	sp, r7
  4009be:	f85d 7b04 	ldr.w	r7, [sp], #4
  4009c2:	4770      	bx	lr

004009c4 <twi_enable_master_mode>:
 * \brief Enable TWI master mode.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
  4009c4:	b480      	push	{r7}
  4009c6:	b083      	sub	sp, #12
  4009c8:	af00      	add	r7, sp, #0
  4009ca:	6078      	str	r0, [r7, #4]
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  4009cc:	687b      	ldr	r3, [r7, #4]
  4009ce:	2208      	movs	r2, #8
  4009d0:	601a      	str	r2, [r3, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  4009d2:	687b      	ldr	r3, [r7, #4]
  4009d4:	2220      	movs	r2, #32
  4009d6:	601a      	str	r2, [r3, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  4009d8:	687b      	ldr	r3, [r7, #4]
  4009da:	2204      	movs	r2, #4
  4009dc:	601a      	str	r2, [r3, #0]
}
  4009de:	bf00      	nop
  4009e0:	370c      	adds	r7, #12
  4009e2:	46bd      	mov	sp, r7
  4009e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4009e8:	4770      	bx	lr
	...

004009ec <twi_master_init>:
 * \param p_opt Options for initializing the TWI module (see \ref twi_options_t).
 *
 * \return TWI_SUCCESS if initialization is complete, error code otherwise.
 */
uint32_t twi_master_init(Twi *p_twi, const twi_options_t *p_opt)
{
  4009ec:	b580      	push	{r7, lr}
  4009ee:	b084      	sub	sp, #16
  4009f0:	af00      	add	r7, sp, #0
  4009f2:	6078      	str	r0, [r7, #4]
  4009f4:	6039      	str	r1, [r7, #0]
	uint32_t status = TWI_SUCCESS;
  4009f6:	2300      	movs	r3, #0
  4009f8:	60fb      	str	r3, [r7, #12]

	/* Disable TWI interrupts */
	p_twi->TWI_IDR = ~0UL;
  4009fa:	687b      	ldr	r3, [r7, #4]
  4009fc:	f04f 32ff 	mov.w	r2, #4294967295
  400a00:	629a      	str	r2, [r3, #40]	; 0x28

	/* Dummy read in status register */
	p_twi->TWI_SR;
  400a02:	687b      	ldr	r3, [r7, #4]
  400a04:	6a1b      	ldr	r3, [r3, #32]

	/* Reset TWI peripheral */
	twi_reset(p_twi);
  400a06:	6878      	ldr	r0, [r7, #4]
  400a08:	4b0e      	ldr	r3, [pc, #56]	; (400a44 <twi_master_init+0x58>)
  400a0a:	4798      	blx	r3

	twi_enable_master_mode(p_twi);
  400a0c:	6878      	ldr	r0, [r7, #4]
  400a0e:	4b0e      	ldr	r3, [pc, #56]	; (400a48 <twi_master_init+0x5c>)
  400a10:	4798      	blx	r3

	/* Select the speed */
	if (twi_set_speed(p_twi, p_opt->speed, p_opt->master_clk) == FAIL) {
  400a12:	683b      	ldr	r3, [r7, #0]
  400a14:	6859      	ldr	r1, [r3, #4]
  400a16:	683b      	ldr	r3, [r7, #0]
  400a18:	681b      	ldr	r3, [r3, #0]
  400a1a:	461a      	mov	r2, r3
  400a1c:	6878      	ldr	r0, [r7, #4]
  400a1e:	4b0b      	ldr	r3, [pc, #44]	; (400a4c <twi_master_init+0x60>)
  400a20:	4798      	blx	r3
  400a22:	4603      	mov	r3, r0
  400a24:	2b01      	cmp	r3, #1
  400a26:	d101      	bne.n	400a2c <twi_master_init+0x40>
		/* The desired speed setting is rejected */
		status = TWI_INVALID_ARGUMENT;
  400a28:	2301      	movs	r3, #1
  400a2a:	60fb      	str	r3, [r7, #12]
	}

	if (p_opt->smbus == 1) {
  400a2c:	683b      	ldr	r3, [r7, #0]
  400a2e:	7a5b      	ldrb	r3, [r3, #9]
  400a30:	2b01      	cmp	r3, #1
  400a32:	d102      	bne.n	400a3a <twi_master_init+0x4e>
		p_twi->TWI_CR = TWI_CR_QUICK;
  400a34:	687b      	ldr	r3, [r7, #4]
  400a36:	2240      	movs	r2, #64	; 0x40
  400a38:	601a      	str	r2, [r3, #0]
	}

	return status;
  400a3a:	68fb      	ldr	r3, [r7, #12]
}
  400a3c:	4618      	mov	r0, r3
  400a3e:	3710      	adds	r7, #16
  400a40:	46bd      	mov	sp, r7
  400a42:	bd80      	pop	{r7, pc}
  400a44:	00400d05 	.word	0x00400d05
  400a48:	004009c5 	.word	0x004009c5
  400a4c:	00400a51 	.word	0x00400a51

00400a50 <twi_set_speed>:
 *
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
  400a50:	b480      	push	{r7}
  400a52:	b087      	sub	sp, #28
  400a54:	af00      	add	r7, sp, #0
  400a56:	60f8      	str	r0, [r7, #12]
  400a58:	60b9      	str	r1, [r7, #8]
  400a5a:	607a      	str	r2, [r7, #4]
	uint32_t ckdiv = 0;
  400a5c:	2300      	movs	r3, #0
  400a5e:	617b      	str	r3, [r7, #20]
	uint32_t c_lh_div;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  400a60:	68bb      	ldr	r3, [r7, #8]
  400a62:	4a16      	ldr	r2, [pc, #88]	; (400abc <twi_set_speed+0x6c>)
  400a64:	4293      	cmp	r3, r2
  400a66:	d901      	bls.n	400a6c <twi_set_speed+0x1c>
		return FAIL;
  400a68:	2301      	movs	r3, #1
  400a6a:	e021      	b.n	400ab0 <twi_set_speed+0x60>
	}

	c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  400a6c:	68bb      	ldr	r3, [r7, #8]
  400a6e:	005b      	lsls	r3, r3, #1
  400a70:	687a      	ldr	r2, [r7, #4]
  400a72:	fbb2 f3f3 	udiv	r3, r2, r3
  400a76:	3b03      	subs	r3, #3
  400a78:	613b      	str	r3, [r7, #16]

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  400a7a:	e005      	b.n	400a88 <twi_set_speed+0x38>
		/* Increase clock divider */
		ckdiv++;
  400a7c:	697b      	ldr	r3, [r7, #20]
  400a7e:	3301      	adds	r3, #1
  400a80:	617b      	str	r3, [r7, #20]
		/* Divide cldiv value */
		c_lh_div /= TWI_CLK_DIVIDER;
  400a82:	693b      	ldr	r3, [r7, #16]
  400a84:	085b      	lsrs	r3, r3, #1
  400a86:	613b      	str	r3, [r7, #16]
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  400a88:	693b      	ldr	r3, [r7, #16]
  400a8a:	2bff      	cmp	r3, #255	; 0xff
  400a8c:	d902      	bls.n	400a94 <twi_set_speed+0x44>
  400a8e:	697b      	ldr	r3, [r7, #20]
  400a90:	2b06      	cmp	r3, #6
  400a92:	d9f3      	bls.n	400a7c <twi_set_speed+0x2c>
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  400a94:	693b      	ldr	r3, [r7, #16]
  400a96:	b2da      	uxtb	r2, r3
  400a98:	693b      	ldr	r3, [r7, #16]
  400a9a:	021b      	lsls	r3, r3, #8
  400a9c:	b29b      	uxth	r3, r3
  400a9e:	431a      	orrs	r2, r3
			TWI_CWGR_CKDIV(ckdiv);
  400aa0:	697b      	ldr	r3, [r7, #20]
  400aa2:	041b      	lsls	r3, r3, #16
  400aa4:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  400aa8:	431a      	orrs	r2, r3
	p_twi->TWI_CWGR =
  400aaa:	68fb      	ldr	r3, [r7, #12]
  400aac:	611a      	str	r2, [r3, #16]

	return PASS;
  400aae:	2300      	movs	r3, #0
}
  400ab0:	4618      	mov	r0, r3
  400ab2:	371c      	adds	r7, #28
  400ab4:	46bd      	mov	sp, r7
  400ab6:	f85d 7b04 	ldr.w	r7, [sp], #4
  400aba:	4770      	bx	lr
  400abc:	00061a80 	.word	0x00061a80

00400ac0 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
  400ac0:	b480      	push	{r7}
  400ac2:	b085      	sub	sp, #20
  400ac4:	af00      	add	r7, sp, #0
  400ac6:	6078      	str	r0, [r7, #4]
  400ac8:	6039      	str	r1, [r7, #0]
	uint32_t val;

	if (len == 0)
  400aca:	683b      	ldr	r3, [r7, #0]
  400acc:	2b00      	cmp	r3, #0
  400ace:	d101      	bne.n	400ad4 <twi_mk_addr+0x14>
		return 0;
  400ad0:	2300      	movs	r3, #0
  400ad2:	e01d      	b.n	400b10 <twi_mk_addr+0x50>

	val = addr[0];
  400ad4:	687b      	ldr	r3, [r7, #4]
  400ad6:	781b      	ldrb	r3, [r3, #0]
  400ad8:	60fb      	str	r3, [r7, #12]
	if (len > 1) {
  400ada:	683b      	ldr	r3, [r7, #0]
  400adc:	2b01      	cmp	r3, #1
  400ade:	dd09      	ble.n	400af4 <twi_mk_addr+0x34>
		val <<= 8;
  400ae0:	68fb      	ldr	r3, [r7, #12]
  400ae2:	021b      	lsls	r3, r3, #8
  400ae4:	60fb      	str	r3, [r7, #12]
		val |= addr[1];
  400ae6:	687b      	ldr	r3, [r7, #4]
  400ae8:	3301      	adds	r3, #1
  400aea:	781b      	ldrb	r3, [r3, #0]
  400aec:	461a      	mov	r2, r3
  400aee:	68fb      	ldr	r3, [r7, #12]
  400af0:	4313      	orrs	r3, r2
  400af2:	60fb      	str	r3, [r7, #12]
	}
	if (len > 2) {
  400af4:	683b      	ldr	r3, [r7, #0]
  400af6:	2b02      	cmp	r3, #2
  400af8:	dd09      	ble.n	400b0e <twi_mk_addr+0x4e>
		val <<= 8;
  400afa:	68fb      	ldr	r3, [r7, #12]
  400afc:	021b      	lsls	r3, r3, #8
  400afe:	60fb      	str	r3, [r7, #12]
		val |= addr[2];
  400b00:	687b      	ldr	r3, [r7, #4]
  400b02:	3302      	adds	r3, #2
  400b04:	781b      	ldrb	r3, [r3, #0]
  400b06:	461a      	mov	r2, r3
  400b08:	68fb      	ldr	r3, [r7, #12]
  400b0a:	4313      	orrs	r3, r2
  400b0c:	60fb      	str	r3, [r7, #12]
	}
	return val;
  400b0e:	68fb      	ldr	r3, [r7, #12]
}
  400b10:	4618      	mov	r0, r3
  400b12:	3714      	adds	r7, #20
  400b14:	46bd      	mov	sp, r7
  400b16:	f85d 7b04 	ldr.w	r7, [sp], #4
  400b1a:	4770      	bx	lr

00400b1c <twi_master_read>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were read, error code otherwise.
 */
uint32_t twi_master_read(Twi *p_twi, twi_packet_t *p_packet)
{
  400b1c:	b580      	push	{r7, lr}
  400b1e:	b088      	sub	sp, #32
  400b20:	af00      	add	r7, sp, #0
  400b22:	6078      	str	r0, [r7, #4]
  400b24:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  400b26:	683b      	ldr	r3, [r7, #0]
  400b28:	68db      	ldr	r3, [r3, #12]
  400b2a:	61fb      	str	r3, [r7, #28]
	uint8_t *buffer = p_packet->buffer;
  400b2c:	683b      	ldr	r3, [r7, #0]
  400b2e:	689b      	ldr	r3, [r3, #8]
  400b30:	61bb      	str	r3, [r7, #24]
	uint8_t stop_sent = 0;
  400b32:	2300      	movs	r3, #0
  400b34:	75fb      	strb	r3, [r7, #23]
	uint32_t timeout = TWI_TIMEOUT;;
  400b36:	f643 2398 	movw	r3, #15000	; 0x3a98
  400b3a:	613b      	str	r3, [r7, #16]
	
	/* Check argument */
	if (cnt == 0) {
  400b3c:	69fb      	ldr	r3, [r7, #28]
  400b3e:	2b00      	cmp	r3, #0
  400b40:	d101      	bne.n	400b46 <twi_master_read+0x2a>
		return TWI_INVALID_ARGUMENT;
  400b42:	2301      	movs	r3, #1
  400b44:	e069      	b.n	400c1a <twi_master_read+0xfe>
	}

	/* Set read mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  400b46:	687b      	ldr	r3, [r7, #4]
  400b48:	2200      	movs	r2, #0
  400b4a:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(p_packet->chip) |
  400b4c:	683b      	ldr	r3, [r7, #0]
  400b4e:	7c1b      	ldrb	r3, [r3, #16]
  400b50:	041b      	lsls	r3, r3, #16
  400b52:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  400b56:	683b      	ldr	r3, [r7, #0]
  400b58:	685b      	ldr	r3, [r3, #4]
  400b5a:	021b      	lsls	r3, r3, #8
  400b5c:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(p_packet->chip) |
  400b60:	4313      	orrs	r3, r2
  400b62:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
  400b66:	687b      	ldr	r3, [r7, #4]
  400b68:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  400b6a:	687b      	ldr	r3, [r7, #4]
  400b6c:	2200      	movs	r2, #0
  400b6e:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  400b70:	683a      	ldr	r2, [r7, #0]
  400b72:	683b      	ldr	r3, [r7, #0]
  400b74:	685b      	ldr	r3, [r3, #4]
  400b76:	4619      	mov	r1, r3
  400b78:	4610      	mov	r0, r2
  400b7a:	4b2a      	ldr	r3, [pc, #168]	; (400c24 <twi_master_read+0x108>)
  400b7c:	4798      	blx	r3
  400b7e:	4602      	mov	r2, r0
  400b80:	687b      	ldr	r3, [r7, #4]
  400b82:	60da      	str	r2, [r3, #12]

	/* Send a START condition */
	if (cnt == 1) {
  400b84:	69fb      	ldr	r3, [r7, #28]
  400b86:	2b01      	cmp	r3, #1
  400b88:	d105      	bne.n	400b96 <twi_master_read+0x7a>
		p_twi->TWI_CR = TWI_CR_START | TWI_CR_STOP;
  400b8a:	687b      	ldr	r3, [r7, #4]
  400b8c:	2203      	movs	r2, #3
  400b8e:	601a      	str	r2, [r3, #0]
		stop_sent = 1;
  400b90:	2301      	movs	r3, #1
  400b92:	75fb      	strb	r3, [r7, #23]
  400b94:	e034      	b.n	400c00 <twi_master_read+0xe4>
	} else {
		p_twi->TWI_CR = TWI_CR_START;
  400b96:	687b      	ldr	r3, [r7, #4]
  400b98:	2201      	movs	r2, #1
  400b9a:	601a      	str	r2, [r3, #0]
		stop_sent = 0;
  400b9c:	2300      	movs	r3, #0
  400b9e:	75fb      	strb	r3, [r7, #23]
	}

	while (cnt > 0) {
  400ba0:	e02e      	b.n	400c00 <twi_master_read+0xe4>
		status = p_twi->TWI_SR;
  400ba2:	687b      	ldr	r3, [r7, #4]
  400ba4:	6a1b      	ldr	r3, [r3, #32]
  400ba6:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  400ba8:	68fb      	ldr	r3, [r7, #12]
  400baa:	f403 7380 	and.w	r3, r3, #256	; 0x100
  400bae:	2b00      	cmp	r3, #0
  400bb0:	d001      	beq.n	400bb6 <twi_master_read+0x9a>
			return TWI_RECEIVE_NACK;
  400bb2:	2305      	movs	r3, #5
  400bb4:	e031      	b.n	400c1a <twi_master_read+0xfe>
		}

		if (!timeout--) {
  400bb6:	693b      	ldr	r3, [r7, #16]
  400bb8:	1e5a      	subs	r2, r3, #1
  400bba:	613a      	str	r2, [r7, #16]
  400bbc:	2b00      	cmp	r3, #0
  400bbe:	d101      	bne.n	400bc4 <twi_master_read+0xa8>
			return TWI_ERROR_TIMEOUT;
  400bc0:	2309      	movs	r3, #9
  400bc2:	e02a      	b.n	400c1a <twi_master_read+0xfe>
		}
		if (!(status & TWI_SR_RXRDY)) {
  400bc4:	68fb      	ldr	r3, [r7, #12]
  400bc6:	f003 0302 	and.w	r3, r3, #2
  400bca:	2b00      	cmp	r3, #0
  400bcc:	d100      	bne.n	400bd0 <twi_master_read+0xb4>
			continue;
  400bce:	e017      	b.n	400c00 <twi_master_read+0xe4>
		}

		/* Send STOP before reading TWI_RHR on the penultimate data */
		if (cnt == 2 && !stop_sent) {
  400bd0:	69fb      	ldr	r3, [r7, #28]
  400bd2:	2b02      	cmp	r3, #2
  400bd4:	d107      	bne.n	400be6 <twi_master_read+0xca>
  400bd6:	7dfb      	ldrb	r3, [r7, #23]
  400bd8:	2b00      	cmp	r3, #0
  400bda:	d104      	bne.n	400be6 <twi_master_read+0xca>
			p_twi->TWI_CR = TWI_CR_STOP;
  400bdc:	687b      	ldr	r3, [r7, #4]
  400bde:	2202      	movs	r2, #2
  400be0:	601a      	str	r2, [r3, #0]
			stop_sent = 1;
  400be2:	2301      	movs	r3, #1
  400be4:	75fb      	strb	r3, [r7, #23]
		}
		*buffer++ = p_twi->TWI_RHR;
  400be6:	69bb      	ldr	r3, [r7, #24]
  400be8:	1c5a      	adds	r2, r3, #1
  400bea:	61ba      	str	r2, [r7, #24]
  400bec:	687a      	ldr	r2, [r7, #4]
  400bee:	6b12      	ldr	r2, [r2, #48]	; 0x30
  400bf0:	b2d2      	uxtb	r2, r2
  400bf2:	701a      	strb	r2, [r3, #0]
		
		cnt--;
  400bf4:	69fb      	ldr	r3, [r7, #28]
  400bf6:	3b01      	subs	r3, #1
  400bf8:	61fb      	str	r3, [r7, #28]
		
		timeout = TWI_TIMEOUT;
  400bfa:	f643 2398 	movw	r3, #15000	; 0x3a98
  400bfe:	613b      	str	r3, [r7, #16]
	while (cnt > 0) {
  400c00:	69fb      	ldr	r3, [r7, #28]
  400c02:	2b00      	cmp	r3, #0
  400c04:	d1cd      	bne.n	400ba2 <twi_master_read+0x86>
	}

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  400c06:	bf00      	nop
  400c08:	687b      	ldr	r3, [r7, #4]
  400c0a:	6a1b      	ldr	r3, [r3, #32]
  400c0c:	f003 0301 	and.w	r3, r3, #1
  400c10:	2b00      	cmp	r3, #0
  400c12:	d0f9      	beq.n	400c08 <twi_master_read+0xec>
	}

	p_twi->TWI_SR;
  400c14:	687b      	ldr	r3, [r7, #4]
  400c16:	6a1b      	ldr	r3, [r3, #32]

	return TWI_SUCCESS;
  400c18:	2300      	movs	r3, #0
}
  400c1a:	4618      	mov	r0, r3
  400c1c:	3720      	adds	r7, #32
  400c1e:	46bd      	mov	sp, r7
  400c20:	bd80      	pop	{r7, pc}
  400c22:	bf00      	nop
  400c24:	00400ac1 	.word	0x00400ac1

00400c28 <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  400c28:	b580      	push	{r7, lr}
  400c2a:	b086      	sub	sp, #24
  400c2c:	af00      	add	r7, sp, #0
  400c2e:	6078      	str	r0, [r7, #4]
  400c30:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  400c32:	683b      	ldr	r3, [r7, #0]
  400c34:	68db      	ldr	r3, [r3, #12]
  400c36:	617b      	str	r3, [r7, #20]
	uint8_t *buffer = p_packet->buffer;
  400c38:	683b      	ldr	r3, [r7, #0]
  400c3a:	689b      	ldr	r3, [r3, #8]
  400c3c:	613b      	str	r3, [r7, #16]

	/* Check argument */
	if (cnt == 0) {
  400c3e:	697b      	ldr	r3, [r7, #20]
  400c40:	2b00      	cmp	r3, #0
  400c42:	d101      	bne.n	400c48 <twi_master_write+0x20>
		return TWI_INVALID_ARGUMENT;
  400c44:	2301      	movs	r3, #1
  400c46:	e056      	b.n	400cf6 <twi_master_write+0xce>
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  400c48:	687b      	ldr	r3, [r7, #4]
  400c4a:	2200      	movs	r2, #0
  400c4c:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  400c4e:	683b      	ldr	r3, [r7, #0]
  400c50:	7c1b      	ldrb	r3, [r3, #16]
  400c52:	041b      	lsls	r3, r3, #16
  400c54:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  400c58:	683b      	ldr	r3, [r7, #0]
  400c5a:	685b      	ldr	r3, [r3, #4]
  400c5c:	021b      	lsls	r3, r3, #8
  400c5e:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  400c62:	431a      	orrs	r2, r3
  400c64:	687b      	ldr	r3, [r7, #4]
  400c66:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  400c68:	687b      	ldr	r3, [r7, #4]
  400c6a:	2200      	movs	r2, #0
  400c6c:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  400c6e:	683a      	ldr	r2, [r7, #0]
  400c70:	683b      	ldr	r3, [r7, #0]
  400c72:	685b      	ldr	r3, [r3, #4]
  400c74:	4619      	mov	r1, r3
  400c76:	4610      	mov	r0, r2
  400c78:	4b21      	ldr	r3, [pc, #132]	; (400d00 <twi_master_write+0xd8>)
  400c7a:	4798      	blx	r3
  400c7c:	4602      	mov	r2, r0
  400c7e:	687b      	ldr	r3, [r7, #4]
  400c80:	60da      	str	r2, [r3, #12]

	/* Send all bytes */
	while (cnt > 0) {
  400c82:	e019      	b.n	400cb8 <twi_master_write+0x90>
		status = p_twi->TWI_SR;
  400c84:	687b      	ldr	r3, [r7, #4]
  400c86:	6a1b      	ldr	r3, [r3, #32]
  400c88:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  400c8a:	68fb      	ldr	r3, [r7, #12]
  400c8c:	f403 7380 	and.w	r3, r3, #256	; 0x100
  400c90:	2b00      	cmp	r3, #0
  400c92:	d001      	beq.n	400c98 <twi_master_write+0x70>
			return TWI_RECEIVE_NACK;
  400c94:	2305      	movs	r3, #5
  400c96:	e02e      	b.n	400cf6 <twi_master_write+0xce>
		}

		if (!(status & TWI_SR_TXRDY)) {
  400c98:	68fb      	ldr	r3, [r7, #12]
  400c9a:	f003 0304 	and.w	r3, r3, #4
  400c9e:	2b00      	cmp	r3, #0
  400ca0:	d100      	bne.n	400ca4 <twi_master_write+0x7c>
			continue;
  400ca2:	e009      	b.n	400cb8 <twi_master_write+0x90>
		}
		p_twi->TWI_THR = *buffer++;
  400ca4:	693b      	ldr	r3, [r7, #16]
  400ca6:	1c5a      	adds	r2, r3, #1
  400ca8:	613a      	str	r2, [r7, #16]
  400caa:	781b      	ldrb	r3, [r3, #0]
  400cac:	461a      	mov	r2, r3
  400cae:	687b      	ldr	r3, [r7, #4]
  400cb0:	635a      	str	r2, [r3, #52]	; 0x34

		cnt--;
  400cb2:	697b      	ldr	r3, [r7, #20]
  400cb4:	3b01      	subs	r3, #1
  400cb6:	617b      	str	r3, [r7, #20]
	while (cnt > 0) {
  400cb8:	697b      	ldr	r3, [r7, #20]
  400cba:	2b00      	cmp	r3, #0
  400cbc:	d1e2      	bne.n	400c84 <twi_master_write+0x5c>
	}

	while (1) {
		status = p_twi->TWI_SR;
  400cbe:	687b      	ldr	r3, [r7, #4]
  400cc0:	6a1b      	ldr	r3, [r3, #32]
  400cc2:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  400cc4:	68fb      	ldr	r3, [r7, #12]
  400cc6:	f403 7380 	and.w	r3, r3, #256	; 0x100
  400cca:	2b00      	cmp	r3, #0
  400ccc:	d001      	beq.n	400cd2 <twi_master_write+0xaa>
			return TWI_RECEIVE_NACK;
  400cce:	2305      	movs	r3, #5
  400cd0:	e011      	b.n	400cf6 <twi_master_write+0xce>
		}

		if (status & TWI_SR_TXRDY) {
  400cd2:	68fb      	ldr	r3, [r7, #12]
  400cd4:	f003 0304 	and.w	r3, r3, #4
  400cd8:	2b00      	cmp	r3, #0
  400cda:	d100      	bne.n	400cde <twi_master_write+0xb6>
		status = p_twi->TWI_SR;
  400cdc:	e7ef      	b.n	400cbe <twi_master_write+0x96>
			break;
  400cde:	bf00      	nop
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  400ce0:	687b      	ldr	r3, [r7, #4]
  400ce2:	2202      	movs	r2, #2
  400ce4:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  400ce6:	bf00      	nop
  400ce8:	687b      	ldr	r3, [r7, #4]
  400cea:	6a1b      	ldr	r3, [r3, #32]
  400cec:	f003 0301 	and.w	r3, r3, #1
  400cf0:	2b00      	cmp	r3, #0
  400cf2:	d0f9      	beq.n	400ce8 <twi_master_write+0xc0>
	}

	return TWI_SUCCESS;
  400cf4:	2300      	movs	r3, #0
}
  400cf6:	4618      	mov	r0, r3
  400cf8:	3718      	adds	r7, #24
  400cfa:	46bd      	mov	sp, r7
  400cfc:	bd80      	pop	{r7, pc}
  400cfe:	bf00      	nop
  400d00:	00400ac1 	.word	0x00400ac1

00400d04 <twi_reset>:
 * \brief Reset TWI.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
  400d04:	b480      	push	{r7}
  400d06:	b083      	sub	sp, #12
  400d08:	af00      	add	r7, sp, #0
  400d0a:	6078      	str	r0, [r7, #4]
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  400d0c:	687b      	ldr	r3, [r7, #4]
  400d0e:	2280      	movs	r2, #128	; 0x80
  400d10:	601a      	str	r2, [r3, #0]
	p_twi->TWI_RHR;
  400d12:	687b      	ldr	r3, [r7, #4]
  400d14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  400d16:	bf00      	nop
  400d18:	370c      	adds	r7, #12
  400d1a:	46bd      	mov	sp, r7
  400d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400d20:	4770      	bx	lr
	...

00400d24 <NVIC_SetPriority>:
{
  400d24:	b480      	push	{r7}
  400d26:	b083      	sub	sp, #12
  400d28:	af00      	add	r7, sp, #0
  400d2a:	4603      	mov	r3, r0
  400d2c:	6039      	str	r1, [r7, #0]
  400d2e:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  400d30:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400d34:	2b00      	cmp	r3, #0
  400d36:	da0b      	bge.n	400d50 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  400d38:	490d      	ldr	r1, [pc, #52]	; (400d70 <NVIC_SetPriority+0x4c>)
  400d3a:	79fb      	ldrb	r3, [r7, #7]
  400d3c:	f003 030f 	and.w	r3, r3, #15
  400d40:	3b04      	subs	r3, #4
  400d42:	683a      	ldr	r2, [r7, #0]
  400d44:	b2d2      	uxtb	r2, r2
  400d46:	0112      	lsls	r2, r2, #4
  400d48:	b2d2      	uxtb	r2, r2
  400d4a:	440b      	add	r3, r1
  400d4c:	761a      	strb	r2, [r3, #24]
}
  400d4e:	e009      	b.n	400d64 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  400d50:	4908      	ldr	r1, [pc, #32]	; (400d74 <NVIC_SetPriority+0x50>)
  400d52:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400d56:	683a      	ldr	r2, [r7, #0]
  400d58:	b2d2      	uxtb	r2, r2
  400d5a:	0112      	lsls	r2, r2, #4
  400d5c:	b2d2      	uxtb	r2, r2
  400d5e:	440b      	add	r3, r1
  400d60:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  400d64:	bf00      	nop
  400d66:	370c      	adds	r7, #12
  400d68:	46bd      	mov	sp, r7
  400d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  400d6e:	4770      	bx	lr
  400d70:	e000ed00 	.word	0xe000ed00
  400d74:	e000e100 	.word	0xe000e100

00400d78 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  400d78:	b580      	push	{r7, lr}
  400d7a:	b082      	sub	sp, #8
  400d7c:	af00      	add	r7, sp, #0
  400d7e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
  400d80:	687b      	ldr	r3, [r7, #4]
  400d82:	3b01      	subs	r3, #1
  400d84:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
  400d88:	d301      	bcc.n	400d8e <SysTick_Config+0x16>
  400d8a:	2301      	movs	r3, #1
  400d8c:	e00f      	b.n	400dae <SysTick_Config+0x36>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
  400d8e:	4a0a      	ldr	r2, [pc, #40]	; (400db8 <SysTick_Config+0x40>)
  400d90:	687b      	ldr	r3, [r7, #4]
  400d92:	3b01      	subs	r3, #1
  400d94:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  400d96:	210f      	movs	r1, #15
  400d98:	f04f 30ff 	mov.w	r0, #4294967295
  400d9c:	4b07      	ldr	r3, [pc, #28]	; (400dbc <SysTick_Config+0x44>)
  400d9e:	4798      	blx	r3
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
  400da0:	4b05      	ldr	r3, [pc, #20]	; (400db8 <SysTick_Config+0x40>)
  400da2:	2200      	movs	r2, #0
  400da4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
  400da6:	4b04      	ldr	r3, [pc, #16]	; (400db8 <SysTick_Config+0x40>)
  400da8:	2207      	movs	r2, #7
  400daa:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
  return (0);                                                  /* Function successful */
  400dac:	2300      	movs	r3, #0
}
  400dae:	4618      	mov	r0, r3
  400db0:	3708      	adds	r7, #8
  400db2:	46bd      	mov	sp, r7
  400db4:	bd80      	pop	{r7, pc}
  400db6:	bf00      	nop
  400db8:	e000e010 	.word	0xe000e010
  400dbc:	00400d25 	.word	0x00400d25

00400dc0 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400dc0:	b480      	push	{r7}
  400dc2:	b083      	sub	sp, #12
  400dc4:	af00      	add	r7, sp, #0
  400dc6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400dc8:	687b      	ldr	r3, [r7, #4]
  400dca:	2b07      	cmp	r3, #7
  400dcc:	d825      	bhi.n	400e1a <osc_get_rate+0x5a>
  400dce:	a201      	add	r2, pc, #4	; (adr r2, 400dd4 <osc_get_rate+0x14>)
  400dd0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400dd4:	00400df5 	.word	0x00400df5
  400dd8:	00400dfb 	.word	0x00400dfb
  400ddc:	00400e01 	.word	0x00400e01
  400de0:	00400e07 	.word	0x00400e07
  400de4:	00400e0b 	.word	0x00400e0b
  400de8:	00400e0f 	.word	0x00400e0f
  400dec:	00400e13 	.word	0x00400e13
  400df0:	00400e17 	.word	0x00400e17
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400df4:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400df8:	e010      	b.n	400e1c <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  400dfa:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400dfe:	e00d      	b.n	400e1c <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  400e00:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400e04:	e00a      	b.n	400e1c <osc_get_rate+0x5c>
#endif

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  400e06:	4b08      	ldr	r3, [pc, #32]	; (400e28 <osc_get_rate+0x68>)
  400e08:	e008      	b.n	400e1c <osc_get_rate+0x5c>

	case OSC_MAINCK_16M_RC:
		return OSC_MAINCK_16M_RC_HZ;
  400e0a:	4b08      	ldr	r3, [pc, #32]	; (400e2c <osc_get_rate+0x6c>)
  400e0c:	e006      	b.n	400e1c <osc_get_rate+0x5c>

	case OSC_MAINCK_24M_RC:
		return OSC_MAINCK_24M_RC_HZ;
  400e0e:	4b08      	ldr	r3, [pc, #32]	; (400e30 <osc_get_rate+0x70>)
  400e10:	e004      	b.n	400e1c <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  400e12:	2300      	movs	r3, #0
  400e14:	e002      	b.n	400e1c <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  400e16:	2300      	movs	r3, #0
  400e18:	e000      	b.n	400e1c <osc_get_rate+0x5c>
#endif
	}

	return 0;
  400e1a:	2300      	movs	r3, #0
}
  400e1c:	4618      	mov	r0, r3
  400e1e:	370c      	adds	r7, #12
  400e20:	46bd      	mov	sp, r7
  400e22:	f85d 7b04 	ldr.w	r7, [sp], #4
  400e26:	4770      	bx	lr
  400e28:	007a1200 	.word	0x007a1200
  400e2c:	00f42400 	.word	0x00f42400
  400e30:	016e3600 	.word	0x016e3600

00400e34 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  400e34:	b580      	push	{r7, lr}
  400e36:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  400e38:	2001      	movs	r0, #1
  400e3a:	4b04      	ldr	r3, [pc, #16]	; (400e4c <sysclk_get_main_hz+0x18>)
  400e3c:	4798      	blx	r3
  400e3e:	4602      	mov	r2, r0
  400e40:	f640 634e 	movw	r3, #3662	; 0xe4e
  400e44:	fb03 f302 	mul.w	r3, r3, r2

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  400e48:	4618      	mov	r0, r3
  400e4a:	bd80      	pop	{r7, pc}
  400e4c:	00400dc1 	.word	0x00400dc1

00400e50 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  400e50:	b580      	push	{r7, lr}
  400e52:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400e54:	4b02      	ldr	r3, [pc, #8]	; (400e60 <sysclk_get_cpu_hz+0x10>)
  400e56:	4798      	blx	r3
  400e58:	4603      	mov	r3, r0
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400e5a:	4618      	mov	r0, r3
  400e5c:	bd80      	pop	{r7, pc}
  400e5e:	bf00      	nop
  400e60:	00400e35 	.word	0x00400e35

00400e64 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  400e64:	b580      	push	{r7, lr}
  400e66:	b082      	sub	sp, #8
  400e68:	af00      	add	r7, sp, #0
  400e6a:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400e6c:	6878      	ldr	r0, [r7, #4]
  400e6e:	4b03      	ldr	r3, [pc, #12]	; (400e7c <sysclk_enable_peripheral_clock+0x18>)
  400e70:	4798      	blx	r3
}
  400e72:	bf00      	nop
  400e74:	3708      	adds	r7, #8
  400e76:	46bd      	mov	sp, r7
  400e78:	bd80      	pop	{r7, pc}
  400e7a:	bf00      	nop
  400e7c:	00404359 	.word	0x00404359

00400e80 <ioport_toggle_pin_level>:
 * an output.
 *
 * \param pin IOPORT pin to toggle
 */
static inline void ioport_toggle_pin_level(ioport_pin_t pin)
{
  400e80:	b480      	push	{r7}
  400e82:	b08b      	sub	sp, #44	; 0x2c
  400e84:	af00      	add	r7, sp, #0
  400e86:	6078      	str	r0, [r7, #4]
  400e88:	687b      	ldr	r3, [r7, #4]
  400e8a:	627b      	str	r3, [r7, #36]	; 0x24
  400e8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400e8e:	623b      	str	r3, [r7, #32]
  400e90:	6a3b      	ldr	r3, [r7, #32]
  400e92:	61fb      	str	r3, [r7, #28]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  400e94:	69fb      	ldr	r3, [r7, #28]
  400e96:	095b      	lsrs	r3, r3, #5
  400e98:	61bb      	str	r3, [r7, #24]
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  400e9a:	69bb      	ldr	r3, [r7, #24]
  400e9c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400ea0:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400ea4:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(port)->PIO_PDSR & mask;
}

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
  400ea6:	617b      	str	r3, [r7, #20]
  400ea8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400eaa:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  400eac:	693b      	ldr	r3, [r7, #16]
  400eae:	f003 031f 	and.w	r3, r3, #31
  400eb2:	2201      	movs	r2, #1
  400eb4:	fa02 f303 	lsl.w	r3, r2, r3
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);
  400eb8:	60fb      	str	r3, [r7, #12]

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  400eba:	697b      	ldr	r3, [r7, #20]
  400ebc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  400ebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400ec0:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  400ec2:	68bb      	ldr	r3, [r7, #8]
  400ec4:	f003 031f 	and.w	r3, r3, #31
  400ec8:	2101      	movs	r1, #1
  400eca:	fa01 f303 	lsl.w	r3, r1, r3
	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  400ece:	4013      	ands	r3, r2
  400ed0:	2b00      	cmp	r3, #0
  400ed2:	d003      	beq.n	400edc <ioport_toggle_pin_level+0x5c>
		port->PIO_CODR = mask;
  400ed4:	697b      	ldr	r3, [r7, #20]
  400ed6:	68fa      	ldr	r2, [r7, #12]
  400ed8:	635a      	str	r2, [r3, #52]	; 0x34
	arch_ioport_toggle_pin_level(pin);
}
  400eda:	e002      	b.n	400ee2 <ioport_toggle_pin_level+0x62>
	} else {
		port->PIO_SODR = mask;
  400edc:	697b      	ldr	r3, [r7, #20]
  400ede:	68fa      	ldr	r2, [r7, #12]
  400ee0:	631a      	str	r2, [r3, #48]	; 0x30
  400ee2:	bf00      	nop
  400ee4:	372c      	adds	r7, #44	; 0x2c
  400ee6:	46bd      	mov	sp, r7
  400ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
  400eec:	4770      	bx	lr
	...

00400ef0 <usart_serial_putchar>:
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  400ef0:	b580      	push	{r7, lr}
  400ef2:	b082      	sub	sp, #8
  400ef4:	af00      	add	r7, sp, #0
  400ef6:	6078      	str	r0, [r7, #4]
  400ef8:	460b      	mov	r3, r1
  400efa:	70fb      	strb	r3, [r7, #3]
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  400efc:	687b      	ldr	r3, [r7, #4]
  400efe:	4a3e      	ldr	r2, [pc, #248]	; (400ff8 <usart_serial_putchar+0x108>)
  400f00:	4293      	cmp	r3, r2
  400f02:	d10a      	bne.n	400f1a <usart_serial_putchar+0x2a>
		while (usart_write(p_usart, c)!=0);
  400f04:	bf00      	nop
  400f06:	78fb      	ldrb	r3, [r7, #3]
  400f08:	4619      	mov	r1, r3
  400f0a:	6878      	ldr	r0, [r7, #4]
  400f0c:	4b3b      	ldr	r3, [pc, #236]	; (400ffc <usart_serial_putchar+0x10c>)
  400f0e:	4798      	blx	r3
  400f10:	4603      	mov	r3, r0
  400f12:	2b00      	cmp	r3, #0
  400f14:	d1f7      	bne.n	400f06 <usart_serial_putchar+0x16>
		return 1;
  400f16:	2301      	movs	r3, #1
  400f18:	e069      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  400f1a:	687b      	ldr	r3, [r7, #4]
  400f1c:	4a38      	ldr	r2, [pc, #224]	; (401000 <usart_serial_putchar+0x110>)
  400f1e:	4293      	cmp	r3, r2
  400f20:	d10a      	bne.n	400f38 <usart_serial_putchar+0x48>
		while (usart_write(p_usart, c)!=0);
  400f22:	bf00      	nop
  400f24:	78fb      	ldrb	r3, [r7, #3]
  400f26:	4619      	mov	r1, r3
  400f28:	6878      	ldr	r0, [r7, #4]
  400f2a:	4b34      	ldr	r3, [pc, #208]	; (400ffc <usart_serial_putchar+0x10c>)
  400f2c:	4798      	blx	r3
  400f2e:	4603      	mov	r3, r0
  400f30:	2b00      	cmp	r3, #0
  400f32:	d1f7      	bne.n	400f24 <usart_serial_putchar+0x34>
		return 1;
  400f34:	2301      	movs	r3, #1
  400f36:	e05a      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART2
	if (USART2 == p_usart) {
  400f38:	687b      	ldr	r3, [r7, #4]
  400f3a:	4a32      	ldr	r2, [pc, #200]	; (401004 <usart_serial_putchar+0x114>)
  400f3c:	4293      	cmp	r3, r2
  400f3e:	d10a      	bne.n	400f56 <usart_serial_putchar+0x66>
		while (usart_write(p_usart, c)!=0);
  400f40:	bf00      	nop
  400f42:	78fb      	ldrb	r3, [r7, #3]
  400f44:	4619      	mov	r1, r3
  400f46:	6878      	ldr	r0, [r7, #4]
  400f48:	4b2c      	ldr	r3, [pc, #176]	; (400ffc <usart_serial_putchar+0x10c>)
  400f4a:	4798      	blx	r3
  400f4c:	4603      	mov	r3, r0
  400f4e:	2b00      	cmp	r3, #0
  400f50:	d1f7      	bne.n	400f42 <usart_serial_putchar+0x52>
		return 1;
  400f52:	2301      	movs	r3, #1
  400f54:	e04b      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART3
	if (USART3 == p_usart) {
  400f56:	687b      	ldr	r3, [r7, #4]
  400f58:	4a2b      	ldr	r2, [pc, #172]	; (401008 <usart_serial_putchar+0x118>)
  400f5a:	4293      	cmp	r3, r2
  400f5c:	d10a      	bne.n	400f74 <usart_serial_putchar+0x84>
		while (usart_write(p_usart, c)!=0);
  400f5e:	bf00      	nop
  400f60:	78fb      	ldrb	r3, [r7, #3]
  400f62:	4619      	mov	r1, r3
  400f64:	6878      	ldr	r0, [r7, #4]
  400f66:	4b25      	ldr	r3, [pc, #148]	; (400ffc <usart_serial_putchar+0x10c>)
  400f68:	4798      	blx	r3
  400f6a:	4603      	mov	r3, r0
  400f6c:	2b00      	cmp	r3, #0
  400f6e:	d1f7      	bne.n	400f60 <usart_serial_putchar+0x70>
		return 1;
  400f70:	2301      	movs	r3, #1
  400f72:	e03c      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART4
	if (USART4 == p_usart) {
  400f74:	687b      	ldr	r3, [r7, #4]
  400f76:	4a25      	ldr	r2, [pc, #148]	; (40100c <usart_serial_putchar+0x11c>)
  400f78:	4293      	cmp	r3, r2
  400f7a:	d10a      	bne.n	400f92 <usart_serial_putchar+0xa2>
		while (usart_write(p_usart, c)!=0);
  400f7c:	bf00      	nop
  400f7e:	78fb      	ldrb	r3, [r7, #3]
  400f80:	4619      	mov	r1, r3
  400f82:	6878      	ldr	r0, [r7, #4]
  400f84:	4b1d      	ldr	r3, [pc, #116]	; (400ffc <usart_serial_putchar+0x10c>)
  400f86:	4798      	blx	r3
  400f88:	4603      	mov	r3, r0
  400f8a:	2b00      	cmp	r3, #0
  400f8c:	d1f7      	bne.n	400f7e <usart_serial_putchar+0x8e>
		return 1;
  400f8e:	2301      	movs	r3, #1
  400f90:	e02d      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART5
	if (USART5 == p_usart) {
  400f92:	687b      	ldr	r3, [r7, #4]
  400f94:	4a1e      	ldr	r2, [pc, #120]	; (401010 <usart_serial_putchar+0x120>)
  400f96:	4293      	cmp	r3, r2
  400f98:	d10a      	bne.n	400fb0 <usart_serial_putchar+0xc0>
		while (usart_write(p_usart, c)!=0);
  400f9a:	bf00      	nop
  400f9c:	78fb      	ldrb	r3, [r7, #3]
  400f9e:	4619      	mov	r1, r3
  400fa0:	6878      	ldr	r0, [r7, #4]
  400fa2:	4b16      	ldr	r3, [pc, #88]	; (400ffc <usart_serial_putchar+0x10c>)
  400fa4:	4798      	blx	r3
  400fa6:	4603      	mov	r3, r0
  400fa8:	2b00      	cmp	r3, #0
  400faa:	d1f7      	bne.n	400f9c <usart_serial_putchar+0xac>
		return 1;
  400fac:	2301      	movs	r3, #1
  400fae:	e01e      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART6
	if (USART6 == p_usart) {
  400fb0:	687b      	ldr	r3, [r7, #4]
  400fb2:	4a18      	ldr	r2, [pc, #96]	; (401014 <usart_serial_putchar+0x124>)
  400fb4:	4293      	cmp	r3, r2
  400fb6:	d10a      	bne.n	400fce <usart_serial_putchar+0xde>
		while (usart_write(p_usart, c)!=0);
  400fb8:	bf00      	nop
  400fba:	78fb      	ldrb	r3, [r7, #3]
  400fbc:	4619      	mov	r1, r3
  400fbe:	6878      	ldr	r0, [r7, #4]
  400fc0:	4b0e      	ldr	r3, [pc, #56]	; (400ffc <usart_serial_putchar+0x10c>)
  400fc2:	4798      	blx	r3
  400fc4:	4603      	mov	r3, r0
  400fc6:	2b00      	cmp	r3, #0
  400fc8:	d1f7      	bne.n	400fba <usart_serial_putchar+0xca>
		return 1;
  400fca:	2301      	movs	r3, #1
  400fcc:	e00f      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART7
	if (USART7 == p_usart) {
  400fce:	687b      	ldr	r3, [r7, #4]
  400fd0:	4a11      	ldr	r2, [pc, #68]	; (401018 <usart_serial_putchar+0x128>)
  400fd2:	4293      	cmp	r3, r2
  400fd4:	d10a      	bne.n	400fec <usart_serial_putchar+0xfc>
		while (usart_write(p_usart, c)!=0);
  400fd6:	bf00      	nop
  400fd8:	78fb      	ldrb	r3, [r7, #3]
  400fda:	4619      	mov	r1, r3
  400fdc:	6878      	ldr	r0, [r7, #4]
  400fde:	4b07      	ldr	r3, [pc, #28]	; (400ffc <usart_serial_putchar+0x10c>)
  400fe0:	4798      	blx	r3
  400fe2:	4603      	mov	r3, r0
  400fe4:	2b00      	cmp	r3, #0
  400fe6:	d1f7      	bne.n	400fd8 <usart_serial_putchar+0xe8>
		return 1;
  400fe8:	2301      	movs	r3, #1
  400fea:	e000      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
#endif /* ifdef USART */

	return 0;
  400fec:	2300      	movs	r3, #0
}
  400fee:	4618      	mov	r0, r3
  400ff0:	3708      	adds	r7, #8
  400ff2:	46bd      	mov	sp, r7
  400ff4:	bd80      	pop	{r7, pc}
  400ff6:	bf00      	nop
  400ff8:	4000c200 	.word	0x4000c200
  400ffc:	00403531 	.word	0x00403531
  401000:	40020200 	.word	0x40020200
  401004:	40024200 	.word	0x40024200
  401008:	40018200 	.word	0x40018200
  40100c:	4001c200 	.word	0x4001c200
  401010:	40008200 	.word	0x40008200
  401014:	40040200 	.word	0x40040200
  401018:	40034200 	.word	0x40034200

0040101c <inv_icm20648_reset_states>:
/** @brief Reset and initialize driver states
 *  @param[in] s             handle to driver states structure
 */
static inline void inv_icm20648_reset_states(struct inv_icm20648 * s,
		const struct inv_icm20648_serif * serif)
{
  40101c:	b5b0      	push	{r4, r5, r7, lr}
  40101e:	b082      	sub	sp, #8
  401020:	af00      	add	r7, sp, #0
  401022:	6078      	str	r0, [r7, #4]
  401024:	6039      	str	r1, [r7, #0]
	assert(icm20648_instance == 0);

	memset(s, 0, sizeof(*s));
  401026:	f44f 629f 	mov.w	r2, #1272	; 0x4f8
  40102a:	2100      	movs	r1, #0
  40102c:	6878      	ldr	r0, [r7, #4]
  40102e:	4b09      	ldr	r3, [pc, #36]	; (401054 <inv_icm20648_reset_states+0x38>)
  401030:	4798      	blx	r3
	s->serif = *serif;
  401032:	687a      	ldr	r2, [r7, #4]
  401034:	683b      	ldr	r3, [r7, #0]
  401036:	4614      	mov	r4, r2
  401038:	461d      	mov	r5, r3
  40103a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  40103c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  40103e:	e895 0003 	ldmia.w	r5, {r0, r1}
  401042:	e884 0003 	stmia.w	r4, {r0, r1}
	icm20648_instance = s;
  401046:	4a04      	ldr	r2, [pc, #16]	; (401058 <inv_icm20648_reset_states+0x3c>)
  401048:	687b      	ldr	r3, [r7, #4]
  40104a:	6013      	str	r3, [r2, #0]
}
  40104c:	bf00      	nop
  40104e:	3708      	adds	r7, #8
  401050:	46bd      	mov	sp, r7
  401052:	bdb0      	pop	{r4, r5, r7, pc}
  401054:	00414431 	.word	0x00414431
  401058:	20001f80 	.word	0x20001f80

0040105c <InvScheduler_init>:

/** @brief Reset scheduler states
 *  @param[in] scheduler    handle to scheduler
 */
static inline void InvScheduler_init(InvScheduler *scheduler)
{
  40105c:	b480      	push	{r7}
  40105e:	b083      	sub	sp, #12
  401060:	af00      	add	r7, sp, #0
  401062:	6078      	str	r0, [r7, #4]
	scheduler->currentTime  = 0;
  401064:	687b      	ldr	r3, [r7, #4]
  401066:	2200      	movs	r2, #0
  401068:	601a      	str	r2, [r3, #0]
	scheduler->queue        = 0;
  40106a:	687b      	ldr	r3, [r7, #4]
  40106c:	2200      	movs	r2, #0
  40106e:	605a      	str	r2, [r3, #4]
	scheduler->contextLock  = 0;
  401070:	687b      	ldr	r3, [r7, #4]
  401072:	2200      	movs	r2, #0
  401074:	609a      	str	r2, [r3, #8]
}
  401076:	bf00      	nop
  401078:	370c      	adds	r7, #12
  40107a:	46bd      	mov	sp, r7
  40107c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401080:	4770      	bx	lr
	...

00401084 <InvScheduler_initTask>:
/** @brief Simitlar to InvScheduler_initTaskDo() but allow to set a name
 */
static inline void InvScheduler_initTask(InvScheduler *scheduler,
		InvSchedulerTask *task, const char *name, void (*func)(void *),
		void *arg, uint8_t prio, uint32_t period)
{
  401084:	b590      	push	{r4, r7, lr}
  401086:	b087      	sub	sp, #28
  401088:	af02      	add	r7, sp, #8
  40108a:	60f8      	str	r0, [r7, #12]
  40108c:	60b9      	str	r1, [r7, #8]
  40108e:	607a      	str	r2, [r7, #4]
  401090:	603b      	str	r3, [r7, #0]
	InvScheduler_initTaskDo(scheduler, task, func, arg, prio, period);
  401092:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401094:	9301      	str	r3, [sp, #4]
  401096:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
  40109a:	9300      	str	r3, [sp, #0]
  40109c:	6a3b      	ldr	r3, [r7, #32]
  40109e:	683a      	ldr	r2, [r7, #0]
  4010a0:	68b9      	ldr	r1, [r7, #8]
  4010a2:	68f8      	ldr	r0, [r7, #12]
  4010a4:	4c02      	ldr	r4, [pc, #8]	; (4010b0 <InvScheduler_initTask+0x2c>)
  4010a6:	47a0      	blx	r4
#ifdef INVSCHEDULER_TASK_NAME
	task->name = name;
#else
	(void)name;
#endif
}
  4010a8:	bf00      	nop
  4010aa:	3714      	adds	r7, #20
  4010ac:	46bd      	mov	sp, r7
  4010ae:	bd90      	pop	{r4, r7, pc}
  4010b0:	0040fe5d 	.word	0x0040fe5d

004010b4 <RingByteBuffer_isEmpty>:

/** @brief 		Check for ring buffer emptyness
	@return 	Return true if ring buffer is empty, false otherwise
*/
static inline inv_bool_t RingByteBuffer_isEmpty(const RingByteBuffer *self)
{
  4010b4:	b480      	push	{r7}
  4010b6:	b083      	sub	sp, #12
  4010b8:	af00      	add	r7, sp, #0
  4010ba:	6078      	str	r0, [r7, #4]
	ASSERT(self);

	return (self->end == self->start && self->msbEnd == self->msbStart);
  4010bc:	687b      	ldr	r3, [r7, #4]
  4010be:	891a      	ldrh	r2, [r3, #8]
  4010c0:	687b      	ldr	r3, [r7, #4]
  4010c2:	88db      	ldrh	r3, [r3, #6]
  4010c4:	429a      	cmp	r2, r3
  4010c6:	d107      	bne.n	4010d8 <RingByteBuffer_isEmpty+0x24>
  4010c8:	687b      	ldr	r3, [r7, #4]
  4010ca:	7ada      	ldrb	r2, [r3, #11]
  4010cc:	687b      	ldr	r3, [r7, #4]
  4010ce:	7a9b      	ldrb	r3, [r3, #10]
  4010d0:	429a      	cmp	r2, r3
  4010d2:	d101      	bne.n	4010d8 <RingByteBuffer_isEmpty+0x24>
  4010d4:	2301      	movs	r3, #1
  4010d6:	e000      	b.n	4010da <RingByteBuffer_isEmpty+0x26>
  4010d8:	2300      	movs	r3, #0
}
  4010da:	4618      	mov	r0, r3
  4010dc:	370c      	adds	r7, #12
  4010de:	46bd      	mov	sp, r7
  4010e0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4010e4:	4770      	bx	lr
	...

004010e8 <BlinkerLedTaskMain>:
#endif

/*
* BlinkerLedTaskMain - Task that blinks the LED.
*/
static void BlinkerLedTaskMain(void * arg){
  4010e8:	b580      	push	{r7, lr}
  4010ea:	b082      	sub	sp, #8
  4010ec:	af00      	add	r7, sp, #0
  4010ee:	6078      	str	r0, [r7, #4]
	(void)arg;

	ioport_toggle_pin_level(LED_0_PIN);
  4010f0:	2006      	movs	r0, #6
  4010f2:	4b03      	ldr	r3, [pc, #12]	; (401100 <BlinkerLedTaskMain+0x18>)
  4010f4:	4798      	blx	r3
}
  4010f6:	bf00      	nop
  4010f8:	3708      	adds	r7, #8
  4010fa:	46bd      	mov	sp, r7
  4010fc:	bd80      	pop	{r7, pc}
  4010fe:	bf00      	nop
  401100:	00400e81 	.word	0x00400e81

00401104 <inv_icm20648_get_time_us>:

uint64_t inv_icm20648_get_time_us(void){
  401104:	b598      	push	{r3, r4, r7, lr}
  401106:	af00      	add	r7, sp, #0
	return InvEMDFrontEnd_getTimestampUs();
  401108:	4b03      	ldr	r3, [pc, #12]	; (401118 <inv_icm20648_get_time_us+0x14>)
  40110a:	4798      	blx	r3
  40110c:	4603      	mov	r3, r0
  40110e:	460c      	mov	r4, r1
}
  401110:	4618      	mov	r0, r3
  401112:	4621      	mov	r1, r4
  401114:	bd98      	pop	{r3, r4, r7, pc}
  401116:	bf00      	nop
  401118:	004031c9 	.word	0x004031c9

0040111c <CommandHandlerTaskMain>:

/*
* CommandHandlerTaskMain - Task that monitors the UART
*/
static void CommandHandlerTaskMain(void * arg){
  40111c:	b580      	push	{r7, lr}
  40111e:	b084      	sub	sp, #16
  401120:	af00      	add	r7, sp, #0
  401122:	6078      	str	r0, [r7, #4]
	(void)arg;

	int byte;
	do {
		byte = EOF;
  401124:	f04f 33ff 	mov.w	r3, #4294967295
  401128:	60fb      	str	r3, [r7, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  40112a:	b672      	cpsid	i
		__disable_irq();

		if(!RingByteBuffer_isEmpty(&uart_rx_rb)) {
  40112c:	480e      	ldr	r0, [pc, #56]	; (401168 <CommandHandlerTaskMain+0x4c>)
  40112e:	4b0f      	ldr	r3, [pc, #60]	; (40116c <CommandHandlerTaskMain+0x50>)
  401130:	4798      	blx	r3
  401132:	4603      	mov	r3, r0
  401134:	2b00      	cmp	r3, #0
  401136:	d104      	bne.n	401142 <CommandHandlerTaskMain+0x26>
			byte = RingByteBuffer_popByte(&uart_rx_rb);
  401138:	480b      	ldr	r0, [pc, #44]	; (401168 <CommandHandlerTaskMain+0x4c>)
  40113a:	4b0d      	ldr	r3, [pc, #52]	; (401170 <CommandHandlerTaskMain+0x54>)
  40113c:	4798      	blx	r3
  40113e:	4603      	mov	r3, r0
  401140:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsie i" : : : "memory");
  401142:	b662      	cpsie	i
		}
		__enable_irq();

		if(byte != EOF) {
  401144:	68fb      	ldr	r3, [r7, #12]
  401146:	f1b3 3fff 	cmp.w	r3, #4294967295
  40114a:	d005      	beq.n	401158 <CommandHandlerTaskMain+0x3c>
			DynProTransportUart_rxProcessByte(&transport, (uint8_t)byte);
  40114c:	68fb      	ldr	r3, [r7, #12]
  40114e:	b2db      	uxtb	r3, r3
  401150:	4619      	mov	r1, r3
  401152:	4808      	ldr	r0, [pc, #32]	; (401174 <CommandHandlerTaskMain+0x58>)
  401154:	4b08      	ldr	r3, [pc, #32]	; (401178 <CommandHandlerTaskMain+0x5c>)
  401156:	4798      	blx	r3
		}
	} while(byte != EOF);
  401158:	68fb      	ldr	r3, [r7, #12]
  40115a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40115e:	d1e1      	bne.n	401124 <CommandHandlerTaskMain+0x8>
}
  401160:	bf00      	nop
  401162:	3710      	adds	r7, #16
  401164:	46bd      	mov	sp, r7
  401166:	bd80      	pop	{r7, pc}
  401168:	20001ed0 	.word	0x20001ed0
  40116c:	004010b5 	.word	0x004010b5
  401170:	00410047 	.word	0x00410047
  401174:	20001988 	.word	0x20001988
  401178:	0040f7e5 	.word	0x0040f7e5

0040117c <main>:

int main (void){
  40117c:	b590      	push	{r4, r7, lr}
  40117e:	b08d      	sub	sp, #52	; 0x34
  401180:	af04      	add	r7, sp, #16

	int rc = 0;
  401182:	2300      	movs	r3, #0
  401184:	61fb      	str	r3, [r7, #28]

	/* Hardware initialization */
	sysclk_init();
  401186:	4b46      	ldr	r3, [pc, #280]	; (4012a0 <main+0x124>)
  401188:	4798      	blx	r3
	board_init(); 
  40118a:	4b46      	ldr	r3, [pc, #280]	; (4012a4 <main+0x128>)
  40118c:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_TC0);	
  40118e:	2017      	movs	r0, #23
  401190:	4b45      	ldr	r3, [pc, #276]	; (4012a8 <main+0x12c>)
  401192:	4798      	blx	r3

	/* Configure Device - Host Interface */
	configure_console();
  401194:	4b45      	ldr	r3, [pc, #276]	; (4012ac <main+0x130>)
  401196:	4798      	blx	r3

#ifdef INV_MSG_ENABLE
	/* Setup message logging */
	INV_MSG_SETUP(INV_MSG_ENABLE, msg_printer);
  401198:	4945      	ldr	r1, [pc, #276]	; (4012b0 <main+0x134>)
  40119a:	2005      	movs	r0, #5
  40119c:	4b45      	ldr	r3, [pc, #276]	; (4012b4 <main+0x138>)
  40119e:	4798      	blx	r3
#endif

	INV_MSG(INV_MSG_LEVEL_INFO, "###################################");
  4011a0:	4945      	ldr	r1, [pc, #276]	; (4012b8 <main+0x13c>)
  4011a2:	2003      	movs	r0, #3
  4011a4:	4b45      	ldr	r3, [pc, #276]	; (4012bc <main+0x140>)
  4011a6:	4798      	blx	r3
	INV_MSG(INV_MSG_LEVEL_INFO, "#   ICM20648 example              #");
  4011a8:	4945      	ldr	r1, [pc, #276]	; (4012c0 <main+0x144>)
  4011aa:	2003      	movs	r0, #3
  4011ac:	4b43      	ldr	r3, [pc, #268]	; (4012bc <main+0x140>)
  4011ae:	4798      	blx	r3
	INV_MSG(INV_MSG_LEVEL_INFO, "###################################");
  4011b0:	4941      	ldr	r1, [pc, #260]	; (4012b8 <main+0x13c>)
  4011b2:	2003      	movs	r0, #3
  4011b4:	4b41      	ldr	r3, [pc, #260]	; (4012bc <main+0x140>)
  4011b6:	4798      	blx	r3

	/* Initialize External Sensor Interrupt */
	ext_int_initialize(&ext_interrupt_handler);
  4011b8:	4842      	ldr	r0, [pc, #264]	; (4012c4 <main+0x148>)
  4011ba:	4b43      	ldr	r3, [pc, #268]	; (4012c8 <main+0x14c>)
  4011bc:	4798      	blx	r3
	interface_initialize();
  4011be:	4b43      	ldr	r3, [pc, #268]	; (4012cc <main+0x150>)
  4011c0:	4798      	blx	r3

	/* Configure sysTick Timer */	
	SysTick_Config(sysclk_get_cpu_hz() / MILLISECONDS_PER_SECOND);
  4011c2:	4b43      	ldr	r3, [pc, #268]	; (4012d0 <main+0x154>)
  4011c4:	4798      	blx	r3
  4011c6:	4602      	mov	r2, r0
  4011c8:	4b42      	ldr	r3, [pc, #264]	; (4012d4 <main+0x158>)
  4011ca:	fba3 2302 	umull	r2, r3, r3, r2
  4011ce:	099b      	lsrs	r3, r3, #6
  4011d0:	4618      	mov	r0, r3
  4011d2:	4b41      	ldr	r3, [pc, #260]	; (4012d8 <main+0x15c>)
  4011d4:	4798      	blx	r3

	/* 
	* Initialize icm20648 serif structure 
	*/
	struct inv_icm20648_serif icm20648_serif;
	icm20648_serif.context   = 0; /* no need */
  4011d6:	2300      	movs	r3, #0
  4011d8:	607b      	str	r3, [r7, #4]
	icm20648_serif.read_reg  = idd_io_hal_read_reg;
  4011da:	4b40      	ldr	r3, [pc, #256]	; (4012dc <main+0x160>)
  4011dc:	60bb      	str	r3, [r7, #8]
	icm20648_serif.write_reg = idd_io_hal_write_reg;
  4011de:	4b40      	ldr	r3, [pc, #256]	; (4012e0 <main+0x164>)
  4011e0:	60fb      	str	r3, [r7, #12]
	icm20648_serif.max_read  = 1024*16; /* maximum number of bytes allowed per serial read */
  4011e2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  4011e6:	613b      	str	r3, [r7, #16]
	icm20648_serif.max_write = 1024*16; /* maximum number of bytes allowed per serial write */
  4011e8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  4011ec:	617b      	str	r3, [r7, #20]

	icm20648_serif.is_spi    = interface_is_SPI();
  4011ee:	4b3d      	ldr	r3, [pc, #244]	; (4012e4 <main+0x168>)
  4011f0:	4798      	blx	r3
  4011f2:	4603      	mov	r3, r0
  4011f4:	61bb      	str	r3, [r7, #24]

	/* 
	* Reset icm20648 driver states
	*/
	inv_icm20648_reset_states(&icm_device, &icm20648_serif);
  4011f6:	1d3b      	adds	r3, r7, #4
  4011f8:	4619      	mov	r1, r3
  4011fa:	483b      	ldr	r0, [pc, #236]	; (4012e8 <main+0x16c>)
  4011fc:	4b3b      	ldr	r3, [pc, #236]	; (4012ec <main+0x170>)
  4011fe:	4798      	blx	r3

	/*
	* Setup the icm20648 device
	*/
	icm20648_sensor_setup();
  401200:	4b3b      	ldr	r3, [pc, #236]	; (4012f0 <main+0x174>)
  401202:	4798      	blx	r3

	/*
	* Now that Icm20648 device was initialized, we can proceed with DMP image loading
	* This step is mandatory as DMP image are not store in non volatile memory
	*/
	rc += load_dmp3();
  401204:	4b3b      	ldr	r3, [pc, #236]	; (4012f4 <main+0x178>)
  401206:	4798      	blx	r3
  401208:	4602      	mov	r2, r0
  40120a:	69fb      	ldr	r3, [r7, #28]
  40120c:	4413      	add	r3, r2
  40120e:	61fb      	str	r3, [r7, #28]
	check_rc(rc, "Error sensor_setup/DMP loading.");
  401210:	4939      	ldr	r1, [pc, #228]	; (4012f8 <main+0x17c>)
  401212:	69f8      	ldr	r0, [r7, #28]
  401214:	4b39      	ldr	r3, [pc, #228]	; (4012fc <main+0x180>)
  401216:	4798      	blx	r3

	/*
	* Initialize Dynamic protocol stuff
	*/
	DynProTransportUart_init(&transport, iddwrapper_transport_event_cb, 0);
  401218:	2200      	movs	r2, #0
  40121a:	4939      	ldr	r1, [pc, #228]	; (401300 <main+0x184>)
  40121c:	4839      	ldr	r0, [pc, #228]	; (401304 <main+0x188>)
  40121e:	4b3a      	ldr	r3, [pc, #232]	; (401308 <main+0x18c>)
  401220:	4798      	blx	r3
	DynProtocol_init(&protocol, iddwrapper_protocol_event_cb, 0);
  401222:	2200      	movs	r2, #0
  401224:	4939      	ldr	r1, [pc, #228]	; (40130c <main+0x190>)
  401226:	483a      	ldr	r0, [pc, #232]	; (401310 <main+0x194>)
  401228:	4b3a      	ldr	r3, [pc, #232]	; (401314 <main+0x198>)
  40122a:	4798      	blx	r3

	InvScheduler_init(&scheduler);
  40122c:	483a      	ldr	r0, [pc, #232]	; (401318 <main+0x19c>)
  40122e:	4b3b      	ldr	r3, [pc, #236]	; (40131c <main+0x1a0>)
  401230:	4798      	blx	r3
	InvScheduler_initTask(&scheduler, &commandHandlerTask, "commandHandlerTask", CommandHandlerTaskMain, 0, INVSCHEDULER_TASK_PRIO_MIN, 1);
  401232:	2301      	movs	r3, #1
  401234:	9302      	str	r3, [sp, #8]
  401236:	2301      	movs	r3, #1
  401238:	9301      	str	r3, [sp, #4]
  40123a:	2300      	movs	r3, #0
  40123c:	9300      	str	r3, [sp, #0]
  40123e:	4b38      	ldr	r3, [pc, #224]	; (401320 <main+0x1a4>)
  401240:	4a38      	ldr	r2, [pc, #224]	; (401324 <main+0x1a8>)
  401242:	4939      	ldr	r1, [pc, #228]	; (401328 <main+0x1ac>)
  401244:	4834      	ldr	r0, [pc, #208]	; (401318 <main+0x19c>)
  401246:	4c39      	ldr	r4, [pc, #228]	; (40132c <main+0x1b0>)
  401248:	47a0      	blx	r4
	InvScheduler_initTask(&scheduler, &blinkerLedTask, "blinkerLedTask", BlinkerLedTaskMain, 0, INVSCHEDULER_TASK_PRIO_MIN+1, 1000000/SCHEDULER_PERIOD);
  40124a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  40124e:	9302      	str	r3, [sp, #8]
  401250:	2302      	movs	r3, #2
  401252:	9301      	str	r3, [sp, #4]
  401254:	2300      	movs	r3, #0
  401256:	9300      	str	r3, [sp, #0]
  401258:	4b35      	ldr	r3, [pc, #212]	; (401330 <main+0x1b4>)
  40125a:	4a36      	ldr	r2, [pc, #216]	; (401334 <main+0x1b8>)
  40125c:	4936      	ldr	r1, [pc, #216]	; (401338 <main+0x1bc>)
  40125e:	482e      	ldr	r0, [pc, #184]	; (401318 <main+0x19c>)
  401260:	4c32      	ldr	r4, [pc, #200]	; (40132c <main+0x1b0>)
  401262:	47a0      	blx	r4
	InvScheduler_startTask(&blinkerLedTask, 0);
  401264:	2100      	movs	r1, #0
  401266:	4834      	ldr	r0, [pc, #208]	; (401338 <main+0x1bc>)
  401268:	4b34      	ldr	r3, [pc, #208]	; (40133c <main+0x1c0>)
  40126a:	4798      	blx	r3
	InvScheduler_startTask(&commandHandlerTask, 0);
  40126c:	2100      	movs	r1, #0
  40126e:	482e      	ldr	r0, [pc, #184]	; (401328 <main+0x1ac>)
  401270:	4b32      	ldr	r3, [pc, #200]	; (40133c <main+0x1c0>)
  401272:	4798      	blx	r3

	hw_timer_start(20);		// Start the timestamp timer at 20 Hz.
  401274:	2014      	movs	r0, #20
  401276:	4b32      	ldr	r3, [pc, #200]	; (401340 <main+0x1c4>)
  401278:	4798      	blx	r3
	while (1) {
		InvScheduler_dispatchTasks(&scheduler);
  40127a:	4827      	ldr	r0, [pc, #156]	; (401318 <main+0x19c>)
  40127c:	4b31      	ldr	r3, [pc, #196]	; (401344 <main+0x1c8>)
  40127e:	4798      	blx	r3

		if (irq_from_device == 1) {
  401280:	4b31      	ldr	r3, [pc, #196]	; (401348 <main+0x1cc>)
  401282:	681b      	ldr	r3, [r3, #0]
  401284:	2b01      	cmp	r3, #1
  401286:	d1f8      	bne.n	40127a <main+0xfe>
			inv_icm20648_poll_sensor(&icm_device, (void *)0, build_sensor_event_data);
  401288:	4a30      	ldr	r2, [pc, #192]	; (40134c <main+0x1d0>)
  40128a:	2100      	movs	r1, #0
  40128c:	4816      	ldr	r0, [pc, #88]	; (4012e8 <main+0x16c>)
  40128e:	4b30      	ldr	r3, [pc, #192]	; (401350 <main+0x1d4>)
  401290:	4798      	blx	r3
  __ASM volatile ("cpsid i" : : : "memory");
  401292:	b672      	cpsid	i

			__disable_irq();
			irq_from_device = 0;
  401294:	4b2c      	ldr	r3, [pc, #176]	; (401348 <main+0x1cc>)
  401296:	2200      	movs	r2, #0
  401298:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
  40129a:	b662      	cpsie	i
		InvScheduler_dispatchTasks(&scheduler);
  40129c:	e7ed      	b.n	40127a <main+0xfe>
  40129e:	bf00      	nop
  4012a0:	00403b19 	.word	0x00403b19
  4012a4:	00403fa5 	.word	0x00403fa5
  4012a8:	00400e65 	.word	0x00400e65
  4012ac:	00402ef5 	.word	0x00402ef5
  4012b0:	00401355 	.word	0x00401355
  4012b4:	0040ff0d 	.word	0x0040ff0d
  4012b8:	00418148 	.word	0x00418148
  4012bc:	0040ff51 	.word	0x0040ff51
  4012c0:	0041816c 	.word	0x0041816c
  4012c4:	00402e7d 	.word	0x00402e7d
  4012c8:	00402e95 	.word	0x00402e95
  4012cc:	004030fd 	.word	0x004030fd
  4012d0:	00400e51 	.word	0x00400e51
  4012d4:	10624dd3 	.word	0x10624dd3
  4012d8:	00400d79 	.word	0x00400d79
  4012dc:	00403291 	.word	0x00403291
  4012e0:	004032c5 	.word	0x004032c5
  4012e4:	004030ed 	.word	0x004030ed
  4012e8:	20001998 	.word	0x20001998
  4012ec:	0040101d 	.word	0x0040101d
  4012f0:	00401769 	.word	0x00401769
  4012f4:	00401681 	.word	0x00401681
  4012f8:	00418190 	.word	0x00418190
  4012fc:	004018ad 	.word	0x004018ad
  401300:	00401985 	.word	0x00401985
  401304:	20001988 	.word	0x20001988
  401308:	0040f7b5 	.word	0x0040f7b5
  40130c:	004018e9 	.word	0x004018e9
  401310:	20001870 	.word	0x20001870
  401314:	0040f1d9 	.word	0x0040f1d9
  401318:	20001eb0 	.word	0x20001eb0
  40131c:	0040105d 	.word	0x0040105d
  401320:	0040111d 	.word	0x0040111d
  401324:	004181b0 	.word	0x004181b0
  401328:	20000dc0 	.word	0x20000dc0
  40132c:	00401085 	.word	0x00401085
  401330:	004010e9 	.word	0x004010e9
  401334:	004181c4 	.word	0x004181c4
  401338:	20000d9c 	.word	0x20000d9c
  40133c:	0040feed 	.word	0x0040feed
  401340:	0040310d 	.word	0x0040310d
  401344:	0040fe2d 	.word	0x0040fe2d
  401348:	20000d98 	.word	0x20000d98
  40134c:	00401a7d 	.word	0x00401a7d
  401350:	0040b385 	.word	0x0040b385

00401354 <msg_printer>:

#ifdef INV_MSG_ENABLE
/*
* Printer function for message facility
*/
static void msg_printer(int level, const char * str, va_list ap){
  401354:	b5b0      	push	{r4, r5, r7, lr}
  401356:	b08c      	sub	sp, #48	; 0x30
  401358:	af00      	add	r7, sp, #0
  40135a:	60f8      	str	r0, [r7, #12]
  40135c:	60b9      	str	r1, [r7, #8]
  40135e:	607a      	str	r2, [r7, #4]

	static char out_str[256]; /* static to limit stack usage */
	unsigned idx = 0;
  401360:	2300      	movs	r3, #0
  401362:	62bb      	str	r3, [r7, #40]	; 0x28
	const char * ptr = out_str;
  401364:	4b2f      	ldr	r3, [pc, #188]	; (401424 <msg_printer+0xd0>)
  401366:	62fb      	str	r3, [r7, #44]	; 0x2c
	const char * s[INV_MSG_LEVEL_MAX] = {
  401368:	4b2f      	ldr	r3, [pc, #188]	; (401428 <msg_printer+0xd4>)
  40136a:	f107 0410 	add.w	r4, r7, #16
  40136e:	461d      	mov	r5, r3
  401370:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  401372:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  401374:	e895 0003 	ldmia.w	r5, {r0, r1}
  401378:	e884 0003 	stmia.w	r4, {r0, r1}
		"[W] ", // INV_MSG_LEVEL_WARNING
		"[I] ", // INV_MSG_LEVEL_INFO
		"[V] ", // INV_MSG_LEVEL_VERBOSE
		"[D] ", // INV_MSG_LEVEL_DEBUG
	};
	idx += snprintf(&out_str[idx], sizeof(out_str) - idx, "%s", s[level]);
  40137c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40137e:	4a29      	ldr	r2, [pc, #164]	; (401424 <msg_printer+0xd0>)
  401380:	1898      	adds	r0, r3, r2
  401382:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401384:	f5c3 7180 	rsb	r1, r3, #256	; 0x100
  401388:	68fb      	ldr	r3, [r7, #12]
  40138a:	009b      	lsls	r3, r3, #2
  40138c:	f107 0230 	add.w	r2, r7, #48	; 0x30
  401390:	4413      	add	r3, r2
  401392:	f853 3c20 	ldr.w	r3, [r3, #-32]
  401396:	4a25      	ldr	r2, [pc, #148]	; (40142c <msg_printer+0xd8>)
  401398:	4c25      	ldr	r4, [pc, #148]	; (401430 <msg_printer+0xdc>)
  40139a:	47a0      	blx	r4
  40139c:	4603      	mov	r3, r0
  40139e:	461a      	mov	r2, r3
  4013a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013a2:	4413      	add	r3, r2
  4013a4:	62bb      	str	r3, [r7, #40]	; 0x28
	if(idx >= (sizeof(out_str)))
  4013a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013a8:	2bff      	cmp	r3, #255	; 0xff
  4013aa:	d832      	bhi.n	401412 <msg_printer+0xbe>
		return;
	idx += vsnprintf(&out_str[idx], sizeof(out_str) - idx, str, ap);
  4013ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013ae:	4a1d      	ldr	r2, [pc, #116]	; (401424 <msg_printer+0xd0>)
  4013b0:	1898      	adds	r0, r3, r2
  4013b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013b4:	f5c3 7180 	rsb	r1, r3, #256	; 0x100
  4013b8:	687b      	ldr	r3, [r7, #4]
  4013ba:	68ba      	ldr	r2, [r7, #8]
  4013bc:	4c1d      	ldr	r4, [pc, #116]	; (401434 <msg_printer+0xe0>)
  4013be:	47a0      	blx	r4
  4013c0:	4603      	mov	r3, r0
  4013c2:	461a      	mov	r2, r3
  4013c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013c6:	4413      	add	r3, r2
  4013c8:	62bb      	str	r3, [r7, #40]	; 0x28
	if(idx >= (sizeof(out_str)))
  4013ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013cc:	2bff      	cmp	r3, #255	; 0xff
  4013ce:	d822      	bhi.n	401416 <msg_printer+0xc2>
		return;
	idx += snprintf(&out_str[idx], sizeof(out_str) - idx, "\r\n");
  4013d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013d2:	4a14      	ldr	r2, [pc, #80]	; (401424 <msg_printer+0xd0>)
  4013d4:	1898      	adds	r0, r3, r2
  4013d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013d8:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
  4013dc:	4a16      	ldr	r2, [pc, #88]	; (401438 <msg_printer+0xe4>)
  4013de:	4619      	mov	r1, r3
  4013e0:	4b13      	ldr	r3, [pc, #76]	; (401430 <msg_printer+0xdc>)
  4013e2:	4798      	blx	r3
  4013e4:	4603      	mov	r3, r0
  4013e6:	461a      	mov	r2, r3
  4013e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013ea:	4413      	add	r3, r2
  4013ec:	62bb      	str	r3, [r7, #40]	; 0x28
	if(idx >= (sizeof(out_str)))
  4013ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013f0:	2bff      	cmp	r3, #255	; 0xff
  4013f2:	d812      	bhi.n	40141a <msg_printer+0xc6>
		return;

	while(*ptr != '\0') {
  4013f4:	e008      	b.n	401408 <msg_printer+0xb4>
		usart_serial_putchar(DEBUG_UART, *ptr);
  4013f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4013f8:	781b      	ldrb	r3, [r3, #0]
  4013fa:	4619      	mov	r1, r3
  4013fc:	480f      	ldr	r0, [pc, #60]	; (40143c <msg_printer+0xe8>)
  4013fe:	4b10      	ldr	r3, [pc, #64]	; (401440 <msg_printer+0xec>)
  401400:	4798      	blx	r3
		++ptr;
  401402:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401404:	3301      	adds	r3, #1
  401406:	62fb      	str	r3, [r7, #44]	; 0x2c
	while(*ptr != '\0') {
  401408:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40140a:	781b      	ldrb	r3, [r3, #0]
  40140c:	2b00      	cmp	r3, #0
  40140e:	d1f2      	bne.n	4013f6 <msg_printer+0xa2>
  401410:	e004      	b.n	40141c <msg_printer+0xc8>
		return;
  401412:	bf00      	nop
  401414:	e002      	b.n	40141c <msg_printer+0xc8>
		return;
  401416:	bf00      	nop
  401418:	e000      	b.n	40141c <msg_printer+0xc8>
		return;
  40141a:	bf00      	nop
	}
}
  40141c:	3730      	adds	r7, #48	; 0x30
  40141e:	46bd      	mov	sp, r7
  401420:	bdb0      	pop	{r4, r5, r7, pc}
  401422:	bf00      	nop
  401424:	20000de4 	.word	0x20000de4
  401428:	00418208 	.word	0x00418208
  40142c:	004181d4 	.word	0x004181d4
  401430:	004144cd 	.word	0x004144cd
  401434:	00415a71 	.word	0x00415a71
  401438:	004181d8 	.word	0x004181d8
  40143c:	40034200 	.word	0x40034200
  401440:	00400ef1 	.word	0x00400ef1
  401444:	00000000 	.word	0x00000000

00401448 <InvEMDFrontEnd_busyWaitUsHook>:
#endif

void InvEMDFrontEnd_busyWaitUsHook(uint32_t us){
  401448:	b5f0      	push	{r4, r5, r6, r7, lr}
  40144a:	b083      	sub	sp, #12
  40144c:	af00      	add	r7, sp, #0
  40144e:	6078      	str	r0, [r7, #4]
	delay_us(us);
  401450:	687b      	ldr	r3, [r7, #4]
  401452:	2b00      	cmp	r3, #0
  401454:	d024      	beq.n	4014a0 <InvEMDFrontEnd_busyWaitUsHook+0x58>
  401456:	687b      	ldr	r3, [r7, #4]
  401458:	461d      	mov	r5, r3
  40145a:	f04f 0600 	mov.w	r6, #0
  40145e:	4b20      	ldr	r3, [pc, #128]	; (4014e0 <InvEMDFrontEnd_busyWaitUsHook+0x98>)
  401460:	4798      	blx	r3
  401462:	4603      	mov	r3, r0
  401464:	f04f 0400 	mov.w	r4, #0
  401468:	fb03 f106 	mul.w	r1, r3, r6
  40146c:	fb05 f204 	mul.w	r2, r5, r4
  401470:	440a      	add	r2, r1
  401472:	fba5 3403 	umull	r3, r4, r5, r3
  401476:	4422      	add	r2, r4
  401478:	4614      	mov	r4, r2
  40147a:	a217      	add	r2, pc, #92	; (adr r2, 4014d8 <InvEMDFrontEnd_busyWaitUsHook+0x90>)
  40147c:	e9d2 1200 	ldrd	r1, r2, [r2]
  401480:	185d      	adds	r5, r3, r1
  401482:	eb44 0602 	adc.w	r6, r4, r2
  401486:	4628      	mov	r0, r5
  401488:	4631      	mov	r1, r6
  40148a:	4c16      	ldr	r4, [pc, #88]	; (4014e4 <InvEMDFrontEnd_busyWaitUsHook+0x9c>)
  40148c:	4a16      	ldr	r2, [pc, #88]	; (4014e8 <InvEMDFrontEnd_busyWaitUsHook+0xa0>)
  40148e:	f04f 0300 	mov.w	r3, #0
  401492:	47a0      	blx	r4
  401494:	4603      	mov	r3, r0
  401496:	460c      	mov	r4, r1
  401498:	4618      	mov	r0, r3
  40149a:	4b14      	ldr	r3, [pc, #80]	; (4014ec <InvEMDFrontEnd_busyWaitUsHook+0xa4>)
  40149c:	4798      	blx	r3
}
  40149e:	e016      	b.n	4014ce <InvEMDFrontEnd_busyWaitUsHook+0x86>
	delay_us(us);
  4014a0:	4b0f      	ldr	r3, [pc, #60]	; (4014e0 <InvEMDFrontEnd_busyWaitUsHook+0x98>)
  4014a2:	4798      	blx	r3
  4014a4:	4603      	mov	r3, r0
  4014a6:	f04f 0400 	mov.w	r4, #0
  4014aa:	a20b      	add	r2, pc, #44	; (adr r2, 4014d8 <InvEMDFrontEnd_busyWaitUsHook+0x90>)
  4014ac:	e9d2 1200 	ldrd	r1, r2, [r2]
  4014b0:	185d      	adds	r5, r3, r1
  4014b2:	eb44 0602 	adc.w	r6, r4, r2
  4014b6:	4628      	mov	r0, r5
  4014b8:	4631      	mov	r1, r6
  4014ba:	4c0a      	ldr	r4, [pc, #40]	; (4014e4 <InvEMDFrontEnd_busyWaitUsHook+0x9c>)
  4014bc:	4a0a      	ldr	r2, [pc, #40]	; (4014e8 <InvEMDFrontEnd_busyWaitUsHook+0xa0>)
  4014be:	f04f 0300 	mov.w	r3, #0
  4014c2:	47a0      	blx	r4
  4014c4:	4603      	mov	r3, r0
  4014c6:	460c      	mov	r4, r1
  4014c8:	4618      	mov	r0, r3
  4014ca:	4b08      	ldr	r3, [pc, #32]	; (4014ec <InvEMDFrontEnd_busyWaitUsHook+0xa4>)
  4014cc:	4798      	blx	r3
}
  4014ce:	bf00      	nop
  4014d0:	370c      	adds	r7, #12
  4014d2:	46bd      	mov	sp, r7
  4014d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4014d6:	bf00      	nop
  4014d8:	00d59f7f 	.word	0x00d59f7f
  4014dc:	00000000 	.word	0x00000000
  4014e0:	00400e51 	.word	0x00400e51
  4014e4:	00413e69 	.word	0x00413e69
  4014e8:	00d59f80 	.word	0x00d59f80
  4014ec:	20000001 	.word	0x20000001

004014f0 <InvEMDFrontEnd_isHwFlowCtrlSupportedHook>:

int InvEMDFrontEnd_isHwFlowCtrlSupportedHook(void){
  4014f0:	b480      	push	{r7}
  4014f2:	af00      	add	r7, sp, #0
	return 0;
  4014f4:	2300      	movs	r3, #0
}
  4014f6:	4618      	mov	r0, r3
  4014f8:	46bd      	mov	sp, r7
  4014fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4014fe:	4770      	bx	lr

00401500 <InvEMDFrontEnd_putcharHook>:

int InvEMDFrontEnd_putcharHook(int c){
  401500:	b580      	push	{r7, lr}
  401502:	b082      	sub	sp, #8
  401504:	af00      	add	r7, sp, #0
  401506:	6078      	str	r0, [r7, #4]
	if(usart_serial_putchar(CONF_UART, (uint8_t)c))
  401508:	687b      	ldr	r3, [r7, #4]
  40150a:	b2db      	uxtb	r3, r3
  40150c:	4619      	mov	r1, r3
  40150e:	4807      	ldr	r0, [pc, #28]	; (40152c <InvEMDFrontEnd_putcharHook+0x2c>)
  401510:	4b07      	ldr	r3, [pc, #28]	; (401530 <InvEMDFrontEnd_putcharHook+0x30>)
  401512:	4798      	blx	r3
  401514:	4603      	mov	r3, r0
  401516:	2b00      	cmp	r3, #0
  401518:	d001      	beq.n	40151e <InvEMDFrontEnd_putcharHook+0x1e>
		return c;
  40151a:	687b      	ldr	r3, [r7, #4]
  40151c:	e001      	b.n	401522 <InvEMDFrontEnd_putcharHook+0x22>
	else
		return -1;
  40151e:	f04f 33ff 	mov.w	r3, #4294967295
}
  401522:	4618      	mov	r0, r3
  401524:	3708      	adds	r7, #8
  401526:	46bd      	mov	sp, r7
  401528:	bd80      	pop	{r7, pc}
  40152a:	bf00      	nop
  40152c:	4000c200 	.word	0x4000c200
  401530:	00400ef1 	.word	0x00400ef1

00401534 <osc_get_rate>:
{
  401534:	b480      	push	{r7}
  401536:	b083      	sub	sp, #12
  401538:	af00      	add	r7, sp, #0
  40153a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40153c:	687b      	ldr	r3, [r7, #4]
  40153e:	2b07      	cmp	r3, #7
  401540:	d825      	bhi.n	40158e <osc_get_rate+0x5a>
  401542:	a201      	add	r2, pc, #4	; (adr r2, 401548 <osc_get_rate+0x14>)
  401544:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401548:	00401569 	.word	0x00401569
  40154c:	0040156f 	.word	0x0040156f
  401550:	00401575 	.word	0x00401575
  401554:	0040157b 	.word	0x0040157b
  401558:	0040157f 	.word	0x0040157f
  40155c:	00401583 	.word	0x00401583
  401560:	00401587 	.word	0x00401587
  401564:	0040158b 	.word	0x0040158b
		return OSC_SLCK_32K_RC_HZ;
  401568:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40156c:	e010      	b.n	401590 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  40156e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401572:	e00d      	b.n	401590 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401574:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401578:	e00a      	b.n	401590 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  40157a:	4b08      	ldr	r3, [pc, #32]	; (40159c <osc_get_rate+0x68>)
  40157c:	e008      	b.n	401590 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  40157e:	4b08      	ldr	r3, [pc, #32]	; (4015a0 <osc_get_rate+0x6c>)
  401580:	e006      	b.n	401590 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  401582:	4b08      	ldr	r3, [pc, #32]	; (4015a4 <osc_get_rate+0x70>)
  401584:	e004      	b.n	401590 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  401586:	2300      	movs	r3, #0
  401588:	e002      	b.n	401590 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  40158a:	2300      	movs	r3, #0
  40158c:	e000      	b.n	401590 <osc_get_rate+0x5c>
	return 0;
  40158e:	2300      	movs	r3, #0
}
  401590:	4618      	mov	r0, r3
  401592:	370c      	adds	r7, #12
  401594:	46bd      	mov	sp, r7
  401596:	f85d 7b04 	ldr.w	r7, [sp], #4
  40159a:	4770      	bx	lr
  40159c:	007a1200 	.word	0x007a1200
  4015a0:	00f42400 	.word	0x00f42400
  4015a4:	016e3600 	.word	0x016e3600

004015a8 <sysclk_get_main_hz>:
{
  4015a8:	b580      	push	{r7, lr}
  4015aa:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4015ac:	2001      	movs	r0, #1
  4015ae:	4b04      	ldr	r3, [pc, #16]	; (4015c0 <sysclk_get_main_hz+0x18>)
  4015b0:	4798      	blx	r3
  4015b2:	4602      	mov	r2, r0
  4015b4:	f640 634e 	movw	r3, #3662	; 0xe4e
  4015b8:	fb03 f302 	mul.w	r3, r3, r2
}
  4015bc:	4618      	mov	r0, r3
  4015be:	bd80      	pop	{r7, pc}
  4015c0:	00401535 	.word	0x00401535

004015c4 <sysclk_get_cpu_hz>:
{
  4015c4:	b580      	push	{r7, lr}
  4015c6:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  4015c8:	4b02      	ldr	r3, [pc, #8]	; (4015d4 <sysclk_get_cpu_hz+0x10>)
  4015ca:	4798      	blx	r3
  4015cc:	4603      	mov	r3, r0
}
  4015ce:	4618      	mov	r0, r3
  4015d0:	bd80      	pop	{r7, pc}
  4015d2:	bf00      	nop
  4015d4:	004015a9 	.word	0x004015a9

004015d8 <inv_icm20648_sleep_us>:
*/
void inv_icm20648_sleep(int ms) {
	delay_ms(ms);
}

void inv_icm20648_sleep_us(int us){
  4015d8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4015da:	b083      	sub	sp, #12
  4015dc:	af00      	add	r7, sp, #0
  4015de:	6078      	str	r0, [r7, #4]
	delay_us(us);
  4015e0:	687b      	ldr	r3, [r7, #4]
  4015e2:	2b00      	cmp	r3, #0
  4015e4:	d024      	beq.n	401630 <inv_icm20648_sleep_us+0x58>
  4015e6:	687b      	ldr	r3, [r7, #4]
  4015e8:	461d      	mov	r5, r3
  4015ea:	ea4f 76e5 	mov.w	r6, r5, asr #31
  4015ee:	4b20      	ldr	r3, [pc, #128]	; (401670 <inv_icm20648_sleep_us+0x98>)
  4015f0:	4798      	blx	r3
  4015f2:	4603      	mov	r3, r0
  4015f4:	f04f 0400 	mov.w	r4, #0
  4015f8:	fb03 f106 	mul.w	r1, r3, r6
  4015fc:	fb05 f204 	mul.w	r2, r5, r4
  401600:	440a      	add	r2, r1
  401602:	fba5 3403 	umull	r3, r4, r5, r3
  401606:	4422      	add	r2, r4
  401608:	4614      	mov	r4, r2
  40160a:	a217      	add	r2, pc, #92	; (adr r2, 401668 <inv_icm20648_sleep_us+0x90>)
  40160c:	e9d2 1200 	ldrd	r1, r2, [r2]
  401610:	185d      	adds	r5, r3, r1
  401612:	eb44 0602 	adc.w	r6, r4, r2
  401616:	4628      	mov	r0, r5
  401618:	4631      	mov	r1, r6
  40161a:	4c16      	ldr	r4, [pc, #88]	; (401674 <inv_icm20648_sleep_us+0x9c>)
  40161c:	4a16      	ldr	r2, [pc, #88]	; (401678 <inv_icm20648_sleep_us+0xa0>)
  40161e:	f04f 0300 	mov.w	r3, #0
  401622:	47a0      	blx	r4
  401624:	4603      	mov	r3, r0
  401626:	460c      	mov	r4, r1
  401628:	4618      	mov	r0, r3
  40162a:	4b14      	ldr	r3, [pc, #80]	; (40167c <inv_icm20648_sleep_us+0xa4>)
  40162c:	4798      	blx	r3
}
  40162e:	e016      	b.n	40165e <inv_icm20648_sleep_us+0x86>
	delay_us(us);
  401630:	4b0f      	ldr	r3, [pc, #60]	; (401670 <inv_icm20648_sleep_us+0x98>)
  401632:	4798      	blx	r3
  401634:	4603      	mov	r3, r0
  401636:	f04f 0400 	mov.w	r4, #0
  40163a:	a20b      	add	r2, pc, #44	; (adr r2, 401668 <inv_icm20648_sleep_us+0x90>)
  40163c:	e9d2 1200 	ldrd	r1, r2, [r2]
  401640:	185d      	adds	r5, r3, r1
  401642:	eb44 0602 	adc.w	r6, r4, r2
  401646:	4628      	mov	r0, r5
  401648:	4631      	mov	r1, r6
  40164a:	4c0a      	ldr	r4, [pc, #40]	; (401674 <inv_icm20648_sleep_us+0x9c>)
  40164c:	4a0a      	ldr	r2, [pc, #40]	; (401678 <inv_icm20648_sleep_us+0xa0>)
  40164e:	f04f 0300 	mov.w	r3, #0
  401652:	47a0      	blx	r4
  401654:	4603      	mov	r3, r0
  401656:	460c      	mov	r4, r1
  401658:	4618      	mov	r0, r3
  40165a:	4b08      	ldr	r3, [pc, #32]	; (40167c <inv_icm20648_sleep_us+0xa4>)
  40165c:	4798      	blx	r3
}
  40165e:	bf00      	nop
  401660:	370c      	adds	r7, #12
  401662:	46bd      	mov	sp, r7
  401664:	bdf0      	pop	{r4, r5, r6, r7, pc}
  401666:	bf00      	nop
  401668:	00d59f7f 	.word	0x00d59f7f
  40166c:	00000000 	.word	0x00000000
  401670:	004015c5 	.word	0x004015c5
  401674:	00413e69 	.word	0x00413e69
  401678:	00d59f80 	.word	0x00d59f80
  40167c:	20000001 	.word	0x20000001

00401680 <load_dmp3>:

int load_dmp3(void){
  401680:	b580      	push	{r7, lr}
  401682:	b082      	sub	sp, #8
  401684:	af00      	add	r7, sp, #0
	int rc = 0;
  401686:	2300      	movs	r3, #0
  401688:	607b      	str	r3, [r7, #4]
	INV_MSG(INV_MSG_LEVEL_INFO, "Load DMP3 image");
  40168a:	4908      	ldr	r1, [pc, #32]	; (4016ac <load_dmp3+0x2c>)
  40168c:	2003      	movs	r0, #3
  40168e:	4b08      	ldr	r3, [pc, #32]	; (4016b0 <load_dmp3+0x30>)
  401690:	4798      	blx	r3
	rc = inv_icm20648_load(&icm_device, dmp3_image, sizeof(dmp3_image));
  401692:	f243 72dd 	movw	r2, #14301	; 0x37dd
  401696:	4907      	ldr	r1, [pc, #28]	; (4016b4 <load_dmp3+0x34>)
  401698:	4807      	ldr	r0, [pc, #28]	; (4016b8 <load_dmp3+0x38>)
  40169a:	4b08      	ldr	r3, [pc, #32]	; (4016bc <load_dmp3+0x3c>)
  40169c:	4798      	blx	r3
  40169e:	6078      	str	r0, [r7, #4]
	return rc;
  4016a0:	687b      	ldr	r3, [r7, #4]
}
  4016a2:	4618      	mov	r0, r3
  4016a4:	3708      	adds	r7, #8
  4016a6:	46bd      	mov	sp, r7
  4016a8:	bd80      	pop	{r7, pc}
  4016aa:	bf00      	nop
  4016ac:	0041ba48 	.word	0x0041ba48
  4016b0:	0040ff51 	.word	0x0040ff51
  4016b4:	00418220 	.word	0x00418220
  4016b8:	20001998 	.word	0x20001998
  4016bc:	0040af91 	.word	0x0040af91

004016c0 <icm20648_apply_mounting_matrix>:

static void icm20648_apply_mounting_matrix(void){
  4016c0:	b580      	push	{r7, lr}
  4016c2:	b082      	sub	sp, #8
  4016c4:	af00      	add	r7, sp, #0
	int ii;

	for (ii = 0; ii < INV_ICM20648_SENSOR_MAX; ii++) {
  4016c6:	2300      	movs	r3, #0
  4016c8:	607b      	str	r3, [r7, #4]
  4016ca:	e017      	b.n	4016fc <icm20648_apply_mounting_matrix+0x3c>
		if (ii == INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED || ii == INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD)
  4016cc:	687b      	ldr	r3, [r7, #4]
  4016ce:	2b04      	cmp	r3, #4
  4016d0:	d002      	beq.n	4016d8 <icm20648_apply_mounting_matrix+0x18>
  4016d2:	687b      	ldr	r3, [r7, #4]
  4016d4:	2b0c      	cmp	r3, #12
  4016d6:	d107      	bne.n	4016e8 <icm20648_apply_mounting_matrix+0x28>
			inv_icm20648_set_matrix(&icm_device, cfg_mag_mounting_matrix, ii);
  4016d8:	687b      	ldr	r3, [r7, #4]
  4016da:	b2db      	uxtb	r3, r3
  4016dc:	461a      	mov	r2, r3
  4016de:	490b      	ldr	r1, [pc, #44]	; (40170c <icm20648_apply_mounting_matrix+0x4c>)
  4016e0:	480b      	ldr	r0, [pc, #44]	; (401710 <icm20648_apply_mounting_matrix+0x50>)
  4016e2:	4b0c      	ldr	r3, [pc, #48]	; (401714 <icm20648_apply_mounting_matrix+0x54>)
  4016e4:	4798      	blx	r3
  4016e6:	e006      	b.n	4016f6 <icm20648_apply_mounting_matrix+0x36>
		else
			inv_icm20648_set_matrix(&icm_device, cfg_mounting_matrix, ii);
  4016e8:	687b      	ldr	r3, [r7, #4]
  4016ea:	b2db      	uxtb	r3, r3
  4016ec:	461a      	mov	r2, r3
  4016ee:	490a      	ldr	r1, [pc, #40]	; (401718 <icm20648_apply_mounting_matrix+0x58>)
  4016f0:	4807      	ldr	r0, [pc, #28]	; (401710 <icm20648_apply_mounting_matrix+0x50>)
  4016f2:	4b08      	ldr	r3, [pc, #32]	; (401714 <icm20648_apply_mounting_matrix+0x54>)
  4016f4:	4798      	blx	r3
	for (ii = 0; ii < INV_ICM20648_SENSOR_MAX; ii++) {
  4016f6:	687b      	ldr	r3, [r7, #4]
  4016f8:	3301      	adds	r3, #1
  4016fa:	607b      	str	r3, [r7, #4]
  4016fc:	687b      	ldr	r3, [r7, #4]
  4016fe:	2b13      	cmp	r3, #19
  401700:	dde4      	ble.n	4016cc <icm20648_apply_mounting_matrix+0xc>
	}
}
  401702:	bf00      	nop
  401704:	3708      	adds	r7, #8
  401706:	46bd      	mov	sp, r7
  401708:	bd80      	pop	{r7, pc}
  40170a:	bf00      	nop
  40170c:	0041ba24 	.word	0x0041ba24
  401710:	20001998 	.word	0x20001998
  401714:	0040acf9 	.word	0x0040acf9
  401718:	0041ba00 	.word	0x0041ba00

0040171c <icm20648_set_fsr>:

static void icm20648_set_fsr(void){
  40171c:	b580      	push	{r7, lr}
  40171e:	af00      	add	r7, sp, #0
	inv_icm20648_set_fsr(&icm_device, INV_ICM20648_SENSOR_RAW_ACCELEROMETER, (const void *)&cfg_acc_fsr);
  401720:	4a0d      	ldr	r2, [pc, #52]	; (401758 <icm20648_set_fsr+0x3c>)
  401722:	2102      	movs	r1, #2
  401724:	480d      	ldr	r0, [pc, #52]	; (40175c <icm20648_set_fsr+0x40>)
  401726:	4b0e      	ldr	r3, [pc, #56]	; (401760 <icm20648_set_fsr+0x44>)
  401728:	4798      	blx	r3
	inv_icm20648_set_fsr(&icm_device, INV_ICM20648_SENSOR_ACCELEROMETER, (const void *)&cfg_acc_fsr);
  40172a:	4a0b      	ldr	r2, [pc, #44]	; (401758 <icm20648_set_fsr+0x3c>)
  40172c:	2100      	movs	r1, #0
  40172e:	480b      	ldr	r0, [pc, #44]	; (40175c <icm20648_set_fsr+0x40>)
  401730:	4b0b      	ldr	r3, [pc, #44]	; (401760 <icm20648_set_fsr+0x44>)
  401732:	4798      	blx	r3
	inv_icm20648_set_fsr(&icm_device, INV_ICM20648_SENSOR_RAW_GYROSCOPE, (const void *)&cfg_gyr_fsr);
  401734:	4a0b      	ldr	r2, [pc, #44]	; (401764 <icm20648_set_fsr+0x48>)
  401736:	2103      	movs	r1, #3
  401738:	4808      	ldr	r0, [pc, #32]	; (40175c <icm20648_set_fsr+0x40>)
  40173a:	4b09      	ldr	r3, [pc, #36]	; (401760 <icm20648_set_fsr+0x44>)
  40173c:	4798      	blx	r3
	inv_icm20648_set_fsr(&icm_device, INV_ICM20648_SENSOR_GYROSCOPE, (const void *)&cfg_gyr_fsr);
  40173e:	4a09      	ldr	r2, [pc, #36]	; (401764 <icm20648_set_fsr+0x48>)
  401740:	2101      	movs	r1, #1
  401742:	4806      	ldr	r0, [pc, #24]	; (40175c <icm20648_set_fsr+0x40>)
  401744:	4b06      	ldr	r3, [pc, #24]	; (401760 <icm20648_set_fsr+0x44>)
  401746:	4798      	blx	r3
	inv_icm20648_set_fsr(&icm_device, INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED, (const void *)&cfg_gyr_fsr);
  401748:	4a06      	ldr	r2, [pc, #24]	; (401764 <icm20648_set_fsr+0x48>)
  40174a:	2105      	movs	r1, #5
  40174c:	4803      	ldr	r0, [pc, #12]	; (40175c <icm20648_set_fsr+0x40>)
  40174e:	4b04      	ldr	r3, [pc, #16]	; (401760 <icm20648_set_fsr+0x44>)
  401750:	4798      	blx	r3
}
  401752:	bf00      	nop
  401754:	bd80      	pop	{r7, pc}
  401756:	bf00      	nop
  401758:	200000fc 	.word	0x200000fc
  40175c:	20001998 	.word	0x20001998
  401760:	0040ab8d 	.word	0x0040ab8d
  401764:	20000100 	.word	0x20000100

00401768 <icm20648_sensor_setup>:

int icm20648_sensor_setup(void){
  401768:	b580      	push	{r7, lr}
  40176a:	b084      	sub	sp, #16
  40176c:	af00      	add	r7, sp, #0
	int rc;
	uint8_t i, whoami = 0xff;
  40176e:	23ff      	movs	r3, #255	; 0xff
  401770:	71fb      	strb	r3, [r7, #7]

	/*
	* Just get the whoami
	*/
	rc = inv_icm20648_get_whoami(&icm_device, &whoami);
  401772:	1dfb      	adds	r3, r7, #7
  401774:	4619      	mov	r1, r3
  401776:	483b      	ldr	r0, [pc, #236]	; (401864 <icm20648_sensor_setup+0xfc>)
  401778:	4b3b      	ldr	r3, [pc, #236]	; (401868 <icm20648_sensor_setup+0x100>)
  40177a:	4798      	blx	r3
  40177c:	60b8      	str	r0, [r7, #8]
	INV_MSG(INV_MSG_LEVEL_INFO, "ICM20648 WHOAMI=0x%02x", whoami);
  40177e:	79fb      	ldrb	r3, [r7, #7]
  401780:	461a      	mov	r2, r3
  401782:	493a      	ldr	r1, [pc, #232]	; (40186c <icm20648_sensor_setup+0x104>)
  401784:	2003      	movs	r0, #3
  401786:	4b3a      	ldr	r3, [pc, #232]	; (401870 <icm20648_sensor_setup+0x108>)
  401788:	4798      	blx	r3

	/*
	* Check if WHOAMI value corresponds to any value from EXPECTED_WHOAMI array
	*/
	for(i = 0; i < sizeof(EXPECTED_WHOAMI)/sizeof(EXPECTED_WHOAMI[0]); ++i) {
  40178a:	2300      	movs	r3, #0
  40178c:	73fb      	strb	r3, [r7, #15]
  40178e:	e006      	b.n	40179e <icm20648_sensor_setup+0x36>
		if(whoami == EXPECTED_WHOAMI[i])
  401790:	22e0      	movs	r2, #224	; 0xe0
  401792:	79fb      	ldrb	r3, [r7, #7]
  401794:	429a      	cmp	r2, r3
  401796:	d006      	beq.n	4017a6 <icm20648_sensor_setup+0x3e>
	for(i = 0; i < sizeof(EXPECTED_WHOAMI)/sizeof(EXPECTED_WHOAMI[0]); ++i) {
  401798:	7bfb      	ldrb	r3, [r7, #15]
  40179a:	3301      	adds	r3, #1
  40179c:	73fb      	strb	r3, [r7, #15]
  40179e:	7bfb      	ldrb	r3, [r7, #15]
  4017a0:	2b00      	cmp	r3, #0
  4017a2:	d0f5      	beq.n	401790 <icm20648_sensor_setup+0x28>
  4017a4:	e000      	b.n	4017a8 <icm20648_sensor_setup+0x40>
			break;
  4017a6:	bf00      	nop
	}

	if(i == sizeof(EXPECTED_WHOAMI)/sizeof(EXPECTED_WHOAMI[0])) {
  4017a8:	7bfb      	ldrb	r3, [r7, #15]
  4017aa:	2b01      	cmp	r3, #1
  4017ac:	d107      	bne.n	4017be <icm20648_sensor_setup+0x56>
		INV_MSG(INV_MSG_LEVEL_ERROR, "Bad WHOAMI value. Got 0x%02x.", whoami);
  4017ae:	79fb      	ldrb	r3, [r7, #7]
  4017b0:	461a      	mov	r2, r3
  4017b2:	4930      	ldr	r1, [pc, #192]	; (401874 <icm20648_sensor_setup+0x10c>)
  4017b4:	2001      	movs	r0, #1
  4017b6:	4b2e      	ldr	r3, [pc, #184]	; (401870 <icm20648_sensor_setup+0x108>)
  4017b8:	4798      	blx	r3
		return rc;
  4017ba:	68bb      	ldr	r3, [r7, #8]
  4017bc:	e04e      	b.n	40185c <icm20648_sensor_setup+0xf4>
	}

	/* Setup accel and gyro mounting matrix and associated angle for current board */
	inv_icm20648_init_matrix(&icm_device);
  4017be:	4829      	ldr	r0, [pc, #164]	; (401864 <icm20648_sensor_setup+0xfc>)
  4017c0:	4b2d      	ldr	r3, [pc, #180]	; (401878 <icm20648_sensor_setup+0x110>)
  4017c2:	4798      	blx	r3

	/* set default power mode */
	INV_MSG(INV_MSG_LEVEL_VERBOSE, "Putting Icm20648 in sleep mode...");
  4017c4:	492d      	ldr	r1, [pc, #180]	; (40187c <icm20648_sensor_setup+0x114>)
  4017c6:	2004      	movs	r0, #4
  4017c8:	4b29      	ldr	r3, [pc, #164]	; (401870 <icm20648_sensor_setup+0x108>)
  4017ca:	4798      	blx	r3
	rc = inv_icm20648_initialize(&icm_device, dmp3_image, sizeof(dmp3_image));
  4017cc:	f243 72dd 	movw	r2, #14301	; 0x37dd
  4017d0:	492b      	ldr	r1, [pc, #172]	; (401880 <icm20648_sensor_setup+0x118>)
  4017d2:	4824      	ldr	r0, [pc, #144]	; (401864 <icm20648_sensor_setup+0xfc>)
  4017d4:	4b2b      	ldr	r3, [pc, #172]	; (401884 <icm20648_sensor_setup+0x11c>)
  4017d6:	4798      	blx	r3
  4017d8:	60b8      	str	r0, [r7, #8]
	if (rc != 0) {
  4017da:	68bb      	ldr	r3, [r7, #8]
  4017dc:	2b00      	cmp	r3, #0
  4017de:	d005      	beq.n	4017ec <icm20648_sensor_setup+0x84>
		INV_MSG(INV_MSG_LEVEL_ERROR, "Initialization failed. Error loading DMP3...");
  4017e0:	4929      	ldr	r1, [pc, #164]	; (401888 <icm20648_sensor_setup+0x120>)
  4017e2:	2001      	movs	r0, #1
  4017e4:	4b22      	ldr	r3, [pc, #136]	; (401870 <icm20648_sensor_setup+0x108>)
  4017e6:	4798      	blx	r3
		return rc;
  4017e8:	68bb      	ldr	r3, [r7, #8]
  4017ea:	e037      	b.n	40185c <icm20648_sensor_setup+0xf4>
	}
	/*
	* Configure and initialize the ICM20648 for normal use
	*/
	INV_MSG(INV_MSG_LEVEL_INFO, "Booting up icm20648...");
  4017ec:	4927      	ldr	r1, [pc, #156]	; (40188c <icm20648_sensor_setup+0x124>)
  4017ee:	2003      	movs	r0, #3
  4017f0:	4b1f      	ldr	r3, [pc, #124]	; (401870 <icm20648_sensor_setup+0x108>)
  4017f2:	4798      	blx	r3

#if COMPASS_IS_AK9912
	/* Initialize auxiliary sensors */
	inv_icm20648_register_aux_compass(&icm_device, INV_ICM20648_COMPASS_ID_AK09912, AK0991x_DEFAULT_I2C_ADDR);
  4017f4:	220c      	movs	r2, #12
  4017f6:	2102      	movs	r1, #2
  4017f8:	481a      	ldr	r0, [pc, #104]	; (401864 <icm20648_sensor_setup+0xfc>)
  4017fa:	4b25      	ldr	r3, [pc, #148]	; (401890 <icm20648_sensor_setup+0x128>)
  4017fc:	4798      	blx	r3
	ak09912_is_available = (inv_icm20648_initialize_auxiliary(&icm_device) == -1) ? 0 : 1;
  4017fe:	4819      	ldr	r0, [pc, #100]	; (401864 <icm20648_sensor_setup+0xfc>)
  401800:	4b24      	ldr	r3, [pc, #144]	; (401894 <icm20648_sensor_setup+0x12c>)
  401802:	4798      	blx	r3
  401804:	4603      	mov	r3, r0
  401806:	f1b3 3fff 	cmp.w	r3, #4294967295
  40180a:	bf14      	ite	ne
  40180c:	2301      	movne	r3, #1
  40180e:	2300      	moveq	r3, #0
  401810:	b2db      	uxtb	r3, r3
  401812:	461a      	mov	r2, r3
  401814:	4b20      	ldr	r3, [pc, #128]	; (401898 <icm20648_sensor_setup+0x130>)
  401816:	601a      	str	r2, [r3, #0]
	if (ak09912_is_available == 0) {
  401818:	4b1f      	ldr	r3, [pc, #124]	; (401898 <icm20648_sensor_setup+0x130>)
  40181a:	681b      	ldr	r3, [r3, #0]
  40181c:	2b00      	cmp	r3, #0
  40181e:	d111      	bne.n	401844 <icm20648_sensor_setup+0xdc>
		inv_icm20648_register_aux_compass(&icm_device, INV_ICM20648_COMPASS_ID_AK09912, AK0991x_SECONDARY_I2C_ADDR);
  401820:	220e      	movs	r2, #14
  401822:	2102      	movs	r1, #2
  401824:	480f      	ldr	r0, [pc, #60]	; (401864 <icm20648_sensor_setup+0xfc>)
  401826:	4b1a      	ldr	r3, [pc, #104]	; (401890 <icm20648_sensor_setup+0x128>)
  401828:	4798      	blx	r3
		ak09912_is_available = (inv_icm20648_initialize_auxiliary(&icm_device) == -1) ? 0 : 1;
  40182a:	480e      	ldr	r0, [pc, #56]	; (401864 <icm20648_sensor_setup+0xfc>)
  40182c:	4b19      	ldr	r3, [pc, #100]	; (401894 <icm20648_sensor_setup+0x12c>)
  40182e:	4798      	blx	r3
  401830:	4603      	mov	r3, r0
  401832:	f1b3 3fff 	cmp.w	r3, #4294967295
  401836:	bf14      	ite	ne
  401838:	2301      	movne	r3, #1
  40183a:	2300      	moveq	r3, #0
  40183c:	b2db      	uxtb	r3, r3
  40183e:	461a      	mov	r2, r3
  401840:	4b15      	ldr	r3, [pc, #84]	; (401898 <icm20648_sensor_setup+0x130>)
  401842:	601a      	str	r2, [r3, #0]
	}
#endif
	icm20648_apply_mounting_matrix();
  401844:	4b15      	ldr	r3, [pc, #84]	; (40189c <icm20648_sensor_setup+0x134>)
  401846:	4798      	blx	r3
	icm20648_set_fsr();
  401848:	4b15      	ldr	r3, [pc, #84]	; (4018a0 <icm20648_sensor_setup+0x138>)
  40184a:	4798      	blx	r3

	/* re-initialize base state structure */
	inv_icm20648_init_structure(&icm_device);
  40184c:	4805      	ldr	r0, [pc, #20]	; (401864 <icm20648_sensor_setup+0xfc>)
  40184e:	4b15      	ldr	r3, [pc, #84]	; (4018a4 <icm20648_sensor_setup+0x13c>)
  401850:	4798      	blx	r3

	/* we should be good to go ! */
	INV_MSG(INV_MSG_LEVEL_VERBOSE, "We're good to go !");
  401852:	4915      	ldr	r1, [pc, #84]	; (4018a8 <icm20648_sensor_setup+0x140>)
  401854:	2004      	movs	r0, #4
  401856:	4b06      	ldr	r3, [pc, #24]	; (401870 <icm20648_sensor_setup+0x108>)
  401858:	4798      	blx	r3

	return 0;
  40185a:	2300      	movs	r3, #0
}
  40185c:	4618      	mov	r0, r3
  40185e:	3710      	adds	r7, #16
  401860:	46bd      	mov	sp, r7
  401862:	bd80      	pop	{r7, pc}
  401864:	20001998 	.word	0x20001998
  401868:	0040aa09 	.word	0x0040aa09
  40186c:	0041ba58 	.word	0x0041ba58
  401870:	0040ff51 	.word	0x0040ff51
  401874:	0041ba70 	.word	0x0041ba70
  401878:	0040aa2d 	.word	0x0040aa2d
  40187c:	0041ba90 	.word	0x0041ba90
  401880:	00418220 	.word	0x00418220
  401884:	0040ab39 	.word	0x0040ab39
  401888:	0041bab4 	.word	0x0041bab4
  40188c:	0041bae4 	.word	0x0041bae4
  401890:	00404831 	.word	0x00404831
  401894:	0040ae55 	.word	0x0040ae55
  401898:	20000ee8 	.word	0x20000ee8
  40189c:	004016c1 	.word	0x004016c1
  4018a0:	0040171d 	.word	0x0040171d
  4018a4:	0040aac5 	.word	0x0040aac5
  4018a8:	0041bafc 	.word	0x0041bafc

004018ac <check_rc>:

/*
* Helper function to check RC value and block program execution
*/
void check_rc(int rc, const char * msg_context){
  4018ac:	b590      	push	{r4, r7, lr}
  4018ae:	b085      	sub	sp, #20
  4018b0:	af02      	add	r7, sp, #8
  4018b2:	6078      	str	r0, [r7, #4]
  4018b4:	6039      	str	r1, [r7, #0]
	if(rc < 0) {
  4018b6:	687b      	ldr	r3, [r7, #4]
  4018b8:	2b00      	cmp	r3, #0
  4018ba:	da0b      	bge.n	4018d4 <check_rc+0x28>
		INV_MSG(INV_MSG_LEVEL_ERROR, "%s: error %d (%s)", msg_context, rc, inv_error_str(rc));
  4018bc:	6878      	ldr	r0, [r7, #4]
  4018be:	4b07      	ldr	r3, [pc, #28]	; (4018dc <check_rc+0x30>)
  4018c0:	4798      	blx	r3
  4018c2:	4603      	mov	r3, r0
  4018c4:	9300      	str	r3, [sp, #0]
  4018c6:	687b      	ldr	r3, [r7, #4]
  4018c8:	683a      	ldr	r2, [r7, #0]
  4018ca:	4905      	ldr	r1, [pc, #20]	; (4018e0 <check_rc+0x34>)
  4018cc:	2001      	movs	r0, #1
  4018ce:	4c05      	ldr	r4, [pc, #20]	; (4018e4 <check_rc+0x38>)
  4018d0:	47a0      	blx	r4
		while(1);
  4018d2:	e7fe      	b.n	4018d2 <check_rc+0x26>
	}
}
  4018d4:	bf00      	nop
  4018d6:	370c      	adds	r7, #12
  4018d8:	46bd      	mov	sp, r7
  4018da:	bd90      	pop	{r4, r7, pc}
  4018dc:	0040fb51 	.word	0x0040fb51
  4018e0:	0041bb10 	.word	0x0041bb10
  4018e4:	0040ff51 	.word	0x0040ff51

004018e8 <iddwrapper_protocol_event_cb>:
void iddwrapper_protocol_event_cb(
	enum DynProtocolEtype etype,
	enum DynProtocolEid eid,
	const DynProtocolEdata_t * edata,
	void * cookie
	){
  4018e8:	b590      	push	{r4, r7, lr}
  4018ea:	b089      	sub	sp, #36	; 0x24
  4018ec:	af02      	add	r7, sp, #8
  4018ee:	60ba      	str	r2, [r7, #8]
  4018f0:	607b      	str	r3, [r7, #4]
  4018f2:	4603      	mov	r3, r0
  4018f4:	73fb      	strb	r3, [r7, #15]
  4018f6:	460b      	mov	r3, r1
  4018f8:	73bb      	strb	r3, [r7, #14]

	static DynProtocolEdata_t resp_edata; /* static to take on .bss */
	static uint8_t respBuffer[256]; /* static to take on .bss */
	uint16_t respLen;

	switch(etype) {
  4018fa:	7bfb      	ldrb	r3, [r7, #15]
  4018fc:	2b00      	cmp	r3, #0
  4018fe:	d11e      	bne.n	40193e <iddwrapper_protocol_event_cb+0x56>
	case DYN_PROTOCOL_ETYPE_CMD:
		resp_edata.d.response.rc = handle_command(eid, edata, &resp_edata);
  401900:	7bbb      	ldrb	r3, [r7, #14]
  401902:	4a16      	ldr	r2, [pc, #88]	; (40195c <iddwrapper_protocol_event_cb+0x74>)
  401904:	68b9      	ldr	r1, [r7, #8]
  401906:	4618      	mov	r0, r3
  401908:	4b15      	ldr	r3, [pc, #84]	; (401960 <iddwrapper_protocol_event_cb+0x78>)
  40190a:	4798      	blx	r3
  40190c:	4602      	mov	r2, r0
  40190e:	4b13      	ldr	r3, [pc, #76]	; (40195c <iddwrapper_protocol_event_cb+0x74>)
  401910:	605a      	str	r2, [r3, #4]

		/* send back response */
		if(DynProtocol_encodeResponse(&protocol, eid, &resp_edata,
  401912:	7bb9      	ldrb	r1, [r7, #14]
  401914:	f107 0316 	add.w	r3, r7, #22
  401918:	9301      	str	r3, [sp, #4]
  40191a:	f44f 7380 	mov.w	r3, #256	; 0x100
  40191e:	9300      	str	r3, [sp, #0]
  401920:	4b10      	ldr	r3, [pc, #64]	; (401964 <iddwrapper_protocol_event_cb+0x7c>)
  401922:	4a0e      	ldr	r2, [pc, #56]	; (40195c <iddwrapper_protocol_event_cb+0x74>)
  401924:	4810      	ldr	r0, [pc, #64]	; (401968 <iddwrapper_protocol_event_cb+0x80>)
  401926:	4c11      	ldr	r4, [pc, #68]	; (40196c <iddwrapper_protocol_event_cb+0x84>)
  401928:	47a0      	blx	r4
  40192a:	4603      	mov	r3, r0
  40192c:	2b00      	cmp	r3, #0
  40192e:	d10c      	bne.n	40194a <iddwrapper_protocol_event_cb+0x62>
			respBuffer, sizeof(respBuffer), &respLen) != 0) {
				goto error_dma_buffer;
		}

		DynProTransportUart_tx(&transport, respBuffer, respLen);
  401930:	8afb      	ldrh	r3, [r7, #22]
  401932:	461a      	mov	r2, r3
  401934:	490b      	ldr	r1, [pc, #44]	; (401964 <iddwrapper_protocol_event_cb+0x7c>)
  401936:	480e      	ldr	r0, [pc, #56]	; (401970 <iddwrapper_protocol_event_cb+0x88>)
  401938:	4b0e      	ldr	r3, [pc, #56]	; (401974 <iddwrapper_protocol_event_cb+0x8c>)
  40193a:	4798      	blx	r3
		break;
  40193c:	e004      	b.n	401948 <iddwrapper_protocol_event_cb+0x60>

	default:
		INV_MSG(INV_MSG_LEVEL_WARNING, "DeviceEmdWrapper: unexpected packet received. Ignored.");
  40193e:	490e      	ldr	r1, [pc, #56]	; (401978 <iddwrapper_protocol_event_cb+0x90>)
  401940:	2002      	movs	r0, #2
  401942:	4b0e      	ldr	r3, [pc, #56]	; (40197c <iddwrapper_protocol_event_cb+0x94>)
  401944:	4798      	blx	r3
		break; /* no suppose to happen */
  401946:	bf00      	nop
	}
	return;
  401948:	e005      	b.n	401956 <iddwrapper_protocol_event_cb+0x6e>
				goto error_dma_buffer;
  40194a:	bf00      	nop

error_dma_buffer:
	INV_MSG(INV_MSG_LEVEL_WARNING, "iddwrapper_protocol_event_cb: encode error, response dropped");
  40194c:	490c      	ldr	r1, [pc, #48]	; (401980 <iddwrapper_protocol_event_cb+0x98>)
  40194e:	2002      	movs	r0, #2
  401950:	4b0a      	ldr	r3, [pc, #40]	; (40197c <iddwrapper_protocol_event_cb+0x94>)
  401952:	4798      	blx	r3

	return;
  401954:	bf00      	nop
}
  401956:	371c      	adds	r7, #28
  401958:	46bd      	mov	sp, r7
  40195a:	bd90      	pop	{r4, r7, pc}
  40195c:	20000eec 	.word	0x20000eec
  401960:	00402165 	.word	0x00402165
  401964:	20000f70 	.word	0x20000f70
  401968:	20001870 	.word	0x20001870
  40196c:	0040f369 	.word	0x0040f369
  401970:	20001988 	.word	0x20001988
  401974:	0040f925 	.word	0x0040f925
  401978:	0041bb24 	.word	0x0041bb24
  40197c:	0040ff51 	.word	0x0040ff51
  401980:	0041bb5c 	.word	0x0041bb5c

00401984 <iddwrapper_transport_event_cb>:
* This function will:
*  - feed the Dynamic protocol layer to analyze for incoming CMD packet
*  - forward byte coming from transport layer to be send over uart to the host
*/
void iddwrapper_transport_event_cb(enum DynProTransportEvent e,
									union DynProTransportEventData data, void * cookie){
  401984:	b590      	push	{r4, r7, lr}
  401986:	b087      	sub	sp, #28
  401988:	af00      	add	r7, sp, #0
  40198a:	4603      	mov	r3, r0
  40198c:	60b9      	str	r1, [r7, #8]
  40198e:	607a      	str	r2, [r7, #4]
  401990:	73fb      	strb	r3, [r7, #15]
	(void)cookie;

	int rc;
	int timeout = 5000; /* us */
  401992:	f241 3388 	movw	r3, #5000	; 0x1388
  401996:	617b      	str	r3, [r7, #20]

	switch(e) {
  401998:	7bfb      	ldrb	r3, [r7, #15]
  40199a:	2b07      	cmp	r3, #7
  40199c:	d841      	bhi.n	401a22 <iddwrapper_transport_event_cb+0x9e>
  40199e:	a201      	add	r2, pc, #4	; (adr r2, 4019a4 <iddwrapper_transport_event_cb+0x20>)
  4019a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4019a4:	004019c5 	.word	0x004019c5
  4019a8:	00401a19 	.word	0x00401a19
  4019ac:	004019d3 	.word	0x004019d3
  4019b0:	00401a19 	.word	0x00401a19
  4019b4:	00401a19 	.word	0x00401a19
  4019b8:	00401a01 	.word	0x00401a01
  4019bc:	00401a19 	.word	0x00401a19
  4019c0:	00401a19 	.word	0x00401a19
	case DYN_PRO_TRANSPORT_EVENT_ERROR:
		INV_MSG(INV_MSG_LEVEL_ERROR, "ERROR event with value %d received from IddWrapper transport", data.error);
  4019c4:	68bb      	ldr	r3, [r7, #8]
  4019c6:	461a      	mov	r2, r3
  4019c8:	4918      	ldr	r1, [pc, #96]	; (401a2c <iddwrapper_transport_event_cb+0xa8>)
  4019ca:	2001      	movs	r0, #1
  4019cc:	4b18      	ldr	r3, [pc, #96]	; (401a30 <iddwrapper_transport_event_cb+0xac>)
  4019ce:	4798      	blx	r3
		break;
  4019d0:	e027      	b.n	401a22 <iddwrapper_transport_event_cb+0x9e>
	case DYN_PRO_TRANSPORT_EVENT_PKT_SIZE:
		break;

	case DYN_PRO_TRANSPORT_EVENT_PKT_BYTE:
		/* Feed IddWrapperProtocol to look for packet */
		rc = DynProtocol_processPktByte(&protocol, data.pkt_byte);
  4019d2:	7a3b      	ldrb	r3, [r7, #8]
  4019d4:	4619      	mov	r1, r3
  4019d6:	4817      	ldr	r0, [pc, #92]	; (401a34 <iddwrapper_transport_event_cb+0xb0>)
  4019d8:	4b17      	ldr	r3, [pc, #92]	; (401a38 <iddwrapper_transport_event_cb+0xb4>)
  4019da:	4798      	blx	r3
  4019dc:	6138      	str	r0, [r7, #16]
		if(rc < 0) {
  4019de:	693b      	ldr	r3, [r7, #16]
  4019e0:	2b00      	cmp	r3, #0
  4019e2:	da1b      	bge.n	401a1c <iddwrapper_transport_event_cb+0x98>
			INV_MSG(INV_MSG_LEVEL_DEBUG, "DynProtocol_processPktByte(%02x) returned %d", data.pkt_byte, rc);
  4019e4:	7a3b      	ldrb	r3, [r7, #8]
  4019e6:	461a      	mov	r2, r3
  4019e8:	693b      	ldr	r3, [r7, #16]
  4019ea:	4914      	ldr	r1, [pc, #80]	; (401a3c <iddwrapper_transport_event_cb+0xb8>)
  4019ec:	2005      	movs	r0, #5
  4019ee:	4c10      	ldr	r4, [pc, #64]	; (401a30 <iddwrapper_transport_event_cb+0xac>)
  4019f0:	47a0      	blx	r4
		}
		break;
  4019f2:	e013      	b.n	401a1c <iddwrapper_transport_event_cb+0x98>
	case DYN_PRO_TRANSPORT_EVENT_TX_START:
		break;

	case DYN_PRO_TRANSPORT_EVENT_TX_BYTE:
		while ((InvEMDFrontEnd_putcharHook(data.tx_byte) == EOF) && (timeout > 0)) {
			InvEMDFrontEnd_busyWaitUsHook(10);
  4019f4:	200a      	movs	r0, #10
  4019f6:	4b12      	ldr	r3, [pc, #72]	; (401a40 <iddwrapper_transport_event_cb+0xbc>)
  4019f8:	4798      	blx	r3
			timeout -= 10;
  4019fa:	697b      	ldr	r3, [r7, #20]
  4019fc:	3b0a      	subs	r3, #10
  4019fe:	617b      	str	r3, [r7, #20]
		while ((InvEMDFrontEnd_putcharHook(data.tx_byte) == EOF) && (timeout > 0)) {
  401a00:	7a3b      	ldrb	r3, [r7, #8]
  401a02:	4618      	mov	r0, r3
  401a04:	4b0f      	ldr	r3, [pc, #60]	; (401a44 <iddwrapper_transport_event_cb+0xc0>)
  401a06:	4798      	blx	r3
  401a08:	4603      	mov	r3, r0
  401a0a:	f1b3 3fff 	cmp.w	r3, #4294967295
  401a0e:	d107      	bne.n	401a20 <iddwrapper_transport_event_cb+0x9c>
  401a10:	697b      	ldr	r3, [r7, #20]
  401a12:	2b00      	cmp	r3, #0
  401a14:	dcee      	bgt.n	4019f4 <iddwrapper_transport_event_cb+0x70>
		}
		break;
  401a16:	e003      	b.n	401a20 <iddwrapper_transport_event_cb+0x9c>
		break;
  401a18:	bf00      	nop
  401a1a:	e002      	b.n	401a22 <iddwrapper_transport_event_cb+0x9e>
		break;
  401a1c:	bf00      	nop
  401a1e:	e000      	b.n	401a22 <iddwrapper_transport_event_cb+0x9e>
		break;
  401a20:	bf00      	nop
		break;

	case DYN_PRO_TRANSPORT_EVENT_TX_START_DMA:
		break;
	}
}
  401a22:	bf00      	nop
  401a24:	371c      	adds	r7, #28
  401a26:	46bd      	mov	sp, r7
  401a28:	bd90      	pop	{r4, r7, pc}
  401a2a:	bf00      	nop
  401a2c:	0041bb9c 	.word	0x0041bb9c
  401a30:	0040ff51 	.word	0x0040ff51
  401a34:	20001870 	.word	0x20001870
  401a38:	0040f221 	.word	0x0040f221
  401a3c:	0041bbdc 	.word	0x0041bbdc
  401a40:	00401449 	.word	0x00401449
  401a44:	00401501 	.word	0x00401501

00401a48 <icm20648_get_grv_accuracy>:

static uint8_t icm20648_get_grv_accuracy(void){
  401a48:	b580      	push	{r7, lr}
  401a4a:	b082      	sub	sp, #8
  401a4c:	af00      	add	r7, sp, #0
	uint8_t accel_accuracy;
	uint8_t gyro_accuracy;

	accel_accuracy = (uint8_t)inv_icm20648_get_accel_accuracy();
  401a4e:	4b09      	ldr	r3, [pc, #36]	; (401a74 <icm20648_get_grv_accuracy+0x2c>)
  401a50:	4798      	blx	r3
  401a52:	4603      	mov	r3, r0
  401a54:	71fb      	strb	r3, [r7, #7]
	gyro_accuracy = (uint8_t)inv_icm20648_get_gyro_accuracy();
  401a56:	4b08      	ldr	r3, [pc, #32]	; (401a78 <icm20648_get_grv_accuracy+0x30>)
  401a58:	4798      	blx	r3
  401a5a:	4603      	mov	r3, r0
  401a5c:	71bb      	strb	r3, [r7, #6]
	return (min(accel_accuracy, gyro_accuracy));
  401a5e:	79ba      	ldrb	r2, [r7, #6]
  401a60:	79fb      	ldrb	r3, [r7, #7]
  401a62:	4293      	cmp	r3, r2
  401a64:	bf28      	it	cs
  401a66:	4613      	movcs	r3, r2
  401a68:	b2db      	uxtb	r3, r3
}
  401a6a:	4618      	mov	r0, r3
  401a6c:	3708      	adds	r7, #8
  401a6e:	46bd      	mov	sp, r7
  401a70:	bd80      	pop	{r7, pc}
  401a72:	bf00      	nop
  401a74:	00409d55 	.word	0x00409d55
  401a78:	00409d6d 	.word	0x00409d6d

00401a7c <build_sensor_event_data>:

void build_sensor_event_data(void * context, uint8_t sensortype, uint64_t timestamp, const void * data, const void *arg){
  401a7c:	b590      	push	{r4, r7, lr}
  401a7e:	b0a1      	sub	sp, #132	; 0x84
  401a80:	af00      	add	r7, sp, #0
  401a82:	60f8      	str	r0, [r7, #12]
  401a84:	e9c7 2300 	strd	r2, r3, [r7]
  401a88:	460b      	mov	r3, r1
  401a8a:	72fb      	strb	r3, [r7, #11]
	float raw_bias_data[6];
	inv_sensor_event_t event;
	(void)context;
	uint8_t sensor_id = convert_to_generic_ids[sensortype];
  401a8c:	7afb      	ldrb	r3, [r7, #11]
  401a8e:	4a94      	ldr	r2, [pc, #592]	; (401ce0 <build_sensor_event_data+0x264>)
  401a90:	5cd3      	ldrb	r3, [r2, r3]
  401a92:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f

	memset((void *)&event, 0, sizeof(event));
  401a96:	f107 0310 	add.w	r3, r7, #16
  401a9a:	2250      	movs	r2, #80	; 0x50
  401a9c:	2100      	movs	r1, #0
  401a9e:	4618      	mov	r0, r3
  401aa0:	4b90      	ldr	r3, [pc, #576]	; (401ce4 <build_sensor_event_data+0x268>)
  401aa2:	4798      	blx	r3
	event.sensor = sensor_id;
  401aa4:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  401aa8:	613b      	str	r3, [r7, #16]
	event.timestamp = timestamp;
  401aaa:	e9d7 3400 	ldrd	r3, r4, [r7]
  401aae:	e9c7 3406 	strd	r3, r4, [r7, #24]
	switch(sensor_id) {
  401ab2:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  401ab6:	3b01      	subs	r3, #1
  401ab8:	2b20      	cmp	r3, #32
  401aba:	f200 810c 	bhi.w	401cd6 <build_sensor_event_data+0x25a>
  401abe:	a201      	add	r2, pc, #4	; (adr r2, 401ac4 <build_sensor_event_data+0x48>)
  401ac0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401ac4:	00401bf7 	.word	0x00401bf7
  401ac8:	00401c15 	.word	0x00401c15
  401acc:	00401ca1 	.word	0x00401ca1
  401ad0:	00401bb9 	.word	0x00401bb9
  401ad4:	00401cd7 	.word	0x00401cd7
  401ad8:	00401cd7 	.word	0x00401cd7
  401adc:	00401cd7 	.word	0x00401cd7
  401ae0:	00401cd7 	.word	0x00401cd7
  401ae4:	00401bd7 	.word	0x00401bd7
  401ae8:	00401bf7 	.word	0x00401bf7
  401aec:	00401c33 	.word	0x00401c33
  401af0:	00401cd7 	.word	0x00401cd7
  401af4:	00401cd7 	.word	0x00401cd7
  401af8:	00401b81 	.word	0x00401b81
  401afc:	00401c4f 	.word	0x00401c4f
  401b00:	00401b49 	.word	0x00401b49
  401b04:	00401c77 	.word	0x00401c77
  401b08:	00401c77 	.word	0x00401c77
  401b0c:	00401c8d 	.word	0x00401c8d
  401b10:	00401c33 	.word	0x00401c33
  401b14:	00401cd7 	.word	0x00401cd7
  401b18:	00401c77 	.word	0x00401c77
  401b1c:	00401cd7 	.word	0x00401cd7
  401b20:	00401cd7 	.word	0x00401cd7
  401b24:	00401c77 	.word	0x00401c77
  401b28:	00401c6d 	.word	0x00401c6d
  401b2c:	00401cd7 	.word	0x00401cd7
  401b30:	00401c7d 	.word	0x00401c7d
  401b34:	00401cd7 	.word	0x00401cd7
  401b38:	00401cd7 	.word	0x00401cd7
  401b3c:	00401cd7 	.word	0x00401cd7
  401b40:	00401cb5 	.word	0x00401cb5
  401b44:	00401cb5 	.word	0x00401cb5
	case INV_SENSOR_TYPE_UNCAL_GYROSCOPE:
		memcpy(raw_bias_data, data, sizeof(raw_bias_data));
  401b48:	f107 0364 	add.w	r3, r7, #100	; 0x64
  401b4c:	2218      	movs	r2, #24
  401b4e:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401b52:	4618      	mov	r0, r3
  401b54:	4b64      	ldr	r3, [pc, #400]	; (401ce8 <build_sensor_event_data+0x26c>)
  401b56:	4798      	blx	r3
		memcpy(event.data.gyr.vect, &raw_bias_data[0], sizeof(event.data.gyr.vect));
  401b58:	f107 0320 	add.w	r3, r7, #32
  401b5c:	f107 0264 	add.w	r2, r7, #100	; 0x64
  401b60:	ca07      	ldmia	r2, {r0, r1, r2}
  401b62:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(event.data.gyr.bias, &raw_bias_data[3], sizeof(event.data.gyr.bias));
  401b66:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  401b6a:	f107 0270 	add.w	r2, r7, #112	; 0x70
  401b6e:	ca07      	ldmia	r2, {r0, r1, r2}
  401b70:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(&(event.data.gyr.accuracy_flag), arg, sizeof(event.data.gyr.accuracy_flag));
  401b74:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401b78:	781b      	ldrb	r3, [r3, #0]
  401b7a:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401b7e:	e0a3      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		memcpy(raw_bias_data, data, sizeof(raw_bias_data));
  401b80:	f107 0364 	add.w	r3, r7, #100	; 0x64
  401b84:	2218      	movs	r2, #24
  401b86:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401b8a:	4618      	mov	r0, r3
  401b8c:	4b56      	ldr	r3, [pc, #344]	; (401ce8 <build_sensor_event_data+0x26c>)
  401b8e:	4798      	blx	r3
		memcpy(event.data.mag.vect, &raw_bias_data[0], sizeof(event.data.mag.vect));
  401b90:	f107 0320 	add.w	r3, r7, #32
  401b94:	f107 0264 	add.w	r2, r7, #100	; 0x64
  401b98:	ca07      	ldmia	r2, {r0, r1, r2}
  401b9a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(event.data.mag.bias, &raw_bias_data[3], sizeof(event.data.mag.bias));
  401b9e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  401ba2:	f107 0270 	add.w	r2, r7, #112	; 0x70
  401ba6:	ca07      	ldmia	r2, {r0, r1, r2}
  401ba8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(&(event.data.gyr.accuracy_flag), arg, sizeof(event.data.gyr.accuracy_flag));
  401bac:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401bb0:	781b      	ldrb	r3, [r3, #0]
  401bb2:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401bb6:	e087      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GYROSCOPE:
		memcpy(event.data.gyr.vect, data, sizeof(event.data.gyr.vect));
  401bb8:	f107 0310 	add.w	r3, r7, #16
  401bbc:	3310      	adds	r3, #16
  401bbe:	220c      	movs	r2, #12
  401bc0:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401bc4:	4618      	mov	r0, r3
  401bc6:	4b48      	ldr	r3, [pc, #288]	; (401ce8 <build_sensor_event_data+0x26c>)
  401bc8:	4798      	blx	r3
		memcpy(&(event.data.gyr.accuracy_flag), arg, sizeof(event.data.gyr.accuracy_flag));
  401bca:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401bce:	781b      	ldrb	r3, [r3, #0]
  401bd0:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401bd4:	e078      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GRAVITY:
		memcpy(event.data.acc.vect, data, sizeof(event.data.acc.vect));
  401bd6:	f107 0310 	add.w	r3, r7, #16
  401bda:	3310      	adds	r3, #16
  401bdc:	220c      	movs	r2, #12
  401bde:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401be2:	4618      	mov	r0, r3
  401be4:	4b40      	ldr	r3, [pc, #256]	; (401ce8 <build_sensor_event_data+0x26c>)
  401be6:	4798      	blx	r3
		event.data.acc.accuracy_flag = inv_icm20648_get_accel_accuracy();
  401be8:	4b40      	ldr	r3, [pc, #256]	; (401cec <build_sensor_event_data+0x270>)
  401bea:	4798      	blx	r3
  401bec:	4603      	mov	r3, r0
  401bee:	b2db      	uxtb	r3, r3
  401bf0:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401bf4:	e068      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_LINEAR_ACCELERATION:
	case INV_SENSOR_TYPE_ACCELEROMETER:
		memcpy(event.data.acc.vect, data, sizeof(event.data.acc.vect));
  401bf6:	f107 0310 	add.w	r3, r7, #16
  401bfa:	3310      	adds	r3, #16
  401bfc:	220c      	movs	r2, #12
  401bfe:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c02:	4618      	mov	r0, r3
  401c04:	4b38      	ldr	r3, [pc, #224]	; (401ce8 <build_sensor_event_data+0x26c>)
  401c06:	4798      	blx	r3
		memcpy(&(event.data.acc.accuracy_flag), arg, sizeof(event.data.acc.accuracy_flag));
  401c08:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401c0c:	781b      	ldrb	r3, [r3, #0]
  401c0e:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401c12:	e059      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_MAGNETOMETER:
		memcpy(event.data.mag.vect, data, sizeof(event.data.mag.vect));
  401c14:	f107 0310 	add.w	r3, r7, #16
  401c18:	3310      	adds	r3, #16
  401c1a:	220c      	movs	r2, #12
  401c1c:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c20:	4618      	mov	r0, r3
  401c22:	4b31      	ldr	r3, [pc, #196]	; (401ce8 <build_sensor_event_data+0x26c>)
  401c24:	4798      	blx	r3
		memcpy(&(event.data.mag.accuracy_flag), arg, sizeof(event.data.mag.accuracy_flag));
  401c26:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401c2a:	781b      	ldrb	r3, [r3, #0]
  401c2c:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401c30:	e04a      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
	case INV_SENSOR_TYPE_ROTATION_VECTOR:
		memcpy(&(event.data.quaternion.accuracy), arg, sizeof(event.data.quaternion.accuracy));
  401c32:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401c36:	681b      	ldr	r3, [r3, #0]
  401c38:	633b      	str	r3, [r7, #48]	; 0x30
		memcpy(event.data.quaternion.quat, data, sizeof(event.data.quaternion.quat));
  401c3a:	f107 0310 	add.w	r3, r7, #16
  401c3e:	3310      	adds	r3, #16
  401c40:	2210      	movs	r2, #16
  401c42:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c46:	4618      	mov	r0, r3
  401c48:	4b27      	ldr	r3, [pc, #156]	; (401ce8 <build_sensor_event_data+0x26c>)
  401c4a:	4798      	blx	r3
		break;
  401c4c:	e03c      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GAME_ROTATION_VECTOR:
		memcpy(event.data.quaternion.quat, data, sizeof(event.data.quaternion.quat));
  401c4e:	f107 0310 	add.w	r3, r7, #16
  401c52:	3310      	adds	r3, #16
  401c54:	2210      	movs	r2, #16
  401c56:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c5a:	4618      	mov	r0, r3
  401c5c:	4b22      	ldr	r3, [pc, #136]	; (401ce8 <build_sensor_event_data+0x26c>)
  401c5e:	4798      	blx	r3
		event.data.quaternion.accuracy_flag = icm20648_get_grv_accuracy();
  401c60:	4b23      	ldr	r3, [pc, #140]	; (401cf0 <build_sensor_event_data+0x274>)
  401c62:	4798      	blx	r3
  401c64:	4603      	mov	r3, r0
  401c66:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
		break;
  401c6a:	e02d      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_BAC:
		memcpy(&(event.data.bac.event), data, sizeof(event.data.bac.event));
  401c6c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  401c70:	681b      	ldr	r3, [r3, #0]
  401c72:	623b      	str	r3, [r7, #32]
		break;
  401c74:	e028      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_PICK_UP_GESTURE:
	case INV_SENSOR_TYPE_TILT_DETECTOR:
	case INV_SENSOR_TYPE_STEP_DETECTOR:
	case INV_SENSOR_TYPE_SMD:
		event.data.event = true;
  401c76:	2301      	movs	r3, #1
  401c78:	623b      	str	r3, [r7, #32]
		break;
  401c7a:	e025      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_B2S:
		event.data.event = true;
  401c7c:	2301      	movs	r3, #1
  401c7e:	623b      	str	r3, [r7, #32]
		memcpy(&(event.data.b2s.direction), data, sizeof(event.data.b2s.direction));
  401c80:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  401c84:	781b      	ldrb	r3, [r3, #0]
  401c86:	f887 3020 	strb.w	r3, [r7, #32]
		break;
  401c8a:	e01d      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_STEP_COUNTER:
		memcpy(&(event.data.step.count), data, sizeof(event.data.step.count));
  401c8c:	f107 0310 	add.w	r3, r7, #16
  401c90:	3310      	adds	r3, #16
  401c92:	2208      	movs	r2, #8
  401c94:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c98:	4618      	mov	r0, r3
  401c9a:	4b13      	ldr	r3, [pc, #76]	; (401ce8 <build_sensor_event_data+0x26c>)
  401c9c:	4798      	blx	r3
		break;
  401c9e:	e013      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_ORIENTATION:
		//we just want to copy x,y,z from orientation data
		memcpy(&(event.data.orientation), data, 3*sizeof(float));
  401ca0:	f107 0310 	add.w	r3, r7, #16
  401ca4:	3310      	adds	r3, #16
  401ca6:	220c      	movs	r2, #12
  401ca8:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401cac:	4618      	mov	r0, r3
  401cae:	4b0e      	ldr	r3, [pc, #56]	; (401ce8 <build_sensor_event_data+0x26c>)
  401cb0:	4798      	blx	r3
		break;
  401cb2:	e009      	b.n	401cc8 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_RAW_ACCELEROMETER:
	case INV_SENSOR_TYPE_RAW_GYROSCOPE:
		memcpy(event.data.raw3d.vect, data, sizeof(event.data.raw3d.vect));
  401cb4:	f107 0310 	add.w	r3, r7, #16
  401cb8:	3310      	adds	r3, #16
  401cba:	220c      	movs	r2, #12
  401cbc:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401cc0:	4618      	mov	r0, r3
  401cc2:	4b09      	ldr	r3, [pc, #36]	; (401ce8 <build_sensor_event_data+0x26c>)
  401cc4:	4798      	blx	r3
		break;
  401cc6:	bf00      	nop
	default:
		return;
	}
	sensor_event(&event, NULL);
  401cc8:	f107 0310 	add.w	r3, r7, #16
  401ccc:	2100      	movs	r1, #0
  401cce:	4618      	mov	r0, r3
  401cd0:	4b08      	ldr	r3, [pc, #32]	; (401cf4 <build_sensor_event_data+0x278>)
  401cd2:	4798      	blx	r3
  401cd4:	e000      	b.n	401cd8 <build_sensor_event_data+0x25c>
		return;
  401cd6:	bf00      	nop
}
  401cd8:	3784      	adds	r7, #132	; 0x84
  401cda:	46bd      	mov	sp, r7
  401cdc:	bd90      	pop	{r4, r7, pc}
  401cde:	bf00      	nop
  401ce0:	20000104 	.word	0x20000104
  401ce4:	00414431 	.word	0x00414431
  401ce8:	00414235 	.word	0x00414235
  401cec:	00409d55 	.word	0x00409d55
  401cf0:	00401a49 	.word	0x00401a49
  401cf4:	00401cf9 	.word	0x00401cf9

00401cf8 <sensor_event>:

void sensor_event(const inv_sensor_event_t * event, void * arg){
  401cf8:	b590      	push	{r4, r7, lr}
  401cfa:	b087      	sub	sp, #28
  401cfc:	af02      	add	r7, sp, #8
  401cfe:	6078      	str	r0, [r7, #4]
  401d00:	6039      	str	r1, [r7, #0]
	*/
	static DynProtocolEdata_t async_edata; /* static to take on .bss */
	static uint8_t async_buffer[256]; /* static to take on .bss */
	uint16_t async_bufferLen;

	async_edata.sensor_id = event->sensor;
  401d02:	687b      	ldr	r3, [r7, #4]
  401d04:	681b      	ldr	r3, [r3, #0]
  401d06:	461a      	mov	r2, r3
  401d08:	4b13      	ldr	r3, [pc, #76]	; (401d58 <sensor_event+0x60>)
  401d0a:	601a      	str	r2, [r3, #0]
	async_edata.d.async.sensorEvent.status = DYN_PRO_SENSOR_STATUS_DATA_UPDATED;
  401d0c:	4b12      	ldr	r3, [pc, #72]	; (401d58 <sensor_event+0x60>)
  401d0e:	2200      	movs	r2, #0
  401d10:	605a      	str	r2, [r3, #4]
	convert_sensor_event_to_dyn_prot_data(event, &async_edata.d.async.sensorEvent.vdata);
  401d12:	4912      	ldr	r1, [pc, #72]	; (401d5c <sensor_event+0x64>)
  401d14:	6878      	ldr	r0, [r7, #4]
  401d16:	4b12      	ldr	r3, [pc, #72]	; (401d60 <sensor_event+0x68>)
  401d18:	4798      	blx	r3

	if(DynProtocol_encodeAsync(&protocol,
  401d1a:	f107 030e 	add.w	r3, r7, #14
  401d1e:	9301      	str	r3, [sp, #4]
  401d20:	f44f 7380 	mov.w	r3, #256	; 0x100
  401d24:	9300      	str	r3, [sp, #0]
  401d26:	4b0f      	ldr	r3, [pc, #60]	; (401d64 <sensor_event+0x6c>)
  401d28:	4a0b      	ldr	r2, [pc, #44]	; (401d58 <sensor_event+0x60>)
  401d2a:	2130      	movs	r1, #48	; 0x30
  401d2c:	480e      	ldr	r0, [pc, #56]	; (401d68 <sensor_event+0x70>)
  401d2e:	4c0f      	ldr	r4, [pc, #60]	; (401d6c <sensor_event+0x74>)
  401d30:	47a0      	blx	r4
  401d32:	4603      	mov	r3, r0
  401d34:	2b00      	cmp	r3, #0
  401d36:	d106      	bne.n	401d46 <sensor_event+0x4e>
		DYN_PROTOCOL_EID_NEW_SENSOR_DATA, &async_edata,
		async_buffer, sizeof(async_buffer), &async_bufferLen) != 0) {
			goto error_dma_buf;
	}

	DynProTransportUart_tx(&transport, async_buffer, async_bufferLen);
  401d38:	89fb      	ldrh	r3, [r7, #14]
  401d3a:	461a      	mov	r2, r3
  401d3c:	4909      	ldr	r1, [pc, #36]	; (401d64 <sensor_event+0x6c>)
  401d3e:	480c      	ldr	r0, [pc, #48]	; (401d70 <sensor_event+0x78>)
  401d40:	4b0c      	ldr	r3, [pc, #48]	; (401d74 <sensor_event+0x7c>)
  401d42:	4798      	blx	r3
	return;
  401d44:	e005      	b.n	401d52 <sensor_event+0x5a>
			goto error_dma_buf;
  401d46:	bf00      	nop

error_dma_buf:
	INV_MSG(INV_MSG_LEVEL_WARNING, "sensor_event_cb: encode error, frame dropped");
  401d48:	490b      	ldr	r1, [pc, #44]	; (401d78 <sensor_event+0x80>)
  401d4a:	2002      	movs	r0, #2
  401d4c:	4b0b      	ldr	r3, [pc, #44]	; (401d7c <sensor_event+0x84>)
  401d4e:	4798      	blx	r3

	return;
  401d50:	bf00      	nop
}
  401d52:	3714      	adds	r7, #20
  401d54:	46bd      	mov	sp, r7
  401d56:	bd90      	pop	{r4, r7, pc}
  401d58:	20001070 	.word	0x20001070
  401d5c:	20001078 	.word	0x20001078
  401d60:	00401d81 	.word	0x00401d81
  401d64:	200010f4 	.word	0x200010f4
  401d68:	20001870 	.word	0x20001870
  401d6c:	0040f6a5 	.word	0x0040f6a5
  401d70:	20001988 	.word	0x20001988
  401d74:	0040f925 	.word	0x0040f925
  401d78:	0041bc0c 	.word	0x0041bc0c
  401d7c:	0040ff51 	.word	0x0040ff51

00401d80 <convert_sensor_event_to_dyn_prot_data>:

/*
* Convert sensor_event to VSensorData because dynamic protocol transports VSensorData
*/
static void convert_sensor_event_to_dyn_prot_data(const inv_sensor_event_t * event, VSensorDataAny * vsensor_data){
  401d80:	b590      	push	{r4, r7, lr}
  401d82:	b083      	sub	sp, #12
  401d84:	af00      	add	r7, sp, #0
  401d86:	6078      	str	r0, [r7, #4]
  401d88:	6039      	str	r1, [r7, #0]
	vsensor_data->base.timestamp = event->timestamp;
  401d8a:	687b      	ldr	r3, [r7, #4]
  401d8c:	e9d3 3402 	ldrd	r3, r4, [r3, #8]
  401d90:	461a      	mov	r2, r3
  401d92:	683b      	ldr	r3, [r7, #0]
  401d94:	601a      	str	r2, [r3, #0]

	switch(event->sensor) {
  401d96:	687b      	ldr	r3, [r7, #4]
  401d98:	681b      	ldr	r3, [r3, #0]
  401d9a:	2b41      	cmp	r3, #65	; 0x41
  401d9c:	f200 815d 	bhi.w	40205a <convert_sensor_event_to_dyn_prot_data+0x2da>
  401da0:	a201      	add	r2, pc, #4	; (adr r2, 401da8 <convert_sensor_event_to_dyn_prot_data+0x28>)
  401da2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401da6:	bf00      	nop
  401da8:	0040205b 	.word	0x0040205b
  401dac:	00401eb1 	.word	0x00401eb1
  401db0:	00401f43 	.word	0x00401f43
  401db4:	00401fc7 	.word	0x00401fc7
  401db8:	00401ed1 	.word	0x00401ed1
  401dbc:	0040205b 	.word	0x0040205b
  401dc0:	0040205b 	.word	0x0040205b
  401dc4:	0040205b 	.word	0x0040205b
  401dc8:	0040205b 	.word	0x0040205b
  401dcc:	00401eb1 	.word	0x00401eb1
  401dd0:	00401eb1 	.word	0x00401eb1
  401dd4:	00401f95 	.word	0x00401f95
  401dd8:	0040205b 	.word	0x0040205b
  401ddc:	0040205b 	.word	0x0040205b
  401de0:	00401f63 	.word	0x00401f63
  401de4:	00401f23 	.word	0x00401f23
  401de8:	00401ef1 	.word	0x00401ef1
  401dec:	0040204f 	.word	0x0040204f
  401df0:	0040204f 	.word	0x0040204f
  401df4:	00402029 	.word	0x00402029
  401df8:	00401f95 	.word	0x00401f95
  401dfc:	0040205b 	.word	0x0040205b
  401e00:	0040204f 	.word	0x0040204f
  401e04:	0040205b 	.word	0x0040205b
  401e08:	0040205b 	.word	0x0040205b
  401e0c:	0040204f 	.word	0x0040204f
  401e10:	00402037 	.word	0x00402037
  401e14:	0040205b 	.word	0x0040205b
  401e18:	0040204f 	.word	0x0040204f
  401e1c:	0040205b 	.word	0x0040205b
  401e20:	0040205b 	.word	0x0040205b
  401e24:	0040205b 	.word	0x0040205b
  401e28:	00402009 	.word	0x00402009
  401e2c:	00402009 	.word	0x00402009
  401e30:	0040205b 	.word	0x0040205b
  401e34:	0040205b 	.word	0x0040205b
  401e38:	0040205b 	.word	0x0040205b
  401e3c:	0040205b 	.word	0x0040205b
  401e40:	0040205b 	.word	0x0040205b
  401e44:	0040205b 	.word	0x0040205b
  401e48:	0040205b 	.word	0x0040205b
  401e4c:	0040205b 	.word	0x0040205b
  401e50:	0040205b 	.word	0x0040205b
  401e54:	0040205b 	.word	0x0040205b
  401e58:	0040205b 	.word	0x0040205b
  401e5c:	0040205b 	.word	0x0040205b
  401e60:	0040205b 	.word	0x0040205b
  401e64:	0040205b 	.word	0x0040205b
  401e68:	0040205b 	.word	0x0040205b
  401e6c:	0040205b 	.word	0x0040205b
  401e70:	0040205b 	.word	0x0040205b
  401e74:	0040205b 	.word	0x0040205b
  401e78:	0040205b 	.word	0x0040205b
  401e7c:	0040205b 	.word	0x0040205b
  401e80:	0040205b 	.word	0x0040205b
  401e84:	0040205b 	.word	0x0040205b
  401e88:	0040205b 	.word	0x0040205b
  401e8c:	00402043 	.word	0x00402043
  401e90:	0040205b 	.word	0x0040205b
  401e94:	0040205b 	.word	0x0040205b
  401e98:	0040205b 	.word	0x0040205b
  401e9c:	0040205b 	.word	0x0040205b
  401ea0:	0040205b 	.word	0x0040205b
  401ea4:	0040205b 	.word	0x0040205b
  401ea8:	00401f23 	.word	0x00401f23
  401eac:	00401f23 	.word	0x00401f23
	case DYN_PRO_SENSOR_TYPE_RESERVED:
		break;
	case DYN_PRO_SENSOR_TYPE_GRAVITY:
	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
		inv_dc_float_to_sfix32(&event->data.acc.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401eb0:	687b      	ldr	r3, [r7, #4]
  401eb2:	f103 0010 	add.w	r0, r3, #16
  401eb6:	683b      	ldr	r3, [r7, #0]
  401eb8:	3308      	adds	r3, #8
  401eba:	2210      	movs	r2, #16
  401ebc:	2103      	movs	r1, #3
  401ebe:	4c69      	ldr	r4, [pc, #420]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401ec0:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.acc.accuracy_flag;
  401ec2:	687b      	ldr	r3, [r7, #4]
  401ec4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401ec8:	461a      	mov	r2, r3
  401eca:	683b      	ldr	r3, [r7, #0]
  401ecc:	605a      	str	r2, [r3, #4]
		break;
  401ece:	e0c5      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
		inv_dc_float_to_sfix32(&event->data.gyr.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401ed0:	687b      	ldr	r3, [r7, #4]
  401ed2:	f103 0010 	add.w	r0, r3, #16
  401ed6:	683b      	ldr	r3, [r7, #0]
  401ed8:	3308      	adds	r3, #8
  401eda:	2210      	movs	r2, #16
  401edc:	2103      	movs	r1, #3
  401ede:	4c61      	ldr	r4, [pc, #388]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401ee0:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.gyr.accuracy_flag;
  401ee2:	687b      	ldr	r3, [r7, #4]
  401ee4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401ee8:	461a      	mov	r2, r3
  401eea:	683b      	ldr	r3, [r7, #0]
  401eec:	605a      	str	r2, [r3, #4]
		break;
  401eee:	e0b5      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		inv_dc_float_to_sfix32(&event->data.gyr.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401ef0:	687b      	ldr	r3, [r7, #4]
  401ef2:	f103 0010 	add.w	r0, r3, #16
  401ef6:	683b      	ldr	r3, [r7, #0]
  401ef8:	3308      	adds	r3, #8
  401efa:	2210      	movs	r2, #16
  401efc:	2103      	movs	r1, #3
  401efe:	4c59      	ldr	r4, [pc, #356]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f00:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.gyr.bias[0], 3, 16, (int32_t *)&vsensor_data->data.u32[3]);
  401f02:	687b      	ldr	r3, [r7, #4]
  401f04:	f103 001c 	add.w	r0, r3, #28
  401f08:	683b      	ldr	r3, [r7, #0]
  401f0a:	3314      	adds	r3, #20
  401f0c:	2210      	movs	r2, #16
  401f0e:	2103      	movs	r1, #3
  401f10:	4c54      	ldr	r4, [pc, #336]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f12:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.gyr.accuracy_flag;
  401f14:	687b      	ldr	r3, [r7, #4]
  401f16:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401f1a:	461a      	mov	r2, r3
  401f1c:	683b      	ldr	r3, [r7, #0]
  401f1e:	605a      	str	r2, [r3, #4]
		break;
  401f20:	e09c      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
		inv_dc_float_to_sfix32(&event->data.quaternion.quat[0], 4, 30, (int32_t *)&vsensor_data->data.u32[0]);
  401f22:	687b      	ldr	r3, [r7, #4]
  401f24:	f103 0010 	add.w	r0, r3, #16
  401f28:	683b      	ldr	r3, [r7, #0]
  401f2a:	3308      	adds	r3, #8
  401f2c:	221e      	movs	r2, #30
  401f2e:	2104      	movs	r1, #4
  401f30:	4c4c      	ldr	r4, [pc, #304]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f32:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.quaternion.accuracy_flag;
  401f34:	687b      	ldr	r3, [r7, #4]
  401f36:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
  401f3a:	461a      	mov	r2, r3
  401f3c:	683b      	ldr	r3, [r7, #0]
  401f3e:	605a      	str	r2, [r3, #4]
		break;
  401f40:	e08c      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
		inv_dc_float_to_sfix32(&event->data.mag.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401f42:	687b      	ldr	r3, [r7, #4]
  401f44:	f103 0010 	add.w	r0, r3, #16
  401f48:	683b      	ldr	r3, [r7, #0]
  401f4a:	3308      	adds	r3, #8
  401f4c:	2210      	movs	r2, #16
  401f4e:	2103      	movs	r1, #3
  401f50:	4c44      	ldr	r4, [pc, #272]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f52:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.mag.accuracy_flag;
  401f54:	687b      	ldr	r3, [r7, #4]
  401f56:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401f5a:	461a      	mov	r2, r3
  401f5c:	683b      	ldr	r3, [r7, #0]
  401f5e:	605a      	str	r2, [r3, #4]
		break;
  401f60:	e07c      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		inv_dc_float_to_sfix32(&event->data.mag.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401f62:	687b      	ldr	r3, [r7, #4]
  401f64:	f103 0010 	add.w	r0, r3, #16
  401f68:	683b      	ldr	r3, [r7, #0]
  401f6a:	3308      	adds	r3, #8
  401f6c:	2210      	movs	r2, #16
  401f6e:	2103      	movs	r1, #3
  401f70:	4c3c      	ldr	r4, [pc, #240]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f72:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.mag.bias[0], 3, 16, (int32_t *)&vsensor_data->data.u32[3]);
  401f74:	687b      	ldr	r3, [r7, #4]
  401f76:	f103 001c 	add.w	r0, r3, #28
  401f7a:	683b      	ldr	r3, [r7, #0]
  401f7c:	3314      	adds	r3, #20
  401f7e:	2210      	movs	r2, #16
  401f80:	2103      	movs	r1, #3
  401f82:	4c38      	ldr	r4, [pc, #224]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f84:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.mag.accuracy_flag;
  401f86:	687b      	ldr	r3, [r7, #4]
  401f88:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401f8c:	461a      	mov	r2, r3
  401f8e:	683b      	ldr	r3, [r7, #0]
  401f90:	605a      	str	r2, [r3, #4]
		break;
  401f92:	e063      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		inv_dc_float_to_sfix32(&event->data.quaternion.quat[0], 4, 30, (int32_t *)&vsensor_data->data.u32[0]);
  401f94:	687b      	ldr	r3, [r7, #4]
  401f96:	f103 0010 	add.w	r0, r3, #16
  401f9a:	683b      	ldr	r3, [r7, #0]
  401f9c:	3308      	adds	r3, #8
  401f9e:	221e      	movs	r2, #30
  401fa0:	2104      	movs	r1, #4
  401fa2:	4c30      	ldr	r4, [pc, #192]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fa4:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.quaternion.accuracy, 1, 16, (int32_t *)&vsensor_data->data.u32[4]);
  401fa6:	687b      	ldr	r3, [r7, #4]
  401fa8:	f103 0020 	add.w	r0, r3, #32
  401fac:	683b      	ldr	r3, [r7, #0]
  401fae:	3318      	adds	r3, #24
  401fb0:	2210      	movs	r2, #16
  401fb2:	2101      	movs	r1, #1
  401fb4:	4c2b      	ldr	r4, [pc, #172]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fb6:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.quaternion.accuracy_flag;
  401fb8:	687b      	ldr	r3, [r7, #4]
  401fba:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
  401fbe:	461a      	mov	r2, r3
  401fc0:	683b      	ldr	r3, [r7, #0]
  401fc2:	605a      	str	r2, [r3, #4]
		break;
  401fc4:	e04a      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
		inv_dc_float_to_sfix32(&event->data.orientation.x, 1, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401fc6:	687b      	ldr	r3, [r7, #4]
  401fc8:	f103 0010 	add.w	r0, r3, #16
  401fcc:	683b      	ldr	r3, [r7, #0]
  401fce:	3308      	adds	r3, #8
  401fd0:	2210      	movs	r2, #16
  401fd2:	2101      	movs	r1, #1
  401fd4:	4c23      	ldr	r4, [pc, #140]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fd6:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.orientation.y, 1, 16, (int32_t *)&vsensor_data->data.u32[1]);
  401fd8:	687b      	ldr	r3, [r7, #4]
  401fda:	f103 0014 	add.w	r0, r3, #20
  401fde:	683b      	ldr	r3, [r7, #0]
  401fe0:	330c      	adds	r3, #12
  401fe2:	2210      	movs	r2, #16
  401fe4:	2101      	movs	r1, #1
  401fe6:	4c1f      	ldr	r4, [pc, #124]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fe8:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.orientation.z, 1, 16, (int32_t *)&vsensor_data->data.u32[2]);
  401fea:	687b      	ldr	r3, [r7, #4]
  401fec:	f103 0018 	add.w	r0, r3, #24
  401ff0:	683b      	ldr	r3, [r7, #0]
  401ff2:	3310      	adds	r3, #16
  401ff4:	2210      	movs	r2, #16
  401ff6:	2101      	movs	r1, #1
  401ff8:	4c1a      	ldr	r4, [pc, #104]	; (402064 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401ffa:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.orientation.accuracy_flag;
  401ffc:	687b      	ldr	r3, [r7, #4]
  401ffe:	7f1b      	ldrb	r3, [r3, #28]
  402000:	461a      	mov	r2, r3
  402002:	683b      	ldr	r3, [r7, #0]
  402004:	605a      	str	r2, [r3, #4]
		break;
  402006:	e029      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
		vsensor_data->data.u32[0] = event->data.raw3d.vect[0];
  402008:	687b      	ldr	r3, [r7, #4]
  40200a:	691b      	ldr	r3, [r3, #16]
  40200c:	461a      	mov	r2, r3
  40200e:	683b      	ldr	r3, [r7, #0]
  402010:	609a      	str	r2, [r3, #8]
		vsensor_data->data.u32[1] = event->data.raw3d.vect[1];
  402012:	687b      	ldr	r3, [r7, #4]
  402014:	695b      	ldr	r3, [r3, #20]
  402016:	461a      	mov	r2, r3
  402018:	683b      	ldr	r3, [r7, #0]
  40201a:	60da      	str	r2, [r3, #12]
		vsensor_data->data.u32[2] = event->data.raw3d.vect[2];
  40201c:	687b      	ldr	r3, [r7, #4]
  40201e:	699b      	ldr	r3, [r3, #24]
  402020:	461a      	mov	r2, r3
  402022:	683b      	ldr	r3, [r7, #0]
  402024:	611a      	str	r2, [r3, #16]
		break;
  402026:	e019      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
		vsensor_data->data.u32[0] = (uint32_t)event->data.step.count;
  402028:	687b      	ldr	r3, [r7, #4]
  40202a:	e9d3 3404 	ldrd	r3, r4, [r3, #16]
  40202e:	461a      	mov	r2, r3
  402030:	683b      	ldr	r3, [r7, #0]
  402032:	609a      	str	r2, [r3, #8]
		break;
  402034:	e012      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_BAC:
		vsensor_data->data.u8[0] = (uint8_t)(int8_t)event->data.bac.event;
  402036:	687b      	ldr	r3, [r7, #4]
  402038:	691b      	ldr	r3, [r3, #16]
  40203a:	b2da      	uxtb	r2, r3
  40203c:	683b      	ldr	r3, [r7, #0]
  40203e:	721a      	strb	r2, [r3, #8]
		break;
  402040:	e00c      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_WOM:
		vsensor_data->data.u8[0] = event->data.wom.flags;
  402042:	687b      	ldr	r3, [r7, #4]
  402044:	691b      	ldr	r3, [r3, #16]
  402046:	b2da      	uxtb	r2, r3
  402048:	683b      	ldr	r3, [r7, #0]
  40204a:	721a      	strb	r2, [r3, #8]
		break;
  40204c:	e006      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	case DYN_PRO_SENSOR_TYPE_B2S:
	case DYN_PRO_SENSOR_TYPE_SMD:
	case DYN_PRO_SENSOR_TYPE_STEP_DETECTOR:
	case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:
	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
		vsensor_data->data.u8[0] = event->data.event;
  40204e:	687b      	ldr	r3, [r7, #4]
  402050:	691b      	ldr	r3, [r3, #16]
  402052:	b2da      	uxtb	r2, r3
  402054:	683b      	ldr	r3, [r7, #0]
  402056:	721a      	strb	r2, [r3, #8]
		break;
  402058:	e000      	b.n	40205c <convert_sensor_event_to_dyn_prot_data+0x2dc>
	default:
		break;
  40205a:	bf00      	nop
	}
}
  40205c:	bf00      	nop
  40205e:	370c      	adds	r7, #12
  402060:	46bd      	mov	sp, r7
  402062:	bd90      	pop	{r4, r7, pc}
  402064:	0040facb 	.word	0x0040facb

00402068 <idd_sensortype_conversion>:

static enum inv_icm20648_sensor idd_sensortype_conversion(int sensor){
  402068:	b480      	push	{r7}
  40206a:	b083      	sub	sp, #12
  40206c:	af00      	add	r7, sp, #0
  40206e:	6078      	str	r0, [r7, #4]
	switch(sensor) {
  402070:	687b      	ldr	r3, [r7, #4]
  402072:	3b01      	subs	r3, #1
  402074:	2b20      	cmp	r3, #32
  402076:	d86d      	bhi.n	402154 <idd_sensortype_conversion+0xec>
  402078:	a201      	add	r2, pc, #4	; (adr r2, 402080 <idd_sensortype_conversion+0x18>)
  40207a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40207e:	bf00      	nop
  402080:	0040210d 	.word	0x0040210d
  402084:	00402135 	.word	0x00402135
  402088:	0040214d 	.word	0x0040214d
  40208c:	00402111 	.word	0x00402111
  402090:	00402155 	.word	0x00402155
  402094:	00402155 	.word	0x00402155
  402098:	00402155 	.word	0x00402155
  40209c:	00402155 	.word	0x00402155
  4020a0:	00402145 	.word	0x00402145
  4020a4:	00402149 	.word	0x00402149
  4020a8:	0040212d 	.word	0x0040212d
  4020ac:	00402155 	.word	0x00402155
  4020b0:	00402155 	.word	0x00402155
  4020b4:	00402115 	.word	0x00402115
  4020b8:	00402129 	.word	0x00402129
  4020bc:	00402119 	.word	0x00402119
  4020c0:	00402139 	.word	0x00402139
  4020c4:	00402121 	.word	0x00402121
  4020c8:	00402125 	.word	0x00402125
  4020cc:	00402131 	.word	0x00402131
  4020d0:	00402155 	.word	0x00402155
  4020d4:	00402141 	.word	0x00402141
  4020d8:	00402155 	.word	0x00402155
  4020dc:	00402155 	.word	0x00402155
  4020e0:	0040213d 	.word	0x0040213d
  4020e4:	0040211d 	.word	0x0040211d
  4020e8:	00402155 	.word	0x00402155
  4020ec:	00402151 	.word	0x00402151
  4020f0:	00402155 	.word	0x00402155
  4020f4:	00402155 	.word	0x00402155
  4020f8:	00402155 	.word	0x00402155
  4020fc:	00402105 	.word	0x00402105
  402100:	00402109 	.word	0x00402109
	case INV_SENSOR_TYPE_RAW_ACCELEROMETER:       return INV_ICM20648_SENSOR_RAW_ACCELEROMETER;
  402104:	2302      	movs	r3, #2
  402106:	e026      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_RAW_GYROSCOPE:           return INV_ICM20648_SENSOR_RAW_GYROSCOPE;
  402108:	2303      	movs	r3, #3
  40210a:	e024      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_ACCELEROMETER:           return INV_ICM20648_SENSOR_ACCELEROMETER;
  40210c:	2300      	movs	r3, #0
  40210e:	e022      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GYROSCOPE:               return INV_ICM20648_SENSOR_GYROSCOPE;
  402110:	2301      	movs	r3, #1
  402112:	e020      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_UNCAL_MAGNETOMETER:      return INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED;
  402114:	2304      	movs	r3, #4
  402116:	e01e      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_UNCAL_GYROSCOPE:         return INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED;
  402118:	2305      	movs	r3, #5
  40211a:	e01c      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_BAC:                     return INV_ICM20648_SENSOR_ACTIVITY_CLASSIFICATON;
  40211c:	2306      	movs	r3, #6
  40211e:	e01a      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_STEP_DETECTOR:           return INV_ICM20648_SENSOR_STEP_DETECTOR;
  402120:	2307      	movs	r3, #7
  402122:	e018      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_STEP_COUNTER:            return INV_ICM20648_SENSOR_STEP_COUNTER;
  402124:	2308      	movs	r3, #8
  402126:	e016      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GAME_ROTATION_VECTOR:    return INV_ICM20648_SENSOR_GAME_ROTATION_VECTOR;
  402128:	2309      	movs	r3, #9
  40212a:	e014      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_ROTATION_VECTOR:         return INV_ICM20648_SENSOR_ROTATION_VECTOR;
  40212c:	230a      	movs	r3, #10
  40212e:	e012      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:  return INV_ICM20648_SENSOR_GEOMAGNETIC_ROTATION_VECTOR;
  402130:	230b      	movs	r3, #11
  402132:	e010      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_MAGNETOMETER:            return INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD;
  402134:	230c      	movs	r3, #12
  402136:	e00e      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_SMD:                     return INV_ICM20648_SENSOR_WAKEUP_SIGNIFICANT_MOTION;
  402138:	230d      	movs	r3, #13
  40213a:	e00c      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_PICK_UP_GESTURE:         return INV_ICM20648_SENSOR_FLIP_PICKUP;
  40213c:	230e      	movs	r3, #14
  40213e:	e00a      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_TILT_DETECTOR:           return INV_ICM20648_SENSOR_WAKEUP_TILT_DETECTOR;
  402140:	230f      	movs	r3, #15
  402142:	e008      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GRAVITY:                 return INV_ICM20648_SENSOR_GRAVITY;
  402144:	2310      	movs	r3, #16
  402146:	e006      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_LINEAR_ACCELERATION:     return INV_ICM20648_SENSOR_LINEAR_ACCELERATION;
  402148:	2311      	movs	r3, #17
  40214a:	e004      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_ORIENTATION:             return INV_ICM20648_SENSOR_ORIENTATION;
  40214c:	2312      	movs	r3, #18
  40214e:	e002      	b.n	402156 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_B2S:                     return INV_ICM20648_SENSOR_B2S;
  402150:	2313      	movs	r3, #19
  402152:	e000      	b.n	402156 <idd_sensortype_conversion+0xee>
	default:                                      return INV_ICM20648_SENSOR_MAX;
  402154:	2314      	movs	r3, #20
	}
}
  402156:	4618      	mov	r0, r3
  402158:	370c      	adds	r7, #12
  40215a:	46bd      	mov	sp, r7
  40215c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402160:	4770      	bx	lr
  402162:	bf00      	nop

00402164 <handle_command>:

int handle_command(enum DynProtocolEid eid, const DynProtocolEdata_t * edata, DynProtocolEdata_t * respdata){
  402164:	b580      	push	{r7, lr}
  402166:	b08a      	sub	sp, #40	; 0x28
  402168:	af00      	add	r7, sp, #0
  40216a:	4603      	mov	r3, r0
  40216c:	60b9      	str	r1, [r7, #8]
  40216e:	607a      	str	r2, [r7, #4]
  402170:	73fb      	strb	r3, [r7, #15]
	int rc = 0;
  402172:	2300      	movs	r3, #0
  402174:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t whoami;
	const int sensor = edata->sensor_id;
  402176:	68bb      	ldr	r3, [r7, #8]
  402178:	681b      	ldr	r3, [r3, #0]
  40217a:	617b      	str	r3, [r7, #20]

	switch(eid) {
  40217c:	7bfb      	ldrb	r3, [r7, #15]
  40217e:	3b10      	subs	r3, #16
  402180:	2b13      	cmp	r3, #19
  402182:	f200 81dd 	bhi.w	402540 <handle_command+0x3dc>
  402186:	a201      	add	r2, pc, #4	; (adr r2, 40218c <handle_command+0x28>)
  402188:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40218c:	00402241 	.word	0x00402241
  402190:	0040225d 	.word	0x0040225d
  402194:	004021f1 	.word	0x004021f1
  402198:	004024f5 	.word	0x004024f5
  40219c:	00402541 	.word	0x00402541
  4021a0:	0040235b 	.word	0x0040235b
  4021a4:	00402541 	.word	0x00402541
  4021a8:	004022c1 	.word	0x004022c1
  4021ac:	00402541 	.word	0x00402541
  4021b0:	004023a1 	.word	0x004023a1
  4021b4:	0040244d 	.word	0x0040244d
  4021b8:	004024ab 	.word	0x004024ab
  4021bc:	00402541 	.word	0x00402541
  4021c0:	00402541 	.word	0x00402541
  4021c4:	00402541 	.word	0x00402541
  4021c8:	00402541 	.word	0x00402541
  4021cc:	00402541 	.word	0x00402541
  4021d0:	00402541 	.word	0x00402541
  4021d4:	004021dd 	.word	0x004021dd
  4021d8:	004024dd 	.word	0x004024dd
	case DYN_PROTOCOL_EID_GET_SW_REG:
		if(edata->d.command.regAddr == DYN_PROTOCOL_EREG_HANDSHAKE_SUPPORT)
  4021dc:	68bb      	ldr	r3, [r7, #8]
  4021de:	791b      	ldrb	r3, [r3, #4]
  4021e0:	2b04      	cmp	r3, #4
  4021e2:	d103      	bne.n	4021ec <handle_command+0x88>
			return InvEMDFrontEnd_isHwFlowCtrlSupportedHook();
  4021e4:	4b85      	ldr	r3, [pc, #532]	; (4023fc <handle_command+0x298>)
  4021e6:	4798      	blx	r3
  4021e8:	4603      	mov	r3, r0
  4021ea:	e1ab      	b.n	402544 <handle_command+0x3e0>
		return 0;
  4021ec:	2300      	movs	r3, #0
  4021ee:	e1a9      	b.n	402544 <handle_command+0x3e0>

	case DYN_PROTOCOL_EID_SETUP:
	{
		int i_sensor = INV_SENSOR_TYPE_MAX;
  4021f0:	2344      	movs	r3, #68	; 0x44
  4021f2:	623b      	str	r3, [r7, #32]
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command setup");
  4021f4:	4982      	ldr	r1, [pc, #520]	; (402400 <handle_command+0x29c>)
  4021f6:	2005      	movs	r0, #5
  4021f8:	4b82      	ldr	r3, [pc, #520]	; (402404 <handle_command+0x2a0>)
  4021fa:	4798      	blx	r3

		/* Disable all sensors */
		while(i_sensor-- > 0) {
  4021fc:	e009      	b.n	402212 <handle_command+0xae>
			rc = inv_icm20648_enable_sensor(&icm_device, idd_sensortype_conversion(i_sensor), 0);
  4021fe:	6a38      	ldr	r0, [r7, #32]
  402200:	4b81      	ldr	r3, [pc, #516]	; (402408 <handle_command+0x2a4>)
  402202:	4798      	blx	r3
  402204:	4603      	mov	r3, r0
  402206:	2200      	movs	r2, #0
  402208:	4619      	mov	r1, r3
  40220a:	4880      	ldr	r0, [pc, #512]	; (40240c <handle_command+0x2a8>)
  40220c:	4b80      	ldr	r3, [pc, #512]	; (402410 <handle_command+0x2ac>)
  40220e:	4798      	blx	r3
  402210:	6278      	str	r0, [r7, #36]	; 0x24
		while(i_sensor-- > 0) {
  402212:	6a3b      	ldr	r3, [r7, #32]
  402214:	1e5a      	subs	r2, r3, #1
  402216:	623a      	str	r2, [r7, #32]
  402218:	2b00      	cmp	r3, #0
  40221a:	dcf0      	bgt.n	4021fe <handle_command+0x9a>
		}

		/* Clear pio interrupt */
		pio_clear(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  40221c:	2108      	movs	r1, #8
  40221e:	487d      	ldr	r0, [pc, #500]	; (402414 <handle_command+0x2b0>)
  402220:	4b7d      	ldr	r3, [pc, #500]	; (402418 <handle_command+0x2b4>)
  402222:	4798      	blx	r3

		/* Re-init the device */
		rc = icm20648_sensor_setup();
  402224:	4b7d      	ldr	r3, [pc, #500]	; (40241c <handle_command+0x2b8>)
  402226:	4798      	blx	r3
  402228:	6278      	str	r0, [r7, #36]	; 0x24
		rc += load_dmp3();
  40222a:	4b7d      	ldr	r3, [pc, #500]	; (402420 <handle_command+0x2bc>)
  40222c:	4798      	blx	r3
  40222e:	4602      	mov	r2, r0
  402230:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402232:	4413      	add	r3, r2
  402234:	627b      	str	r3, [r7, #36]	; 0x24

		/* .. no sensors are reporting on setup */
		enabled_sensor_mask = 0;
  402236:	4b7b      	ldr	r3, [pc, #492]	; (402424 <handle_command+0x2c0>)
  402238:	2200      	movs	r2, #0
  40223a:	601a      	str	r2, [r3, #0]
		return rc;
  40223c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40223e:	e181      	b.n	402544 <handle_command+0x3e0>
	}

	case DYN_PROTOCOL_EID_WHO_AM_I:
		rc = inv_icm20648_get_whoami(&icm_device, &whoami);
  402240:	f107 0313 	add.w	r3, r7, #19
  402244:	4619      	mov	r1, r3
  402246:	4871      	ldr	r0, [pc, #452]	; (40240c <handle_command+0x2a8>)
  402248:	4b77      	ldr	r3, [pc, #476]	; (402428 <handle_command+0x2c4>)
  40224a:	4798      	blx	r3
  40224c:	6278      	str	r0, [r7, #36]	; 0x24
		return (rc == 0) ? whoami : rc;
  40224e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402250:	2b00      	cmp	r3, #0
  402252:	d101      	bne.n	402258 <handle_command+0xf4>
  402254:	7cfb      	ldrb	r3, [r7, #19]
  402256:	e175      	b.n	402544 <handle_command+0x3e0>
  402258:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40225a:	e173      	b.n	402544 <handle_command+0x3e0>

	case DYN_PROTOCOL_EID_RESET:
	{
		int i_sensor = INV_SENSOR_TYPE_MAX;
  40225c:	2344      	movs	r3, #68	; 0x44
  40225e:	61fb      	str	r3, [r7, #28]
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command reset");
  402260:	4972      	ldr	r1, [pc, #456]	; (40242c <handle_command+0x2c8>)
  402262:	2005      	movs	r0, #5
  402264:	4b67      	ldr	r3, [pc, #412]	; (402404 <handle_command+0x2a0>)
  402266:	4798      	blx	r3

		/* Disable all sensors */
		while(i_sensor-- > 0) {
  402268:	e009      	b.n	40227e <handle_command+0x11a>
			rc = inv_icm20648_enable_sensor(&icm_device, idd_sensortype_conversion(i_sensor), 0);
  40226a:	69f8      	ldr	r0, [r7, #28]
  40226c:	4b66      	ldr	r3, [pc, #408]	; (402408 <handle_command+0x2a4>)
  40226e:	4798      	blx	r3
  402270:	4603      	mov	r3, r0
  402272:	2200      	movs	r2, #0
  402274:	4619      	mov	r1, r3
  402276:	4865      	ldr	r0, [pc, #404]	; (40240c <handle_command+0x2a8>)
  402278:	4b65      	ldr	r3, [pc, #404]	; (402410 <handle_command+0x2ac>)
  40227a:	4798      	blx	r3
  40227c:	6278      	str	r0, [r7, #36]	; 0x24
		while(i_sensor-- > 0) {
  40227e:	69fb      	ldr	r3, [r7, #28]
  402280:	1e5a      	subs	r2, r3, #1
  402282:	61fa      	str	r2, [r7, #28]
  402284:	2b00      	cmp	r3, #0
  402286:	dcf0      	bgt.n	40226a <handle_command+0x106>
		}

		/* Clear pio interrupt */
		pio_clear(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  402288:	2108      	movs	r1, #8
  40228a:	4862      	ldr	r0, [pc, #392]	; (402414 <handle_command+0x2b0>)
  40228c:	4b62      	ldr	r3, [pc, #392]	; (402418 <handle_command+0x2b4>)
  40228e:	4798      	blx	r3

		/* Soft reset */
		rc += inv_icm20648_soft_reset(&icm_device);
  402290:	485e      	ldr	r0, [pc, #376]	; (40240c <handle_command+0x2a8>)
  402292:	4b67      	ldr	r3, [pc, #412]	; (402430 <handle_command+0x2cc>)
  402294:	4798      	blx	r3
  402296:	4602      	mov	r2, r0
  402298:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40229a:	4413      	add	r3, r2
  40229c:	627b      	str	r3, [r7, #36]	; 0x24

		/* --- Setup --- */
		/* Re-init the device */
		rc += icm20648_sensor_setup();
  40229e:	4b5f      	ldr	r3, [pc, #380]	; (40241c <handle_command+0x2b8>)
  4022a0:	4798      	blx	r3
  4022a2:	4602      	mov	r2, r0
  4022a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4022a6:	4413      	add	r3, r2
  4022a8:	627b      	str	r3, [r7, #36]	; 0x24
		rc += load_dmp3();
  4022aa:	4b5d      	ldr	r3, [pc, #372]	; (402420 <handle_command+0x2bc>)
  4022ac:	4798      	blx	r3
  4022ae:	4602      	mov	r2, r0
  4022b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4022b2:	4413      	add	r3, r2
  4022b4:	627b      	str	r3, [r7, #36]	; 0x24

		/* All sensors stop reporting on reset */
		enabled_sensor_mask = 0;
  4022b6:	4b5b      	ldr	r3, [pc, #364]	; (402424 <handle_command+0x2c0>)
  4022b8:	2200      	movs	r2, #0
  4022ba:	601a      	str	r2, [r3, #0]
		return rc;
  4022bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4022be:	e141      	b.n	402544 <handle_command+0x3e0>
	}

	case DYN_PROTOCOL_EID_PING_SENSOR:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command ping(%s)", inv_sensor_2str(sensor));
  4022c0:	6978      	ldr	r0, [r7, #20]
  4022c2:	4b5c      	ldr	r3, [pc, #368]	; (402434 <handle_command+0x2d0>)
  4022c4:	4798      	blx	r3
  4022c6:	4603      	mov	r3, r0
  4022c8:	461a      	mov	r2, r3
  4022ca:	495b      	ldr	r1, [pc, #364]	; (402438 <handle_command+0x2d4>)
  4022cc:	2005      	movs	r0, #5
  4022ce:	4b4d      	ldr	r3, [pc, #308]	; (402404 <handle_command+0x2a0>)
  4022d0:	4798      	blx	r3
		if((sensor == INV_SENSOR_TYPE_RAW_ACCELEROMETER)
  4022d2:	697b      	ldr	r3, [r7, #20]
  4022d4:	2b20      	cmp	r3, #32
  4022d6:	d029      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_RAW_GYROSCOPE)
  4022d8:	697b      	ldr	r3, [r7, #20]
  4022da:	2b21      	cmp	r3, #33	; 0x21
  4022dc:	d026      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_ACCELEROMETER)
  4022de:	697b      	ldr	r3, [r7, #20]
  4022e0:	2b01      	cmp	r3, #1
  4022e2:	d023      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_GYROSCOPE)
  4022e4:	697b      	ldr	r3, [r7, #20]
  4022e6:	2b04      	cmp	r3, #4
  4022e8:	d020      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_UNCAL_GYROSCOPE)
  4022ea:	697b      	ldr	r3, [r7, #20]
  4022ec:	2b10      	cmp	r3, #16
  4022ee:	d01d      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_GAME_ROTATION_VECTOR)
  4022f0:	697b      	ldr	r3, [r7, #20]
  4022f2:	2b0f      	cmp	r3, #15
  4022f4:	d01a      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_GRAVITY)
  4022f6:	697b      	ldr	r3, [r7, #20]
  4022f8:	2b09      	cmp	r3, #9
  4022fa:	d017      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_LINEAR_ACCELERATION)
  4022fc:	697b      	ldr	r3, [r7, #20]
  4022fe:	2b0a      	cmp	r3, #10
  402300:	d014      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_STEP_COUNTER)
  402302:	697b      	ldr	r3, [r7, #20]
  402304:	2b13      	cmp	r3, #19
  402306:	d011      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_BAC)
  402308:	697b      	ldr	r3, [r7, #20]
  40230a:	2b1a      	cmp	r3, #26
  40230c:	d00e      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_B2S)
  40230e:	697b      	ldr	r3, [r7, #20]
  402310:	2b1c      	cmp	r3, #28
  402312:	d00b      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_SMD)
  402314:	697b      	ldr	r3, [r7, #20]
  402316:	2b11      	cmp	r3, #17
  402318:	d008      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_STEP_DETECTOR)
  40231a:	697b      	ldr	r3, [r7, #20]
  40231c:	2b12      	cmp	r3, #18
  40231e:	d005      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_TILT_DETECTOR)
  402320:	697b      	ldr	r3, [r7, #20]
  402322:	2b16      	cmp	r3, #22
  402324:	d002      	beq.n	40232c <handle_command+0x1c8>
			|| (sensor == INV_SENSOR_TYPE_PICK_UP_GESTURE)
  402326:	697b      	ldr	r3, [r7, #20]
  402328:	2b19      	cmp	r3, #25
  40232a:	d101      	bne.n	402330 <handle_command+0x1cc>
			) {
				return 0;
  40232c:	2300      	movs	r3, #0
  40232e:	e109      	b.n	402544 <handle_command+0x3e0>
		} else if(((sensor == INV_SENSOR_TYPE_MAGNETOMETER)
  402330:	697b      	ldr	r3, [r7, #20]
  402332:	2b02      	cmp	r3, #2
  402334:	d008      	beq.n	402348 <handle_command+0x1e4>
			|| (sensor == INV_SENSOR_TYPE_UNCAL_MAGNETOMETER)
  402336:	697b      	ldr	r3, [r7, #20]
  402338:	2b0e      	cmp	r3, #14
  40233a:	d005      	beq.n	402348 <handle_command+0x1e4>
			|| (sensor == INV_SENSOR_TYPE_ROTATION_VECTOR)
  40233c:	697b      	ldr	r3, [r7, #20]
  40233e:	2b0b      	cmp	r3, #11
  402340:	d002      	beq.n	402348 <handle_command+0x1e4>
			|| (sensor == INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR))
  402342:	697b      	ldr	r3, [r7, #20]
  402344:	2b14      	cmp	r3, #20
  402346:	d105      	bne.n	402354 <handle_command+0x1f0>
			&& ak09912_is_available) {
  402348:	4b3c      	ldr	r3, [pc, #240]	; (40243c <handle_command+0x2d8>)
  40234a:	681b      	ldr	r3, [r3, #0]
  40234c:	2b00      	cmp	r3, #0
  40234e:	d001      	beq.n	402354 <handle_command+0x1f0>
				return 0;
  402350:	2300      	movs	r3, #0
  402352:	e0f7      	b.n	402544 <handle_command+0x3e0>
		} else
			return INV_ERROR_BAD_ARG;
  402354:	f06f 030a 	mvn.w	r3, #10
  402358:	e0f4      	b.n	402544 <handle_command+0x3e0>

	case DYN_PROTOCOL_EID_SELF_TEST:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command self_test(%s)", inv_sensor_2str(sensor));
  40235a:	6978      	ldr	r0, [r7, #20]
  40235c:	4b35      	ldr	r3, [pc, #212]	; (402434 <handle_command+0x2d0>)
  40235e:	4798      	blx	r3
  402360:	4603      	mov	r3, r0
  402362:	461a      	mov	r2, r3
  402364:	4936      	ldr	r1, [pc, #216]	; (402440 <handle_command+0x2dc>)
  402366:	2005      	movs	r0, #5
  402368:	4b26      	ldr	r3, [pc, #152]	; (402404 <handle_command+0x2a0>)
  40236a:	4798      	blx	r3
		if(	(sensor == INV_SENSOR_TYPE_RAW_ACCELEROMETER || sensor == INV_SENSOR_TYPE_ACCELEROMETER) ||
  40236c:	697b      	ldr	r3, [r7, #20]
  40236e:	2b20      	cmp	r3, #32
  402370:	d00f      	beq.n	402392 <handle_command+0x22e>
  402372:	697b      	ldr	r3, [r7, #20]
  402374:	2b01      	cmp	r3, #1
  402376:	d00c      	beq.n	402392 <handle_command+0x22e>
  402378:	697b      	ldr	r3, [r7, #20]
  40237a:	2b21      	cmp	r3, #33	; 0x21
  40237c:	d009      	beq.n	402392 <handle_command+0x22e>
			(sensor == INV_SENSOR_TYPE_RAW_GYROSCOPE || sensor == INV_SENSOR_TYPE_GYROSCOPE) ||
  40237e:	697b      	ldr	r3, [r7, #20]
  402380:	2b04      	cmp	r3, #4
  402382:	d006      	beq.n	402392 <handle_command+0x22e>
  402384:	697b      	ldr	r3, [r7, #20]
  402386:	2b02      	cmp	r3, #2
  402388:	d107      	bne.n	40239a <handle_command+0x236>
			(sensor == INV_SENSOR_TYPE_MAGNETOMETER && ak09912_is_available) ) {
  40238a:	4b2c      	ldr	r3, [pc, #176]	; (40243c <handle_command+0x2d8>)
  40238c:	681b      	ldr	r3, [r3, #0]
  40238e:	2b00      	cmp	r3, #0
  402390:	d003      	beq.n	40239a <handle_command+0x236>
				return icm20648_run_selftest();
  402392:	4b2c      	ldr	r3, [pc, #176]	; (402444 <handle_command+0x2e0>)
  402394:	4798      	blx	r3
  402396:	4603      	mov	r3, r0
  402398:	e0d4      	b.n	402544 <handle_command+0x3e0>
		}
		else
			return INV_ERROR_BAD_ARG;
  40239a:	f06f 030a 	mvn.w	r3, #10
  40239e:	e0d1      	b.n	402544 <handle_command+0x3e0>
		break;

	case DYN_PROTOCOL_EID_START_SENSOR:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command start(%s)", inv_sensor_2str(sensor));
  4023a0:	6978      	ldr	r0, [r7, #20]
  4023a2:	4b24      	ldr	r3, [pc, #144]	; (402434 <handle_command+0x2d0>)
  4023a4:	4798      	blx	r3
  4023a6:	4603      	mov	r3, r0
  4023a8:	461a      	mov	r2, r3
  4023aa:	4927      	ldr	r1, [pc, #156]	; (402448 <handle_command+0x2e4>)
  4023ac:	2005      	movs	r0, #5
  4023ae:	4b15      	ldr	r3, [pc, #84]	; (402404 <handle_command+0x2a0>)
  4023b0:	4798      	blx	r3
		if (sensor > 0 && idd_sensortype_conversion(sensor) < INV_ICM20648_SENSOR_MAX) {
  4023b2:	697b      	ldr	r3, [r7, #20]
  4023b4:	2b00      	cmp	r3, #0
  4023b6:	dd1e      	ble.n	4023f6 <handle_command+0x292>
  4023b8:	6978      	ldr	r0, [r7, #20]
  4023ba:	4b13      	ldr	r3, [pc, #76]	; (402408 <handle_command+0x2a4>)
  4023bc:	4798      	blx	r3
  4023be:	4603      	mov	r3, r0
  4023c0:	2b13      	cmp	r3, #19
  4023c2:	d818      	bhi.n	4023f6 <handle_command+0x292>
			/* Sensor data will be notified */
			rc = inv_icm20648_enable_sensor(&icm_device, idd_sensortype_conversion(sensor), 1);
  4023c4:	6978      	ldr	r0, [r7, #20]
  4023c6:	4b10      	ldr	r3, [pc, #64]	; (402408 <handle_command+0x2a4>)
  4023c8:	4798      	blx	r3
  4023ca:	4603      	mov	r3, r0
  4023cc:	2201      	movs	r2, #1
  4023ce:	4619      	mov	r1, r3
  4023d0:	480e      	ldr	r0, [pc, #56]	; (40240c <handle_command+0x2a8>)
  4023d2:	4b0f      	ldr	r3, [pc, #60]	; (402410 <handle_command+0x2ac>)
  4023d4:	4798      	blx	r3
  4023d6:	6278      	str	r0, [r7, #36]	; 0x24
			enabled_sensor_mask |= (1 << idd_sensortype_conversion(sensor));
  4023d8:	6978      	ldr	r0, [r7, #20]
  4023da:	4b0b      	ldr	r3, [pc, #44]	; (402408 <handle_command+0x2a4>)
  4023dc:	4798      	blx	r3
  4023de:	4603      	mov	r3, r0
  4023e0:	461a      	mov	r2, r3
  4023e2:	2301      	movs	r3, #1
  4023e4:	4093      	lsls	r3, r2
  4023e6:	461a      	mov	r2, r3
  4023e8:	4b0e      	ldr	r3, [pc, #56]	; (402424 <handle_command+0x2c0>)
  4023ea:	681b      	ldr	r3, [r3, #0]
  4023ec:	4313      	orrs	r3, r2
  4023ee:	4a0d      	ldr	r2, [pc, #52]	; (402424 <handle_command+0x2c0>)
  4023f0:	6013      	str	r3, [r2, #0]
			return rc;
  4023f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4023f4:	e0a6      	b.n	402544 <handle_command+0x3e0>
		} else
			return INV_ERROR_NIMPL; /*this sensor is not supported*/
  4023f6:	f06f 0301 	mvn.w	r3, #1
  4023fa:	e0a3      	b.n	402544 <handle_command+0x3e0>
  4023fc:	004014f1 	.word	0x004014f1
  402400:	0041bc3c 	.word	0x0041bc3c
  402404:	0040ff51 	.word	0x0040ff51
  402408:	00402069 	.word	0x00402069
  40240c:	20001998 	.word	0x20001998
  402410:	0040aeb5 	.word	0x0040aeb5
  402414:	400e1000 	.word	0x400e1000
  402418:	004001e1 	.word	0x004001e1
  40241c:	00401769 	.word	0x00401769
  402420:	00401681 	.word	0x00401681
  402424:	20000ee4 	.word	0x20000ee4
  402428:	0040aa09 	.word	0x0040aa09
  40242c:	0041bc68 	.word	0x0041bc68
  402430:	0040ae85 	.word	0x0040ae85
  402434:	0040cf9d 	.word	0x0040cf9d
  402438:	0041bc94 	.word	0x0041bc94
  40243c:	20000ee8 	.word	0x20000ee8
  402440:	0041bcc0 	.word	0x0041bcc0
  402444:	00402711 	.word	0x00402711
  402448:	0041bcf4 	.word	0x0041bcf4

	case DYN_PROTOCOL_EID_STOP_SENSOR:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command stop(%s)", inv_sensor_2str(sensor));
  40244c:	6978      	ldr	r0, [r7, #20]
  40244e:	4b3f      	ldr	r3, [pc, #252]	; (40254c <handle_command+0x3e8>)
  402450:	4798      	blx	r3
  402452:	4603      	mov	r3, r0
  402454:	461a      	mov	r2, r3
  402456:	493e      	ldr	r1, [pc, #248]	; (402550 <handle_command+0x3ec>)
  402458:	2005      	movs	r0, #5
  40245a:	4b3e      	ldr	r3, [pc, #248]	; (402554 <handle_command+0x3f0>)
  40245c:	4798      	blx	r3
		if (sensor > 0 && idd_sensortype_conversion(sensor) < INV_ICM20648_SENSOR_MAX) {
  40245e:	697b      	ldr	r3, [r7, #20]
  402460:	2b00      	cmp	r3, #0
  402462:	dd1f      	ble.n	4024a4 <handle_command+0x340>
  402464:	6978      	ldr	r0, [r7, #20]
  402466:	4b3c      	ldr	r3, [pc, #240]	; (402558 <handle_command+0x3f4>)
  402468:	4798      	blx	r3
  40246a:	4603      	mov	r3, r0
  40246c:	2b13      	cmp	r3, #19
  40246e:	d819      	bhi.n	4024a4 <handle_command+0x340>
			/* Sensor data will not be notified anymore */
			rc = inv_icm20648_enable_sensor(&icm_device, idd_sensortype_conversion(sensor), 0);
  402470:	6978      	ldr	r0, [r7, #20]
  402472:	4b39      	ldr	r3, [pc, #228]	; (402558 <handle_command+0x3f4>)
  402474:	4798      	blx	r3
  402476:	4603      	mov	r3, r0
  402478:	2200      	movs	r2, #0
  40247a:	4619      	mov	r1, r3
  40247c:	4837      	ldr	r0, [pc, #220]	; (40255c <handle_command+0x3f8>)
  40247e:	4b38      	ldr	r3, [pc, #224]	; (402560 <handle_command+0x3fc>)
  402480:	4798      	blx	r3
  402482:	6278      	str	r0, [r7, #36]	; 0x24
			enabled_sensor_mask &= ~(1 << idd_sensortype_conversion(sensor));
  402484:	6978      	ldr	r0, [r7, #20]
  402486:	4b34      	ldr	r3, [pc, #208]	; (402558 <handle_command+0x3f4>)
  402488:	4798      	blx	r3
  40248a:	4603      	mov	r3, r0
  40248c:	461a      	mov	r2, r3
  40248e:	2301      	movs	r3, #1
  402490:	4093      	lsls	r3, r2
  402492:	43db      	mvns	r3, r3
  402494:	461a      	mov	r2, r3
  402496:	4b33      	ldr	r3, [pc, #204]	; (402564 <handle_command+0x400>)
  402498:	681b      	ldr	r3, [r3, #0]
  40249a:	4013      	ands	r3, r2
  40249c:	4a31      	ldr	r2, [pc, #196]	; (402564 <handle_command+0x400>)
  40249e:	6013      	str	r3, [r2, #0]
			return rc;
  4024a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4024a2:	e04f      	b.n	402544 <handle_command+0x3e0>
		} else
			return INV_ERROR_NIMPL; /*this sensor is not supported*/
  4024a4:	f06f 0301 	mvn.w	r3, #1
  4024a8:	e04c      	b.n	402544 <handle_command+0x3e0>

	case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command set_period(%d us)",edata->d.command.period);
  4024aa:	68bb      	ldr	r3, [r7, #8]
  4024ac:	685b      	ldr	r3, [r3, #4]
  4024ae:	461a      	mov	r2, r3
  4024b0:	492d      	ldr	r1, [pc, #180]	; (402568 <handle_command+0x404>)
  4024b2:	2005      	movs	r0, #5
  4024b4:	4b27      	ldr	r3, [pc, #156]	; (402554 <handle_command+0x3f0>)
  4024b6:	4798      	blx	r3
		rc = inv_icm20648_set_sensor_period(&icm_device, idd_sensortype_conversion(sensor), edata->d.command.period / 1000);
  4024b8:	6978      	ldr	r0, [r7, #20]
  4024ba:	4b27      	ldr	r3, [pc, #156]	; (402558 <handle_command+0x3f4>)
  4024bc:	4798      	blx	r3
  4024be:	4603      	mov	r3, r0
  4024c0:	4619      	mov	r1, r3
  4024c2:	68bb      	ldr	r3, [r7, #8]
  4024c4:	685b      	ldr	r3, [r3, #4]
  4024c6:	4a29      	ldr	r2, [pc, #164]	; (40256c <handle_command+0x408>)
  4024c8:	fba2 2303 	umull	r2, r3, r2, r3
  4024cc:	099b      	lsrs	r3, r3, #6
  4024ce:	461a      	mov	r2, r3
  4024d0:	4822      	ldr	r0, [pc, #136]	; (40255c <handle_command+0x3f8>)
  4024d2:	4b27      	ldr	r3, [pc, #156]	; (402570 <handle_command+0x40c>)
  4024d4:	4798      	blx	r3
  4024d6:	6278      	str	r0, [r7, #36]	; 0x24
		return rc;
  4024d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4024da:	e033      	b.n	402544 <handle_command+0x3e0>

	case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command set_sensor_config(%s)", inv_sensor_2str(sensor));
  4024dc:	6978      	ldr	r0, [r7, #20]
  4024de:	4b1b      	ldr	r3, [pc, #108]	; (40254c <handle_command+0x3e8>)
  4024e0:	4798      	blx	r3
  4024e2:	4603      	mov	r3, r0
  4024e4:	461a      	mov	r2, r3
  4024e6:	4923      	ldr	r1, [pc, #140]	; (402574 <handle_command+0x410>)
  4024e8:	2005      	movs	r0, #5
  4024ea:	4b1a      	ldr	r3, [pc, #104]	; (402554 <handle_command+0x3f0>)
  4024ec:	4798      	blx	r3
		return INV_ERROR_NIMPL;
  4024ee:	f06f 0301 	mvn.w	r3, #1
  4024f2:	e027      	b.n	402544 <handle_command+0x3e0>

	case DYN_PROTOCOL_EID_CLEANUP:
	{
		int i_sensor = INV_SENSOR_TYPE_MAX;
  4024f4:	2344      	movs	r3, #68	; 0x44
  4024f6:	61bb      	str	r3, [r7, #24]
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command cleanup");
  4024f8:	491f      	ldr	r1, [pc, #124]	; (402578 <handle_command+0x414>)
  4024fa:	2005      	movs	r0, #5
  4024fc:	4b15      	ldr	r3, [pc, #84]	; (402554 <handle_command+0x3f0>)
  4024fe:	4798      	blx	r3

		/* Disable all sensors on cleanup */
		while(i_sensor-- > 0) {
  402500:	e009      	b.n	402516 <handle_command+0x3b2>
			rc = inv_icm20648_enable_sensor(&icm_device, idd_sensortype_conversion(i_sensor), 0);
  402502:	69b8      	ldr	r0, [r7, #24]
  402504:	4b14      	ldr	r3, [pc, #80]	; (402558 <handle_command+0x3f4>)
  402506:	4798      	blx	r3
  402508:	4603      	mov	r3, r0
  40250a:	2200      	movs	r2, #0
  40250c:	4619      	mov	r1, r3
  40250e:	4813      	ldr	r0, [pc, #76]	; (40255c <handle_command+0x3f8>)
  402510:	4b13      	ldr	r3, [pc, #76]	; (402560 <handle_command+0x3fc>)
  402512:	4798      	blx	r3
  402514:	6278      	str	r0, [r7, #36]	; 0x24
		while(i_sensor-- > 0) {
  402516:	69bb      	ldr	r3, [r7, #24]
  402518:	1e5a      	subs	r2, r3, #1
  40251a:	61ba      	str	r2, [r7, #24]
  40251c:	2b00      	cmp	r3, #0
  40251e:	dcf0      	bgt.n	402502 <handle_command+0x39e>
		}

		/* Clear pio interrupt */
		pio_clear(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  402520:	2108      	movs	r1, #8
  402522:	4816      	ldr	r0, [pc, #88]	; (40257c <handle_command+0x418>)
  402524:	4b16      	ldr	r3, [pc, #88]	; (402580 <handle_command+0x41c>)
  402526:	4798      	blx	r3

		/* Soft reset */
		rc += inv_icm20648_soft_reset(&icm_device);
  402528:	480c      	ldr	r0, [pc, #48]	; (40255c <handle_command+0x3f8>)
  40252a:	4b16      	ldr	r3, [pc, #88]	; (402584 <handle_command+0x420>)
  40252c:	4798      	blx	r3
  40252e:	4602      	mov	r2, r0
  402530:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402532:	4413      	add	r3, r2
  402534:	627b      	str	r3, [r7, #36]	; 0x24

		/* All sensors stop reporting on cleanup */
		enabled_sensor_mask = 0;
  402536:	4b0b      	ldr	r3, [pc, #44]	; (402564 <handle_command+0x400>)
  402538:	2200      	movs	r2, #0
  40253a:	601a      	str	r2, [r3, #0]
		return rc;
  40253c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40253e:	e001      	b.n	402544 <handle_command+0x3e0>
	}

	default:
		return INV_ERROR_NIMPL;
  402540:	f06f 0301 	mvn.w	r3, #1
	}
}
  402544:	4618      	mov	r0, r3
  402546:	3728      	adds	r7, #40	; 0x28
  402548:	46bd      	mov	sp, r7
  40254a:	bd80      	pop	{r7, pc}
  40254c:	0040cf9d 	.word	0x0040cf9d
  402550:	0041bd24 	.word	0x0041bd24
  402554:	0040ff51 	.word	0x0040ff51
  402558:	00402069 	.word	0x00402069
  40255c:	20001998 	.word	0x20001998
  402560:	0040aeb5 	.word	0x0040aeb5
  402564:	20000ee4 	.word	0x20000ee4
  402568:	0041bd50 	.word	0x0041bd50
  40256c:	10624dd3 	.word	0x10624dd3
  402570:	0040af19 	.word	0x0040af19
  402574:	0041bd88 	.word	0x0041bd88
  402578:	0041bdc4 	.word	0x0041bdc4
  40257c:	400e1000 	.word	0x400e1000
  402580:	004001e1 	.word	0x004001e1
  402584:	0040ae85 	.word	0x0040ae85

00402588 <inv_icm20648_get_st_bias>:

void inv_icm20648_get_st_bias(struct inv_icm20648 * s, int *gyro_bias, int *accel_bias, int * st_bias){
  402588:	b480      	push	{r7}
  40258a:	b08d      	sub	sp, #52	; 0x34
  40258c:	af00      	add	r7, sp, #0
  40258e:	60f8      	str	r0, [r7, #12]
  402590:	60b9      	str	r1, [r7, #8]
  402592:	607a      	str	r2, [r7, #4]
  402594:	603b      	str	r3, [r7, #0]
	int i, t;
	int check;
	int scale;

	/* check bias there ? */
	check = 0;
  402596:	2300      	movs	r3, #0
  402598:	623b      	str	r3, [r7, #32]
	for (i = 0; i < 3; i++) {
  40259a:	2300      	movs	r3, #0
  40259c:	627b      	str	r3, [r7, #36]	; 0x24
  40259e:	e014      	b.n	4025ca <inv_icm20648_get_st_bias+0x42>
		if (gyro_bias[i] != 0)
  4025a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025a2:	009b      	lsls	r3, r3, #2
  4025a4:	68ba      	ldr	r2, [r7, #8]
  4025a6:	4413      	add	r3, r2
  4025a8:	681b      	ldr	r3, [r3, #0]
  4025aa:	2b00      	cmp	r3, #0
  4025ac:	d001      	beq.n	4025b2 <inv_icm20648_get_st_bias+0x2a>
			check = 1;
  4025ae:	2301      	movs	r3, #1
  4025b0:	623b      	str	r3, [r7, #32]
		if (accel_bias[i] != 0)
  4025b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025b4:	009b      	lsls	r3, r3, #2
  4025b6:	687a      	ldr	r2, [r7, #4]
  4025b8:	4413      	add	r3, r2
  4025ba:	681b      	ldr	r3, [r3, #0]
  4025bc:	2b00      	cmp	r3, #0
  4025be:	d001      	beq.n	4025c4 <inv_icm20648_get_st_bias+0x3c>
			check = 1;
  4025c0:	2301      	movs	r3, #1
  4025c2:	623b      	str	r3, [r7, #32]
	for (i = 0; i < 3; i++) {
  4025c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025c6:	3301      	adds	r3, #1
  4025c8:	627b      	str	r3, [r7, #36]	; 0x24
  4025ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025cc:	2b02      	cmp	r3, #2
  4025ce:	dde7      	ble.n	4025a0 <inv_icm20648_get_st_bias+0x18>
	}

	/* if no bias, return all 0 */
	if (check == 0) {
  4025d0:	6a3b      	ldr	r3, [r7, #32]
  4025d2:	2b00      	cmp	r3, #0
  4025d4:	d10f      	bne.n	4025f6 <inv_icm20648_get_st_bias+0x6e>
		for (i = 0; i < 12; i++)
  4025d6:	2300      	movs	r3, #0
  4025d8:	627b      	str	r3, [r7, #36]	; 0x24
  4025da:	e008      	b.n	4025ee <inv_icm20648_get_st_bias+0x66>
			st_bias[i] = 0;
  4025dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025de:	009b      	lsls	r3, r3, #2
  4025e0:	683a      	ldr	r2, [r7, #0]
  4025e2:	4413      	add	r3, r2
  4025e4:	2200      	movs	r2, #0
  4025e6:	601a      	str	r2, [r3, #0]
		for (i = 0; i < 12; i++)
  4025e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025ea:	3301      	adds	r3, #1
  4025ec:	627b      	str	r3, [r7, #36]	; 0x24
  4025ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025f0:	2b0b      	cmp	r3, #11
  4025f2:	ddf3      	ble.n	4025dc <inv_icm20648_get_st_bias+0x54>
		return;
  4025f4:	e086      	b.n	402704 <inv_icm20648_get_st_bias+0x17c>
	}

	/* dps scaled by 2^16 */
	scale = 65536 / DEF_SELFTEST_GYRO_SENS;
  4025f6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  4025fa:	61fb      	str	r3, [r7, #28]

	/* Gyro normal mode */
	t = 0;
  4025fc:	2300      	movs	r3, #0
  4025fe:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < 3; i++)
  402600:	2300      	movs	r3, #0
  402602:	627b      	str	r3, [r7, #36]	; 0x24
  402604:	e011      	b.n	40262a <inv_icm20648_get_st_bias+0xa2>
		st_bias[i + t] = gyro_bias[i] * scale;
  402606:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402608:	69bb      	ldr	r3, [r7, #24]
  40260a:	4413      	add	r3, r2
  40260c:	009b      	lsls	r3, r3, #2
  40260e:	683a      	ldr	r2, [r7, #0]
  402610:	4413      	add	r3, r2
  402612:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402614:	0092      	lsls	r2, r2, #2
  402616:	68b9      	ldr	r1, [r7, #8]
  402618:	440a      	add	r2, r1
  40261a:	6812      	ldr	r2, [r2, #0]
  40261c:	69f9      	ldr	r1, [r7, #28]
  40261e:	fb01 f202 	mul.w	r2, r1, r2
  402622:	601a      	str	r2, [r3, #0]
	for (i = 0; i < 3; i++)
  402624:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402626:	3301      	adds	r3, #1
  402628:	627b      	str	r3, [r7, #36]	; 0x24
  40262a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40262c:	2b02      	cmp	r3, #2
  40262e:	ddea      	ble.n	402606 <inv_icm20648_get_st_bias+0x7e>

	axis = 0;
  402630:	2300      	movs	r3, #0
  402632:	62fb      	str	r3, [r7, #44]	; 0x2c
	axis_sign = 1;
  402634:	2301      	movs	r3, #1
  402636:	62bb      	str	r3, [r7, #40]	; 0x28
	if (INV20648_ABS(accel_bias[1]) > INV20648_ABS(accel_bias[0]))
  402638:	687b      	ldr	r3, [r7, #4]
  40263a:	3304      	adds	r3, #4
  40263c:	681b      	ldr	r3, [r3, #0]
  40263e:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
  402642:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
  402646:	687b      	ldr	r3, [r7, #4]
  402648:	681b      	ldr	r3, [r3, #0]
  40264a:	2b00      	cmp	r3, #0
  40264c:	bfb8      	it	lt
  40264e:	425b      	neglt	r3, r3
  402650:	429a      	cmp	r2, r3
  402652:	dd01      	ble.n	402658 <inv_icm20648_get_st_bias+0xd0>
		axis = 1;
  402654:	2301      	movs	r3, #1
  402656:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (INV20648_ABS(accel_bias[2]) > INV20648_ABS(accel_bias[axis]))
  402658:	687b      	ldr	r3, [r7, #4]
  40265a:	3308      	adds	r3, #8
  40265c:	681b      	ldr	r3, [r3, #0]
  40265e:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
  402662:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
  402666:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402668:	009b      	lsls	r3, r3, #2
  40266a:	6879      	ldr	r1, [r7, #4]
  40266c:	440b      	add	r3, r1
  40266e:	681b      	ldr	r3, [r3, #0]
  402670:	2b00      	cmp	r3, #0
  402672:	bfb8      	it	lt
  402674:	425b      	neglt	r3, r3
  402676:	429a      	cmp	r2, r3
  402678:	dd01      	ble.n	40267e <inv_icm20648_get_st_bias+0xf6>
		axis = 2;
  40267a:	2302      	movs	r3, #2
  40267c:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (accel_bias[axis] < 0)
  40267e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402680:	009b      	lsls	r3, r3, #2
  402682:	687a      	ldr	r2, [r7, #4]
  402684:	4413      	add	r3, r2
  402686:	681b      	ldr	r3, [r3, #0]
  402688:	2b00      	cmp	r3, #0
  40268a:	da02      	bge.n	402692 <inv_icm20648_get_st_bias+0x10a>
		axis_sign = -1;
  40268c:	f04f 33ff 	mov.w	r3, #4294967295
  402690:	62bb      	str	r3, [r7, #40]	; 0x28

	/* gee scaled by 2^16 */
	scale = 65536 / (DEF_ST_SCALE / (DEF_ST_ACCEL_FS_MG / 1000));
  402692:	2304      	movs	r3, #4
  402694:	61fb      	str	r3, [r7, #28]

	gravity = 32768 / (DEF_ST_ACCEL_FS_MG / 1000) * axis_sign;
  402696:	6abb      	ldr	r3, [r7, #40]	; 0x28
  402698:	039b      	lsls	r3, r3, #14
  40269a:	617b      	str	r3, [r7, #20]
	gravity *= scale;
  40269c:	697b      	ldr	r3, [r7, #20]
  40269e:	69fa      	ldr	r2, [r7, #28]
  4026a0:	fb02 f303 	mul.w	r3, r2, r3
  4026a4:	617b      	str	r3, [r7, #20]

	/* Accel normal mode */
	t += 3;
  4026a6:	69bb      	ldr	r3, [r7, #24]
  4026a8:	3303      	adds	r3, #3
  4026aa:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < 3; i++) {
  4026ac:	2300      	movs	r3, #0
  4026ae:	627b      	str	r3, [r7, #36]	; 0x24
  4026b0:	e025      	b.n	4026fe <inv_icm20648_get_st_bias+0x176>
		st_bias[i + t] = accel_bias[i] * scale;
  4026b2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4026b4:	69bb      	ldr	r3, [r7, #24]
  4026b6:	4413      	add	r3, r2
  4026b8:	009b      	lsls	r3, r3, #2
  4026ba:	683a      	ldr	r2, [r7, #0]
  4026bc:	4413      	add	r3, r2
  4026be:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4026c0:	0092      	lsls	r2, r2, #2
  4026c2:	6879      	ldr	r1, [r7, #4]
  4026c4:	440a      	add	r2, r1
  4026c6:	6812      	ldr	r2, [r2, #0]
  4026c8:	69f9      	ldr	r1, [r7, #28]
  4026ca:	fb01 f202 	mul.w	r2, r1, r2
  4026ce:	601a      	str	r2, [r3, #0]
		if (axis == i)
  4026d0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  4026d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4026d4:	429a      	cmp	r2, r3
  4026d6:	d10f      	bne.n	4026f8 <inv_icm20648_get_st_bias+0x170>
			st_bias[i + t] -= gravity;
  4026d8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4026da:	69bb      	ldr	r3, [r7, #24]
  4026dc:	4413      	add	r3, r2
  4026de:	009b      	lsls	r3, r3, #2
  4026e0:	683a      	ldr	r2, [r7, #0]
  4026e2:	4413      	add	r3, r2
  4026e4:	6a79      	ldr	r1, [r7, #36]	; 0x24
  4026e6:	69ba      	ldr	r2, [r7, #24]
  4026e8:	440a      	add	r2, r1
  4026ea:	0092      	lsls	r2, r2, #2
  4026ec:	6839      	ldr	r1, [r7, #0]
  4026ee:	440a      	add	r2, r1
  4026f0:	6811      	ldr	r1, [r2, #0]
  4026f2:	697a      	ldr	r2, [r7, #20]
  4026f4:	1a8a      	subs	r2, r1, r2
  4026f6:	601a      	str	r2, [r3, #0]
	for (i = 0; i < 3; i++) {
  4026f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4026fa:	3301      	adds	r3, #1
  4026fc:	627b      	str	r3, [r7, #36]	; 0x24
  4026fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402700:	2b02      	cmp	r3, #2
  402702:	ddd6      	ble.n	4026b2 <inv_icm20648_get_st_bias+0x12a>
	}
}
  402704:	3734      	adds	r7, #52	; 0x34
  402706:	46bd      	mov	sp, r7
  402708:	f85d 7b04 	ldr.w	r7, [sp], #4
  40270c:	4770      	bx	lr
	...

00402710 <icm20648_run_selftest>:

int icm20648_run_selftest(void){
  402710:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
  402714:	b08a      	sub	sp, #40	; 0x28
  402716:	af04      	add	r7, sp, #16
	static int rc = 0;		// Keep this value as we're only going to do this once.
	int gyro_bias_regular[THREE_AXES];
	int accel_bias_regular[THREE_AXES];
	static int raw_bias[THREE_AXES * 2];

	if (icm_device.selftest_done == 1) {
  402718:	4b63      	ldr	r3, [pc, #396]	; (4028a8 <icm20648_run_selftest+0x198>)
  40271a:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
  40271e:	2b01      	cmp	r3, #1
  402720:	d104      	bne.n	40272c <icm20648_run_selftest+0x1c>
		INV_MSG(INV_MSG_LEVEL_INFO, "Self-test has already run. Skipping.");
  402722:	4962      	ldr	r1, [pc, #392]	; (4028ac <icm20648_run_selftest+0x19c>)
  402724:	2003      	movs	r0, #3
  402726:	4b62      	ldr	r3, [pc, #392]	; (4028b0 <icm20648_run_selftest+0x1a0>)
  402728:	4798      	blx	r3
  40272a:	e0b6      	b.n	40289a <icm20648_run_selftest+0x18a>
	else {
		/*
		* Perform self-test
		* For ICM20648 self-test is performed for both RAW_ACC/RAW_GYR
		*/
		INV_MSG(INV_MSG_LEVEL_INFO, "Running self-test...");
  40272c:	4961      	ldr	r1, [pc, #388]	; (4028b4 <icm20648_run_selftest+0x1a4>)
  40272e:	2003      	movs	r0, #3
  402730:	4b5f      	ldr	r3, [pc, #380]	; (4028b0 <icm20648_run_selftest+0x1a0>)
  402732:	4798      	blx	r3

		/* Run the self-test */
		rc = inv_icm20648_run_selftest(&icm_device, gyro_bias_regular, accel_bias_regular);
  402734:	463a      	mov	r2, r7
  402736:	f107 030c 	add.w	r3, r7, #12
  40273a:	4619      	mov	r1, r3
  40273c:	485a      	ldr	r0, [pc, #360]	; (4028a8 <icm20648_run_selftest+0x198>)
  40273e:	4b5e      	ldr	r3, [pc, #376]	; (4028b8 <icm20648_run_selftest+0x1a8>)
  402740:	4798      	blx	r3
  402742:	4602      	mov	r2, r0
  402744:	4b5d      	ldr	r3, [pc, #372]	; (4028bc <icm20648_run_selftest+0x1ac>)
  402746:	601a      	str	r2, [r3, #0]
		if (ak09912_is_available && ((rc & INV_ICM20648_SELF_TEST_OK) == INV_ICM20648_SELF_TEST_OK)) {
  402748:	4b5d      	ldr	r3, [pc, #372]	; (4028c0 <icm20648_run_selftest+0x1b0>)
  40274a:	681b      	ldr	r3, [r3, #0]
  40274c:	2b00      	cmp	r3, #0
  40274e:	d00d      	beq.n	40276c <icm20648_run_selftest+0x5c>
  402750:	4b5a      	ldr	r3, [pc, #360]	; (4028bc <icm20648_run_selftest+0x1ac>)
  402752:	681b      	ldr	r3, [r3, #0]
  402754:	f003 0307 	and.w	r3, r3, #7
  402758:	2b07      	cmp	r3, #7
  40275a:	d107      	bne.n	40276c <icm20648_run_selftest+0x5c>
			/* On A+G+M success, offset will be kept until reset */
			icm_device.selftest_done = 1;
  40275c:	4b52      	ldr	r3, [pc, #328]	; (4028a8 <icm20648_run_selftest+0x198>)
  40275e:	2201      	movs	r2, #1
  402760:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
			rc = 0;
  402764:	4b55      	ldr	r3, [pc, #340]	; (4028bc <icm20648_run_selftest+0x1ac>)
  402766:	2200      	movs	r2, #0
  402768:	601a      	str	r2, [r3, #0]
  40276a:	e019      	b.n	4027a0 <icm20648_run_selftest+0x90>
		} else if (!ak09912_is_available && ((rc & INV_ICM20648_SELF_TEST_AG_OK) == INV_ICM20648_SELF_TEST_AG_OK)) {
  40276c:	4b54      	ldr	r3, [pc, #336]	; (4028c0 <icm20648_run_selftest+0x1b0>)
  40276e:	681b      	ldr	r3, [r3, #0]
  402770:	2b00      	cmp	r3, #0
  402772:	d10d      	bne.n	402790 <icm20648_run_selftest+0x80>
  402774:	4b51      	ldr	r3, [pc, #324]	; (4028bc <icm20648_run_selftest+0x1ac>)
  402776:	681b      	ldr	r3, [r3, #0]
  402778:	f003 0303 	and.w	r3, r3, #3
  40277c:	2b03      	cmp	r3, #3
  40277e:	d107      	bne.n	402790 <icm20648_run_selftest+0x80>
			/* On A+G success, offset will be kept until reset */
			icm_device.selftest_done = 1;
  402780:	4b49      	ldr	r3, [pc, #292]	; (4028a8 <icm20648_run_selftest+0x198>)
  402782:	2201      	movs	r2, #1
  402784:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
			rc = 0;
  402788:	4b4c      	ldr	r3, [pc, #304]	; (4028bc <icm20648_run_selftest+0x1ac>)
  40278a:	2200      	movs	r2, #0
  40278c:	601a      	str	r2, [r3, #0]
  40278e:	e007      	b.n	4027a0 <icm20648_run_selftest+0x90>
		} else {
			/* On A | G | M Selftest failure, return Error */
			INV_MSG(INV_MSG_LEVEL_ERROR, "Self-test failure !");
  402790:	494c      	ldr	r1, [pc, #304]	; (4028c4 <icm20648_run_selftest+0x1b4>)
  402792:	2001      	movs	r0, #1
  402794:	4b46      	ldr	r3, [pc, #280]	; (4028b0 <icm20648_run_selftest+0x1a0>)
  402796:	4798      	blx	r3
			/* 0 would be considered OK, we want KO */
			rc = INV_ERROR;
  402798:	4b48      	ldr	r3, [pc, #288]	; (4028bc <icm20648_run_selftest+0x1ac>)
  40279a:	f04f 32ff 	mov.w	r2, #4294967295
  40279e:	601a      	str	r2, [r3, #0]
		}

		/* It's advised to re-init the icm20648 device after self-test for normal use */
		icm20648_sensor_setup();
  4027a0:	4b49      	ldr	r3, [pc, #292]	; (4028c8 <icm20648_run_selftest+0x1b8>)
  4027a2:	4798      	blx	r3
		inv_icm20648_get_st_bias(&icm_device, gyro_bias_regular, accel_bias_regular, raw_bias);
  4027a4:	463a      	mov	r2, r7
  4027a6:	f107 010c 	add.w	r1, r7, #12
  4027aa:	4b48      	ldr	r3, [pc, #288]	; (4028cc <icm20648_run_selftest+0x1bc>)
  4027ac:	483e      	ldr	r0, [pc, #248]	; (4028a8 <icm20648_run_selftest+0x198>)
  4027ae:	4c48      	ldr	r4, [pc, #288]	; (4028d0 <icm20648_run_selftest+0x1c0>)
  4027b0:	47a0      	blx	r4

		INV_MSG(INV_MSG_LEVEL_INFO, "GYR bias (FS=250dps) (dps): x=%f, y=%f, z=%f", (float)(raw_bias[0] / (float)(1 << 16)), (float)(raw_bias[1] / (float)(1 << 16)), (float)(raw_bias[2] / (float)(1 << 16)));
  4027b2:	4b46      	ldr	r3, [pc, #280]	; (4028cc <icm20648_run_selftest+0x1bc>)
  4027b4:	681b      	ldr	r3, [r3, #0]
  4027b6:	ee07 3a90 	vmov	s15, r3
  4027ba:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  4027be:	ed9f 7a45 	vldr	s14, [pc, #276]	; 4028d4 <icm20648_run_selftest+0x1c4>
  4027c2:	eec7 6a87 	vdiv.f32	s13, s15, s14
  4027c6:	4b44      	ldr	r3, [pc, #272]	; (4028d8 <icm20648_run_selftest+0x1c8>)
  4027c8:	ee16 0a90 	vmov	r0, s13
  4027cc:	4798      	blx	r3
  4027ce:	4680      	mov	r8, r0
  4027d0:	4689      	mov	r9, r1
  4027d2:	4b3e      	ldr	r3, [pc, #248]	; (4028cc <icm20648_run_selftest+0x1bc>)
  4027d4:	685b      	ldr	r3, [r3, #4]
  4027d6:	ee07 3a90 	vmov	s15, r3
  4027da:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  4027de:	ed9f 7a3d 	vldr	s14, [pc, #244]	; 4028d4 <icm20648_run_selftest+0x1c4>
  4027e2:	eec7 6a87 	vdiv.f32	s13, s15, s14
  4027e6:	4b3c      	ldr	r3, [pc, #240]	; (4028d8 <icm20648_run_selftest+0x1c8>)
  4027e8:	ee16 0a90 	vmov	r0, s13
  4027ec:	4798      	blx	r3
  4027ee:	4604      	mov	r4, r0
  4027f0:	460d      	mov	r5, r1
  4027f2:	4b36      	ldr	r3, [pc, #216]	; (4028cc <icm20648_run_selftest+0x1bc>)
  4027f4:	689b      	ldr	r3, [r3, #8]
  4027f6:	ee07 3a90 	vmov	s15, r3
  4027fa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  4027fe:	ed9f 7a35 	vldr	s14, [pc, #212]	; 4028d4 <icm20648_run_selftest+0x1c4>
  402802:	eec7 6a87 	vdiv.f32	s13, s15, s14
  402806:	4b34      	ldr	r3, [pc, #208]	; (4028d8 <icm20648_run_selftest+0x1c8>)
  402808:	ee16 0a90 	vmov	r0, s13
  40280c:	4798      	blx	r3
  40280e:	4602      	mov	r2, r0
  402810:	460b      	mov	r3, r1
  402812:	e9cd 2302 	strd	r2, r3, [sp, #8]
  402816:	e9cd 4500 	strd	r4, r5, [sp]
  40281a:	4642      	mov	r2, r8
  40281c:	464b      	mov	r3, r9
  40281e:	492f      	ldr	r1, [pc, #188]	; (4028dc <icm20648_run_selftest+0x1cc>)
  402820:	2003      	movs	r0, #3
  402822:	4c23      	ldr	r4, [pc, #140]	; (4028b0 <icm20648_run_selftest+0x1a0>)
  402824:	47a0      	blx	r4
		INV_MSG(INV_MSG_LEVEL_INFO, "ACC bias (FS=2g) (g): x=%f, y=%f, z=%f", (float)(raw_bias[0 + 3] / (float)(1 << 16)), (float)(raw_bias[1 + 3] / (float)(1 << 16)), (float)(raw_bias[2 + 3] / (float)(1 << 16)));
  402826:	4b29      	ldr	r3, [pc, #164]	; (4028cc <icm20648_run_selftest+0x1bc>)
  402828:	68db      	ldr	r3, [r3, #12]
  40282a:	ee07 3a90 	vmov	s15, r3
  40282e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  402832:	ed9f 7a28 	vldr	s14, [pc, #160]	; 4028d4 <icm20648_run_selftest+0x1c4>
  402836:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40283a:	4b27      	ldr	r3, [pc, #156]	; (4028d8 <icm20648_run_selftest+0x1c8>)
  40283c:	ee16 0a90 	vmov	r0, s13
  402840:	4798      	blx	r3
  402842:	4680      	mov	r8, r0
  402844:	4689      	mov	r9, r1
  402846:	4b21      	ldr	r3, [pc, #132]	; (4028cc <icm20648_run_selftest+0x1bc>)
  402848:	691b      	ldr	r3, [r3, #16]
  40284a:	ee07 3a90 	vmov	s15, r3
  40284e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  402852:	ed9f 7a20 	vldr	s14, [pc, #128]	; 4028d4 <icm20648_run_selftest+0x1c4>
  402856:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40285a:	4b1f      	ldr	r3, [pc, #124]	; (4028d8 <icm20648_run_selftest+0x1c8>)
  40285c:	ee16 0a90 	vmov	r0, s13
  402860:	4798      	blx	r3
  402862:	4604      	mov	r4, r0
  402864:	460d      	mov	r5, r1
  402866:	4b19      	ldr	r3, [pc, #100]	; (4028cc <icm20648_run_selftest+0x1bc>)
  402868:	695b      	ldr	r3, [r3, #20]
  40286a:	ee07 3a90 	vmov	s15, r3
  40286e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  402872:	ed9f 7a18 	vldr	s14, [pc, #96]	; 4028d4 <icm20648_run_selftest+0x1c4>
  402876:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40287a:	4b17      	ldr	r3, [pc, #92]	; (4028d8 <icm20648_run_selftest+0x1c8>)
  40287c:	ee16 0a90 	vmov	r0, s13
  402880:	4798      	blx	r3
  402882:	4602      	mov	r2, r0
  402884:	460b      	mov	r3, r1
  402886:	e9cd 2302 	strd	r2, r3, [sp, #8]
  40288a:	e9cd 4500 	strd	r4, r5, [sp]
  40288e:	4642      	mov	r2, r8
  402890:	464b      	mov	r3, r9
  402892:	4913      	ldr	r1, [pc, #76]	; (4028e0 <icm20648_run_selftest+0x1d0>)
  402894:	2003      	movs	r0, #3
  402896:	4c06      	ldr	r4, [pc, #24]	; (4028b0 <icm20648_run_selftest+0x1a0>)
  402898:	47a0      	blx	r4
	}

	return rc;
  40289a:	4b08      	ldr	r3, [pc, #32]	; (4028bc <icm20648_run_selftest+0x1ac>)
  40289c:	681b      	ldr	r3, [r3, #0]
}
  40289e:	4618      	mov	r0, r3
  4028a0:	3718      	adds	r7, #24
  4028a2:	46bd      	mov	sp, r7
  4028a4:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
  4028a8:	20001998 	.word	0x20001998
  4028ac:	0041bdf0 	.word	0x0041bdf0
  4028b0:	0040ff51 	.word	0x0040ff51
  4028b4:	0041be18 	.word	0x0041be18
  4028b8:	0040a649 	.word	0x0040a649
  4028bc:	200011f4 	.word	0x200011f4
  4028c0:	20000ee8 	.word	0x20000ee8
  4028c4:	0041be30 	.word	0x0041be30
  4028c8:	00401769 	.word	0x00401769
  4028cc:	200011f8 	.word	0x200011f8
  4028d0:	00402589 	.word	0x00402589
  4028d4:	47800000 	.word	0x47800000
  4028d8:	004138fd 	.word	0x004138fd
  4028dc:	0041be44 	.word	0x0041be44
  4028e0:	0041be74 	.word	0x0041be74

004028e4 <NVIC_EnableIRQ>:
{
  4028e4:	b480      	push	{r7}
  4028e6:	b083      	sub	sp, #12
  4028e8:	af00      	add	r7, sp, #0
  4028ea:	4603      	mov	r3, r0
  4028ec:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4028ee:	4909      	ldr	r1, [pc, #36]	; (402914 <NVIC_EnableIRQ+0x30>)
  4028f0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4028f4:	095b      	lsrs	r3, r3, #5
  4028f6:	79fa      	ldrb	r2, [r7, #7]
  4028f8:	f002 021f 	and.w	r2, r2, #31
  4028fc:	2001      	movs	r0, #1
  4028fe:	fa00 f202 	lsl.w	r2, r0, r2
  402902:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402906:	bf00      	nop
  402908:	370c      	adds	r7, #12
  40290a:	46bd      	mov	sp, r7
  40290c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402910:	4770      	bx	lr
  402912:	bf00      	nop
  402914:	e000e100 	.word	0xe000e100

00402918 <NVIC_DisableIRQ>:
{
  402918:	b480      	push	{r7}
  40291a:	b083      	sub	sp, #12
  40291c:	af00      	add	r7, sp, #0
  40291e:	4603      	mov	r3, r0
  402920:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  402922:	4909      	ldr	r1, [pc, #36]	; (402948 <NVIC_DisableIRQ+0x30>)
  402924:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402928:	095b      	lsrs	r3, r3, #5
  40292a:	79fa      	ldrb	r2, [r7, #7]
  40292c:	f002 021f 	and.w	r2, r2, #31
  402930:	2001      	movs	r0, #1
  402932:	fa00 f202 	lsl.w	r2, r0, r2
  402936:	3320      	adds	r3, #32
  402938:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40293c:	bf00      	nop
  40293e:	370c      	adds	r7, #12
  402940:	46bd      	mov	sp, r7
  402942:	f85d 7b04 	ldr.w	r7, [sp], #4
  402946:	4770      	bx	lr
  402948:	e000e100 	.word	0xe000e100

0040294c <NVIC_ClearPendingIRQ>:
{
  40294c:	b480      	push	{r7}
  40294e:	b083      	sub	sp, #12
  402950:	af00      	add	r7, sp, #0
  402952:	4603      	mov	r3, r0
  402954:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  402956:	4909      	ldr	r1, [pc, #36]	; (40297c <NVIC_ClearPendingIRQ+0x30>)
  402958:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40295c:	095b      	lsrs	r3, r3, #5
  40295e:	79fa      	ldrb	r2, [r7, #7]
  402960:	f002 021f 	and.w	r2, r2, #31
  402964:	2001      	movs	r0, #1
  402966:	fa00 f202 	lsl.w	r2, r0, r2
  40296a:	3360      	adds	r3, #96	; 0x60
  40296c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402970:	bf00      	nop
  402972:	370c      	adds	r7, #12
  402974:	46bd      	mov	sp, r7
  402976:	f85d 7b04 	ldr.w	r7, [sp], #4
  40297a:	4770      	bx	lr
  40297c:	e000e100 	.word	0xe000e100

00402980 <NVIC_SetPriority>:
{
  402980:	b480      	push	{r7}
  402982:	b083      	sub	sp, #12
  402984:	af00      	add	r7, sp, #0
  402986:	4603      	mov	r3, r0
  402988:	6039      	str	r1, [r7, #0]
  40298a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  40298c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402990:	2b00      	cmp	r3, #0
  402992:	da0b      	bge.n	4029ac <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  402994:	490d      	ldr	r1, [pc, #52]	; (4029cc <NVIC_SetPriority+0x4c>)
  402996:	79fb      	ldrb	r3, [r7, #7]
  402998:	f003 030f 	and.w	r3, r3, #15
  40299c:	3b04      	subs	r3, #4
  40299e:	683a      	ldr	r2, [r7, #0]
  4029a0:	b2d2      	uxtb	r2, r2
  4029a2:	0112      	lsls	r2, r2, #4
  4029a4:	b2d2      	uxtb	r2, r2
  4029a6:	440b      	add	r3, r1
  4029a8:	761a      	strb	r2, [r3, #24]
}
  4029aa:	e009      	b.n	4029c0 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4029ac:	4908      	ldr	r1, [pc, #32]	; (4029d0 <NVIC_SetPriority+0x50>)
  4029ae:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4029b2:	683a      	ldr	r2, [r7, #0]
  4029b4:	b2d2      	uxtb	r2, r2
  4029b6:	0112      	lsls	r2, r2, #4
  4029b8:	b2d2      	uxtb	r2, r2
  4029ba:	440b      	add	r3, r1
  4029bc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  4029c0:	bf00      	nop
  4029c2:	370c      	adds	r7, #12
  4029c4:	46bd      	mov	sp, r7
  4029c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4029ca:	4770      	bx	lr
  4029cc:	e000ed00 	.word	0xe000ed00
  4029d0:	e000e100 	.word	0xe000e100

004029d4 <osc_get_rate>:
{
  4029d4:	b480      	push	{r7}
  4029d6:	b083      	sub	sp, #12
  4029d8:	af00      	add	r7, sp, #0
  4029da:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4029dc:	687b      	ldr	r3, [r7, #4]
  4029de:	2b07      	cmp	r3, #7
  4029e0:	d825      	bhi.n	402a2e <osc_get_rate+0x5a>
  4029e2:	a201      	add	r2, pc, #4	; (adr r2, 4029e8 <osc_get_rate+0x14>)
  4029e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4029e8:	00402a09 	.word	0x00402a09
  4029ec:	00402a0f 	.word	0x00402a0f
  4029f0:	00402a15 	.word	0x00402a15
  4029f4:	00402a1b 	.word	0x00402a1b
  4029f8:	00402a1f 	.word	0x00402a1f
  4029fc:	00402a23 	.word	0x00402a23
  402a00:	00402a27 	.word	0x00402a27
  402a04:	00402a2b 	.word	0x00402a2b
		return OSC_SLCK_32K_RC_HZ;
  402a08:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  402a0c:	e010      	b.n	402a30 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  402a0e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402a12:	e00d      	b.n	402a30 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  402a14:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402a18:	e00a      	b.n	402a30 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  402a1a:	4b08      	ldr	r3, [pc, #32]	; (402a3c <osc_get_rate+0x68>)
  402a1c:	e008      	b.n	402a30 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  402a1e:	4b08      	ldr	r3, [pc, #32]	; (402a40 <osc_get_rate+0x6c>)
  402a20:	e006      	b.n	402a30 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  402a22:	4b08      	ldr	r3, [pc, #32]	; (402a44 <osc_get_rate+0x70>)
  402a24:	e004      	b.n	402a30 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  402a26:	2300      	movs	r3, #0
  402a28:	e002      	b.n	402a30 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  402a2a:	2300      	movs	r3, #0
  402a2c:	e000      	b.n	402a30 <osc_get_rate+0x5c>
	return 0;
  402a2e:	2300      	movs	r3, #0
}
  402a30:	4618      	mov	r0, r3
  402a32:	370c      	adds	r7, #12
  402a34:	46bd      	mov	sp, r7
  402a36:	f85d 7b04 	ldr.w	r7, [sp], #4
  402a3a:	4770      	bx	lr
  402a3c:	007a1200 	.word	0x007a1200
  402a40:	00f42400 	.word	0x00f42400
  402a44:	016e3600 	.word	0x016e3600

00402a48 <sysclk_get_main_hz>:
{
  402a48:	b580      	push	{r7, lr}
  402a4a:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  402a4c:	2001      	movs	r0, #1
  402a4e:	4b04      	ldr	r3, [pc, #16]	; (402a60 <sysclk_get_main_hz+0x18>)
  402a50:	4798      	blx	r3
  402a52:	4602      	mov	r2, r0
  402a54:	f640 634e 	movw	r3, #3662	; 0xe4e
  402a58:	fb03 f302 	mul.w	r3, r3, r2
}
  402a5c:	4618      	mov	r0, r3
  402a5e:	bd80      	pop	{r7, pc}
  402a60:	004029d5 	.word	0x004029d5

00402a64 <sysclk_get_cpu_hz>:
{
  402a64:	b580      	push	{r7, lr}
  402a66:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402a68:	4b02      	ldr	r3, [pc, #8]	; (402a74 <sysclk_get_cpu_hz+0x10>)
  402a6a:	4798      	blx	r3
  402a6c:	4603      	mov	r3, r0
}
  402a6e:	4618      	mov	r0, r3
  402a70:	bd80      	pop	{r7, pc}
  402a72:	bf00      	nop
  402a74:	00402a49 	.word	0x00402a49

00402a78 <sysclk_get_peripheral_hz>:
{
  402a78:	b580      	push	{r7, lr}
  402a7a:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402a7c:	4b02      	ldr	r3, [pc, #8]	; (402a88 <sysclk_get_peripheral_hz+0x10>)
  402a7e:	4798      	blx	r3
  402a80:	4603      	mov	r3, r0
}
  402a82:	4618      	mov	r0, r3
  402a84:	bd80      	pop	{r7, pc}
  402a86:	bf00      	nop
  402a88:	00402a49 	.word	0x00402a49

00402a8c <sysclk_enable_peripheral_clock>:
{
  402a8c:	b580      	push	{r7, lr}
  402a8e:	b082      	sub	sp, #8
  402a90:	af00      	add	r7, sp, #0
  402a92:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  402a94:	6878      	ldr	r0, [r7, #4]
  402a96:	4b03      	ldr	r3, [pc, #12]	; (402aa4 <sysclk_enable_peripheral_clock+0x18>)
  402a98:	4798      	blx	r3
}
  402a9a:	bf00      	nop
  402a9c:	3708      	adds	r7, #8
  402a9e:	46bd      	mov	sp, r7
  402aa0:	bd80      	pop	{r7, pc}
  402aa2:	bf00      	nop
  402aa4:	00404359 	.word	0x00404359

00402aa8 <usart_serial_init>:
{
  402aa8:	b580      	push	{r7, lr}
  402aaa:	b088      	sub	sp, #32
  402aac:	af00      	add	r7, sp, #0
  402aae:	6078      	str	r0, [r7, #4]
  402ab0:	6039      	str	r1, [r7, #0]
	usart_settings.baudrate = opt->baudrate;
  402ab2:	683b      	ldr	r3, [r7, #0]
  402ab4:	681b      	ldr	r3, [r3, #0]
  402ab6:	60bb      	str	r3, [r7, #8]
	usart_settings.char_length = opt->charlength;
  402ab8:	683b      	ldr	r3, [r7, #0]
  402aba:	685b      	ldr	r3, [r3, #4]
  402abc:	60fb      	str	r3, [r7, #12]
	usart_settings.parity_type = opt->paritytype;
  402abe:	683b      	ldr	r3, [r7, #0]
  402ac0:	689b      	ldr	r3, [r3, #8]
  402ac2:	613b      	str	r3, [r7, #16]
	usart_settings.stop_bits= opt->stopbits;
  402ac4:	683b      	ldr	r3, [r7, #0]
  402ac6:	68db      	ldr	r3, [r3, #12]
  402ac8:	617b      	str	r3, [r7, #20]
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
  402aca:	2300      	movs	r3, #0
  402acc:	61bb      	str	r3, [r7, #24]
	if (USART0 == p_usart) {
  402ace:	687b      	ldr	r3, [r7, #4]
  402ad0:	4a69      	ldr	r2, [pc, #420]	; (402c78 <usart_serial_init+0x1d0>)
  402ad2:	4293      	cmp	r3, r2
  402ad4:	d115      	bne.n	402b02 <usart_serial_init+0x5a>
		flexcom_enable(FLEXCOM0);
  402ad6:	4869      	ldr	r0, [pc, #420]	; (402c7c <usart_serial_init+0x1d4>)
  402ad8:	4b69      	ldr	r3, [pc, #420]	; (402c80 <usart_serial_init+0x1d8>)
  402ada:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM0, FLEXCOM_USART);
  402adc:	2101      	movs	r1, #1
  402ade:	4867      	ldr	r0, [pc, #412]	; (402c7c <usart_serial_init+0x1d4>)
  402ae0:	4b68      	ldr	r3, [pc, #416]	; (402c84 <usart_serial_init+0x1dc>)
  402ae2:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402ae4:	4b68      	ldr	r3, [pc, #416]	; (402c88 <usart_serial_init+0x1e0>)
  402ae6:	4798      	blx	r3
  402ae8:	4602      	mov	r2, r0
  402aea:	f107 0308 	add.w	r3, r7, #8
  402aee:	4619      	mov	r1, r3
  402af0:	6878      	ldr	r0, [r7, #4]
  402af2:	4b66      	ldr	r3, [pc, #408]	; (402c8c <usart_serial_init+0x1e4>)
  402af4:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402af6:	6878      	ldr	r0, [r7, #4]
  402af8:	4b65      	ldr	r3, [pc, #404]	; (402c90 <usart_serial_init+0x1e8>)
  402afa:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402afc:	6878      	ldr	r0, [r7, #4]
  402afe:	4b65      	ldr	r3, [pc, #404]	; (402c94 <usart_serial_init+0x1ec>)
  402b00:	4798      	blx	r3
	if (USART1 == p_usart) {
  402b02:	687b      	ldr	r3, [r7, #4]
  402b04:	4a64      	ldr	r2, [pc, #400]	; (402c98 <usart_serial_init+0x1f0>)
  402b06:	4293      	cmp	r3, r2
  402b08:	d115      	bne.n	402b36 <usart_serial_init+0x8e>
		flexcom_enable(FLEXCOM1);
  402b0a:	4864      	ldr	r0, [pc, #400]	; (402c9c <usart_serial_init+0x1f4>)
  402b0c:	4b5c      	ldr	r3, [pc, #368]	; (402c80 <usart_serial_init+0x1d8>)
  402b0e:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM1, FLEXCOM_USART);
  402b10:	2101      	movs	r1, #1
  402b12:	4862      	ldr	r0, [pc, #392]	; (402c9c <usart_serial_init+0x1f4>)
  402b14:	4b5b      	ldr	r3, [pc, #364]	; (402c84 <usart_serial_init+0x1dc>)
  402b16:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402b18:	4b5b      	ldr	r3, [pc, #364]	; (402c88 <usart_serial_init+0x1e0>)
  402b1a:	4798      	blx	r3
  402b1c:	4602      	mov	r2, r0
  402b1e:	f107 0308 	add.w	r3, r7, #8
  402b22:	4619      	mov	r1, r3
  402b24:	6878      	ldr	r0, [r7, #4]
  402b26:	4b59      	ldr	r3, [pc, #356]	; (402c8c <usart_serial_init+0x1e4>)
  402b28:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402b2a:	6878      	ldr	r0, [r7, #4]
  402b2c:	4b58      	ldr	r3, [pc, #352]	; (402c90 <usart_serial_init+0x1e8>)
  402b2e:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402b30:	6878      	ldr	r0, [r7, #4]
  402b32:	4b58      	ldr	r3, [pc, #352]	; (402c94 <usart_serial_init+0x1ec>)
  402b34:	4798      	blx	r3
	if (USART2 == p_usart) {
  402b36:	687b      	ldr	r3, [r7, #4]
  402b38:	4a59      	ldr	r2, [pc, #356]	; (402ca0 <usart_serial_init+0x1f8>)
  402b3a:	4293      	cmp	r3, r2
  402b3c:	d115      	bne.n	402b6a <usart_serial_init+0xc2>
		flexcom_enable(FLEXCOM2);
  402b3e:	4859      	ldr	r0, [pc, #356]	; (402ca4 <usart_serial_init+0x1fc>)
  402b40:	4b4f      	ldr	r3, [pc, #316]	; (402c80 <usart_serial_init+0x1d8>)
  402b42:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM2, FLEXCOM_USART);
  402b44:	2101      	movs	r1, #1
  402b46:	4857      	ldr	r0, [pc, #348]	; (402ca4 <usart_serial_init+0x1fc>)
  402b48:	4b4e      	ldr	r3, [pc, #312]	; (402c84 <usart_serial_init+0x1dc>)
  402b4a:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402b4c:	4b4e      	ldr	r3, [pc, #312]	; (402c88 <usart_serial_init+0x1e0>)
  402b4e:	4798      	blx	r3
  402b50:	4602      	mov	r2, r0
  402b52:	f107 0308 	add.w	r3, r7, #8
  402b56:	4619      	mov	r1, r3
  402b58:	6878      	ldr	r0, [r7, #4]
  402b5a:	4b4c      	ldr	r3, [pc, #304]	; (402c8c <usart_serial_init+0x1e4>)
  402b5c:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402b5e:	6878      	ldr	r0, [r7, #4]
  402b60:	4b4b      	ldr	r3, [pc, #300]	; (402c90 <usart_serial_init+0x1e8>)
  402b62:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402b64:	6878      	ldr	r0, [r7, #4]
  402b66:	4b4b      	ldr	r3, [pc, #300]	; (402c94 <usart_serial_init+0x1ec>)
  402b68:	4798      	blx	r3
	if (USART3 == p_usart) {
  402b6a:	687b      	ldr	r3, [r7, #4]
  402b6c:	4a4e      	ldr	r2, [pc, #312]	; (402ca8 <usart_serial_init+0x200>)
  402b6e:	4293      	cmp	r3, r2
  402b70:	d115      	bne.n	402b9e <usart_serial_init+0xf6>
		flexcom_enable(FLEXCOM3);
  402b72:	484e      	ldr	r0, [pc, #312]	; (402cac <usart_serial_init+0x204>)
  402b74:	4b42      	ldr	r3, [pc, #264]	; (402c80 <usart_serial_init+0x1d8>)
  402b76:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM3, FLEXCOM_USART);
  402b78:	2101      	movs	r1, #1
  402b7a:	484c      	ldr	r0, [pc, #304]	; (402cac <usart_serial_init+0x204>)
  402b7c:	4b41      	ldr	r3, [pc, #260]	; (402c84 <usart_serial_init+0x1dc>)
  402b7e:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402b80:	4b41      	ldr	r3, [pc, #260]	; (402c88 <usart_serial_init+0x1e0>)
  402b82:	4798      	blx	r3
  402b84:	4602      	mov	r2, r0
  402b86:	f107 0308 	add.w	r3, r7, #8
  402b8a:	4619      	mov	r1, r3
  402b8c:	6878      	ldr	r0, [r7, #4]
  402b8e:	4b3f      	ldr	r3, [pc, #252]	; (402c8c <usart_serial_init+0x1e4>)
  402b90:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402b92:	6878      	ldr	r0, [r7, #4]
  402b94:	4b3e      	ldr	r3, [pc, #248]	; (402c90 <usart_serial_init+0x1e8>)
  402b96:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402b98:	6878      	ldr	r0, [r7, #4]
  402b9a:	4b3e      	ldr	r3, [pc, #248]	; (402c94 <usart_serial_init+0x1ec>)
  402b9c:	4798      	blx	r3
	if (USART4 == p_usart) {
  402b9e:	687b      	ldr	r3, [r7, #4]
  402ba0:	4a43      	ldr	r2, [pc, #268]	; (402cb0 <usart_serial_init+0x208>)
  402ba2:	4293      	cmp	r3, r2
  402ba4:	d115      	bne.n	402bd2 <usart_serial_init+0x12a>
		flexcom_enable(FLEXCOM4);
  402ba6:	4843      	ldr	r0, [pc, #268]	; (402cb4 <usart_serial_init+0x20c>)
  402ba8:	4b35      	ldr	r3, [pc, #212]	; (402c80 <usart_serial_init+0x1d8>)
  402baa:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM4, FLEXCOM_USART);
  402bac:	2101      	movs	r1, #1
  402bae:	4841      	ldr	r0, [pc, #260]	; (402cb4 <usart_serial_init+0x20c>)
  402bb0:	4b34      	ldr	r3, [pc, #208]	; (402c84 <usart_serial_init+0x1dc>)
  402bb2:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402bb4:	4b34      	ldr	r3, [pc, #208]	; (402c88 <usart_serial_init+0x1e0>)
  402bb6:	4798      	blx	r3
  402bb8:	4602      	mov	r2, r0
  402bba:	f107 0308 	add.w	r3, r7, #8
  402bbe:	4619      	mov	r1, r3
  402bc0:	6878      	ldr	r0, [r7, #4]
  402bc2:	4b32      	ldr	r3, [pc, #200]	; (402c8c <usart_serial_init+0x1e4>)
  402bc4:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402bc6:	6878      	ldr	r0, [r7, #4]
  402bc8:	4b31      	ldr	r3, [pc, #196]	; (402c90 <usart_serial_init+0x1e8>)
  402bca:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402bcc:	6878      	ldr	r0, [r7, #4]
  402bce:	4b31      	ldr	r3, [pc, #196]	; (402c94 <usart_serial_init+0x1ec>)
  402bd0:	4798      	blx	r3
	if (USART5 == p_usart) {
  402bd2:	687b      	ldr	r3, [r7, #4]
  402bd4:	4a38      	ldr	r2, [pc, #224]	; (402cb8 <usart_serial_init+0x210>)
  402bd6:	4293      	cmp	r3, r2
  402bd8:	d115      	bne.n	402c06 <usart_serial_init+0x15e>
		flexcom_enable(FLEXCOM5);
  402bda:	4838      	ldr	r0, [pc, #224]	; (402cbc <usart_serial_init+0x214>)
  402bdc:	4b28      	ldr	r3, [pc, #160]	; (402c80 <usart_serial_init+0x1d8>)
  402bde:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM5, FLEXCOM_USART);
  402be0:	2101      	movs	r1, #1
  402be2:	4836      	ldr	r0, [pc, #216]	; (402cbc <usart_serial_init+0x214>)
  402be4:	4b27      	ldr	r3, [pc, #156]	; (402c84 <usart_serial_init+0x1dc>)
  402be6:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402be8:	4b27      	ldr	r3, [pc, #156]	; (402c88 <usart_serial_init+0x1e0>)
  402bea:	4798      	blx	r3
  402bec:	4602      	mov	r2, r0
  402bee:	f107 0308 	add.w	r3, r7, #8
  402bf2:	4619      	mov	r1, r3
  402bf4:	6878      	ldr	r0, [r7, #4]
  402bf6:	4b25      	ldr	r3, [pc, #148]	; (402c8c <usart_serial_init+0x1e4>)
  402bf8:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402bfa:	6878      	ldr	r0, [r7, #4]
  402bfc:	4b24      	ldr	r3, [pc, #144]	; (402c90 <usart_serial_init+0x1e8>)
  402bfe:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402c00:	6878      	ldr	r0, [r7, #4]
  402c02:	4b24      	ldr	r3, [pc, #144]	; (402c94 <usart_serial_init+0x1ec>)
  402c04:	4798      	blx	r3
	if (USART6 == p_usart) {
  402c06:	687b      	ldr	r3, [r7, #4]
  402c08:	4a2d      	ldr	r2, [pc, #180]	; (402cc0 <usart_serial_init+0x218>)
  402c0a:	4293      	cmp	r3, r2
  402c0c:	d115      	bne.n	402c3a <usart_serial_init+0x192>
		flexcom_enable(FLEXCOM6);
  402c0e:	482d      	ldr	r0, [pc, #180]	; (402cc4 <usart_serial_init+0x21c>)
  402c10:	4b1b      	ldr	r3, [pc, #108]	; (402c80 <usart_serial_init+0x1d8>)
  402c12:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM6, FLEXCOM_USART);
  402c14:	2101      	movs	r1, #1
  402c16:	482b      	ldr	r0, [pc, #172]	; (402cc4 <usart_serial_init+0x21c>)
  402c18:	4b1a      	ldr	r3, [pc, #104]	; (402c84 <usart_serial_init+0x1dc>)
  402c1a:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402c1c:	4b1a      	ldr	r3, [pc, #104]	; (402c88 <usart_serial_init+0x1e0>)
  402c1e:	4798      	blx	r3
  402c20:	4602      	mov	r2, r0
  402c22:	f107 0308 	add.w	r3, r7, #8
  402c26:	4619      	mov	r1, r3
  402c28:	6878      	ldr	r0, [r7, #4]
  402c2a:	4b18      	ldr	r3, [pc, #96]	; (402c8c <usart_serial_init+0x1e4>)
  402c2c:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402c2e:	6878      	ldr	r0, [r7, #4]
  402c30:	4b17      	ldr	r3, [pc, #92]	; (402c90 <usart_serial_init+0x1e8>)
  402c32:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402c34:	6878      	ldr	r0, [r7, #4]
  402c36:	4b17      	ldr	r3, [pc, #92]	; (402c94 <usart_serial_init+0x1ec>)
  402c38:	4798      	blx	r3
	if (USART7 == p_usart) {
  402c3a:	687b      	ldr	r3, [r7, #4]
  402c3c:	4a22      	ldr	r2, [pc, #136]	; (402cc8 <usart_serial_init+0x220>)
  402c3e:	4293      	cmp	r3, r2
  402c40:	d115      	bne.n	402c6e <usart_serial_init+0x1c6>
		flexcom_enable(FLEXCOM7);
  402c42:	4822      	ldr	r0, [pc, #136]	; (402ccc <usart_serial_init+0x224>)
  402c44:	4b0e      	ldr	r3, [pc, #56]	; (402c80 <usart_serial_init+0x1d8>)
  402c46:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM7, FLEXCOM_USART);
  402c48:	2101      	movs	r1, #1
  402c4a:	4820      	ldr	r0, [pc, #128]	; (402ccc <usart_serial_init+0x224>)
  402c4c:	4b0d      	ldr	r3, [pc, #52]	; (402c84 <usart_serial_init+0x1dc>)
  402c4e:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402c50:	4b0d      	ldr	r3, [pc, #52]	; (402c88 <usart_serial_init+0x1e0>)
  402c52:	4798      	blx	r3
  402c54:	4602      	mov	r2, r0
  402c56:	f107 0308 	add.w	r3, r7, #8
  402c5a:	4619      	mov	r1, r3
  402c5c:	6878      	ldr	r0, [r7, #4]
  402c5e:	4b0b      	ldr	r3, [pc, #44]	; (402c8c <usart_serial_init+0x1e4>)
  402c60:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402c62:	6878      	ldr	r0, [r7, #4]
  402c64:	4b0a      	ldr	r3, [pc, #40]	; (402c90 <usart_serial_init+0x1e8>)
  402c66:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402c68:	6878      	ldr	r0, [r7, #4]
  402c6a:	4b0a      	ldr	r3, [pc, #40]	; (402c94 <usart_serial_init+0x1ec>)
  402c6c:	4798      	blx	r3
}
  402c6e:	bf00      	nop
  402c70:	3720      	adds	r7, #32
  402c72:	46bd      	mov	sp, r7
  402c74:	bd80      	pop	{r7, pc}
  402c76:	bf00      	nop
  402c78:	4000c200 	.word	0x4000c200
  402c7c:	4000c000 	.word	0x4000c000
  402c80:	004036a1 	.word	0x004036a1
  402c84:	00403809 	.word	0x00403809
  402c88:	00402a79 	.word	0x00402a79
  402c8c:	004033d9 	.word	0x004033d9
  402c90:	0040345d 	.word	0x0040345d
  402c94:	00403491 	.word	0x00403491
  402c98:	40020200 	.word	0x40020200
  402c9c:	40020000 	.word	0x40020000
  402ca0:	40024200 	.word	0x40024200
  402ca4:	40024000 	.word	0x40024000
  402ca8:	40018200 	.word	0x40018200
  402cac:	40018000 	.word	0x40018000
  402cb0:	4001c200 	.word	0x4001c200
  402cb4:	4001c000 	.word	0x4001c000
  402cb8:	40008200 	.word	0x40008200
  402cbc:	40008000 	.word	0x40008000
  402cc0:	40040200 	.word	0x40040200
  402cc4:	40040000 	.word	0x40040000
  402cc8:	40034200 	.word	0x40034200
  402ccc:	40034000 	.word	0x40034000

00402cd0 <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  402cd0:	b580      	push	{r7, lr}
  402cd2:	b084      	sub	sp, #16
  402cd4:	af00      	add	r7, sp, #0
  402cd6:	6078      	str	r0, [r7, #4]
  402cd8:	6039      	str	r1, [r7, #0]
	uint32_t val = 0;
  402cda:	2300      	movs	r3, #0
  402cdc:	60fb      	str	r3, [r7, #12]
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  402cde:	687b      	ldr	r3, [r7, #4]
  402ce0:	4a49      	ldr	r2, [pc, #292]	; (402e08 <usart_serial_getchar+0x138>)
  402ce2:	4293      	cmp	r3, r2
  402ce4:	d10d      	bne.n	402d02 <usart_serial_getchar+0x32>
		while (usart_read(p_usart, &val));
  402ce6:	bf00      	nop
  402ce8:	f107 030c 	add.w	r3, r7, #12
  402cec:	4619      	mov	r1, r3
  402cee:	6878      	ldr	r0, [r7, #4]
  402cf0:	4b46      	ldr	r3, [pc, #280]	; (402e0c <usart_serial_getchar+0x13c>)
  402cf2:	4798      	blx	r3
  402cf4:	4603      	mov	r3, r0
  402cf6:	2b00      	cmp	r3, #0
  402cf8:	d1f6      	bne.n	402ce8 <usart_serial_getchar+0x18>
		*data = (uint8_t)(val & 0xFF);
  402cfa:	68fb      	ldr	r3, [r7, #12]
  402cfc:	b2da      	uxtb	r2, r3
  402cfe:	683b      	ldr	r3, [r7, #0]
  402d00:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  402d02:	687b      	ldr	r3, [r7, #4]
  402d04:	4a42      	ldr	r2, [pc, #264]	; (402e10 <usart_serial_getchar+0x140>)
  402d06:	4293      	cmp	r3, r2
  402d08:	d10d      	bne.n	402d26 <usart_serial_getchar+0x56>
		while (usart_read(p_usart, &val));
  402d0a:	bf00      	nop
  402d0c:	f107 030c 	add.w	r3, r7, #12
  402d10:	4619      	mov	r1, r3
  402d12:	6878      	ldr	r0, [r7, #4]
  402d14:	4b3d      	ldr	r3, [pc, #244]	; (402e0c <usart_serial_getchar+0x13c>)
  402d16:	4798      	blx	r3
  402d18:	4603      	mov	r3, r0
  402d1a:	2b00      	cmp	r3, #0
  402d1c:	d1f6      	bne.n	402d0c <usart_serial_getchar+0x3c>
		*data = (uint8_t)(val & 0xFF);
  402d1e:	68fb      	ldr	r3, [r7, #12]
  402d20:	b2da      	uxtb	r2, r3
  402d22:	683b      	ldr	r3, [r7, #0]
  402d24:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART2
	if (USART2 == p_usart) {
  402d26:	687b      	ldr	r3, [r7, #4]
  402d28:	4a3a      	ldr	r2, [pc, #232]	; (402e14 <usart_serial_getchar+0x144>)
  402d2a:	4293      	cmp	r3, r2
  402d2c:	d10d      	bne.n	402d4a <usart_serial_getchar+0x7a>
		while (usart_read(p_usart, &val));
  402d2e:	bf00      	nop
  402d30:	f107 030c 	add.w	r3, r7, #12
  402d34:	4619      	mov	r1, r3
  402d36:	6878      	ldr	r0, [r7, #4]
  402d38:	4b34      	ldr	r3, [pc, #208]	; (402e0c <usart_serial_getchar+0x13c>)
  402d3a:	4798      	blx	r3
  402d3c:	4603      	mov	r3, r0
  402d3e:	2b00      	cmp	r3, #0
  402d40:	d1f6      	bne.n	402d30 <usart_serial_getchar+0x60>
		*data = (uint8_t)(val & 0xFF);
  402d42:	68fb      	ldr	r3, [r7, #12]
  402d44:	b2da      	uxtb	r2, r3
  402d46:	683b      	ldr	r3, [r7, #0]
  402d48:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART3
	if (USART3 == p_usart) {
  402d4a:	687b      	ldr	r3, [r7, #4]
  402d4c:	4a32      	ldr	r2, [pc, #200]	; (402e18 <usart_serial_getchar+0x148>)
  402d4e:	4293      	cmp	r3, r2
  402d50:	d10d      	bne.n	402d6e <usart_serial_getchar+0x9e>
		while (usart_read(p_usart, &val));
  402d52:	bf00      	nop
  402d54:	f107 030c 	add.w	r3, r7, #12
  402d58:	4619      	mov	r1, r3
  402d5a:	6878      	ldr	r0, [r7, #4]
  402d5c:	4b2b      	ldr	r3, [pc, #172]	; (402e0c <usart_serial_getchar+0x13c>)
  402d5e:	4798      	blx	r3
  402d60:	4603      	mov	r3, r0
  402d62:	2b00      	cmp	r3, #0
  402d64:	d1f6      	bne.n	402d54 <usart_serial_getchar+0x84>
		*data = (uint8_t)(val & 0xFF);
  402d66:	68fb      	ldr	r3, [r7, #12]
  402d68:	b2da      	uxtb	r2, r3
  402d6a:	683b      	ldr	r3, [r7, #0]
  402d6c:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART4
	if (USART4 == p_usart) {
  402d6e:	687b      	ldr	r3, [r7, #4]
  402d70:	4a2a      	ldr	r2, [pc, #168]	; (402e1c <usart_serial_getchar+0x14c>)
  402d72:	4293      	cmp	r3, r2
  402d74:	d10d      	bne.n	402d92 <usart_serial_getchar+0xc2>
		while (usart_read(p_usart, &val));
  402d76:	bf00      	nop
  402d78:	f107 030c 	add.w	r3, r7, #12
  402d7c:	4619      	mov	r1, r3
  402d7e:	6878      	ldr	r0, [r7, #4]
  402d80:	4b22      	ldr	r3, [pc, #136]	; (402e0c <usart_serial_getchar+0x13c>)
  402d82:	4798      	blx	r3
  402d84:	4603      	mov	r3, r0
  402d86:	2b00      	cmp	r3, #0
  402d88:	d1f6      	bne.n	402d78 <usart_serial_getchar+0xa8>
		*data = (uint8_t)(val & 0xFF);
  402d8a:	68fb      	ldr	r3, [r7, #12]
  402d8c:	b2da      	uxtb	r2, r3
  402d8e:	683b      	ldr	r3, [r7, #0]
  402d90:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART5
	if (USART5 == p_usart) {
  402d92:	687b      	ldr	r3, [r7, #4]
  402d94:	4a22      	ldr	r2, [pc, #136]	; (402e20 <usart_serial_getchar+0x150>)
  402d96:	4293      	cmp	r3, r2
  402d98:	d10d      	bne.n	402db6 <usart_serial_getchar+0xe6>
		while (usart_read(p_usart, &val));
  402d9a:	bf00      	nop
  402d9c:	f107 030c 	add.w	r3, r7, #12
  402da0:	4619      	mov	r1, r3
  402da2:	6878      	ldr	r0, [r7, #4]
  402da4:	4b19      	ldr	r3, [pc, #100]	; (402e0c <usart_serial_getchar+0x13c>)
  402da6:	4798      	blx	r3
  402da8:	4603      	mov	r3, r0
  402daa:	2b00      	cmp	r3, #0
  402dac:	d1f6      	bne.n	402d9c <usart_serial_getchar+0xcc>
		*data = (uint8_t)(val & 0xFF);
  402dae:	68fb      	ldr	r3, [r7, #12]
  402db0:	b2da      	uxtb	r2, r3
  402db2:	683b      	ldr	r3, [r7, #0]
  402db4:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART6
	if (USART6 == p_usart) {
  402db6:	687b      	ldr	r3, [r7, #4]
  402db8:	4a1a      	ldr	r2, [pc, #104]	; (402e24 <usart_serial_getchar+0x154>)
  402dba:	4293      	cmp	r3, r2
  402dbc:	d10d      	bne.n	402dda <usart_serial_getchar+0x10a>
		while (usart_read(p_usart, &val));
  402dbe:	bf00      	nop
  402dc0:	f107 030c 	add.w	r3, r7, #12
  402dc4:	4619      	mov	r1, r3
  402dc6:	6878      	ldr	r0, [r7, #4]
  402dc8:	4b10      	ldr	r3, [pc, #64]	; (402e0c <usart_serial_getchar+0x13c>)
  402dca:	4798      	blx	r3
  402dcc:	4603      	mov	r3, r0
  402dce:	2b00      	cmp	r3, #0
  402dd0:	d1f6      	bne.n	402dc0 <usart_serial_getchar+0xf0>
		*data = (uint8_t)(val & 0xFF);
  402dd2:	68fb      	ldr	r3, [r7, #12]
  402dd4:	b2da      	uxtb	r2, r3
  402dd6:	683b      	ldr	r3, [r7, #0]
  402dd8:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART7
	if (USART7 == p_usart) {
  402dda:	687b      	ldr	r3, [r7, #4]
  402ddc:	4a12      	ldr	r2, [pc, #72]	; (402e28 <usart_serial_getchar+0x158>)
  402dde:	4293      	cmp	r3, r2
  402de0:	d10d      	bne.n	402dfe <usart_serial_getchar+0x12e>
		while (usart_read(p_usart, &val));
  402de2:	bf00      	nop
  402de4:	f107 030c 	add.w	r3, r7, #12
  402de8:	4619      	mov	r1, r3
  402dea:	6878      	ldr	r0, [r7, #4]
  402dec:	4b07      	ldr	r3, [pc, #28]	; (402e0c <usart_serial_getchar+0x13c>)
  402dee:	4798      	blx	r3
  402df0:	4603      	mov	r3, r0
  402df2:	2b00      	cmp	r3, #0
  402df4:	d1f6      	bne.n	402de4 <usart_serial_getchar+0x114>
		*data = (uint8_t)(val & 0xFF);
  402df6:	68fb      	ldr	r3, [r7, #12]
  402df8:	b2da      	uxtb	r2, r3
  402dfa:	683b      	ldr	r3, [r7, #0]
  402dfc:	701a      	strb	r2, [r3, #0]
	}
# endif
#endif /* ifdef USART */

}
  402dfe:	bf00      	nop
  402e00:	3710      	adds	r7, #16
  402e02:	46bd      	mov	sp, r7
  402e04:	bd80      	pop	{r7, pc}
  402e06:	bf00      	nop
  402e08:	4000c200 	.word	0x4000c200
  402e0c:	00403563 	.word	0x00403563
  402e10:	40020200 	.word	0x40020200
  402e14:	40024200 	.word	0x40024200
  402e18:	40018200 	.word	0x40018200
  402e1c:	4001c200 	.word	0x4001c200
  402e20:	40008200 	.word	0x40008200
  402e24:	40040200 	.word	0x40040200
  402e28:	40034200 	.word	0x40034200

00402e2c <InvScheduler_updateTime>:
{
  402e2c:	b480      	push	{r7}
  402e2e:	b083      	sub	sp, #12
  402e30:	af00      	add	r7, sp, #0
  402e32:	6078      	str	r0, [r7, #4]
	++scheduler->currentTime;
  402e34:	687b      	ldr	r3, [r7, #4]
  402e36:	681b      	ldr	r3, [r3, #0]
  402e38:	1c5a      	adds	r2, r3, #1
  402e3a:	687b      	ldr	r3, [r7, #4]
  402e3c:	601a      	str	r2, [r3, #0]
}
  402e3e:	bf00      	nop
  402e40:	370c      	adds	r7, #12
  402e42:	46bd      	mov	sp, r7
  402e44:	f85d 7b04 	ldr.w	r7, [sp], #4
  402e48:	4770      	bx	lr

00402e4a <RingByteBuffer_isFull>:
{
  402e4a:	b480      	push	{r7}
  402e4c:	b083      	sub	sp, #12
  402e4e:	af00      	add	r7, sp, #0
  402e50:	6078      	str	r0, [r7, #4]
	return (self->end == self->start && self->msbEnd != self->msbStart);
  402e52:	687b      	ldr	r3, [r7, #4]
  402e54:	891a      	ldrh	r2, [r3, #8]
  402e56:	687b      	ldr	r3, [r7, #4]
  402e58:	88db      	ldrh	r3, [r3, #6]
  402e5a:	429a      	cmp	r2, r3
  402e5c:	d107      	bne.n	402e6e <RingByteBuffer_isFull+0x24>
  402e5e:	687b      	ldr	r3, [r7, #4]
  402e60:	7ada      	ldrb	r2, [r3, #11]
  402e62:	687b      	ldr	r3, [r7, #4]
  402e64:	7a9b      	ldrb	r3, [r3, #10]
  402e66:	429a      	cmp	r2, r3
  402e68:	d001      	beq.n	402e6e <RingByteBuffer_isFull+0x24>
  402e6a:	2301      	movs	r3, #1
  402e6c:	e000      	b.n	402e70 <RingByteBuffer_isFull+0x26>
  402e6e:	2300      	movs	r3, #0
}
  402e70:	4618      	mov	r0, r3
  402e72:	370c      	adds	r7, #12
  402e74:	46bd      	mov	sp, r7
  402e76:	f85d 7b04 	ldr.w	r7, [sp], #4
  402e7a:	4770      	bx	lr

00402e7c <ext_interrupt_handler>:
* @param[out]	NULL
*
* @return		NULL
*
*/
void ext_interrupt_handler(void){
  402e7c:	b480      	push	{r7}
  402e7e:	af00      	add	r7, sp, #0
	irq_from_device = 1;
  402e80:	4b03      	ldr	r3, [pc, #12]	; (402e90 <ext_interrupt_handler+0x14>)
  402e82:	2201      	movs	r2, #1
  402e84:	601a      	str	r2, [r3, #0]
}
  402e86:	bf00      	nop
  402e88:	46bd      	mov	sp, r7
  402e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  402e8e:	4770      	bx	lr
  402e90:	20000d98 	.word	0x20000d98

00402e94 <ext_int_initialize>:

void ext_int_initialize(void (*handler_function)(void)){
  402e94:	b590      	push	{r4, r7, lr}
  402e96:	b085      	sub	sp, #20
  402e98:	af02      	add	r7, sp, #8
  402e9a:	6078      	str	r0, [r7, #4]
	/* Enable the peripheral clock for the board interrupt pin. */
	pmc_enable_periph_clk(PIN_EXT_INTERRUPT_ID);
  402e9c:	200c      	movs	r0, #12
  402e9e:	4b0f      	ldr	r3, [pc, #60]	; (402edc <ext_int_initialize+0x48>)
  402ea0:	4798      	blx	r3

	/* Configure PIOs as input pins. */
	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_INTERRUPT_MASK, PIN_EXT_INTERRUPT_ATTR);
  402ea2:	2370      	movs	r3, #112	; 0x70
  402ea4:	2208      	movs	r2, #8
  402ea6:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  402eaa:	480d      	ldr	r0, [pc, #52]	; (402ee0 <ext_int_initialize+0x4c>)
  402eac:	4c0d      	ldr	r4, [pc, #52]	; (402ee4 <ext_int_initialize+0x50>)
  402eae:	47a0      	blx	r4

	/* Initialize PIO interrupt handler, interrupt on rising edge. */
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_INTERRUPT_MASK,
  402eb0:	687b      	ldr	r3, [r7, #4]
  402eb2:	9300      	str	r3, [sp, #0]
  402eb4:	2370      	movs	r3, #112	; 0x70
  402eb6:	2208      	movs	r2, #8
  402eb8:	210c      	movs	r1, #12
  402eba:	4809      	ldr	r0, [pc, #36]	; (402ee0 <ext_int_initialize+0x4c>)
  402ebc:	4c0a      	ldr	r4, [pc, #40]	; (402ee8 <ext_int_initialize+0x54>)
  402ebe:	47a0      	blx	r4
		PIN_EXT_INTERRUPT_ATTR, (void (*) (uint32_t, uint32_t))handler_function);

	/* Initialize and enable push button (PIO) interrupt. */
	pio_handler_set_priority(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_IRQn, 0);
  402ec0:	2200      	movs	r2, #0
  402ec2:	210c      	movs	r1, #12
  402ec4:	4806      	ldr	r0, [pc, #24]	; (402ee0 <ext_int_initialize+0x4c>)
  402ec6:	4b09      	ldr	r3, [pc, #36]	; (402eec <ext_int_initialize+0x58>)
  402ec8:	4798      	blx	r3
	pio_enable_interrupt(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  402eca:	2108      	movs	r1, #8
  402ecc:	4804      	ldr	r0, [pc, #16]	; (402ee0 <ext_int_initialize+0x4c>)
  402ece:	4b08      	ldr	r3, [pc, #32]	; (402ef0 <ext_int_initialize+0x5c>)
  402ed0:	4798      	blx	r3
}
  402ed2:	bf00      	nop
  402ed4:	370c      	adds	r7, #12
  402ed6:	46bd      	mov	sp, r7
  402ed8:	bd90      	pop	{r4, r7, pc}
  402eda:	bf00      	nop
  402edc:	00404359 	.word	0x00404359
  402ee0:	400e1000 	.word	0x400e1000
  402ee4:	00400391 	.word	0x00400391
  402ee8:	004006cd 	.word	0x004006cd
  402eec:	00400765 	.word	0x00400765
  402ef0:	004004bd 	.word	0x004004bd

00402ef4 <configure_console>:
#define console_uart_irq_handler    FLEXCOM0_Handler

static uint8_t uart_rx_rb_buffer[512];
RingByteBuffer uart_rx_rb;

void configure_console(void){
  402ef4:	b590      	push	{r4, r7, lr}
  402ef6:	b089      	sub	sp, #36	; 0x24
  402ef8:	af00      	add	r7, sp, #0
	const usart_serial_options_t uart_serial_options_debug = {
  402efa:	4b18      	ldr	r3, [pc, #96]	; (402f5c <configure_console+0x68>)
  402efc:	f107 0410 	add.w	r4, r7, #16
  402f00:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  402f02:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		.paritytype = CONF_UART_PARITY,
		.stopbits = CONF_UART_STOP_BITS,
	};

	/* Configure debug UART. */
	sysclk_enable_peripheral_clock(DEBUG_UART_ID);
  402f06:	2007      	movs	r0, #7
  402f08:	4b15      	ldr	r3, [pc, #84]	; (402f60 <configure_console+0x6c>)
  402f0a:	4798      	blx	r3
	usart_serial_init(DEBUG_UART, (usart_serial_options_t *)&uart_serial_options_debug);
  402f0c:	f107 0310 	add.w	r3, r7, #16
  402f10:	4619      	mov	r1, r3
  402f12:	4814      	ldr	r0, [pc, #80]	; (402f64 <configure_console+0x70>)
  402f14:	4b14      	ldr	r3, [pc, #80]	; (402f68 <configure_console+0x74>)
  402f16:	4798      	blx	r3

	const usart_serial_options_t uart_serial_options = {
  402f18:	4b14      	ldr	r3, [pc, #80]	; (402f6c <configure_console+0x78>)
  402f1a:	463c      	mov	r4, r7
  402f1c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  402f1e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		.paritytype = CONF_UART_PARITY,
		.stopbits = CONF_UART_STOP_BITS,
	};

	/* Configure console UART. */
	sysclk_enable_peripheral_clock(CONSOLE_UART_ID);
  402f22:	2008      	movs	r0, #8
  402f24:	4b0e      	ldr	r3, [pc, #56]	; (402f60 <configure_console+0x6c>)
  402f26:	4798      	blx	r3
	usart_serial_init(CONF_UART, (usart_serial_options_t *)&uart_serial_options);
  402f28:	463b      	mov	r3, r7
  402f2a:	4619      	mov	r1, r3
  402f2c:	4810      	ldr	r0, [pc, #64]	; (402f70 <configure_console+0x7c>)
  402f2e:	4b0e      	ldr	r3, [pc, #56]	; (402f68 <configure_console+0x74>)
  402f30:	4798      	blx	r3

	RingByteBuffer_init(&uart_rx_rb, uart_rx_rb_buffer, sizeof(uart_rx_rb_buffer));
  402f32:	f44f 7200 	mov.w	r2, #512	; 0x200
  402f36:	490f      	ldr	r1, [pc, #60]	; (402f74 <configure_console+0x80>)
  402f38:	480f      	ldr	r0, [pc, #60]	; (402f78 <configure_console+0x84>)
  402f3a:	4b10      	ldr	r3, [pc, #64]	; (402f7c <configure_console+0x88>)
  402f3c:	4798      	blx	r3

	/* Enable UART IRQ */
	usart_enable_interrupt(CONSOLE_UART, US_IER_RXRDY);
  402f3e:	2101      	movs	r1, #1
  402f40:	480b      	ldr	r0, [pc, #44]	; (402f70 <configure_console+0x7c>)
  402f42:	4b0f      	ldr	r3, [pc, #60]	; (402f80 <configure_console+0x8c>)
  402f44:	4798      	blx	r3

	/* Enable UART interrupt */
	NVIC_SetPriority(CONSOLE_UART_IRQn, 0);
  402f46:	2100      	movs	r1, #0
  402f48:	2008      	movs	r0, #8
  402f4a:	4b0e      	ldr	r3, [pc, #56]	; (402f84 <configure_console+0x90>)
  402f4c:	4798      	blx	r3

	/* Enable UART interrupt */
	NVIC_EnableIRQ(CONSOLE_UART_IRQn);
  402f4e:	2008      	movs	r0, #8
  402f50:	4b0d      	ldr	r3, [pc, #52]	; (402f88 <configure_console+0x94>)
  402f52:	4798      	blx	r3
}
  402f54:	bf00      	nop
  402f56:	3724      	adds	r7, #36	; 0x24
  402f58:	46bd      	mov	sp, r7
  402f5a:	bd90      	pop	{r4, r7, pc}
  402f5c:	0041be9c 	.word	0x0041be9c
  402f60:	00402a8d 	.word	0x00402a8d
  402f64:	40034200 	.word	0x40034200
  402f68:	00402aa9 	.word	0x00402aa9
  402f6c:	0041beac 	.word	0x0041beac
  402f70:	4000c200 	.word	0x4000c200
  402f74:	20001210 	.word	0x20001210
  402f78:	20001ed0 	.word	0x20001ed0
  402f7c:	0040ff9d 	.word	0x0040ff9d
  402f80:	004034c5 	.word	0x004034c5
  402f84:	00402981 	.word	0x00402981
  402f88:	004028e5 	.word	0x004028e5

00402f8c <FLEXCOM0_Handler>:

/**
* \brief Interrupt handler for USART interrupt.
*/
void console_uart_irq_handler(void){
  402f8c:	b580      	push	{r7, lr}
  402f8e:	b082      	sub	sp, #8
  402f90:	af00      	add	r7, sp, #0
	uint32_t ul_status;

	/* Read USART Status. */
	ul_status = usart_get_status(CONSOLE_UART);
  402f92:	480e      	ldr	r0, [pc, #56]	; (402fcc <FLEXCOM0_Handler+0x40>)
  402f94:	4b0e      	ldr	r3, [pc, #56]	; (402fd0 <FLEXCOM0_Handler+0x44>)
  402f96:	4798      	blx	r3
  402f98:	6078      	str	r0, [r7, #4]

	if((ul_status &  US_CSR_RXRDY ))
  402f9a:	687b      	ldr	r3, [r7, #4]
  402f9c:	f003 0301 	and.w	r3, r3, #1
  402fa0:	2b00      	cmp	r3, #0
  402fa2:	d00f      	beq.n	402fc4 <FLEXCOM0_Handler+0x38>
	{
		uint8_t rxbyte;
		usart_serial_getchar(CONSOLE_UART, &rxbyte);
  402fa4:	1cfb      	adds	r3, r7, #3
  402fa6:	4619      	mov	r1, r3
  402fa8:	4808      	ldr	r0, [pc, #32]	; (402fcc <FLEXCOM0_Handler+0x40>)
  402faa:	4b0a      	ldr	r3, [pc, #40]	; (402fd4 <FLEXCOM0_Handler+0x48>)
  402fac:	4798      	blx	r3
		if(!RingByteBuffer_isFull(&uart_rx_rb))
  402fae:	480a      	ldr	r0, [pc, #40]	; (402fd8 <FLEXCOM0_Handler+0x4c>)
  402fb0:	4b0a      	ldr	r3, [pc, #40]	; (402fdc <FLEXCOM0_Handler+0x50>)
  402fb2:	4798      	blx	r3
  402fb4:	4603      	mov	r3, r0
  402fb6:	2b00      	cmp	r3, #0
  402fb8:	d104      	bne.n	402fc4 <FLEXCOM0_Handler+0x38>
			RingByteBuffer_pushByte(&uart_rx_rb, rxbyte);
  402fba:	78fb      	ldrb	r3, [r7, #3]
  402fbc:	4619      	mov	r1, r3
  402fbe:	4806      	ldr	r0, [pc, #24]	; (402fd8 <FLEXCOM0_Handler+0x4c>)
  402fc0:	4b07      	ldr	r3, [pc, #28]	; (402fe0 <FLEXCOM0_Handler+0x54>)
  402fc2:	4798      	blx	r3
	}
}
  402fc4:	bf00      	nop
  402fc6:	3708      	adds	r7, #8
  402fc8:	46bd      	mov	sp, r7
  402fca:	bd80      	pop	{r7, pc}
  402fcc:	4000c200 	.word	0x4000c200
  402fd0:	004034e1 	.word	0x004034e1
  402fd4:	00402cd1 	.word	0x00402cd1
  402fd8:	20001ed0 	.word	0x20001ed0
  402fdc:	00402e4b 	.word	0x00402e4b
  402fe0:	0040fff5 	.word	0x0040fff5

00402fe4 <i2c_master_initialize>:

#if SERIF_TYPE_I2C
twi_options_t opt;
twi_packet_t packet_tx, packet_rx;

static void i2c_master_initialize(void){
  402fe4:	b580      	push	{r7, lr}
  402fe6:	af00      	add	r7, sp, #0
	/* Insert application code here, after the board has been initialized. */
	/* Enable the peripheral and set TWI mode. */
	flexcom_enable(BOARD_FLEXCOM_TWI);
  402fe8:	480a      	ldr	r0, [pc, #40]	; (403014 <i2c_master_initialize+0x30>)
  402fea:	4b0b      	ldr	r3, [pc, #44]	; (403018 <i2c_master_initialize+0x34>)
  402fec:	4798      	blx	r3
	flexcom_set_opmode(BOARD_FLEXCOM_TWI, FLEXCOM_TWI);
  402fee:	2103      	movs	r1, #3
  402ff0:	4808      	ldr	r0, [pc, #32]	; (403014 <i2c_master_initialize+0x30>)
  402ff2:	4b0a      	ldr	r3, [pc, #40]	; (40301c <i2c_master_initialize+0x38>)
  402ff4:	4798      	blx	r3

	/* Configure the options of TWI driver */
	opt.master_clk = sysclk_get_peripheral_hz();
  402ff6:	4b0a      	ldr	r3, [pc, #40]	; (403020 <i2c_master_initialize+0x3c>)
  402ff8:	4798      	blx	r3
  402ffa:	4602      	mov	r2, r0
  402ffc:	4b09      	ldr	r3, [pc, #36]	; (403024 <i2c_master_initialize+0x40>)
  402ffe:	601a      	str	r2, [r3, #0]
	opt.speed = TWI_CLK;
  403000:	4b08      	ldr	r3, [pc, #32]	; (403024 <i2c_master_initialize+0x40>)
  403002:	4a09      	ldr	r2, [pc, #36]	; (403028 <i2c_master_initialize+0x44>)
  403004:	605a      	str	r2, [r3, #4]

	twi_master_init(BOARD_BASE_TWI, &opt);
  403006:	4907      	ldr	r1, [pc, #28]	; (403024 <i2c_master_initialize+0x40>)
  403008:	4808      	ldr	r0, [pc, #32]	; (40302c <i2c_master_initialize+0x48>)
  40300a:	4b09      	ldr	r3, [pc, #36]	; (403030 <i2c_master_initialize+0x4c>)
  40300c:	4798      	blx	r3
}
  40300e:	bf00      	nop
  403010:	bd80      	pop	{r7, pc}
  403012:	bf00      	nop
  403014:	4001c000 	.word	0x4001c000
  403018:	004036a1 	.word	0x004036a1
  40301c:	00403809 	.word	0x00403809
  403020:	00402a79 	.word	0x00402a79
  403024:	20001ea4 	.word	0x20001ea4
  403028:	00061a80 	.word	0x00061a80
  40302c:	4001c600 	.word	0x4001c600
  403030:	004009ed 	.word	0x004009ed

00403034 <i2c_master_read_register>:

static unsigned long i2c_master_read_register(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, unsigned char *RegisterValue){
  403034:	b580      	push	{r7, lr}
  403036:	b088      	sub	sp, #32
  403038:	af00      	add	r7, sp, #0
  40303a:	603b      	str	r3, [r7, #0]
  40303c:	4603      	mov	r3, r0
  40303e:	71fb      	strb	r3, [r7, #7]
  403040:	460b      	mov	r3, r1
  403042:	71bb      	strb	r3, [r7, #6]
  403044:	4613      	mov	r3, r2
  403046:	80bb      	strh	r3, [r7, #4]
	twi_packet_t packet_read;

	if(Address == 0){
  403048:	79fb      	ldrb	r3, [r7, #7]
  40304a:	2b00      	cmp	r3, #0
  40304c:	d102      	bne.n	403054 <i2c_master_read_register+0x20>
		Address = I2C_Address;	// Slave Address is 0x69 for on-board sensors, 0x68 for external sensors
  40304e:	4b0e      	ldr	r3, [pc, #56]	; (403088 <i2c_master_read_register+0x54>)
  403050:	781b      	ldrb	r3, [r3, #0]
  403052:	71fb      	strb	r3, [r7, #7]
	}

	packet_read.chip = Address;
  403054:	79fb      	ldrb	r3, [r7, #7]
  403056:	773b      	strb	r3, [r7, #28]
	packet_read.addr[0] = RegisterAddr;
  403058:	79bb      	ldrb	r3, [r7, #6]
  40305a:	733b      	strb	r3, [r7, #12]
	packet_read.addr_length = 1;
  40305c:	2301      	movs	r3, #1
  40305e:	613b      	str	r3, [r7, #16]
	packet_read.buffer = RegisterValue;
  403060:	683b      	ldr	r3, [r7, #0]
  403062:	617b      	str	r3, [r7, #20]
	packet_read.length = RegisterLen;
  403064:	88bb      	ldrh	r3, [r7, #4]
  403066:	61bb      	str	r3, [r7, #24]

	if(twi_master_read((Twi*)BOARD_BASE_TWI, &packet_read) == TWI_SUCCESS){
  403068:	f107 030c 	add.w	r3, r7, #12
  40306c:	4619      	mov	r1, r3
  40306e:	4807      	ldr	r0, [pc, #28]	; (40308c <i2c_master_read_register+0x58>)
  403070:	4b07      	ldr	r3, [pc, #28]	; (403090 <i2c_master_read_register+0x5c>)
  403072:	4798      	blx	r3
  403074:	4603      	mov	r3, r0
  403076:	2b00      	cmp	r3, #0
  403078:	d101      	bne.n	40307e <i2c_master_read_register+0x4a>
		return TWI_SUCCESS;
  40307a:	2300      	movs	r3, #0
  40307c:	e000      	b.n	403080 <i2c_master_read_register+0x4c>
	}
	return TWI_BUSY;
  40307e:	2308      	movs	r3, #8
}
  403080:	4618      	mov	r0, r3
  403082:	3720      	adds	r7, #32
  403084:	46bd      	mov	sp, r7
  403086:	bd80      	pop	{r7, pc}
  403088:	20000118 	.word	0x20000118
  40308c:	4001c600 	.word	0x4001c600
  403090:	00400b1d 	.word	0x00400b1d

00403094 <i2c_master_write_register>:

static unsigned long i2c_master_write_register(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, const unsigned char *RegisterValue){
  403094:	b580      	push	{r7, lr}
  403096:	b088      	sub	sp, #32
  403098:	af00      	add	r7, sp, #0
  40309a:	603b      	str	r3, [r7, #0]
  40309c:	4603      	mov	r3, r0
  40309e:	71fb      	strb	r3, [r7, #7]
  4030a0:	460b      	mov	r3, r1
  4030a2:	71bb      	strb	r3, [r7, #6]
  4030a4:	4613      	mov	r3, r2
  4030a6:	80bb      	strh	r3, [r7, #4]
	twi_packet_t packet_write;

	if(Address == 0){
  4030a8:	79fb      	ldrb	r3, [r7, #7]
  4030aa:	2b00      	cmp	r3, #0
  4030ac:	d102      	bne.n	4030b4 <i2c_master_write_register+0x20>
		Address = I2C_Address; // Slave Address is 0x69 for on-board sensors, 0x68 for external sensors
  4030ae:	4b0c      	ldr	r3, [pc, #48]	; (4030e0 <i2c_master_write_register+0x4c>)
  4030b0:	781b      	ldrb	r3, [r3, #0]
  4030b2:	71fb      	strb	r3, [r7, #7]
	}
	packet_write.chip = Address;
  4030b4:	79fb      	ldrb	r3, [r7, #7]
  4030b6:	773b      	strb	r3, [r7, #28]
	packet_write.addr[0] = RegisterAddr;
  4030b8:	79bb      	ldrb	r3, [r7, #6]
  4030ba:	733b      	strb	r3, [r7, #12]
	packet_write.addr_length = 1;
  4030bc:	2301      	movs	r3, #1
  4030be:	613b      	str	r3, [r7, #16]
	packet_write.buffer = (void *)RegisterValue;
  4030c0:	683b      	ldr	r3, [r7, #0]
  4030c2:	617b      	str	r3, [r7, #20]
	packet_write.length = RegisterLen;
  4030c4:	88bb      	ldrh	r3, [r7, #4]
  4030c6:	61bb      	str	r3, [r7, #24]

	return twi_master_write((Twi*)BOARD_BASE_TWI, &packet_write);
  4030c8:	f107 030c 	add.w	r3, r7, #12
  4030cc:	4619      	mov	r1, r3
  4030ce:	4805      	ldr	r0, [pc, #20]	; (4030e4 <i2c_master_write_register+0x50>)
  4030d0:	4b05      	ldr	r3, [pc, #20]	; (4030e8 <i2c_master_write_register+0x54>)
  4030d2:	4798      	blx	r3
  4030d4:	4603      	mov	r3, r0
}
  4030d6:	4618      	mov	r0, r3
  4030d8:	3720      	adds	r7, #32
  4030da:	46bd      	mov	sp, r7
  4030dc:	bd80      	pop	{r7, pc}
  4030de:	bf00      	nop
  4030e0:	20000118 	.word	0x20000118
  4030e4:	4001c600 	.word	0x4001c600
  4030e8:	00400c29 	.word	0x00400c29

004030ec <interface_is_SPI>:

	return 0;
}
#endif

inv_bool_t interface_is_SPI(void){
  4030ec:	b480      	push	{r7}
  4030ee:	af00      	add	r7, sp, #0
#if SERIF_TYPE_SPI
	return true;
#else
	return false;
  4030f0:	2300      	movs	r3, #0
#endif
}
  4030f2:	4618      	mov	r0, r3
  4030f4:	46bd      	mov	sp, r7
  4030f6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4030fa:	4770      	bx	lr

004030fc <interface_initialize>:

void interface_initialize(void){
  4030fc:	b580      	push	{r7, lr}
  4030fe:	af00      	add	r7, sp, #0
#if SERIF_TYPE_SPI
	spi_master_initialize();
#endif

#if SERIF_TYPE_I2C
	i2c_master_initialize();
  403100:	4b01      	ldr	r3, [pc, #4]	; (403108 <interface_initialize+0xc>)
  403102:	4798      	blx	r3
#endif
}
  403104:	bf00      	nop
  403106:	bd80      	pop	{r7, pc}
  403108:	00402fe5 	.word	0x00402fe5

0040310c <hw_timer_start>:

InvScheduler 	scheduler;

void hw_timer_start(uint32_t timer_freq){
  40310c:	b590      	push	{r4, r7, lr}
  40310e:	b089      	sub	sp, #36	; 0x24
  403110:	af02      	add	r7, sp, #8
  403112:	6078      	str	r0, [r7, #4]
	uint32_t counts;
	uint32_t ul_div;
	uint32_t ul_tcclks;
	uint32_t ul_sysclk = sysclk_get_cpu_hz();
  403114:	4b20      	ldr	r3, [pc, #128]	; (403198 <hw_timer_start+0x8c>)
  403116:	4798      	blx	r3
  403118:	6178      	str	r0, [r7, #20]

	NVIC_DisableIRQ(TC0_IRQn);
  40311a:	2017      	movs	r0, #23
  40311c:	4b1f      	ldr	r3, [pc, #124]	; (40319c <hw_timer_start+0x90>)
  40311e:	4798      	blx	r3
	NVIC_ClearPendingIRQ(TC0_IRQn);
  403120:	2017      	movs	r0, #23
  403122:	4b1f      	ldr	r3, [pc, #124]	; (4031a0 <hw_timer_start+0x94>)
  403124:	4798      	blx	r3
	tc_find_mck_divisor((uint32_t)(timer_freq),		// The desired frequency as a uint32.
  403126:	f107 0108 	add.w	r1, r7, #8
  40312a:	f107 020c 	add.w	r2, r7, #12
  40312e:	697b      	ldr	r3, [r7, #20]
  403130:	9300      	str	r3, [sp, #0]
  403132:	460b      	mov	r3, r1
  403134:	6979      	ldr	r1, [r7, #20]
  403136:	6878      	ldr	r0, [r7, #4]
  403138:	4c1a      	ldr	r4, [pc, #104]	; (4031a4 <hw_timer_start+0x98>)
  40313a:	47a0      	blx	r4
		&ul_div,					// Pointer to register where divisor will be stored.
		&ul_tcclks,					// Pointer to reg where clock selection number is stored.
		ul_sysclk);					// Board clock freq in Hz.


	tc_init(TC0, 0, ul_tcclks | TC_CMR_CPCTRG);
  40313c:	68bb      	ldr	r3, [r7, #8]
  40313e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  403142:	461a      	mov	r2, r3
  403144:	2100      	movs	r1, #0
  403146:	4818      	ldr	r0, [pc, #96]	; (4031a8 <hw_timer_start+0x9c>)
  403148:	4b18      	ldr	r3, [pc, #96]	; (4031ac <hw_timer_start+0xa0>)
  40314a:	4798      	blx	r3

	/* Find the best estimate of counts, then write it to TC register C. */
	counts = (ul_sysclk/ul_div)/timer_freq;
  40314c:	68fb      	ldr	r3, [r7, #12]
  40314e:	697a      	ldr	r2, [r7, #20]
  403150:	fbb2 f2f3 	udiv	r2, r2, r3
  403154:	687b      	ldr	r3, [r7, #4]
  403156:	fbb2 f3f3 	udiv	r3, r2, r3
  40315a:	613b      	str	r3, [r7, #16]

	tc_write_rc(TC0, 0, counts);
  40315c:	693a      	ldr	r2, [r7, #16]
  40315e:	2100      	movs	r1, #0
  403160:	4811      	ldr	r0, [pc, #68]	; (4031a8 <hw_timer_start+0x9c>)
  403162:	4b13      	ldr	r3, [pc, #76]	; (4031b0 <hw_timer_start+0xa4>)
  403164:	4798      	blx	r3
	tc_get_status(TC0, 0);
  403166:	2100      	movs	r1, #0
  403168:	480f      	ldr	r0, [pc, #60]	; (4031a8 <hw_timer_start+0x9c>)
  40316a:	4b12      	ldr	r3, [pc, #72]	; (4031b4 <hw_timer_start+0xa8>)
  40316c:	4798      	blx	r3
	tc_enable_interrupt(TC0, 0, TC_IER_CPCS);
  40316e:	2210      	movs	r2, #16
  403170:	2100      	movs	r1, #0
  403172:	480d      	ldr	r0, [pc, #52]	; (4031a8 <hw_timer_start+0x9c>)
  403174:	4b10      	ldr	r3, [pc, #64]	; (4031b8 <hw_timer_start+0xac>)
  403176:	4798      	blx	r3
	tc_start(TC0, 0);
  403178:	2100      	movs	r1, #0
  40317a:	480b      	ldr	r0, [pc, #44]	; (4031a8 <hw_timer_start+0x9c>)
  40317c:	4b0f      	ldr	r3, [pc, #60]	; (4031bc <hw_timer_start+0xb0>)
  40317e:	4798      	blx	r3
	NVIC_SetPriority(TC0_IRQn,0);
  403180:	2100      	movs	r1, #0
  403182:	2017      	movs	r0, #23
  403184:	4b0e      	ldr	r3, [pc, #56]	; (4031c0 <hw_timer_start+0xb4>)
  403186:	4798      	blx	r3
	NVIC_EnableIRQ(TC0_IRQn);
  403188:	2017      	movs	r0, #23
  40318a:	4b0e      	ldr	r3, [pc, #56]	; (4031c4 <hw_timer_start+0xb8>)
  40318c:	4798      	blx	r3
}
  40318e:	bf00      	nop
  403190:	371c      	adds	r7, #28
  403192:	46bd      	mov	sp, r7
  403194:	bd90      	pop	{r4, r7, pc}
  403196:	bf00      	nop
  403198:	00402a65 	.word	0x00402a65
  40319c:	00402919 	.word	0x00402919
  4031a0:	0040294d 	.word	0x0040294d
  4031a4:	0040091f 	.word	0x0040091f
  4031a8:	40010000 	.word	0x40010000
  4031ac:	004007e9 	.word	0x004007e9
  4031b0:	00400889 	.word	0x00400889
  4031b4:	004008fb 	.word	0x004008fb
  4031b8:	004008af 	.word	0x004008af
  4031bc:	00400823 	.word	0x00400823
  4031c0:	00402981 	.word	0x00402981
  4031c4:	004028e5 	.word	0x004028e5

004031c8 <InvEMDFrontEnd_getTimestampUs>:
	NVIC_ClearPendingIRQ(TC0_IRQn);
}

static uint32_t Num50msTicks = 0;				// The timestamp timer ticks over every 50 ms.

uint64_t InvEMDFrontEnd_getTimestampUs(void){
  4031c8:	b590      	push	{r4, r7, lr}
  4031ca:	b083      	sub	sp, #12
  4031cc:	af00      	add	r7, sp, #0
	uint32_t timer_counter_value = tc_read_cv(TC0, 0);		// Read the timer counter
  4031ce:	2100      	movs	r1, #0
  4031d0:	480f      	ldr	r0, [pc, #60]	; (403210 <InvEMDFrontEnd_getTimestampUs+0x48>)
  4031d2:	4b10      	ldr	r3, [pc, #64]	; (403214 <InvEMDFrontEnd_getTimestampUs+0x4c>)
  4031d4:	4798      	blx	r3
  4031d6:	6078      	str	r0, [r7, #4]
	uint32_t max_counter_value = tc_read_rc(TC0, 0);		// read the timer limit
  4031d8:	2100      	movs	r1, #0
  4031da:	480d      	ldr	r0, [pc, #52]	; (403210 <InvEMDFrontEnd_getTimestampUs+0x48>)
  4031dc:	4b0e      	ldr	r3, [pc, #56]	; (403218 <InvEMDFrontEnd_getTimestampUs+0x50>)
  4031de:	4798      	blx	r3
  4031e0:	6038      	str	r0, [r7, #0]

	// In order to get a micro-second timestamp, we track the number of 50 ms intervals since startup or rollover.
	// This value is multiplied by the number of microseconds in 50 ms, and then add the number of microseconds since
	// the last 50 ms tick.
	// timer_counter_value / max_counter_value is the fraction of the current 50 ms interval that has already expired.
	return (Num50msTicks * MICROSECONDS_PER_50ms) + ((timer_counter_value * MICROSECONDS_PER_50ms) / max_counter_value);
  4031e2:	4b0e      	ldr	r3, [pc, #56]	; (40321c <InvEMDFrontEnd_getTimestampUs+0x54>)
  4031e4:	681b      	ldr	r3, [r3, #0]
  4031e6:	f24c 3250 	movw	r2, #50000	; 0xc350
  4031ea:	fb02 f203 	mul.w	r2, r2, r3
  4031ee:	687b      	ldr	r3, [r7, #4]
  4031f0:	f24c 3150 	movw	r1, #50000	; 0xc350
  4031f4:	fb01 f103 	mul.w	r1, r1, r3
  4031f8:	683b      	ldr	r3, [r7, #0]
  4031fa:	fbb1 f3f3 	udiv	r3, r1, r3
  4031fe:	4413      	add	r3, r2
  403200:	f04f 0400 	mov.w	r4, #0
}
  403204:	4618      	mov	r0, r3
  403206:	4621      	mov	r1, r4
  403208:	370c      	adds	r7, #12
  40320a:	46bd      	mov	sp, r7
  40320c:	bd90      	pop	{r4, r7, pc}
  40320e:	bf00      	nop
  403210:	40010000 	.word	0x40010000
  403214:	00400845 	.word	0x00400845
  403218:	00400867 	.word	0x00400867
  40321c:	20001410 	.word	0x20001410

00403220 <TC0_Handler>:

void TC0_Handler(void){
  403220:	b580      	push	{r7, lr}
  403222:	b082      	sub	sp, #8
  403224:	af00      	add	r7, sp, #0
	uint32_t ul_status;

	ul_status = tc_get_status(TC0, 0);
  403226:	2100      	movs	r1, #0
  403228:	480c      	ldr	r0, [pc, #48]	; (40325c <TC0_Handler+0x3c>)
  40322a:	4b0d      	ldr	r3, [pc, #52]	; (403260 <TC0_Handler+0x40>)
  40322c:	4798      	blx	r3
  40322e:	6078      	str	r0, [r7, #4]
	ul_status &= tc_get_interrupt_mask(TC0, 0);
  403230:	2100      	movs	r1, #0
  403232:	480a      	ldr	r0, [pc, #40]	; (40325c <TC0_Handler+0x3c>)
  403234:	4b0b      	ldr	r3, [pc, #44]	; (403264 <TC0_Handler+0x44>)
  403236:	4798      	blx	r3
  403238:	4602      	mov	r2, r0
  40323a:	687b      	ldr	r3, [r7, #4]
  40323c:	4013      	ands	r3, r2
  40323e:	607b      	str	r3, [r7, #4]

	if (ul_status & TC_SR_CPCS)
  403240:	687b      	ldr	r3, [r7, #4]
  403242:	f003 0310 	and.w	r3, r3, #16
  403246:	2b00      	cmp	r3, #0
  403248:	d004      	beq.n	403254 <TC0_Handler+0x34>
		Num50msTicks++;
  40324a:	4b07      	ldr	r3, [pc, #28]	; (403268 <TC0_Handler+0x48>)
  40324c:	681b      	ldr	r3, [r3, #0]
  40324e:	3301      	adds	r3, #1
  403250:	4a05      	ldr	r2, [pc, #20]	; (403268 <TC0_Handler+0x48>)
  403252:	6013      	str	r3, [r2, #0]
}
  403254:	bf00      	nop
  403256:	3708      	adds	r7, #8
  403258:	46bd      	mov	sp, r7
  40325a:	bd80      	pop	{r7, pc}
  40325c:	40010000 	.word	0x40010000
  403260:	004008fb 	.word	0x004008fb
  403264:	004008d7 	.word	0x004008d7
  403268:	20001410 	.word	0x20001410

0040326c <SysTick_Handler>:

volatile uint32_t ul_ticks = 0;

void SysTick_Handler(void){
  40326c:	b580      	push	{r7, lr}
  40326e:	af00      	add	r7, sp, #0
	ul_ticks++;
  403270:	4b04      	ldr	r3, [pc, #16]	; (403284 <SysTick_Handler+0x18>)
  403272:	681b      	ldr	r3, [r3, #0]
  403274:	3301      	adds	r3, #1
  403276:	4a03      	ldr	r2, [pc, #12]	; (403284 <SysTick_Handler+0x18>)
  403278:	6013      	str	r3, [r2, #0]
	InvScheduler_updateTime(&scheduler);
  40327a:	4803      	ldr	r0, [pc, #12]	; (403288 <SysTick_Handler+0x1c>)
  40327c:	4b03      	ldr	r3, [pc, #12]	; (40328c <SysTick_Handler+0x20>)
  40327e:	4798      	blx	r3
}
  403280:	bf00      	nop
  403282:	bd80      	pop	{r7, pc}
  403284:	20001414 	.word	0x20001414
  403288:	20001eb0 	.word	0x20001eb0
  40328c:	00402e2d 	.word	0x00402e2d

00403290 <idd_io_hal_read_reg>:

int idd_io_hal_read_reg(void * context, uint8_t reg, uint8_t * rbuffer, uint32_t rlen){
  403290:	b590      	push	{r4, r7, lr}
  403292:	b085      	sub	sp, #20
  403294:	af00      	add	r7, sp, #0
  403296:	60f8      	str	r0, [r7, #12]
  403298:	607a      	str	r2, [r7, #4]
  40329a:	603b      	str	r3, [r7, #0]
  40329c:	460b      	mov	r3, r1
  40329e:	72fb      	strb	r3, [r7, #11]
	(void)context;
#if SERIF_TYPE_SPI
	return spi_master_transfer_rx(NULL, reg, rbuffer, rlen);
#else /* SERIF_TYPE_I2C */
	return i2c_master_read_register(I2C_Address, reg, rlen, rbuffer);
  4032a0:	4b06      	ldr	r3, [pc, #24]	; (4032bc <idd_io_hal_read_reg+0x2c>)
  4032a2:	7818      	ldrb	r0, [r3, #0]
  4032a4:	683b      	ldr	r3, [r7, #0]
  4032a6:	b29a      	uxth	r2, r3
  4032a8:	7af9      	ldrb	r1, [r7, #11]
  4032aa:	687b      	ldr	r3, [r7, #4]
  4032ac:	4c04      	ldr	r4, [pc, #16]	; (4032c0 <idd_io_hal_read_reg+0x30>)
  4032ae:	47a0      	blx	r4
  4032b0:	4603      	mov	r3, r0
#endif
}
  4032b2:	4618      	mov	r0, r3
  4032b4:	3714      	adds	r7, #20
  4032b6:	46bd      	mov	sp, r7
  4032b8:	bd90      	pop	{r4, r7, pc}
  4032ba:	bf00      	nop
  4032bc:	20000118 	.word	0x20000118
  4032c0:	00403035 	.word	0x00403035

004032c4 <idd_io_hal_write_reg>:

int idd_io_hal_write_reg(void * context, uint8_t reg, const uint8_t * wbuffer, uint32_t wlen){
  4032c4:	b590      	push	{r4, r7, lr}
  4032c6:	b085      	sub	sp, #20
  4032c8:	af00      	add	r7, sp, #0
  4032ca:	60f8      	str	r0, [r7, #12]
  4032cc:	607a      	str	r2, [r7, #4]
  4032ce:	603b      	str	r3, [r7, #0]
  4032d0:	460b      	mov	r3, r1
  4032d2:	72fb      	strb	r3, [r7, #11]
	(void)context;
#if SERIF_TYPE_SPI
	return spi_master_transfer_tx(NULL, reg, wbuffer, wlen);
#else /* SERIF_TYPE_I2C */
	return i2c_master_write_register(I2C_Address, reg, wlen, wbuffer);
  4032d4:	4b06      	ldr	r3, [pc, #24]	; (4032f0 <idd_io_hal_write_reg+0x2c>)
  4032d6:	7818      	ldrb	r0, [r3, #0]
  4032d8:	683b      	ldr	r3, [r7, #0]
  4032da:	b29a      	uxth	r2, r3
  4032dc:	7af9      	ldrb	r1, [r7, #11]
  4032de:	687b      	ldr	r3, [r7, #4]
  4032e0:	4c04      	ldr	r4, [pc, #16]	; (4032f4 <idd_io_hal_write_reg+0x30>)
  4032e2:	47a0      	blx	r4
  4032e4:	4603      	mov	r3, r0
#endif
}
  4032e6:	4618      	mov	r0, r3
  4032e8:	3714      	adds	r7, #20
  4032ea:	46bd      	mov	sp, r7
  4032ec:	bd90      	pop	{r4, r7, pc}
  4032ee:	bf00      	nop
  4032f0:	20000118 	.word	0x20000118
  4032f4:	00403095 	.word	0x00403095

004032f8 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  4032f8:	b480      	push	{r7}
  4032fa:	b089      	sub	sp, #36	; 0x24
  4032fc:	af00      	add	r7, sp, #0
  4032fe:	60f8      	str	r0, [r7, #12]
  403300:	60b9      	str	r1, [r7, #8]
  403302:	607a      	str	r2, [r7, #4]
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  403304:	68bb      	ldr	r3, [r7, #8]
  403306:	011a      	lsls	r2, r3, #4
  403308:	687b      	ldr	r3, [r7, #4]
  40330a:	429a      	cmp	r2, r3
  40330c:	d802      	bhi.n	403314 <usart_set_async_baudrate+0x1c>
		over = HIGH_FRQ_SAMPLE_DIV;
  40330e:	2310      	movs	r3, #16
  403310:	61fb      	str	r3, [r7, #28]
  403312:	e001      	b.n	403318 <usart_set_async_baudrate+0x20>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
  403314:	2308      	movs	r3, #8
  403316:	61fb      	str	r3, [r7, #28]
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  403318:	687b      	ldr	r3, [r7, #4]
  40331a:	00da      	lsls	r2, r3, #3
  40331c:	69fb      	ldr	r3, [r7, #28]
  40331e:	68b9      	ldr	r1, [r7, #8]
  403320:	fb01 f303 	mul.w	r3, r1, r3
  403324:	085b      	lsrs	r3, r3, #1
  403326:	441a      	add	r2, r3
  403328:	69fb      	ldr	r3, [r7, #28]
  40332a:	68b9      	ldr	r1, [r7, #8]
  40332c:	fb01 f303 	mul.w	r3, r1, r3
  403330:	fbb2 f3f3 	udiv	r3, r2, r3
  403334:	61bb      	str	r3, [r7, #24]
	cd = cd_fp >> 3;
  403336:	69bb      	ldr	r3, [r7, #24]
  403338:	08db      	lsrs	r3, r3, #3
  40333a:	617b      	str	r3, [r7, #20]
	fp = cd_fp & 0x07;
  40333c:	69bb      	ldr	r3, [r7, #24]
  40333e:	f003 0307 	and.w	r3, r3, #7
  403342:	613b      	str	r3, [r7, #16]
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  403344:	697b      	ldr	r3, [r7, #20]
  403346:	2b00      	cmp	r3, #0
  403348:	d003      	beq.n	403352 <usart_set_async_baudrate+0x5a>
  40334a:	697b      	ldr	r3, [r7, #20]
  40334c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  403350:	d301      	bcc.n	403356 <usart_set_async_baudrate+0x5e>
		return 1;
  403352:	2301      	movs	r3, #1
  403354:	e00f      	b.n	403376 <usart_set_async_baudrate+0x7e>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
  403356:	69fb      	ldr	r3, [r7, #28]
  403358:	2b08      	cmp	r3, #8
  40335a:	d105      	bne.n	403368 <usart_set_async_baudrate+0x70>
		p_usart->US_MR |= US_MR_OVER;
  40335c:	68fb      	ldr	r3, [r7, #12]
  40335e:	685b      	ldr	r3, [r3, #4]
  403360:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
  403364:	68fb      	ldr	r3, [r7, #12]
  403366:	605a      	str	r2, [r3, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  403368:	693b      	ldr	r3, [r7, #16]
  40336a:	041a      	lsls	r2, r3, #16
  40336c:	697b      	ldr	r3, [r7, #20]
  40336e:	431a      	orrs	r2, r3
  403370:	68fb      	ldr	r3, [r7, #12]
  403372:	621a      	str	r2, [r3, #32]

	return 0;
  403374:	2300      	movs	r3, #0
}
  403376:	4618      	mov	r0, r3
  403378:	3724      	adds	r7, #36	; 0x24
  40337a:	46bd      	mov	sp, r7
  40337c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403380:	4770      	bx	lr
	...

00403384 <usart_reset>:
 * \brief Reset the USART and disable TX and RX.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset(Usart *p_usart)
{
  403384:	b580      	push	{r7, lr}
  403386:	b082      	sub	sp, #8
  403388:	af00      	add	r7, sp, #0
  40338a:	6078      	str	r0, [r7, #4]
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);
  40338c:	6878      	ldr	r0, [r7, #4]
  40338e:	4b0d      	ldr	r3, [pc, #52]	; (4033c4 <usart_reset+0x40>)
  403390:	4798      	blx	r3

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  403392:	687b      	ldr	r3, [r7, #4]
  403394:	2200      	movs	r2, #0
  403396:	605a      	str	r2, [r3, #4]
	p_usart->US_RTOR = 0;
  403398:	687b      	ldr	r3, [r7, #4]
  40339a:	2200      	movs	r2, #0
  40339c:	625a      	str	r2, [r3, #36]	; 0x24
	p_usart->US_TTGR = 0;
  40339e:	687b      	ldr	r3, [r7, #4]
  4033a0:	2200      	movs	r2, #0
  4033a2:	629a      	str	r2, [r3, #40]	; 0x28

	/* Disable TX and RX. */
	usart_reset_tx(p_usart);
  4033a4:	6878      	ldr	r0, [r7, #4]
  4033a6:	4b08      	ldr	r3, [pc, #32]	; (4033c8 <usart_reset+0x44>)
  4033a8:	4798      	blx	r3
	usart_reset_rx(p_usart);
  4033aa:	6878      	ldr	r0, [r7, #4]
  4033ac:	4b07      	ldr	r3, [pc, #28]	; (4033cc <usart_reset+0x48>)
  4033ae:	4798      	blx	r3
	/* Reset status bits. */
	usart_reset_status(p_usart);
  4033b0:	6878      	ldr	r0, [r7, #4]
  4033b2:	4b07      	ldr	r3, [pc, #28]	; (4033d0 <usart_reset+0x4c>)
  4033b4:	4798      	blx	r3
	/* Turn off RTS and DTR if exist. */
	usart_drive_RTS_pin_high(p_usart);
  4033b6:	6878      	ldr	r0, [r7, #4]
  4033b8:	4b06      	ldr	r3, [pc, #24]	; (4033d4 <usart_reset+0x50>)
  4033ba:	4798      	blx	r3
#if (SAM3S || SAM4S || SAM3U || SAM4L || SAM4E)
	usart_drive_DTR_pin_high(p_usart);
#endif
}
  4033bc:	bf00      	nop
  4033be:	3708      	adds	r7, #8
  4033c0:	46bd      	mov	sp, r7
  4033c2:	bd80      	pop	{r7, pc}
  4033c4:	00403599 	.word	0x00403599
  4033c8:	00403477 	.word	0x00403477
  4033cc:	004034ab 	.word	0x004034ab
  4033d0:	004034f9 	.word	0x004034f9
  4033d4:	00403515 	.word	0x00403515

004033d8 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  4033d8:	b580      	push	{r7, lr}
  4033da:	b084      	sub	sp, #16
  4033dc:	af00      	add	r7, sp, #0
  4033de:	60f8      	str	r0, [r7, #12]
  4033e0:	60b9      	str	r1, [r7, #8]
  4033e2:	607a      	str	r2, [r7, #4]
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
  4033e4:	68f8      	ldr	r0, [r7, #12]
  4033e6:	4b1a      	ldr	r3, [pc, #104]	; (403450 <usart_init_rs232+0x78>)
  4033e8:	4798      	blx	r3

	ul_reg_val = 0;
  4033ea:	4b1a      	ldr	r3, [pc, #104]	; (403454 <usart_init_rs232+0x7c>)
  4033ec:	2200      	movs	r2, #0
  4033ee:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  4033f0:	68bb      	ldr	r3, [r7, #8]
  4033f2:	2b00      	cmp	r3, #0
  4033f4:	d009      	beq.n	40340a <usart_init_rs232+0x32>
  4033f6:	68bb      	ldr	r3, [r7, #8]
  4033f8:	681b      	ldr	r3, [r3, #0]
  4033fa:	687a      	ldr	r2, [r7, #4]
  4033fc:	4619      	mov	r1, r3
  4033fe:	68f8      	ldr	r0, [r7, #12]
  403400:	4b15      	ldr	r3, [pc, #84]	; (403458 <usart_init_rs232+0x80>)
  403402:	4798      	blx	r3
  403404:	4603      	mov	r3, r0
  403406:	2b00      	cmp	r3, #0
  403408:	d001      	beq.n	40340e <usart_init_rs232+0x36>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
  40340a:	2301      	movs	r3, #1
  40340c:	e01b      	b.n	403446 <usart_init_rs232+0x6e>
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  40340e:	68bb      	ldr	r3, [r7, #8]
  403410:	685a      	ldr	r2, [r3, #4]
  403412:	68bb      	ldr	r3, [r7, #8]
  403414:	689b      	ldr	r3, [r3, #8]
  403416:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  403418:	68bb      	ldr	r3, [r7, #8]
  40341a:	691b      	ldr	r3, [r3, #16]
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  40341c:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  40341e:	68bb      	ldr	r3, [r7, #8]
  403420:	68db      	ldr	r3, [r3, #12]
  403422:	431a      	orrs	r2, r3
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  403424:	4b0b      	ldr	r3, [pc, #44]	; (403454 <usart_init_rs232+0x7c>)
  403426:	681b      	ldr	r3, [r3, #0]
  403428:	4313      	orrs	r3, r2
  40342a:	4a0a      	ldr	r2, [pc, #40]	; (403454 <usart_init_rs232+0x7c>)
  40342c:	6013      	str	r3, [r2, #0]

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;
  40342e:	4b09      	ldr	r3, [pc, #36]	; (403454 <usart_init_rs232+0x7c>)
  403430:	681b      	ldr	r3, [r3, #0]
  403432:	4a08      	ldr	r2, [pc, #32]	; (403454 <usart_init_rs232+0x7c>)
  403434:	6013      	str	r3, [r2, #0]

	p_usart->US_MR |= ul_reg_val;
  403436:	68fb      	ldr	r3, [r7, #12]
  403438:	685a      	ldr	r2, [r3, #4]
  40343a:	4b06      	ldr	r3, [pc, #24]	; (403454 <usart_init_rs232+0x7c>)
  40343c:	681b      	ldr	r3, [r3, #0]
  40343e:	431a      	orrs	r2, r3
  403440:	68fb      	ldr	r3, [r7, #12]
  403442:	605a      	str	r2, [r3, #4]

	return 0;
  403444:	2300      	movs	r3, #0
}
  403446:	4618      	mov	r0, r3
  403448:	3710      	adds	r7, #16
  40344a:	46bd      	mov	sp, r7
  40344c:	bd80      	pop	{r7, pc}
  40344e:	bf00      	nop
  403450:	00403385 	.word	0x00403385
  403454:	20001418 	.word	0x20001418
  403458:	004032f9 	.word	0x004032f9

0040345c <usart_enable_tx>:
 * \brief Enable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
  40345c:	b480      	push	{r7}
  40345e:	b083      	sub	sp, #12
  403460:	af00      	add	r7, sp, #0
  403462:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_TXEN;
  403464:	687b      	ldr	r3, [r7, #4]
  403466:	2240      	movs	r2, #64	; 0x40
  403468:	601a      	str	r2, [r3, #0]
}
  40346a:	bf00      	nop
  40346c:	370c      	adds	r7, #12
  40346e:	46bd      	mov	sp, r7
  403470:	f85d 7b04 	ldr.w	r7, [sp], #4
  403474:	4770      	bx	lr

00403476 <usart_reset_tx>:
 * \brief Immediately stop and disable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
  403476:	b480      	push	{r7}
  403478:	b083      	sub	sp, #12
  40347a:	af00      	add	r7, sp, #0
  40347c:	6078      	str	r0, [r7, #4]
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  40347e:	687b      	ldr	r3, [r7, #4]
  403480:	2288      	movs	r2, #136	; 0x88
  403482:	601a      	str	r2, [r3, #0]
}
  403484:	bf00      	nop
  403486:	370c      	adds	r7, #12
  403488:	46bd      	mov	sp, r7
  40348a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40348e:	4770      	bx	lr

00403490 <usart_enable_rx>:
 * \brief Enable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
  403490:	b480      	push	{r7}
  403492:	b083      	sub	sp, #12
  403494:	af00      	add	r7, sp, #0
  403496:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RXEN;
  403498:	687b      	ldr	r3, [r7, #4]
  40349a:	2210      	movs	r2, #16
  40349c:	601a      	str	r2, [r3, #0]
}
  40349e:	bf00      	nop
  4034a0:	370c      	adds	r7, #12
  4034a2:	46bd      	mov	sp, r7
  4034a4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4034a8:	4770      	bx	lr

004034aa <usart_reset_rx>:
 * \brief Immediately stop and disable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
  4034aa:	b480      	push	{r7}
  4034ac:	b083      	sub	sp, #12
  4034ae:	af00      	add	r7, sp, #0
  4034b0:	6078      	str	r0, [r7, #4]
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  4034b2:	687b      	ldr	r3, [r7, #4]
  4034b4:	2224      	movs	r2, #36	; 0x24
  4034b6:	601a      	str	r2, [r3, #0]
}
  4034b8:	bf00      	nop
  4034ba:	370c      	adds	r7, #12
  4034bc:	46bd      	mov	sp, r7
  4034be:	f85d 7b04 	ldr.w	r7, [sp], #4
  4034c2:	4770      	bx	lr

004034c4 <usart_enable_interrupt>:
 *
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
  4034c4:	b480      	push	{r7}
  4034c6:	b083      	sub	sp, #12
  4034c8:	af00      	add	r7, sp, #0
  4034ca:	6078      	str	r0, [r7, #4]
  4034cc:	6039      	str	r1, [r7, #0]
	p_usart->US_IER = ul_sources;
  4034ce:	687b      	ldr	r3, [r7, #4]
  4034d0:	683a      	ldr	r2, [r7, #0]
  4034d2:	609a      	str	r2, [r3, #8]
}
  4034d4:	bf00      	nop
  4034d6:	370c      	adds	r7, #12
  4034d8:	46bd      	mov	sp, r7
  4034da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4034de:	4770      	bx	lr

004034e0 <usart_get_status>:
 * \param p_usart Pointer to a USART instance.
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
  4034e0:	b480      	push	{r7}
  4034e2:	b083      	sub	sp, #12
  4034e4:	af00      	add	r7, sp, #0
  4034e6:	6078      	str	r0, [r7, #4]
	return p_usart->US_CSR;
  4034e8:	687b      	ldr	r3, [r7, #4]
  4034ea:	695b      	ldr	r3, [r3, #20]
}
  4034ec:	4618      	mov	r0, r3
  4034ee:	370c      	adds	r7, #12
  4034f0:	46bd      	mov	sp, r7
  4034f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4034f6:	4770      	bx	lr

004034f8 <usart_reset_status>:
 * \brief Reset status bits (PARE, OVER, MANERR, UNRE and PXBRK in US_CSR).
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
  4034f8:	b480      	push	{r7}
  4034fa:	b083      	sub	sp, #12
  4034fc:	af00      	add	r7, sp, #0
  4034fe:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RSTSTA;
  403500:	687b      	ldr	r3, [r7, #4]
  403502:	f44f 7280 	mov.w	r2, #256	; 0x100
  403506:	601a      	str	r2, [r3, #0]
}
  403508:	bf00      	nop
  40350a:	370c      	adds	r7, #12
  40350c:	46bd      	mov	sp, r7
  40350e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403512:	4770      	bx	lr

00403514 <usart_drive_RTS_pin_high>:
 * \brief Drive the pin RTS to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
  403514:	b480      	push	{r7}
  403516:	b083      	sub	sp, #12
  403518:	af00      	add	r7, sp, #0
  40351a:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RTSDIS;
  40351c:	687b      	ldr	r3, [r7, #4]
  40351e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  403522:	601a      	str	r2, [r3, #0]
}
  403524:	bf00      	nop
  403526:	370c      	adds	r7, #12
  403528:	46bd      	mov	sp, r7
  40352a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40352e:	4770      	bx	lr

00403530 <usart_write>:
 *
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
  403530:	b480      	push	{r7}
  403532:	b083      	sub	sp, #12
  403534:	af00      	add	r7, sp, #0
  403536:	6078      	str	r0, [r7, #4]
  403538:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  40353a:	687b      	ldr	r3, [r7, #4]
  40353c:	695b      	ldr	r3, [r3, #20]
  40353e:	f003 0302 	and.w	r3, r3, #2
  403542:	2b00      	cmp	r3, #0
  403544:	d101      	bne.n	40354a <usart_write+0x1a>
		return 1;
  403546:	2301      	movs	r3, #1
  403548:	e005      	b.n	403556 <usart_write+0x26>
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  40354a:	683b      	ldr	r3, [r7, #0]
  40354c:	f3c3 0208 	ubfx	r2, r3, #0, #9
  403550:	687b      	ldr	r3, [r7, #4]
  403552:	61da      	str	r2, [r3, #28]
	return 0;
  403554:	2300      	movs	r3, #0
}
  403556:	4618      	mov	r0, r3
  403558:	370c      	adds	r7, #12
  40355a:	46bd      	mov	sp, r7
  40355c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403560:	4770      	bx	lr

00403562 <usart_read>:
 *
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
  403562:	b480      	push	{r7}
  403564:	b083      	sub	sp, #12
  403566:	af00      	add	r7, sp, #0
  403568:	6078      	str	r0, [r7, #4]
  40356a:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  40356c:	687b      	ldr	r3, [r7, #4]
  40356e:	695b      	ldr	r3, [r3, #20]
  403570:	f003 0301 	and.w	r3, r3, #1
  403574:	2b00      	cmp	r3, #0
  403576:	d101      	bne.n	40357c <usart_read+0x1a>
		return 1;
  403578:	2301      	movs	r3, #1
  40357a:	e006      	b.n	40358a <usart_read+0x28>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  40357c:	687b      	ldr	r3, [r7, #4]
  40357e:	699b      	ldr	r3, [r3, #24]
  403580:	f3c3 0208 	ubfx	r2, r3, #0, #9
  403584:	683b      	ldr	r3, [r7, #0]
  403586:	601a      	str	r2, [r3, #0]

	return 0;
  403588:	2300      	movs	r3, #0
}
  40358a:	4618      	mov	r0, r3
  40358c:	370c      	adds	r7, #12
  40358e:	46bd      	mov	sp, r7
  403590:	f85d 7b04 	ldr.w	r7, [sp], #4
  403594:	4770      	bx	lr
	...

00403598 <usart_disable_writeprotect>:
 * \brief Disable write protect of USART registers.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
  403598:	b480      	push	{r7}
  40359a:	b083      	sub	sp, #12
  40359c:	af00      	add	r7, sp, #0
  40359e:	6078      	str	r0, [r7, #4]
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  4035a0:	687b      	ldr	r3, [r7, #4]
  4035a2:	4a04      	ldr	r2, [pc, #16]	; (4035b4 <usart_disable_writeprotect+0x1c>)
  4035a4:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  4035a8:	bf00      	nop
  4035aa:	370c      	adds	r7, #12
  4035ac:	46bd      	mov	sp, r7
  4035ae:	f85d 7b04 	ldr.w	r7, [sp], #4
  4035b2:	4770      	bx	lr
  4035b4:	55534100 	.word	0x55534100

004035b8 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  4035b8:	b480      	push	{r7}
  4035ba:	b083      	sub	sp, #12
  4035bc:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4035be:	f3ef 8310 	mrs	r3, PRIMASK
  4035c2:	607b      	str	r3, [r7, #4]
  return(result);
  4035c4:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  4035c6:	2b00      	cmp	r3, #0
  4035c8:	bf0c      	ite	eq
  4035ca:	2301      	moveq	r3, #1
  4035cc:	2300      	movne	r3, #0
  4035ce:	b2db      	uxtb	r3, r3
  4035d0:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4035d2:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4035d4:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  4035d8:	4b04      	ldr	r3, [pc, #16]	; (4035ec <cpu_irq_save+0x34>)
  4035da:	2200      	movs	r2, #0
  4035dc:	701a      	strb	r2, [r3, #0]
	return flags;
  4035de:	683b      	ldr	r3, [r7, #0]
}
  4035e0:	4618      	mov	r0, r3
  4035e2:	370c      	adds	r7, #12
  4035e4:	46bd      	mov	sp, r7
  4035e6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4035ea:	4770      	bx	lr
  4035ec:	20000119 	.word	0x20000119

004035f0 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  4035f0:	b480      	push	{r7}
  4035f2:	b083      	sub	sp, #12
  4035f4:	af00      	add	r7, sp, #0
  4035f6:	6078      	str	r0, [r7, #4]
	return (flags);
  4035f8:	687b      	ldr	r3, [r7, #4]
  4035fa:	2b00      	cmp	r3, #0
  4035fc:	bf14      	ite	ne
  4035fe:	2301      	movne	r3, #1
  403600:	2300      	moveq	r3, #0
  403602:	b2db      	uxtb	r3, r3
}
  403604:	4618      	mov	r0, r3
  403606:	370c      	adds	r7, #12
  403608:	46bd      	mov	sp, r7
  40360a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40360e:	4770      	bx	lr

00403610 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  403610:	b580      	push	{r7, lr}
  403612:	b082      	sub	sp, #8
  403614:	af00      	add	r7, sp, #0
  403616:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  403618:	6878      	ldr	r0, [r7, #4]
  40361a:	4b07      	ldr	r3, [pc, #28]	; (403638 <cpu_irq_restore+0x28>)
  40361c:	4798      	blx	r3
  40361e:	4603      	mov	r3, r0
  403620:	2b00      	cmp	r3, #0
  403622:	d005      	beq.n	403630 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  403624:	4b05      	ldr	r3, [pc, #20]	; (40363c <cpu_irq_restore+0x2c>)
  403626:	2201      	movs	r2, #1
  403628:	701a      	strb	r2, [r3, #0]
  40362a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  40362e:	b662      	cpsie	i
}
  403630:	bf00      	nop
  403632:	3708      	adds	r7, #8
  403634:	46bd      	mov	sp, r7
  403636:	bd80      	pop	{r7, pc}
  403638:	004035f1 	.word	0x004035f1
  40363c:	20000119 	.word	0x20000119

00403640 <sysclk_enable_peripheral_clock>:
{
  403640:	b580      	push	{r7, lr}
  403642:	b082      	sub	sp, #8
  403644:	af00      	add	r7, sp, #0
  403646:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  403648:	6878      	ldr	r0, [r7, #4]
  40364a:	4b03      	ldr	r3, [pc, #12]	; (403658 <sysclk_enable_peripheral_clock+0x18>)
  40364c:	4798      	blx	r3
}
  40364e:	bf00      	nop
  403650:	3708      	adds	r7, #8
  403652:	46bd      	mov	sp, r7
  403654:	bd80      	pop	{r7, pc}
  403656:	bf00      	nop
  403658:	00404359 	.word	0x00404359

0040365c <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
  40365c:	b580      	push	{r7, lr}
  40365e:	b084      	sub	sp, #16
  403660:	af00      	add	r7, sp, #0
  403662:	4603      	mov	r3, r0
  403664:	71fb      	strb	r3, [r7, #7]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  403666:	79fb      	ldrb	r3, [r7, #7]
  403668:	4a0a      	ldr	r2, [pc, #40]	; (403694 <sleepmgr_lock_mode+0x38>)
  40366a:	5cd3      	ldrb	r3, [r2, r3]
  40366c:	2bff      	cmp	r3, #255	; 0xff
  40366e:	d100      	bne.n	403672 <sleepmgr_lock_mode+0x16>
		while (true) {
  403670:	e7fe      	b.n	403670 <sleepmgr_lock_mode+0x14>
			// Check APP or change the data type to uint16_t.
		}
	}

	// Enter a critical section
	flags = cpu_irq_save();
  403672:	4b09      	ldr	r3, [pc, #36]	; (403698 <sleepmgr_lock_mode+0x3c>)
  403674:	4798      	blx	r3
  403676:	60f8      	str	r0, [r7, #12]

	++sleepmgr_locks[mode];
  403678:	79fb      	ldrb	r3, [r7, #7]
  40367a:	4a06      	ldr	r2, [pc, #24]	; (403694 <sleepmgr_lock_mode+0x38>)
  40367c:	5cd2      	ldrb	r2, [r2, r3]
  40367e:	3201      	adds	r2, #1
  403680:	b2d1      	uxtb	r1, r2
  403682:	4a04      	ldr	r2, [pc, #16]	; (403694 <sleepmgr_lock_mode+0x38>)
  403684:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
  403686:	68f8      	ldr	r0, [r7, #12]
  403688:	4b04      	ldr	r3, [pc, #16]	; (40369c <sleepmgr_lock_mode+0x40>)
  40368a:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
  40368c:	bf00      	nop
  40368e:	3710      	adds	r7, #16
  403690:	46bd      	mov	sp, r7
  403692:	bd80      	pop	{r7, pc}
  403694:	20001868 	.word	0x20001868
  403698:	004035b9 	.word	0x004035b9
  40369c:	00403611 	.word	0x00403611

004036a0 <flexcom_enable>:
 *
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 *
 */
void flexcom_enable(Flexcom *p_flexcom)
{
  4036a0:	b580      	push	{r7, lr}
  4036a2:	b082      	sub	sp, #8
  4036a4:	af00      	add	r7, sp, #0
  4036a6:	6078      	str	r0, [r7, #4]
#if SAMG55
    #define PMC_PCK_PRES_CLK_1  PMC_PCK_PRES(0)
#endif

	sleepmgr_lock_mode(SLEEPMGR_ACTIVE);
  4036a8:	2000      	movs	r0, #0
  4036aa:	4b4a      	ldr	r3, [pc, #296]	; (4037d4 <flexcom_enable+0x134>)
  4036ac:	4798      	blx	r3
	/* Enable PMC clock for FLEXCOM */
#ifdef ID_FLEXCOM7
	 if (p_flexcom == FLEXCOM7) {
  4036ae:	687b      	ldr	r3, [r7, #4]
  4036b0:	4a49      	ldr	r2, [pc, #292]	; (4037d8 <flexcom_enable+0x138>)
  4036b2:	4293      	cmp	r3, r2
  4036b4:	d10d      	bne.n	4036d2 <flexcom_enable+0x32>
		sysclk_enable_peripheral_clock(ID_FLEXCOM7);
  4036b6:	2007      	movs	r0, #7
  4036b8:	4b48      	ldr	r3, [pc, #288]	; (4037dc <flexcom_enable+0x13c>)
  4036ba:	4798      	blx	r3
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  4036bc:	2007      	movs	r0, #7
  4036be:	4b48      	ldr	r3, [pc, #288]	; (4037e0 <flexcom_enable+0x140>)
  4036c0:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  4036c2:	2100      	movs	r1, #0
  4036c4:	2007      	movs	r0, #7
  4036c6:	4b47      	ldr	r3, [pc, #284]	; (4037e4 <flexcom_enable+0x144>)
  4036c8:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  4036ca:	2007      	movs	r0, #7
  4036cc:	4b46      	ldr	r3, [pc, #280]	; (4037e8 <flexcom_enable+0x148>)
  4036ce:	4798      	blx	r3
	} else
#endif
	{
		Assert(false);
	}
}
  4036d0:	e07c      	b.n	4037cc <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM6) {
  4036d2:	687b      	ldr	r3, [r7, #4]
  4036d4:	4a45      	ldr	r2, [pc, #276]	; (4037ec <flexcom_enable+0x14c>)
  4036d6:	4293      	cmp	r3, r2
  4036d8:	d10d      	bne.n	4036f6 <flexcom_enable+0x56>
		sysclk_enable_peripheral_clock(ID_FLEXCOM6);
  4036da:	2016      	movs	r0, #22
  4036dc:	4b3f      	ldr	r3, [pc, #252]	; (4037dc <flexcom_enable+0x13c>)
  4036de:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  4036e0:	2007      	movs	r0, #7
  4036e2:	4b3f      	ldr	r3, [pc, #252]	; (4037e0 <flexcom_enable+0x140>)
  4036e4:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  4036e6:	2100      	movs	r1, #0
  4036e8:	2007      	movs	r0, #7
  4036ea:	4b3e      	ldr	r3, [pc, #248]	; (4037e4 <flexcom_enable+0x144>)
  4036ec:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  4036ee:	2007      	movs	r0, #7
  4036f0:	4b3d      	ldr	r3, [pc, #244]	; (4037e8 <flexcom_enable+0x148>)
  4036f2:	4798      	blx	r3
}
  4036f4:	e06a      	b.n	4037cc <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM5) {
  4036f6:	687b      	ldr	r3, [r7, #4]
  4036f8:	4a3d      	ldr	r2, [pc, #244]	; (4037f0 <flexcom_enable+0x150>)
  4036fa:	4293      	cmp	r3, r2
  4036fc:	d10d      	bne.n	40371a <flexcom_enable+0x7a>
		sysclk_enable_peripheral_clock(ID_FLEXCOM5);
  4036fe:	2015      	movs	r0, #21
  403700:	4b36      	ldr	r3, [pc, #216]	; (4037dc <flexcom_enable+0x13c>)
  403702:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  403704:	2007      	movs	r0, #7
  403706:	4b36      	ldr	r3, [pc, #216]	; (4037e0 <flexcom_enable+0x140>)
  403708:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  40370a:	2100      	movs	r1, #0
  40370c:	2007      	movs	r0, #7
  40370e:	4b35      	ldr	r3, [pc, #212]	; (4037e4 <flexcom_enable+0x144>)
  403710:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  403712:	2007      	movs	r0, #7
  403714:	4b34      	ldr	r3, [pc, #208]	; (4037e8 <flexcom_enable+0x148>)
  403716:	4798      	blx	r3
}
  403718:	e058      	b.n	4037cc <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM4) {
  40371a:	687b      	ldr	r3, [r7, #4]
  40371c:	4a35      	ldr	r2, [pc, #212]	; (4037f4 <flexcom_enable+0x154>)
  40371e:	4293      	cmp	r3, r2
  403720:	d10d      	bne.n	40373e <flexcom_enable+0x9e>
		sysclk_enable_peripheral_clock(ID_FLEXCOM4);
  403722:	2014      	movs	r0, #20
  403724:	4b2d      	ldr	r3, [pc, #180]	; (4037dc <flexcom_enable+0x13c>)
  403726:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  403728:	2007      	movs	r0, #7
  40372a:	4b2d      	ldr	r3, [pc, #180]	; (4037e0 <flexcom_enable+0x140>)
  40372c:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  40372e:	2100      	movs	r1, #0
  403730:	2007      	movs	r0, #7
  403732:	4b2c      	ldr	r3, [pc, #176]	; (4037e4 <flexcom_enable+0x144>)
  403734:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  403736:	2007      	movs	r0, #7
  403738:	4b2b      	ldr	r3, [pc, #172]	; (4037e8 <flexcom_enable+0x148>)
  40373a:	4798      	blx	r3
}
  40373c:	e046      	b.n	4037cc <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM3) {
  40373e:	687b      	ldr	r3, [r7, #4]
  403740:	4a2d      	ldr	r2, [pc, #180]	; (4037f8 <flexcom_enable+0x158>)
  403742:	4293      	cmp	r3, r2
  403744:	d10d      	bne.n	403762 <flexcom_enable+0xc2>
		sysclk_enable_peripheral_clock(ID_FLEXCOM3);
  403746:	2013      	movs	r0, #19
  403748:	4b24      	ldr	r3, [pc, #144]	; (4037dc <flexcom_enable+0x13c>)
  40374a:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  40374c:	2006      	movs	r0, #6
  40374e:	4b24      	ldr	r3, [pc, #144]	; (4037e0 <flexcom_enable+0x140>)
  403750:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  403752:	2100      	movs	r1, #0
  403754:	2006      	movs	r0, #6
  403756:	4b23      	ldr	r3, [pc, #140]	; (4037e4 <flexcom_enable+0x144>)
  403758:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  40375a:	2006      	movs	r0, #6
  40375c:	4b22      	ldr	r3, [pc, #136]	; (4037e8 <flexcom_enable+0x148>)
  40375e:	4798      	blx	r3
}
  403760:	e034      	b.n	4037cc <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM2) {
  403762:	687b      	ldr	r3, [r7, #4]
  403764:	4a25      	ldr	r2, [pc, #148]	; (4037fc <flexcom_enable+0x15c>)
  403766:	4293      	cmp	r3, r2
  403768:	d10d      	bne.n	403786 <flexcom_enable+0xe6>
		sysclk_enable_peripheral_clock(ID_FLEXCOM2);
  40376a:	200e      	movs	r0, #14
  40376c:	4b1b      	ldr	r3, [pc, #108]	; (4037dc <flexcom_enable+0x13c>)
  40376e:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  403770:	2006      	movs	r0, #6
  403772:	4b1b      	ldr	r3, [pc, #108]	; (4037e0 <flexcom_enable+0x140>)
  403774:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  403776:	2100      	movs	r1, #0
  403778:	2006      	movs	r0, #6
  40377a:	4b1a      	ldr	r3, [pc, #104]	; (4037e4 <flexcom_enable+0x144>)
  40377c:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  40377e:	2006      	movs	r0, #6
  403780:	4b19      	ldr	r3, [pc, #100]	; (4037e8 <flexcom_enable+0x148>)
  403782:	4798      	blx	r3
}
  403784:	e022      	b.n	4037cc <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM1) {
  403786:	687b      	ldr	r3, [r7, #4]
  403788:	4a1d      	ldr	r2, [pc, #116]	; (403800 <flexcom_enable+0x160>)
  40378a:	4293      	cmp	r3, r2
  40378c:	d10d      	bne.n	4037aa <flexcom_enable+0x10a>
		sysclk_enable_peripheral_clock(ID_FLEXCOM1);
  40378e:	2009      	movs	r0, #9
  403790:	4b12      	ldr	r3, [pc, #72]	; (4037dc <flexcom_enable+0x13c>)
  403792:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  403794:	2006      	movs	r0, #6
  403796:	4b12      	ldr	r3, [pc, #72]	; (4037e0 <flexcom_enable+0x140>)
  403798:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  40379a:	2100      	movs	r1, #0
  40379c:	2006      	movs	r0, #6
  40379e:	4b11      	ldr	r3, [pc, #68]	; (4037e4 <flexcom_enable+0x144>)
  4037a0:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4037a2:	2006      	movs	r0, #6
  4037a4:	4b10      	ldr	r3, [pc, #64]	; (4037e8 <flexcom_enable+0x148>)
  4037a6:	4798      	blx	r3
}
  4037a8:	e010      	b.n	4037cc <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM0) {
  4037aa:	687b      	ldr	r3, [r7, #4]
  4037ac:	4a15      	ldr	r2, [pc, #84]	; (403804 <flexcom_enable+0x164>)
  4037ae:	4293      	cmp	r3, r2
  4037b0:	d10c      	bne.n	4037cc <flexcom_enable+0x12c>
		sysclk_enable_peripheral_clock(ID_FLEXCOM0);
  4037b2:	2008      	movs	r0, #8
  4037b4:	4b09      	ldr	r3, [pc, #36]	; (4037dc <flexcom_enable+0x13c>)
  4037b6:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  4037b8:	2006      	movs	r0, #6
  4037ba:	4b09      	ldr	r3, [pc, #36]	; (4037e0 <flexcom_enable+0x140>)
  4037bc:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4037be:	2100      	movs	r1, #0
  4037c0:	2006      	movs	r0, #6
  4037c2:	4b08      	ldr	r3, [pc, #32]	; (4037e4 <flexcom_enable+0x144>)
  4037c4:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4037c6:	2006      	movs	r0, #6
  4037c8:	4b07      	ldr	r3, [pc, #28]	; (4037e8 <flexcom_enable+0x148>)
  4037ca:	4798      	blx	r3
}
  4037cc:	bf00      	nop
  4037ce:	3708      	adds	r7, #8
  4037d0:	46bd      	mov	sp, r7
  4037d2:	bd80      	pop	{r7, pc}
  4037d4:	0040365d 	.word	0x0040365d
  4037d8:	40034000 	.word	0x40034000
  4037dc:	00403641 	.word	0x00403641
  4037e0:	0040445d 	.word	0x0040445d
  4037e4:	004043dd 	.word	0x004043dd
  4037e8:	00404435 	.word	0x00404435
  4037ec:	40040000 	.word	0x40040000
  4037f0:	40008000 	.word	0x40008000
  4037f4:	4001c000 	.word	0x4001c000
  4037f8:	40018000 	.word	0x40018000
  4037fc:	40024000 	.word	0x40024000
  403800:	40020000 	.word	0x40020000
  403804:	4000c000 	.word	0x4000c000

00403808 <flexcom_set_opmode>:
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 * \param opmode  Opration mode.
 *
 */
void flexcom_set_opmode(Flexcom *p_flexcom, enum flexcom_opmode opmode)
{
  403808:	b480      	push	{r7}
  40380a:	b083      	sub	sp, #12
  40380c:	af00      	add	r7, sp, #0
  40380e:	6078      	str	r0, [r7, #4]
  403810:	460b      	mov	r3, r1
  403812:	70fb      	strb	r3, [r7, #3]
	p_flexcom->FLEXCOM_MR = opmode;
  403814:	78fa      	ldrb	r2, [r7, #3]
  403816:	687b      	ldr	r3, [r7, #4]
  403818:	601a      	str	r2, [r3, #0]
}
  40381a:	bf00      	nop
  40381c:	370c      	adds	r7, #12
  40381e:	46bd      	mov	sp, r7
  403820:	f85d 7b04 	ldr.w	r7, [sp], #4
  403824:	4770      	bx	lr
	...

00403828 <osc_enable>:
{
  403828:	b580      	push	{r7, lr}
  40382a:	b082      	sub	sp, #8
  40382c:	af00      	add	r7, sp, #0
  40382e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  403830:	687b      	ldr	r3, [r7, #4]
  403832:	2b07      	cmp	r3, #7
  403834:	d831      	bhi.n	40389a <osc_enable+0x72>
  403836:	a201      	add	r2, pc, #4	; (adr r2, 40383c <osc_enable+0x14>)
  403838:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40383c:	00403899 	.word	0x00403899
  403840:	0040385d 	.word	0x0040385d
  403844:	00403865 	.word	0x00403865
  403848:	0040386d 	.word	0x0040386d
  40384c:	00403875 	.word	0x00403875
  403850:	0040387d 	.word	0x0040387d
  403854:	00403885 	.word	0x00403885
  403858:	0040388f 	.word	0x0040388f
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  40385c:	2000      	movs	r0, #0
  40385e:	4b11      	ldr	r3, [pc, #68]	; (4038a4 <osc_enable+0x7c>)
  403860:	4798      	blx	r3
		break;
  403862:	e01a      	b.n	40389a <osc_enable+0x72>
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  403864:	2001      	movs	r0, #1
  403866:	4b0f      	ldr	r3, [pc, #60]	; (4038a4 <osc_enable+0x7c>)
  403868:	4798      	blx	r3
		break;
  40386a:	e016      	b.n	40389a <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  40386c:	2000      	movs	r0, #0
  40386e:	4b0e      	ldr	r3, [pc, #56]	; (4038a8 <osc_enable+0x80>)
  403870:	4798      	blx	r3
		break;
  403872:	e012      	b.n	40389a <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_16_MHz);
  403874:	2010      	movs	r0, #16
  403876:	4b0c      	ldr	r3, [pc, #48]	; (4038a8 <osc_enable+0x80>)
  403878:	4798      	blx	r3
		break;
  40387a:	e00e      	b.n	40389a <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_24_MHz);
  40387c:	2020      	movs	r0, #32
  40387e:	4b0a      	ldr	r3, [pc, #40]	; (4038a8 <osc_enable+0x80>)
  403880:	4798      	blx	r3
		break;
  403882:	e00a      	b.n	40389a <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  403884:	213e      	movs	r1, #62	; 0x3e
  403886:	2000      	movs	r0, #0
  403888:	4b08      	ldr	r3, [pc, #32]	; (4038ac <osc_enable+0x84>)
  40388a:	4798      	blx	r3
		break;
  40388c:	e005      	b.n	40389a <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  40388e:	213e      	movs	r1, #62	; 0x3e
  403890:	2001      	movs	r0, #1
  403892:	4b06      	ldr	r3, [pc, #24]	; (4038ac <osc_enable+0x84>)
  403894:	4798      	blx	r3
		break;
  403896:	e000      	b.n	40389a <osc_enable+0x72>
		break;
  403898:	bf00      	nop
}
  40389a:	bf00      	nop
  40389c:	3708      	adds	r7, #8
  40389e:	46bd      	mov	sp, r7
  4038a0:	bd80      	pop	{r7, pc}
  4038a2:	bf00      	nop
  4038a4:	00404181 	.word	0x00404181
  4038a8:	004041ed 	.word	0x004041ed
  4038ac:	0040425d 	.word	0x0040425d

004038b0 <osc_is_ready>:
{
  4038b0:	b580      	push	{r7, lr}
  4038b2:	b082      	sub	sp, #8
  4038b4:	af00      	add	r7, sp, #0
  4038b6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4038b8:	687b      	ldr	r3, [r7, #4]
  4038ba:	2b07      	cmp	r3, #7
  4038bc:	d826      	bhi.n	40390c <osc_is_ready+0x5c>
  4038be:	a201      	add	r2, pc, #4	; (adr r2, 4038c4 <osc_is_ready+0x14>)
  4038c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4038c4:	004038e5 	.word	0x004038e5
  4038c8:	004038e9 	.word	0x004038e9
  4038cc:	004038e9 	.word	0x004038e9
  4038d0:	004038fb 	.word	0x004038fb
  4038d4:	004038fb 	.word	0x004038fb
  4038d8:	004038fb 	.word	0x004038fb
  4038dc:	004038fb 	.word	0x004038fb
  4038e0:	004038fb 	.word	0x004038fb
		return 1;
  4038e4:	2301      	movs	r3, #1
  4038e6:	e012      	b.n	40390e <osc_is_ready+0x5e>
		return pmc_osc_is_ready_32kxtal();
  4038e8:	4b0b      	ldr	r3, [pc, #44]	; (403918 <osc_is_ready+0x68>)
  4038ea:	4798      	blx	r3
  4038ec:	4603      	mov	r3, r0
  4038ee:	2b00      	cmp	r3, #0
  4038f0:	bf14      	ite	ne
  4038f2:	2301      	movne	r3, #1
  4038f4:	2300      	moveq	r3, #0
  4038f6:	b2db      	uxtb	r3, r3
  4038f8:	e009      	b.n	40390e <osc_is_ready+0x5e>
		return pmc_osc_is_ready_mainck();
  4038fa:	4b08      	ldr	r3, [pc, #32]	; (40391c <osc_is_ready+0x6c>)
  4038fc:	4798      	blx	r3
  4038fe:	4603      	mov	r3, r0
  403900:	2b00      	cmp	r3, #0
  403902:	bf14      	ite	ne
  403904:	2301      	movne	r3, #1
  403906:	2300      	moveq	r3, #0
  403908:	b2db      	uxtb	r3, r3
  40390a:	e000      	b.n	40390e <osc_is_ready+0x5e>
	return 0;
  40390c:	2300      	movs	r3, #0
}
  40390e:	4618      	mov	r0, r3
  403910:	3708      	adds	r7, #8
  403912:	46bd      	mov	sp, r7
  403914:	bd80      	pop	{r7, pc}
  403916:	bf00      	nop
  403918:	004041b9 	.word	0x004041b9
  40391c:	004042d5 	.word	0x004042d5

00403920 <osc_get_rate>:
{
  403920:	b480      	push	{r7}
  403922:	b083      	sub	sp, #12
  403924:	af00      	add	r7, sp, #0
  403926:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  403928:	687b      	ldr	r3, [r7, #4]
  40392a:	2b07      	cmp	r3, #7
  40392c:	d825      	bhi.n	40397a <osc_get_rate+0x5a>
  40392e:	a201      	add	r2, pc, #4	; (adr r2, 403934 <osc_get_rate+0x14>)
  403930:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  403934:	00403955 	.word	0x00403955
  403938:	0040395b 	.word	0x0040395b
  40393c:	00403961 	.word	0x00403961
  403940:	00403967 	.word	0x00403967
  403944:	0040396b 	.word	0x0040396b
  403948:	0040396f 	.word	0x0040396f
  40394c:	00403973 	.word	0x00403973
  403950:	00403977 	.word	0x00403977
		return OSC_SLCK_32K_RC_HZ;
  403954:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  403958:	e010      	b.n	40397c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  40395a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40395e:	e00d      	b.n	40397c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  403960:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  403964:	e00a      	b.n	40397c <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  403966:	4b08      	ldr	r3, [pc, #32]	; (403988 <osc_get_rate+0x68>)
  403968:	e008      	b.n	40397c <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  40396a:	4b08      	ldr	r3, [pc, #32]	; (40398c <osc_get_rate+0x6c>)
  40396c:	e006      	b.n	40397c <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  40396e:	4b08      	ldr	r3, [pc, #32]	; (403990 <osc_get_rate+0x70>)
  403970:	e004      	b.n	40397c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  403972:	2300      	movs	r3, #0
  403974:	e002      	b.n	40397c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  403976:	2300      	movs	r3, #0
  403978:	e000      	b.n	40397c <osc_get_rate+0x5c>
	return 0;
  40397a:	2300      	movs	r3, #0
}
  40397c:	4618      	mov	r0, r3
  40397e:	370c      	adds	r7, #12
  403980:	46bd      	mov	sp, r7
  403982:	f85d 7b04 	ldr.w	r7, [sp], #4
  403986:	4770      	bx	lr
  403988:	007a1200 	.word	0x007a1200
  40398c:	00f42400 	.word	0x00f42400
  403990:	016e3600 	.word	0x016e3600

00403994 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  403994:	b580      	push	{r7, lr}
  403996:	b082      	sub	sp, #8
  403998:	af00      	add	r7, sp, #0
  40399a:	4603      	mov	r3, r0
  40399c:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  40399e:	bf00      	nop
  4039a0:	79fb      	ldrb	r3, [r7, #7]
  4039a2:	4618      	mov	r0, r3
  4039a4:	4b05      	ldr	r3, [pc, #20]	; (4039bc <osc_wait_ready+0x28>)
  4039a6:	4798      	blx	r3
  4039a8:	4603      	mov	r3, r0
  4039aa:	f083 0301 	eor.w	r3, r3, #1
  4039ae:	b2db      	uxtb	r3, r3
  4039b0:	2b00      	cmp	r3, #0
  4039b2:	d1f5      	bne.n	4039a0 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  4039b4:	bf00      	nop
  4039b6:	3708      	adds	r7, #8
  4039b8:	46bd      	mov	sp, r7
  4039ba:	bd80      	pop	{r7, pc}
  4039bc:	004038b1 	.word	0x004038b1

004039c0 <pll_config_init>:
 * \note The SAMG PLL hardware interprets mul as mul+1. For readability the hardware mul+1
 * is hidden in this implementation. Use mul as mul effective value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  4039c0:	b580      	push	{r7, lr}
  4039c2:	b086      	sub	sp, #24
  4039c4:	af00      	add	r7, sp, #0
  4039c6:	60f8      	str	r0, [r7, #12]
  4039c8:	607a      	str	r2, [r7, #4]
  4039ca:	603b      	str	r3, [r7, #0]
  4039cc:	460b      	mov	r3, r1
  4039ce:	72fb      	strb	r3, [r7, #11]

	Assert(e_src < PLL_NR_SOURCES);
	Assert(ul_div < 2);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  4039d0:	7afb      	ldrb	r3, [r7, #11]
  4039d2:	4618      	mov	r0, r3
  4039d4:	4b0d      	ldr	r3, [pc, #52]	; (403a0c <pll_config_init+0x4c>)
  4039d6:	4798      	blx	r3
  4039d8:	4602      	mov	r2, r0
  4039da:	687b      	ldr	r3, [r7, #4]
  4039dc:	fbb2 f3f3 	udiv	r3, r2, r3
  4039e0:	617b      	str	r3, [r7, #20]

	vco_hz *= ul_mul;
  4039e2:	697b      	ldr	r3, [r7, #20]
  4039e4:	683a      	ldr	r2, [r7, #0]
  4039e6:	fb02 f303 	mul.w	r3, r2, r3
  4039ea:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= (PLL_OUTPUT_MIN_HZ - (PLL_OUTPUT_MIN_HZ >> 6)));
	Assert(vco_hz <= (PLL_OUTPUT_MAX_HZ + (PLL_OUTPUT_MAX_HZ >> 6)));

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_PLLAEN(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
  4039ec:	683b      	ldr	r3, [r7, #0]
  4039ee:	3b01      	subs	r3, #1
  4039f0:	041a      	lsls	r2, r3, #16
  4039f2:	4b07      	ldr	r3, [pc, #28]	; (403a10 <pll_config_init+0x50>)
  4039f4:	4013      	ands	r3, r2
  4039f6:	687a      	ldr	r2, [r7, #4]
  4039f8:	b2d2      	uxtb	r2, r2
  4039fa:	4313      	orrs	r3, r2
  4039fc:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  403a00:	68fb      	ldr	r3, [r7, #12]
  403a02:	601a      	str	r2, [r3, #0]
}
  403a04:	bf00      	nop
  403a06:	3718      	adds	r7, #24
  403a08:	46bd      	mov	sp, r7
  403a0a:	bd80      	pop	{r7, pc}
  403a0c:	00403921 	.word	0x00403921
  403a10:	1fff0000 	.word	0x1fff0000

00403a14 <pll_enable>:
#endif
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  403a14:	b580      	push	{r7, lr}
  403a16:	b082      	sub	sp, #8
  403a18:	af00      	add	r7, sp, #0
  403a1a:	6078      	str	r0, [r7, #4]
  403a1c:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  403a1e:	683b      	ldr	r3, [r7, #0]
  403a20:	2b00      	cmp	r3, #0
  403a22:	d106      	bne.n	403a32 <pll_enable+0x1e>
		pmc_disable_pllack(); // Always stop PLL first!
  403a24:	4b08      	ldr	r3, [pc, #32]	; (403a48 <pll_enable+0x34>)
  403a26:	4798      	blx	r3
		PMC->CKGR_PLLAR = p_cfg->ctrl;
  403a28:	4a08      	ldr	r2, [pc, #32]	; (403a4c <pll_enable+0x38>)
  403a2a:	687b      	ldr	r3, [r7, #4]
  403a2c:	681b      	ldr	r3, [r3, #0]
  403a2e:	6293      	str	r3, [r2, #40]	; 0x28
	} else {
		pmc_disable_pllbck(); // Always stop PLL first!
		PMC->CKGR_PLLBR = p_cfg->ctrl;
#endif
	}
}
  403a30:	e005      	b.n	403a3e <pll_enable+0x2a>
		pmc_disable_pllbck(); // Always stop PLL first!
  403a32:	4b07      	ldr	r3, [pc, #28]	; (403a50 <pll_enable+0x3c>)
  403a34:	4798      	blx	r3
		PMC->CKGR_PLLBR = p_cfg->ctrl;
  403a36:	4a05      	ldr	r2, [pc, #20]	; (403a4c <pll_enable+0x38>)
  403a38:	687b      	ldr	r3, [r7, #4]
  403a3a:	681b      	ldr	r3, [r3, #0]
  403a3c:	62d3      	str	r3, [r2, #44]	; 0x2c
}
  403a3e:	bf00      	nop
  403a40:	3708      	adds	r7, #8
  403a42:	46bd      	mov	sp, r7
  403a44:	bd80      	pop	{r7, pc}
  403a46:	bf00      	nop
  403a48:	004042f1 	.word	0x004042f1
  403a4c:	400e0400 	.word	0x400e0400
  403a50:	00404325 	.word	0x00404325

00403a54 <pll_is_locked>:
#endif
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  403a54:	b580      	push	{r7, lr}
  403a56:	b082      	sub	sp, #8
  403a58:	af00      	add	r7, sp, #0
  403a5a:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  403a5c:	687b      	ldr	r3, [r7, #4]
  403a5e:	2b00      	cmp	r3, #0
  403a60:	d103      	bne.n	403a6a <pll_is_locked+0x16>
		return pmc_is_locked_pllack();
  403a62:	4b08      	ldr	r3, [pc, #32]	; (403a84 <pll_is_locked+0x30>)
  403a64:	4798      	blx	r3
  403a66:	4603      	mov	r3, r0
  403a68:	e007      	b.n	403a7a <pll_is_locked+0x26>
#if SAMG55
	} else if (ul_pll_id == PLLB_ID) {
  403a6a:	687b      	ldr	r3, [r7, #4]
  403a6c:	2b01      	cmp	r3, #1
  403a6e:	d103      	bne.n	403a78 <pll_is_locked+0x24>
		return pmc_is_locked_pllbck();
  403a70:	4b05      	ldr	r3, [pc, #20]	; (403a88 <pll_is_locked+0x34>)
  403a72:	4798      	blx	r3
  403a74:	4603      	mov	r3, r0
  403a76:	e000      	b.n	403a7a <pll_is_locked+0x26>
#endif
	} else {
		return 0;
  403a78:	2300      	movs	r3, #0
	}
}
  403a7a:	4618      	mov	r0, r3
  403a7c:	3708      	adds	r7, #8
  403a7e:	46bd      	mov	sp, r7
  403a80:	bd80      	pop	{r7, pc}
  403a82:	bf00      	nop
  403a84:	00404309 	.word	0x00404309
  403a88:	0040433d 	.word	0x0040433d

00403a8c <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  403a8c:	b580      	push	{r7, lr}
  403a8e:	b082      	sub	sp, #8
  403a90:	af00      	add	r7, sp, #0
  403a92:	4603      	mov	r3, r0
  403a94:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  403a96:	79fb      	ldrb	r3, [r7, #7]
  403a98:	3300      	adds	r3, #0
  403a9a:	2b01      	cmp	r3, #1
  403a9c:	d808      	bhi.n	403ab0 <pll_enable_source+0x24>
	case PLL_SRC_SLCK_RC:
	case PLL_SRC_SLCK_XTAL:
		osc_enable(e_src);
  403a9e:	79fb      	ldrb	r3, [r7, #7]
  403aa0:	4618      	mov	r0, r3
  403aa2:	4b06      	ldr	r3, [pc, #24]	; (403abc <pll_enable_source+0x30>)
  403aa4:	4798      	blx	r3
		osc_wait_ready(e_src);
  403aa6:	79fb      	ldrb	r3, [r7, #7]
  403aa8:	4618      	mov	r0, r3
  403aaa:	4b05      	ldr	r3, [pc, #20]	; (403ac0 <pll_enable_source+0x34>)
  403aac:	4798      	blx	r3
		break;
  403aae:	e000      	b.n	403ab2 <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  403ab0:	bf00      	nop
	}
}
  403ab2:	bf00      	nop
  403ab4:	3708      	adds	r7, #8
  403ab6:	46bd      	mov	sp, r7
  403ab8:	bd80      	pop	{r7, pc}
  403aba:	bf00      	nop
  403abc:	00403829 	.word	0x00403829
  403ac0:	00403995 	.word	0x00403995

00403ac4 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  403ac4:	b580      	push	{r7, lr}
  403ac6:	b082      	sub	sp, #8
  403ac8:	af00      	add	r7, sp, #0
  403aca:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  403acc:	bf00      	nop
  403ace:	6878      	ldr	r0, [r7, #4]
  403ad0:	4b04      	ldr	r3, [pc, #16]	; (403ae4 <pll_wait_for_lock+0x20>)
  403ad2:	4798      	blx	r3
  403ad4:	4603      	mov	r3, r0
  403ad6:	2b00      	cmp	r3, #0
  403ad8:	d0f9      	beq.n	403ace <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  403ada:	2300      	movs	r3, #0
}
  403adc:	4618      	mov	r0, r3
  403ade:	3708      	adds	r7, #8
  403ae0:	46bd      	mov	sp, r7
  403ae2:	bd80      	pop	{r7, pc}
  403ae4:	00403a55 	.word	0x00403a55

00403ae8 <sysclk_get_main_hz>:
{
  403ae8:	b580      	push	{r7, lr}
  403aea:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  403aec:	2001      	movs	r0, #1
  403aee:	4b04      	ldr	r3, [pc, #16]	; (403b00 <sysclk_get_main_hz+0x18>)
  403af0:	4798      	blx	r3
  403af2:	4602      	mov	r2, r0
  403af4:	f640 634e 	movw	r3, #3662	; 0xe4e
  403af8:	fb03 f302 	mul.w	r3, r3, r2
}
  403afc:	4618      	mov	r0, r3
  403afe:	bd80      	pop	{r7, pc}
  403b00:	00403921 	.word	0x00403921

00403b04 <sysclk_get_cpu_hz>:
{
  403b04:	b580      	push	{r7, lr}
  403b06:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  403b08:	4b02      	ldr	r3, [pc, #8]	; (403b14 <sysclk_get_cpu_hz+0x10>)
  403b0a:	4798      	blx	r3
  403b0c:	4603      	mov	r3, r0
}
  403b0e:	4618      	mov	r0, r3
  403b10:	bd80      	pop	{r7, pc}
  403b12:	bf00      	nop
  403b14:	00403ae9 	.word	0x00403ae9

00403b18 <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE
#endif

void sysclk_init(void)
{
  403b18:	b590      	push	{r4, r7, lr}
  403b1a:	b0a5      	sub	sp, #148	; 0x94
  403b1c:	af02      	add	r7, sp, #8
	uint32_t unique_id[32];
	uint32_t trim_value;
#endif

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  403b1e:	4820      	ldr	r0, [pc, #128]	; (403ba0 <sysclk_init+0x88>)
  403b20:	4b20      	ldr	r3, [pc, #128]	; (403ba4 <sysclk_init+0x8c>)
  403b22:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  403b24:	2001      	movs	r0, #1
  403b26:	4b20      	ldr	r3, [pc, #128]	; (403ba8 <sysclk_init+0x90>)
  403b28:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  403b2a:	4638      	mov	r0, r7
  403b2c:	f640 634e 	movw	r3, #3662	; 0xe4e
  403b30:	2201      	movs	r2, #1
  403b32:	2101      	movs	r1, #1
  403b34:	4c1d      	ldr	r4, [pc, #116]	; (403bac <sysclk_init+0x94>)
  403b36:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  403b38:	463b      	mov	r3, r7
  403b3a:	2100      	movs	r1, #0
  403b3c:	4618      	mov	r0, r3
  403b3e:	4b1c      	ldr	r3, [pc, #112]	; (403bb0 <sysclk_init+0x98>)
  403b40:	4798      	blx	r3
		pll_wait_for_lock(0);
  403b42:	2000      	movs	r0, #0
  403b44:	4b1b      	ldr	r3, [pc, #108]	; (403bb4 <sysclk_init+0x9c>)
  403b46:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  403b48:	2000      	movs	r0, #0
  403b4a:	4b1b      	ldr	r3, [pc, #108]	; (403bb8 <sysclk_init+0xa0>)
  403b4c:	4798      	blx	r3
	}
#endif
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  403b4e:	4b1b      	ldr	r3, [pc, #108]	; (403bbc <sysclk_init+0xa4>)
  403b50:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  403b52:	4b1b      	ldr	r3, [pc, #108]	; (403bc0 <sysclk_init+0xa8>)
  403b54:	4798      	blx	r3
  403b56:	4603      	mov	r3, r0
  403b58:	4618      	mov	r0, r3
  403b5a:	4b12      	ldr	r3, [pc, #72]	; (403ba4 <sysclk_init+0x8c>)
  403b5c:	4798      	blx	r3
	}
#endif

#if SAMG55
	/* Set the trim value when system run near 120M */
	if ((SystemCoreClock <= (CHIP_FREQ_CPU_MAX + (CHIP_FREQ_CPU_MAX >> 3))) &&
  403b5e:	4b19      	ldr	r3, [pc, #100]	; (403bc4 <sysclk_init+0xac>)
  403b60:	681b      	ldr	r3, [r3, #0]
  403b62:	4a19      	ldr	r2, [pc, #100]	; (403bc8 <sysclk_init+0xb0>)
  403b64:	4293      	cmp	r3, r2
  403b66:	d816      	bhi.n	403b96 <sysclk_init+0x7e>
	(SystemCoreClock >= (CHIP_FREQ_CPU_MAX - (CHIP_FREQ_CPU_MAX >> 3)))) {
  403b68:	4b16      	ldr	r3, [pc, #88]	; (403bc4 <sysclk_init+0xac>)
  403b6a:	681b      	ldr	r3, [r3, #0]
	if ((SystemCoreClock <= (CHIP_FREQ_CPU_MAX + (CHIP_FREQ_CPU_MAX >> 3))) &&
  403b6c:	4a17      	ldr	r2, [pc, #92]	; (403bcc <sysclk_init+0xb4>)
  403b6e:	4293      	cmp	r3, r2
  403b70:	d911      	bls.n	403b96 <sysclk_init+0x7e>
		/* Get the trim value from unique ID area */
		efc_perform_read_sequence(EFC, EFC_FCMD_STUI, EFC_FCMD_SPUI,
  403b72:	1d3a      	adds	r2, r7, #4
  403b74:	2320      	movs	r3, #32
  403b76:	9300      	str	r3, [sp, #0]
  403b78:	4613      	mov	r3, r2
  403b7a:	220f      	movs	r2, #15
  403b7c:	210e      	movs	r1, #14
  403b7e:	4814      	ldr	r0, [pc, #80]	; (403bd0 <sysclk_init+0xb8>)
  403b80:	4c14      	ldr	r4, [pc, #80]	; (403bd4 <sysclk_init+0xbc>)
  403b82:	47a0      	blx	r4
		unique_id, 32);

		trim_value = unique_id[16] & 0x0000FFFF;
  403b84:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  403b86:	b29b      	uxth	r3, r3
  403b88:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		supc_set_regulator_trim_user(SUPC, trim_value);
  403b8c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  403b90:	4811      	ldr	r0, [pc, #68]	; (403bd8 <sysclk_init+0xc0>)
  403b92:	4b12      	ldr	r3, [pc, #72]	; (403bdc <sysclk_init+0xc4>)
  403b94:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  403b96:	bf00      	nop
  403b98:	378c      	adds	r7, #140	; 0x8c
  403b9a:	46bd      	mov	sp, r7
  403b9c:	bd90      	pop	{r4, r7, pc}
  403b9e:	bf00      	nop
  403ba0:	07270e00 	.word	0x07270e00
  403ba4:	00404741 	.word	0x00404741
  403ba8:	00403a8d 	.word	0x00403a8d
  403bac:	004039c1 	.word	0x004039c1
  403bb0:	00403a15 	.word	0x00403a15
  403bb4:	00403ac5 	.word	0x00403ac5
  403bb8:	004040fd 	.word	0x004040fd
  403bbc:	0040461d 	.word	0x0040461d
  403bc0:	00403b05 	.word	0x00403b05
  403bc4:	2000011c 	.word	0x2000011c
  403bc8:	080befc0 	.word	0x080befc0
  403bcc:	06422c3f 	.word	0x06422c3f
  403bd0:	400e0a00 	.word	0x400e0a00
  403bd4:	2000000b 	.word	0x2000000b
  403bd8:	400e1410 	.word	0x400e1410
  403bdc:	00404485 	.word	0x00404485

00403be0 <sysclk_enable_peripheral_clock>:
{
  403be0:	b580      	push	{r7, lr}
  403be2:	b082      	sub	sp, #8
  403be4:	af00      	add	r7, sp, #0
  403be6:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  403be8:	6878      	ldr	r0, [r7, #4]
  403bea:	4b03      	ldr	r3, [pc, #12]	; (403bf8 <sysclk_enable_peripheral_clock+0x18>)
  403bec:	4798      	blx	r3
}
  403bee:	bf00      	nop
  403bf0:	3708      	adds	r7, #8
  403bf2:	46bd      	mov	sp, r7
  403bf4:	bd80      	pop	{r7, pc}
  403bf6:	bf00      	nop
  403bf8:	00404359 	.word	0x00404359

00403bfc <ioport_init>:
{
  403bfc:	b580      	push	{r7, lr}
  403bfe:	af00      	add	r7, sp, #0
	sysclk_enable_peripheral_clock(ID_PIOA);
  403c00:	200b      	movs	r0, #11
  403c02:	4b03      	ldr	r3, [pc, #12]	; (403c10 <ioport_init+0x14>)
  403c04:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOB);
  403c06:	200c      	movs	r0, #12
  403c08:	4b01      	ldr	r3, [pc, #4]	; (403c10 <ioport_init+0x14>)
  403c0a:	4798      	blx	r3
}
  403c0c:	bf00      	nop
  403c0e:	bd80      	pop	{r7, pc}
  403c10:	00403be1 	.word	0x00403be1

00403c14 <ioport_disable_pin>:
{
  403c14:	b480      	push	{r7}
  403c16:	b089      	sub	sp, #36	; 0x24
  403c18:	af00      	add	r7, sp, #0
  403c1a:	6078      	str	r0, [r7, #4]
  403c1c:	687b      	ldr	r3, [r7, #4]
  403c1e:	61fb      	str	r3, [r7, #28]
  403c20:	69fb      	ldr	r3, [r7, #28]
  403c22:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  403c24:	69bb      	ldr	r3, [r7, #24]
  403c26:	095a      	lsrs	r2, r3, #5
  403c28:	69fb      	ldr	r3, [r7, #28]
  403c2a:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  403c2c:	697b      	ldr	r3, [r7, #20]
  403c2e:	f003 031f 	and.w	r3, r3, #31
  403c32:	2101      	movs	r1, #1
  403c34:	fa01 f303 	lsl.w	r3, r1, r3
  403c38:	613a      	str	r2, [r7, #16]
  403c3a:	60fb      	str	r3, [r7, #12]
  403c3c:	693b      	ldr	r3, [r7, #16]
  403c3e:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403c40:	68bb      	ldr	r3, [r7, #8]
  403c42:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403c46:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403c4a:	025b      	lsls	r3, r3, #9
  403c4c:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  403c4e:	68fb      	ldr	r3, [r7, #12]
  403c50:	6053      	str	r3, [r2, #4]
}
  403c52:	bf00      	nop
  403c54:	3724      	adds	r7, #36	; 0x24
  403c56:	46bd      	mov	sp, r7
  403c58:	f85d 7b04 	ldr.w	r7, [sp], #4
  403c5c:	4770      	bx	lr

00403c5e <ioport_disable_port>:
{
  403c5e:	b480      	push	{r7}
  403c60:	b087      	sub	sp, #28
  403c62:	af00      	add	r7, sp, #0
  403c64:	6078      	str	r0, [r7, #4]
  403c66:	6039      	str	r1, [r7, #0]
  403c68:	687b      	ldr	r3, [r7, #4]
  403c6a:	617b      	str	r3, [r7, #20]
  403c6c:	683b      	ldr	r3, [r7, #0]
  403c6e:	613b      	str	r3, [r7, #16]
  403c70:	697b      	ldr	r3, [r7, #20]
  403c72:	60fb      	str	r3, [r7, #12]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403c74:	68fb      	ldr	r3, [r7, #12]
  403c76:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403c7a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403c7e:	025b      	lsls	r3, r3, #9
  403c80:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  403c82:	693b      	ldr	r3, [r7, #16]
  403c84:	6053      	str	r3, [r2, #4]
}
  403c86:	bf00      	nop
  403c88:	371c      	adds	r7, #28
  403c8a:	46bd      	mov	sp, r7
  403c8c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403c90:	4770      	bx	lr

00403c92 <ioport_set_port_mode>:
{
  403c92:	b480      	push	{r7}
  403c94:	b08b      	sub	sp, #44	; 0x2c
  403c96:	af00      	add	r7, sp, #0
  403c98:	60f8      	str	r0, [r7, #12]
  403c9a:	60b9      	str	r1, [r7, #8]
  403c9c:	607a      	str	r2, [r7, #4]
  403c9e:	68fb      	ldr	r3, [r7, #12]
  403ca0:	627b      	str	r3, [r7, #36]	; 0x24
  403ca2:	68bb      	ldr	r3, [r7, #8]
  403ca4:	623b      	str	r3, [r7, #32]
  403ca6:	687b      	ldr	r3, [r7, #4]
  403ca8:	61fb      	str	r3, [r7, #28]
  403caa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403cac:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403cae:	69bb      	ldr	r3, [r7, #24]
  403cb0:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403cb4:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403cb8:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  403cba:	617b      	str	r3, [r7, #20]
	if (mode & IOPORT_MODE_PULLUP) {
  403cbc:	69fb      	ldr	r3, [r7, #28]
  403cbe:	f003 0308 	and.w	r3, r3, #8
  403cc2:	2b00      	cmp	r3, #0
  403cc4:	d003      	beq.n	403cce <ioport_set_port_mode+0x3c>
		base->PIO_PUER = mask;
  403cc6:	697b      	ldr	r3, [r7, #20]
  403cc8:	6a3a      	ldr	r2, [r7, #32]
  403cca:	665a      	str	r2, [r3, #100]	; 0x64
  403ccc:	e002      	b.n	403cd4 <ioport_set_port_mode+0x42>
		base->PIO_PUDR = mask;
  403cce:	697b      	ldr	r3, [r7, #20]
  403cd0:	6a3a      	ldr	r2, [r7, #32]
  403cd2:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  403cd4:	69fb      	ldr	r3, [r7, #28]
  403cd6:	f003 0310 	and.w	r3, r3, #16
  403cda:	2b00      	cmp	r3, #0
  403cdc:	d004      	beq.n	403ce8 <ioport_set_port_mode+0x56>
		base->PIO_PPDER = mask;
  403cde:	697b      	ldr	r3, [r7, #20]
  403ce0:	6a3a      	ldr	r2, [r7, #32]
  403ce2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  403ce6:	e003      	b.n	403cf0 <ioport_set_port_mode+0x5e>
		base->PIO_PPDDR = mask;
  403ce8:	697b      	ldr	r3, [r7, #20]
  403cea:	6a3a      	ldr	r2, [r7, #32]
  403cec:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  403cf0:	69fb      	ldr	r3, [r7, #28]
  403cf2:	f003 0320 	and.w	r3, r3, #32
  403cf6:	2b00      	cmp	r3, #0
  403cf8:	d003      	beq.n	403d02 <ioport_set_port_mode+0x70>
		base->PIO_MDER = mask;
  403cfa:	697b      	ldr	r3, [r7, #20]
  403cfc:	6a3a      	ldr	r2, [r7, #32]
  403cfe:	651a      	str	r2, [r3, #80]	; 0x50
  403d00:	e002      	b.n	403d08 <ioport_set_port_mode+0x76>
		base->PIO_MDDR = mask;
  403d02:	697b      	ldr	r3, [r7, #20]
  403d04:	6a3a      	ldr	r2, [r7, #32]
  403d06:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  403d08:	69fb      	ldr	r3, [r7, #28]
  403d0a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  403d0e:	2b00      	cmp	r3, #0
  403d10:	d003      	beq.n	403d1a <ioport_set_port_mode+0x88>
		base->PIO_IFER = mask;
  403d12:	697b      	ldr	r3, [r7, #20]
  403d14:	6a3a      	ldr	r2, [r7, #32]
  403d16:	621a      	str	r2, [r3, #32]
  403d18:	e002      	b.n	403d20 <ioport_set_port_mode+0x8e>
		base->PIO_IFDR = mask;
  403d1a:	697b      	ldr	r3, [r7, #20]
  403d1c:	6a3a      	ldr	r2, [r7, #32]
  403d1e:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  403d20:	69fb      	ldr	r3, [r7, #28]
  403d22:	f003 0380 	and.w	r3, r3, #128	; 0x80
  403d26:	2b00      	cmp	r3, #0
  403d28:	d004      	beq.n	403d34 <ioport_set_port_mode+0xa2>
		base->PIO_IFSCER = mask;
  403d2a:	697b      	ldr	r3, [r7, #20]
  403d2c:	6a3a      	ldr	r2, [r7, #32]
  403d2e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  403d32:	e003      	b.n	403d3c <ioport_set_port_mode+0xaa>
		base->PIO_IFSCDR = mask;
  403d34:	697b      	ldr	r3, [r7, #20]
  403d36:	6a3a      	ldr	r2, [r7, #32]
  403d38:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  403d3c:	69fb      	ldr	r3, [r7, #28]
  403d3e:	f003 0301 	and.w	r3, r3, #1
  403d42:	2b00      	cmp	r3, #0
  403d44:	d006      	beq.n	403d54 <ioport_set_port_mode+0xc2>
		base->PIO_ABCDSR[0] |= mask;
  403d46:	697b      	ldr	r3, [r7, #20]
  403d48:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403d4a:	6a3b      	ldr	r3, [r7, #32]
  403d4c:	431a      	orrs	r2, r3
  403d4e:	697b      	ldr	r3, [r7, #20]
  403d50:	671a      	str	r2, [r3, #112]	; 0x70
  403d52:	e006      	b.n	403d62 <ioport_set_port_mode+0xd0>
		base->PIO_ABCDSR[0] &= ~mask;
  403d54:	697b      	ldr	r3, [r7, #20]
  403d56:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403d58:	6a3b      	ldr	r3, [r7, #32]
  403d5a:	43db      	mvns	r3, r3
  403d5c:	401a      	ands	r2, r3
  403d5e:	697b      	ldr	r3, [r7, #20]
  403d60:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  403d62:	69fb      	ldr	r3, [r7, #28]
  403d64:	f003 0302 	and.w	r3, r3, #2
  403d68:	2b00      	cmp	r3, #0
  403d6a:	d006      	beq.n	403d7a <ioport_set_port_mode+0xe8>
		base->PIO_ABCDSR[1] |= mask;
  403d6c:	697b      	ldr	r3, [r7, #20]
  403d6e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403d70:	6a3b      	ldr	r3, [r7, #32]
  403d72:	431a      	orrs	r2, r3
  403d74:	697b      	ldr	r3, [r7, #20]
  403d76:	675a      	str	r2, [r3, #116]	; 0x74
}
  403d78:	e006      	b.n	403d88 <ioport_set_port_mode+0xf6>
		base->PIO_ABCDSR[1] &= ~mask;
  403d7a:	697b      	ldr	r3, [r7, #20]
  403d7c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403d7e:	6a3b      	ldr	r3, [r7, #32]
  403d80:	43db      	mvns	r3, r3
  403d82:	401a      	ands	r2, r3
  403d84:	697b      	ldr	r3, [r7, #20]
  403d86:	675a      	str	r2, [r3, #116]	; 0x74
  403d88:	bf00      	nop
  403d8a:	372c      	adds	r7, #44	; 0x2c
  403d8c:	46bd      	mov	sp, r7
  403d8e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d92:	4770      	bx	lr

00403d94 <ioport_set_pin_mode>:
{
  403d94:	b480      	push	{r7}
  403d96:	b08d      	sub	sp, #52	; 0x34
  403d98:	af00      	add	r7, sp, #0
  403d9a:	6078      	str	r0, [r7, #4]
  403d9c:	6039      	str	r1, [r7, #0]
  403d9e:	687b      	ldr	r3, [r7, #4]
  403da0:	62fb      	str	r3, [r7, #44]	; 0x2c
  403da2:	683b      	ldr	r3, [r7, #0]
  403da4:	62bb      	str	r3, [r7, #40]	; 0x28
  403da6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403da8:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  403daa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403dac:	095a      	lsrs	r2, r3, #5
  403dae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403db0:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  403db2:	6a3b      	ldr	r3, [r7, #32]
  403db4:	f003 031f 	and.w	r3, r3, #31
  403db8:	2101      	movs	r1, #1
  403dba:	fa01 f303 	lsl.w	r3, r1, r3
  403dbe:	61fa      	str	r2, [r7, #28]
  403dc0:	61bb      	str	r3, [r7, #24]
  403dc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  403dc4:	617b      	str	r3, [r7, #20]
  403dc6:	69fb      	ldr	r3, [r7, #28]
  403dc8:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403dca:	693b      	ldr	r3, [r7, #16]
  403dcc:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403dd0:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403dd4:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  403dd6:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  403dd8:	697b      	ldr	r3, [r7, #20]
  403dda:	f003 0308 	and.w	r3, r3, #8
  403dde:	2b00      	cmp	r3, #0
  403de0:	d003      	beq.n	403dea <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  403de2:	68fb      	ldr	r3, [r7, #12]
  403de4:	69ba      	ldr	r2, [r7, #24]
  403de6:	665a      	str	r2, [r3, #100]	; 0x64
  403de8:	e002      	b.n	403df0 <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  403dea:	68fb      	ldr	r3, [r7, #12]
  403dec:	69ba      	ldr	r2, [r7, #24]
  403dee:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  403df0:	697b      	ldr	r3, [r7, #20]
  403df2:	f003 0310 	and.w	r3, r3, #16
  403df6:	2b00      	cmp	r3, #0
  403df8:	d004      	beq.n	403e04 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  403dfa:	68fb      	ldr	r3, [r7, #12]
  403dfc:	69ba      	ldr	r2, [r7, #24]
  403dfe:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  403e02:	e003      	b.n	403e0c <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  403e04:	68fb      	ldr	r3, [r7, #12]
  403e06:	69ba      	ldr	r2, [r7, #24]
  403e08:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  403e0c:	697b      	ldr	r3, [r7, #20]
  403e0e:	f003 0320 	and.w	r3, r3, #32
  403e12:	2b00      	cmp	r3, #0
  403e14:	d003      	beq.n	403e1e <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  403e16:	68fb      	ldr	r3, [r7, #12]
  403e18:	69ba      	ldr	r2, [r7, #24]
  403e1a:	651a      	str	r2, [r3, #80]	; 0x50
  403e1c:	e002      	b.n	403e24 <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  403e1e:	68fb      	ldr	r3, [r7, #12]
  403e20:	69ba      	ldr	r2, [r7, #24]
  403e22:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  403e24:	697b      	ldr	r3, [r7, #20]
  403e26:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  403e2a:	2b00      	cmp	r3, #0
  403e2c:	d003      	beq.n	403e36 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  403e2e:	68fb      	ldr	r3, [r7, #12]
  403e30:	69ba      	ldr	r2, [r7, #24]
  403e32:	621a      	str	r2, [r3, #32]
  403e34:	e002      	b.n	403e3c <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  403e36:	68fb      	ldr	r3, [r7, #12]
  403e38:	69ba      	ldr	r2, [r7, #24]
  403e3a:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  403e3c:	697b      	ldr	r3, [r7, #20]
  403e3e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  403e42:	2b00      	cmp	r3, #0
  403e44:	d004      	beq.n	403e50 <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  403e46:	68fb      	ldr	r3, [r7, #12]
  403e48:	69ba      	ldr	r2, [r7, #24]
  403e4a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  403e4e:	e003      	b.n	403e58 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  403e50:	68fb      	ldr	r3, [r7, #12]
  403e52:	69ba      	ldr	r2, [r7, #24]
  403e54:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  403e58:	697b      	ldr	r3, [r7, #20]
  403e5a:	f003 0301 	and.w	r3, r3, #1
  403e5e:	2b00      	cmp	r3, #0
  403e60:	d006      	beq.n	403e70 <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  403e62:	68fb      	ldr	r3, [r7, #12]
  403e64:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403e66:	69bb      	ldr	r3, [r7, #24]
  403e68:	431a      	orrs	r2, r3
  403e6a:	68fb      	ldr	r3, [r7, #12]
  403e6c:	671a      	str	r2, [r3, #112]	; 0x70
  403e6e:	e006      	b.n	403e7e <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  403e70:	68fb      	ldr	r3, [r7, #12]
  403e72:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403e74:	69bb      	ldr	r3, [r7, #24]
  403e76:	43db      	mvns	r3, r3
  403e78:	401a      	ands	r2, r3
  403e7a:	68fb      	ldr	r3, [r7, #12]
  403e7c:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  403e7e:	697b      	ldr	r3, [r7, #20]
  403e80:	f003 0302 	and.w	r3, r3, #2
  403e84:	2b00      	cmp	r3, #0
  403e86:	d006      	beq.n	403e96 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  403e88:	68fb      	ldr	r3, [r7, #12]
  403e8a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403e8c:	69bb      	ldr	r3, [r7, #24]
  403e8e:	431a      	orrs	r2, r3
  403e90:	68fb      	ldr	r3, [r7, #12]
  403e92:	675a      	str	r2, [r3, #116]	; 0x74
}
  403e94:	e006      	b.n	403ea4 <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  403e96:	68fb      	ldr	r3, [r7, #12]
  403e98:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403e9a:	69bb      	ldr	r3, [r7, #24]
  403e9c:	43db      	mvns	r3, r3
  403e9e:	401a      	ands	r2, r3
  403ea0:	68fb      	ldr	r3, [r7, #12]
  403ea2:	675a      	str	r2, [r3, #116]	; 0x74
  403ea4:	bf00      	nop
  403ea6:	3734      	adds	r7, #52	; 0x34
  403ea8:	46bd      	mov	sp, r7
  403eaa:	f85d 7b04 	ldr.w	r7, [sp], #4
  403eae:	4770      	bx	lr

00403eb0 <ioport_set_pin_dir>:
{
  403eb0:	b480      	push	{r7}
  403eb2:	b08d      	sub	sp, #52	; 0x34
  403eb4:	af00      	add	r7, sp, #0
  403eb6:	6078      	str	r0, [r7, #4]
  403eb8:	460b      	mov	r3, r1
  403eba:	70fb      	strb	r3, [r7, #3]
  403ebc:	687b      	ldr	r3, [r7, #4]
  403ebe:	62fb      	str	r3, [r7, #44]	; 0x2c
  403ec0:	78fb      	ldrb	r3, [r7, #3]
  403ec2:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  403ec6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403ec8:	627b      	str	r3, [r7, #36]	; 0x24
  403eca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403ecc:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  403ece:	6a3b      	ldr	r3, [r7, #32]
  403ed0:	095b      	lsrs	r3, r3, #5
  403ed2:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403ed4:	69fb      	ldr	r3, [r7, #28]
  403ed6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403eda:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403ede:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  403ee0:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  403ee2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  403ee6:	2b01      	cmp	r3, #1
  403ee8:	d109      	bne.n	403efe <ioport_set_pin_dir+0x4e>
  403eea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403eec:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  403eee:	697b      	ldr	r3, [r7, #20]
  403ef0:	f003 031f 	and.w	r3, r3, #31
  403ef4:	2201      	movs	r2, #1
  403ef6:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  403ef8:	69bb      	ldr	r3, [r7, #24]
  403efa:	611a      	str	r2, [r3, #16]
  403efc:	e00c      	b.n	403f18 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  403efe:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  403f02:	2b00      	cmp	r3, #0
  403f04:	d108      	bne.n	403f18 <ioport_set_pin_dir+0x68>
  403f06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403f08:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  403f0a:	693b      	ldr	r3, [r7, #16]
  403f0c:	f003 031f 	and.w	r3, r3, #31
  403f10:	2201      	movs	r2, #1
  403f12:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  403f14:	69bb      	ldr	r3, [r7, #24]
  403f16:	615a      	str	r2, [r3, #20]
  403f18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403f1a:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  403f1c:	68fb      	ldr	r3, [r7, #12]
  403f1e:	f003 031f 	and.w	r3, r3, #31
  403f22:	2201      	movs	r2, #1
  403f24:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  403f26:	69bb      	ldr	r3, [r7, #24]
  403f28:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  403f2c:	bf00      	nop
  403f2e:	3734      	adds	r7, #52	; 0x34
  403f30:	46bd      	mov	sp, r7
  403f32:	f85d 7b04 	ldr.w	r7, [sp], #4
  403f36:	4770      	bx	lr

00403f38 <ioport_set_pin_level>:
{
  403f38:	b480      	push	{r7}
  403f3a:	b08b      	sub	sp, #44	; 0x2c
  403f3c:	af00      	add	r7, sp, #0
  403f3e:	6078      	str	r0, [r7, #4]
  403f40:	460b      	mov	r3, r1
  403f42:	70fb      	strb	r3, [r7, #3]
  403f44:	687b      	ldr	r3, [r7, #4]
  403f46:	627b      	str	r3, [r7, #36]	; 0x24
  403f48:	78fb      	ldrb	r3, [r7, #3]
  403f4a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  403f4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403f50:	61fb      	str	r3, [r7, #28]
  403f52:	69fb      	ldr	r3, [r7, #28]
  403f54:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  403f56:	69bb      	ldr	r3, [r7, #24]
  403f58:	095b      	lsrs	r3, r3, #5
  403f5a:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403f5c:	697b      	ldr	r3, [r7, #20]
  403f5e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403f62:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403f66:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  403f68:	613b      	str	r3, [r7, #16]
	if (level) {
  403f6a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  403f6e:	2b00      	cmp	r3, #0
  403f70:	d009      	beq.n	403f86 <ioport_set_pin_level+0x4e>
  403f72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403f74:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  403f76:	68fb      	ldr	r3, [r7, #12]
  403f78:	f003 031f 	and.w	r3, r3, #31
  403f7c:	2201      	movs	r2, #1
  403f7e:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  403f80:	693b      	ldr	r3, [r7, #16]
  403f82:	631a      	str	r2, [r3, #48]	; 0x30
}
  403f84:	e008      	b.n	403f98 <ioport_set_pin_level+0x60>
  403f86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403f88:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  403f8a:	68bb      	ldr	r3, [r7, #8]
  403f8c:	f003 031f 	and.w	r3, r3, #31
  403f90:	2201      	movs	r2, #1
  403f92:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  403f94:	693b      	ldr	r3, [r7, #16]
  403f96:	635a      	str	r2, [r3, #52]	; 0x34
  403f98:	bf00      	nop
  403f9a:	372c      	adds	r7, #44	; 0x2c
  403f9c:	46bd      	mov	sp, r7
  403f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403fa2:	4770      	bx	lr

00403fa4 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
  403fa4:	b580      	push	{r7, lr}
  403fa6:	af00      	add	r7, sp, #0

#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	WDT->WDT_MR = WDT_MR_WDDIS;
  403fa8:	4b4c      	ldr	r3, [pc, #304]	; (4040dc <system_board_init+0x138>)
  403faa:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  403fae:	605a      	str	r2, [r3, #4]
#endif
	ioport_init();
  403fb0:	4b4b      	ldr	r3, [pc, #300]	; (4040e0 <system_board_init+0x13c>)
  403fb2:	4798      	blx	r3

	/* Initialize LED0, turned off */
	ioport_set_pin_dir(LED_0_PIN, IOPORT_DIR_OUTPUT);
  403fb4:	2101      	movs	r1, #1
  403fb6:	2006      	movs	r0, #6
  403fb8:	4b4a      	ldr	r3, [pc, #296]	; (4040e4 <system_board_init+0x140>)
  403fba:	4798      	blx	r3
	ioport_set_pin_level(LED_0_PIN, IOPORT_PIN_LEVEL_HIGH);
  403fbc:	2101      	movs	r1, #1
  403fbe:	2006      	movs	r0, #6
  403fc0:	4b49      	ldr	r3, [pc, #292]	; (4040e8 <system_board_init+0x144>)
  403fc2:	4798      	blx	r3

	/* Initialize SW0 */
	ioport_set_pin_dir(BUTTON_0_PIN, IOPORT_DIR_INPUT);
  403fc4:	2100      	movs	r1, #0
  403fc6:	2002      	movs	r0, #2
  403fc8:	4b46      	ldr	r3, [pc, #280]	; (4040e4 <system_board_init+0x140>)
  403fca:	4798      	blx	r3
	ioport_set_pin_mode(BUTTON_0_PIN, IOPORT_MODE_PULLUP);
  403fcc:	2108      	movs	r1, #8
  403fce:	2002      	movs	r0, #2
  403fd0:	4b46      	ldr	r3, [pc, #280]	; (4040ec <system_board_init+0x148>)
  403fd2:	4798      	blx	r3

	/* Initialize EXT3 LED0, LED1 & LED2, turned off */
	ioport_set_pin_level(OLED1_LED1_PIN, !OLED1_LED1_ACTIVE);
  403fd4:	2101      	movs	r1, #1
  403fd6:	2001      	movs	r0, #1
  403fd8:	4b43      	ldr	r3, [pc, #268]	; (4040e8 <system_board_init+0x144>)
  403fda:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED1_PIN, IOPORT_DIR_OUTPUT);
  403fdc:	2101      	movs	r1, #1
  403fde:	2001      	movs	r0, #1
  403fe0:	4b40      	ldr	r3, [pc, #256]	; (4040e4 <system_board_init+0x140>)
  403fe2:	4798      	blx	r3
	ioport_set_pin_level(OLED1_LED2_PIN, !OLED1_LED2_ACTIVE);
  403fe4:	2101      	movs	r1, #1
  403fe6:	202d      	movs	r0, #45	; 0x2d
  403fe8:	4b3f      	ldr	r3, [pc, #252]	; (4040e8 <system_board_init+0x144>)
  403fea:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED2_PIN, IOPORT_DIR_OUTPUT);
  403fec:	2101      	movs	r1, #1
  403fee:	202d      	movs	r0, #45	; 0x2d
  403ff0:	4b3c      	ldr	r3, [pc, #240]	; (4040e4 <system_board_init+0x140>)
  403ff2:	4798      	blx	r3
	ioport_set_pin_level(OLED1_LED3_PIN, !OLED1_LED3_ACTIVE);
  403ff4:	2101      	movs	r1, #1
  403ff6:	202f      	movs	r0, #47	; 0x2f
  403ff8:	4b3b      	ldr	r3, [pc, #236]	; (4040e8 <system_board_init+0x144>)
  403ffa:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED3_PIN, IOPORT_DIR_OUTPUT);
  403ffc:	2101      	movs	r1, #1
  403ffe:	202f      	movs	r0, #47	; 0x2f
  404000:	4b38      	ldr	r3, [pc, #224]	; (4040e4 <system_board_init+0x140>)
  404002:	4798      	blx	r3

#if defined (CONF_BOARD_UART_CONSOLE)
	/* Configure UART pins */
	ioport_set_port_peripheral_mode(PINS_USART0_PORT, PINS_USART0, PINS_USART0_FLAGS);
  404004:	2201      	movs	r2, #1
  404006:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  40400a:	2000      	movs	r0, #0
  40400c:	4b38      	ldr	r3, [pc, #224]	; (4040f0 <system_board_init+0x14c>)
  40400e:	4798      	blx	r3
  404010:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  404014:	2000      	movs	r0, #0
  404016:	4b37      	ldr	r3, [pc, #220]	; (4040f4 <system_board_init+0x150>)
  404018:	4798      	blx	r3
	ioport_set_port_peripheral_mode(PINS_USART7_PORT, PINS_USART7, PINS_USART7_FLAGS);
  40401a:	2201      	movs	r2, #1
  40401c:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  404020:	2000      	movs	r0, #0
  404022:	4b33      	ldr	r3, [pc, #204]	; (4040f0 <system_board_init+0x14c>)
  404024:	4798      	blx	r3
  404026:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40402a:	2000      	movs	r0, #0
  40402c:	4b31      	ldr	r3, [pc, #196]	; (4040f4 <system_board_init+0x150>)
  40402e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(EXT3_PIN_8,
			IOPORT_MODE_MUX_B);
#endif

#if defined(CONF_BOARD_SPI) || defined(CONF_BOARD_SD_MMC_SPI)
	ioport_set_pin_peripheral_mode(SPI_MISO_GPIO, SPI_MISO_FLAGS);
  404030:	2100      	movs	r1, #0
  404032:	200c      	movs	r0, #12
  404034:	4b2d      	ldr	r3, [pc, #180]	; (4040ec <system_board_init+0x148>)
  404036:	4798      	blx	r3
  404038:	200c      	movs	r0, #12
  40403a:	4b2f      	ldr	r3, [pc, #188]	; (4040f8 <system_board_init+0x154>)
  40403c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(SPI_MOSI_GPIO, SPI_MOSI_FLAGS);
  40403e:	2100      	movs	r1, #0
  404040:	200d      	movs	r0, #13
  404042:	4b2a      	ldr	r3, [pc, #168]	; (4040ec <system_board_init+0x148>)
  404044:	4798      	blx	r3
  404046:	200d      	movs	r0, #13
  404048:	4b2b      	ldr	r3, [pc, #172]	; (4040f8 <system_board_init+0x154>)
  40404a:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(SPI_SPCK_GPIO, SPI_SPCK_FLAGS);
  40404c:	2100      	movs	r1, #0
  40404e:	200e      	movs	r0, #14
  404050:	4b26      	ldr	r3, [pc, #152]	; (4040ec <system_board_init+0x148>)
  404052:	4798      	blx	r3
  404054:	200e      	movs	r0, #14
  404056:	4b28      	ldr	r3, [pc, #160]	; (4040f8 <system_board_init+0x154>)
  404058:	4798      	blx	r3
	ioport_set_pin_dir(SD_MMC_0_CD_GPIO, IOPORT_DIR_INPUT);
	ioport_set_pin_mode(SD_MMC_0_CD_GPIO, IOPORT_MODE_PULLUP);
#endif

#ifdef CONF_BOARD_SPI_NPCS0
	ioport_set_pin_peripheral_mode(SPI_NPCS0_GPIO, SPI_NPCS0_FLAGS);
  40405a:	2100      	movs	r1, #0
  40405c:	200b      	movs	r0, #11
  40405e:	4b23      	ldr	r3, [pc, #140]	; (4040ec <system_board_init+0x148>)
  404060:	4798      	blx	r3
  404062:	200b      	movs	r0, #11
  404064:	4b24      	ldr	r3, [pc, #144]	; (4040f8 <system_board_init+0x154>)
  404066:	4798      	blx	r3
#endif

#ifdef CONF_BOARD_SPI_NPCS1
	ioport_set_pin_peripheral_mode(SPI_NPCS1_GPIO, SPI_NPCS1_FLAGS);
  404068:	2101      	movs	r1, #1
  40406a:	2005      	movs	r0, #5
  40406c:	4b1f      	ldr	r3, [pc, #124]	; (4040ec <system_board_init+0x148>)
  40406e:	4798      	blx	r3
  404070:	2005      	movs	r0, #5
  404072:	4b21      	ldr	r3, [pc, #132]	; (4040f8 <system_board_init+0x154>)
  404074:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI2_DATA_GPIO, TWI2_DATA_FLAGS);
	ioport_set_pin_peripheral_mode(TWI2_CLK_GPIO, TWI2_CLK_FLAGS);
#endif

#if defined(CONF_BOARD_TWI4) ||defined(CONF_BOARD_AT30TSE)
	ioport_set_pin_peripheral_mode(TWI4_DATA_GPIO, TWI4_DATA_FLAGS);
  404076:	2100      	movs	r1, #0
  404078:	2028      	movs	r0, #40	; 0x28
  40407a:	4b1c      	ldr	r3, [pc, #112]	; (4040ec <system_board_init+0x148>)
  40407c:	4798      	blx	r3
  40407e:	2028      	movs	r0, #40	; 0x28
  404080:	4b1d      	ldr	r3, [pc, #116]	; (4040f8 <system_board_init+0x154>)
  404082:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI4_CLK_GPIO, TWI4_CLK_FLAGS);
  404084:	2100      	movs	r1, #0
  404086:	2029      	movs	r0, #41	; 0x29
  404088:	4b18      	ldr	r3, [pc, #96]	; (4040ec <system_board_init+0x148>)
  40408a:	4798      	blx	r3
  40408c:	2029      	movs	r0, #41	; 0x29
  40408e:	4b1a      	ldr	r3, [pc, #104]	; (4040f8 <system_board_init+0x154>)
  404090:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PDM_CLK_GPIO, PDM_CLK_FLAGS);
	ioport_set_pin_peripheral_mode(PDM_DAT_GPIO, PDM_DAT_FLAGS);
#endif

#ifdef CONF_BOARD_USART0
	ioport_set_pin_peripheral_mode(USART0_RXD_GPIO, USART0_RXD_FLAGS);
  404092:	2100      	movs	r1, #0
  404094:	2009      	movs	r0, #9
  404096:	4b15      	ldr	r3, [pc, #84]	; (4040ec <system_board_init+0x148>)
  404098:	4798      	blx	r3
  40409a:	2009      	movs	r0, #9
  40409c:	4b16      	ldr	r3, [pc, #88]	; (4040f8 <system_board_init+0x154>)
  40409e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_TXD_GPIO, USART0_TXD_FLAGS);
  4040a0:	2100      	movs	r1, #0
  4040a2:	200a      	movs	r0, #10
  4040a4:	4b11      	ldr	r3, [pc, #68]	; (4040ec <system_board_init+0x148>)
  4040a6:	4798      	blx	r3
  4040a8:	200a      	movs	r0, #10
  4040aa:	4b13      	ldr	r3, [pc, #76]	; (4040f8 <system_board_init+0x154>)
  4040ac:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_SCK_GPIO, USART0_SCK_FLAGS);
  4040ae:	2100      	movs	r1, #0
  4040b0:	2020      	movs	r0, #32
  4040b2:	4b0e      	ldr	r3, [pc, #56]	; (4040ec <system_board_init+0x148>)
  4040b4:	4798      	blx	r3
  4040b6:	2020      	movs	r0, #32
  4040b8:	4b0f      	ldr	r3, [pc, #60]	; (4040f8 <system_board_init+0x154>)
  4040ba:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_CTS_GPIO, USART0_CTS_FLAGS);
  4040bc:	2100      	movs	r1, #0
  4040be:	2019      	movs	r0, #25
  4040c0:	4b0a      	ldr	r3, [pc, #40]	; (4040ec <system_board_init+0x148>)
  4040c2:	4798      	blx	r3
  4040c4:	2019      	movs	r0, #25
  4040c6:	4b0c      	ldr	r3, [pc, #48]	; (4040f8 <system_board_init+0x154>)
  4040c8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_RTS_GPIO, USART0_RTS_FLAGS);
  4040ca:	2100      	movs	r1, #0
  4040cc:	201a      	movs	r0, #26
  4040ce:	4b07      	ldr	r3, [pc, #28]	; (4040ec <system_board_init+0x148>)
  4040d0:	4798      	blx	r3
  4040d2:	201a      	movs	r0, #26
  4040d4:	4b08      	ldr	r3, [pc, #32]	; (4040f8 <system_board_init+0x154>)
  4040d6:	4798      	blx	r3
#if defined(CONF_BOARD_USB_PORT)
#  if defined(CONF_BOARD_USB_VBUS_DETECT)
	gpio_configure_pin(USB_VBUS_PIN, USB_VBUS_FLAGS);
#  endif
#endif
}
  4040d8:	bf00      	nop
  4040da:	bd80      	pop	{r7, pc}
  4040dc:	400e1450 	.word	0x400e1450
  4040e0:	00403bfd 	.word	0x00403bfd
  4040e4:	00403eb1 	.word	0x00403eb1
  4040e8:	00403f39 	.word	0x00403f39
  4040ec:	00403d95 	.word	0x00403d95
  4040f0:	00403c93 	.word	0x00403c93
  4040f4:	00403c5f 	.word	0x00403c5f
  4040f8:	00403c15 	.word	0x00403c15

004040fc <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  4040fc:	b480      	push	{r7}
  4040fe:	b085      	sub	sp, #20
  404100:	af00      	add	r7, sp, #0
  404102:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  404104:	491d      	ldr	r1, [pc, #116]	; (40417c <pmc_switch_mck_to_pllack+0x80>)
  404106:	4b1d      	ldr	r3, [pc, #116]	; (40417c <pmc_switch_mck_to_pllack+0x80>)
  404108:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40410a:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  40410e:	687b      	ldr	r3, [r7, #4]
  404110:	4313      	orrs	r3, r2
  404112:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404114:	f44f 6300 	mov.w	r3, #2048	; 0x800
  404118:	60fb      	str	r3, [r7, #12]
  40411a:	e007      	b.n	40412c <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40411c:	68fb      	ldr	r3, [r7, #12]
  40411e:	2b00      	cmp	r3, #0
  404120:	d101      	bne.n	404126 <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  404122:	2301      	movs	r3, #1
  404124:	e023      	b.n	40416e <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  404126:	68fb      	ldr	r3, [r7, #12]
  404128:	3b01      	subs	r3, #1
  40412a:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40412c:	4b13      	ldr	r3, [pc, #76]	; (40417c <pmc_switch_mck_to_pllack+0x80>)
  40412e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404130:	f003 0308 	and.w	r3, r3, #8
  404134:	2b00      	cmp	r3, #0
  404136:	d0f1      	beq.n	40411c <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  404138:	4a10      	ldr	r2, [pc, #64]	; (40417c <pmc_switch_mck_to_pllack+0x80>)
  40413a:	4b10      	ldr	r3, [pc, #64]	; (40417c <pmc_switch_mck_to_pllack+0x80>)
  40413c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40413e:	f023 0303 	bic.w	r3, r3, #3
  404142:	f043 0302 	orr.w	r3, r3, #2
  404146:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404148:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40414c:	60fb      	str	r3, [r7, #12]
  40414e:	e007      	b.n	404160 <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  404150:	68fb      	ldr	r3, [r7, #12]
  404152:	2b00      	cmp	r3, #0
  404154:	d101      	bne.n	40415a <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  404156:	2301      	movs	r3, #1
  404158:	e009      	b.n	40416e <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  40415a:	68fb      	ldr	r3, [r7, #12]
  40415c:	3b01      	subs	r3, #1
  40415e:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404160:	4b06      	ldr	r3, [pc, #24]	; (40417c <pmc_switch_mck_to_pllack+0x80>)
  404162:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404164:	f003 0308 	and.w	r3, r3, #8
  404168:	2b00      	cmp	r3, #0
  40416a:	d0f1      	beq.n	404150 <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  40416c:	2300      	movs	r3, #0
}
  40416e:	4618      	mov	r0, r3
  404170:	3714      	adds	r7, #20
  404172:	46bd      	mov	sp, r7
  404174:	f85d 7b04 	ldr.w	r7, [sp], #4
  404178:	4770      	bx	lr
  40417a:	bf00      	nop
  40417c:	400e0400 	.word	0x400e0400

00404180 <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  404180:	b480      	push	{r7}
  404182:	b083      	sub	sp, #12
  404184:	af00      	add	r7, sp, #0
  404186:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  404188:	687b      	ldr	r3, [r7, #4]
  40418a:	2b01      	cmp	r3, #1
  40418c:	d107      	bne.n	40419e <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  40418e:	4a08      	ldr	r2, [pc, #32]	; (4041b0 <pmc_switch_sclk_to_32kxtal+0x30>)
  404190:	4b07      	ldr	r3, [pc, #28]	; (4041b0 <pmc_switch_sclk_to_32kxtal+0x30>)
  404192:	689b      	ldr	r3, [r3, #8]
  404194:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  404198:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  40419c:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  40419e:	4b04      	ldr	r3, [pc, #16]	; (4041b0 <pmc_switch_sclk_to_32kxtal+0x30>)
  4041a0:	4a04      	ldr	r2, [pc, #16]	; (4041b4 <pmc_switch_sclk_to_32kxtal+0x34>)
  4041a2:	601a      	str	r2, [r3, #0]
}
  4041a4:	bf00      	nop
  4041a6:	370c      	adds	r7, #12
  4041a8:	46bd      	mov	sp, r7
  4041aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4041ae:	4770      	bx	lr
  4041b0:	400e1410 	.word	0x400e1410
  4041b4:	a5000008 	.word	0xa5000008

004041b8 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4041b8:	b480      	push	{r7}
  4041ba:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4041bc:	4b09      	ldr	r3, [pc, #36]	; (4041e4 <pmc_osc_is_ready_32kxtal+0x2c>)
  4041be:	695b      	ldr	r3, [r3, #20]
  4041c0:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4041c4:	2b00      	cmp	r3, #0
  4041c6:	d007      	beq.n	4041d8 <pmc_osc_is_ready_32kxtal+0x20>
  4041c8:	4b07      	ldr	r3, [pc, #28]	; (4041e8 <pmc_osc_is_ready_32kxtal+0x30>)
  4041ca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4041cc:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4041d0:	2b00      	cmp	r3, #0
  4041d2:	d001      	beq.n	4041d8 <pmc_osc_is_ready_32kxtal+0x20>
  4041d4:	2301      	movs	r3, #1
  4041d6:	e000      	b.n	4041da <pmc_osc_is_ready_32kxtal+0x22>
  4041d8:	2300      	movs	r3, #0
}
  4041da:	4618      	mov	r0, r3
  4041dc:	46bd      	mov	sp, r7
  4041de:	f85d 7b04 	ldr.w	r7, [sp], #4
  4041e2:	4770      	bx	lr
  4041e4:	400e1410 	.word	0x400e1410
  4041e8:	400e0400 	.word	0x400e0400

004041ec <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  4041ec:	b480      	push	{r7}
  4041ee:	b083      	sub	sp, #12
  4041f0:	af00      	add	r7, sp, #0
  4041f2:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4041f4:	4a18      	ldr	r2, [pc, #96]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  4041f6:	4b18      	ldr	r3, [pc, #96]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  4041f8:	6a1b      	ldr	r3, [r3, #32]
  4041fa:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4041fe:	f043 0308 	orr.w	r3, r3, #8
  404202:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  404204:	bf00      	nop
  404206:	4b14      	ldr	r3, [pc, #80]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  404208:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40420a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  40420e:	2b00      	cmp	r3, #0
  404210:	d0f9      	beq.n	404206 <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  404212:	4911      	ldr	r1, [pc, #68]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  404214:	4b10      	ldr	r3, [pc, #64]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  404216:	6a1b      	ldr	r3, [r3, #32]
  404218:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  40421c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  404220:	687a      	ldr	r2, [r7, #4]
  404222:	4313      	orrs	r3, r2
  404224:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  404228:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  40422a:	bf00      	nop
  40422c:	4b0a      	ldr	r3, [pc, #40]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  40422e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404230:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  404234:	2b00      	cmp	r3, #0
  404236:	d0f9      	beq.n	40422c <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  404238:	4a07      	ldr	r2, [pc, #28]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  40423a:	4b07      	ldr	r3, [pc, #28]	; (404258 <pmc_switch_mainck_to_fastrc+0x6c>)
  40423c:	6a1b      	ldr	r3, [r3, #32]
  40423e:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  404242:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  404246:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40424a:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  40424c:	bf00      	nop
  40424e:	370c      	adds	r7, #12
  404250:	46bd      	mov	sp, r7
  404252:	f85d 7b04 	ldr.w	r7, [sp], #4
  404256:	4770      	bx	lr
  404258:	400e0400 	.word	0x400e0400

0040425c <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  40425c:	b480      	push	{r7}
  40425e:	b083      	sub	sp, #12
  404260:	af00      	add	r7, sp, #0
  404262:	6078      	str	r0, [r7, #4]
  404264:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  404266:	687b      	ldr	r3, [r7, #4]
  404268:	2b00      	cmp	r3, #0
  40426a:	d008      	beq.n	40427e <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40426c:	4916      	ldr	r1, [pc, #88]	; (4042c8 <pmc_switch_mainck_to_xtal+0x6c>)
  40426e:	4b16      	ldr	r3, [pc, #88]	; (4042c8 <pmc_switch_mainck_to_xtal+0x6c>)
  404270:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  404272:	4a16      	ldr	r2, [pc, #88]	; (4042cc <pmc_switch_mainck_to_xtal+0x70>)
  404274:	401a      	ands	r2, r3
  404276:	4b16      	ldr	r3, [pc, #88]	; (4042d0 <pmc_switch_mainck_to_xtal+0x74>)
  404278:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40427a:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  40427c:	e01e      	b.n	4042bc <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40427e:	4912      	ldr	r1, [pc, #72]	; (4042c8 <pmc_switch_mainck_to_xtal+0x6c>)
  404280:	4b11      	ldr	r3, [pc, #68]	; (4042c8 <pmc_switch_mainck_to_xtal+0x6c>)
  404282:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404284:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  404288:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40428c:	683a      	ldr	r2, [r7, #0]
  40428e:	0212      	lsls	r2, r2, #8
  404290:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404292:	4313      	orrs	r3, r2
  404294:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  404298:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40429c:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  40429e:	bf00      	nop
  4042a0:	4b09      	ldr	r3, [pc, #36]	; (4042c8 <pmc_switch_mainck_to_xtal+0x6c>)
  4042a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4042a4:	f003 0301 	and.w	r3, r3, #1
  4042a8:	2b00      	cmp	r3, #0
  4042aa:	d0f9      	beq.n	4042a0 <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4042ac:	4a06      	ldr	r2, [pc, #24]	; (4042c8 <pmc_switch_mainck_to_xtal+0x6c>)
  4042ae:	4b06      	ldr	r3, [pc, #24]	; (4042c8 <pmc_switch_mainck_to_xtal+0x6c>)
  4042b0:	6a1b      	ldr	r3, [r3, #32]
  4042b2:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4042b6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4042ba:	6213      	str	r3, [r2, #32]
}
  4042bc:	bf00      	nop
  4042be:	370c      	adds	r7, #12
  4042c0:	46bd      	mov	sp, r7
  4042c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042c6:	4770      	bx	lr
  4042c8:	400e0400 	.word	0x400e0400
  4042cc:	fec8fffc 	.word	0xfec8fffc
  4042d0:	01370002 	.word	0x01370002

004042d4 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4042d4:	b480      	push	{r7}
  4042d6:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4042d8:	4b04      	ldr	r3, [pc, #16]	; (4042ec <pmc_osc_is_ready_mainck+0x18>)
  4042da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4042dc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4042e0:	4618      	mov	r0, r3
  4042e2:	46bd      	mov	sp, r7
  4042e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042e8:	4770      	bx	lr
  4042ea:	bf00      	nop
  4042ec:	400e0400 	.word	0x400e0400

004042f0 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  4042f0:	b480      	push	{r7}
  4042f2:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
  4042f4:	4b03      	ldr	r3, [pc, #12]	; (404304 <pmc_disable_pllack+0x14>)
  4042f6:	2200      	movs	r2, #0
  4042f8:	629a      	str	r2, [r3, #40]	; 0x28
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
#endif
}
  4042fa:	bf00      	nop
  4042fc:	46bd      	mov	sp, r7
  4042fe:	f85d 7b04 	ldr.w	r7, [sp], #4
  404302:	4770      	bx	lr
  404304:	400e0400 	.word	0x400e0400

00404308 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  404308:	b480      	push	{r7}
  40430a:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40430c:	4b04      	ldr	r3, [pc, #16]	; (404320 <pmc_is_locked_pllack+0x18>)
  40430e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404310:	f003 0302 	and.w	r3, r3, #2
}
  404314:	4618      	mov	r0, r3
  404316:	46bd      	mov	sp, r7
  404318:	f85d 7b04 	ldr.w	r7, [sp], #4
  40431c:	4770      	bx	lr
  40431e:	bf00      	nop
  404320:	400e0400 	.word	0x400e0400

00404324 <pmc_disable_pllbck>:

/**
 * \brief Disable PLLB clock.
 */
void pmc_disable_pllbck(void)
{
  404324:	b480      	push	{r7}
  404326:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLBR = CKGR_PLLBR_MULB(0);
  404328:	4b03      	ldr	r3, [pc, #12]	; (404338 <pmc_disable_pllbck+0x14>)
  40432a:	2200      	movs	r2, #0
  40432c:	62da      	str	r2, [r3, #44]	; 0x2c
}
  40432e:	bf00      	nop
  404330:	46bd      	mov	sp, r7
  404332:	f85d 7b04 	ldr.w	r7, [sp], #4
  404336:	4770      	bx	lr
  404338:	400e0400 	.word	0x400e0400

0040433c <pmc_is_locked_pllbck>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllbck(void)
{
  40433c:	b480      	push	{r7}
  40433e:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKB);
  404340:	4b04      	ldr	r3, [pc, #16]	; (404354 <pmc_is_locked_pllbck+0x18>)
  404342:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404344:	f003 0304 	and.w	r3, r3, #4
}
  404348:	4618      	mov	r0, r3
  40434a:	46bd      	mov	sp, r7
  40434c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404350:	4770      	bx	lr
  404352:	bf00      	nop
  404354:	400e0400 	.word	0x400e0400

00404358 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  404358:	b480      	push	{r7}
  40435a:	b083      	sub	sp, #12
  40435c:	af00      	add	r7, sp, #0
  40435e:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
  404360:	687b      	ldr	r3, [r7, #4]
  404362:	2b32      	cmp	r3, #50	; 0x32
  404364:	d901      	bls.n	40436a <pmc_enable_periph_clk+0x12>
		return 1;
  404366:	2301      	movs	r3, #1
  404368:	e02f      	b.n	4043ca <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  40436a:	687b      	ldr	r3, [r7, #4]
  40436c:	2b1f      	cmp	r3, #31
  40436e:	d813      	bhi.n	404398 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  404370:	4b19      	ldr	r3, [pc, #100]	; (4043d8 <pmc_enable_periph_clk+0x80>)
  404372:	699a      	ldr	r2, [r3, #24]
  404374:	2101      	movs	r1, #1
  404376:	687b      	ldr	r3, [r7, #4]
  404378:	fa01 f303 	lsl.w	r3, r1, r3
  40437c:	401a      	ands	r2, r3
  40437e:	2101      	movs	r1, #1
  404380:	687b      	ldr	r3, [r7, #4]
  404382:	fa01 f303 	lsl.w	r3, r1, r3
  404386:	429a      	cmp	r2, r3
  404388:	d01e      	beq.n	4043c8 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  40438a:	4a13      	ldr	r2, [pc, #76]	; (4043d8 <pmc_enable_periph_clk+0x80>)
  40438c:	2101      	movs	r1, #1
  40438e:	687b      	ldr	r3, [r7, #4]
  404390:	fa01 f303 	lsl.w	r3, r1, r3
  404394:	6113      	str	r3, [r2, #16]
  404396:	e017      	b.n	4043c8 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  404398:	687b      	ldr	r3, [r7, #4]
  40439a:	3b20      	subs	r3, #32
  40439c:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40439e:	4b0e      	ldr	r3, [pc, #56]	; (4043d8 <pmc_enable_periph_clk+0x80>)
  4043a0:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  4043a4:	2101      	movs	r1, #1
  4043a6:	687b      	ldr	r3, [r7, #4]
  4043a8:	fa01 f303 	lsl.w	r3, r1, r3
  4043ac:	401a      	ands	r2, r3
  4043ae:	2101      	movs	r1, #1
  4043b0:	687b      	ldr	r3, [r7, #4]
  4043b2:	fa01 f303 	lsl.w	r3, r1, r3
  4043b6:	429a      	cmp	r2, r3
  4043b8:	d006      	beq.n	4043c8 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  4043ba:	4a07      	ldr	r2, [pc, #28]	; (4043d8 <pmc_enable_periph_clk+0x80>)
  4043bc:	2101      	movs	r1, #1
  4043be:	687b      	ldr	r3, [r7, #4]
  4043c0:	fa01 f303 	lsl.w	r3, r1, r3
  4043c4:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  4043c8:	2300      	movs	r3, #0
}
  4043ca:	4618      	mov	r0, r3
  4043cc:	370c      	adds	r7, #12
  4043ce:	46bd      	mov	sp, r7
  4043d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043d4:	4770      	bx	lr
  4043d6:	bf00      	nop
  4043d8:	400e0400 	.word	0x400e0400

004043dc <pmc_switch_pck_to_mck>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
  4043dc:	b480      	push	{r7}
  4043de:	b085      	sub	sp, #20
  4043e0:	af00      	add	r7, sp, #0
  4043e2:	6078      	str	r0, [r7, #4]
  4043e4:	6039      	str	r1, [r7, #0]
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
  4043e6:	4912      	ldr	r1, [pc, #72]	; (404430 <pmc_switch_pck_to_mck+0x54>)
  4043e8:	683b      	ldr	r3, [r7, #0]
  4043ea:	f043 0204 	orr.w	r2, r3, #4
  4043ee:	687b      	ldr	r3, [r7, #4]
  4043f0:	3310      	adds	r3, #16
  4043f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for (ul_timeout = PMC_TIMEOUT;
  4043f6:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4043fa:	60fb      	str	r3, [r7, #12]
  4043fc:	e007      	b.n	40440e <pmc_switch_pck_to_mck+0x32>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
  4043fe:	68fb      	ldr	r3, [r7, #12]
  404400:	2b00      	cmp	r3, #0
  404402:	d101      	bne.n	404408 <pmc_switch_pck_to_mck+0x2c>
			return 1;
  404404:	2301      	movs	r3, #1
  404406:	e00d      	b.n	404424 <pmc_switch_pck_to_mck+0x48>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  404408:	68fb      	ldr	r3, [r7, #12]
  40440a:	3b01      	subs	r3, #1
  40440c:	60fb      	str	r3, [r7, #12]
  40440e:	4b08      	ldr	r3, [pc, #32]	; (404430 <pmc_switch_pck_to_mck+0x54>)
  404410:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  404412:	f44f 7180 	mov.w	r1, #256	; 0x100
  404416:	687b      	ldr	r3, [r7, #4]
  404418:	fa01 f303 	lsl.w	r3, r1, r3
  40441c:	4013      	ands	r3, r2
	for (ul_timeout = PMC_TIMEOUT;
  40441e:	2b00      	cmp	r3, #0
  404420:	d0ed      	beq.n	4043fe <pmc_switch_pck_to_mck+0x22>
		}
	}

	return 0;
  404422:	2300      	movs	r3, #0
}
  404424:	4618      	mov	r0, r3
  404426:	3714      	adds	r7, #20
  404428:	46bd      	mov	sp, r7
  40442a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40442e:	4770      	bx	lr
  404430:	400e0400 	.word	0x400e0400

00404434 <pmc_enable_pck>:
 * \brief Enable the specified programmable clock.
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_enable_pck(uint32_t ul_id)
{
  404434:	b480      	push	{r7}
  404436:	b083      	sub	sp, #12
  404438:	af00      	add	r7, sp, #0
  40443a:	6078      	str	r0, [r7, #4]
	PMC->PMC_SCER = PMC_SCER_PCK0 << ul_id;
  40443c:	4a06      	ldr	r2, [pc, #24]	; (404458 <pmc_enable_pck+0x24>)
  40443e:	f44f 7180 	mov.w	r1, #256	; 0x100
  404442:	687b      	ldr	r3, [r7, #4]
  404444:	fa01 f303 	lsl.w	r3, r1, r3
  404448:	6013      	str	r3, [r2, #0]
}
  40444a:	bf00      	nop
  40444c:	370c      	adds	r7, #12
  40444e:	46bd      	mov	sp, r7
  404450:	f85d 7b04 	ldr.w	r7, [sp], #4
  404454:	4770      	bx	lr
  404456:	bf00      	nop
  404458:	400e0400 	.word	0x400e0400

0040445c <pmc_disable_pck>:
 * \brief Disable the specified programmable clock.
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_disable_pck(uint32_t ul_id)
{
  40445c:	b480      	push	{r7}
  40445e:	b083      	sub	sp, #12
  404460:	af00      	add	r7, sp, #0
  404462:	6078      	str	r0, [r7, #4]
	PMC->PMC_SCDR = PMC_SCER_PCK0 << ul_id;
  404464:	4a06      	ldr	r2, [pc, #24]	; (404480 <pmc_disable_pck+0x24>)
  404466:	f44f 7180 	mov.w	r1, #256	; 0x100
  40446a:	687b      	ldr	r3, [r7, #4]
  40446c:	fa01 f303 	lsl.w	r3, r1, r3
  404470:	6053      	str	r3, [r2, #4]
}
  404472:	bf00      	nop
  404474:	370c      	adds	r7, #12
  404476:	46bd      	mov	sp, r7
  404478:	f85d 7b04 	ldr.w	r7, [sp], #4
  40447c:	4770      	bx	lr
  40447e:	bf00      	nop
  404480:	400e0400 	.word	0x400e0400

00404484 <supc_set_regulator_trim_user>:
 * \param value the trim value.
 *
 * \note For the trim value in 96M PLL, please read the value in flash unique identifier area.
 */
void supc_set_regulator_trim_user(Supc *p_supc, uint32_t value)
{
  404484:	b480      	push	{r7}
  404486:	b085      	sub	sp, #20
  404488:	af00      	add	r7, sp, #0
  40448a:	6078      	str	r0, [r7, #4]
  40448c:	6039      	str	r1, [r7, #0]
#if SAMG54
	uint32_t ul_mr = p_supc->SUPC_MR & (~SUPC_MR_VRVDD_Msk);
	p_supc->SUPC_MR = SUPC_MR_KEY_PASSWD | ul_mr | SUPC_MR_VDDSEL_USER_VRVDD
		 | SUPC_MR_VRVDD(value);
#else
	uint32_t ul_pwmr = p_supc->SUPC_PWMR & (~(0xFu << 9));
  40448e:	687b      	ldr	r3, [r7, #4]
  404490:	69db      	ldr	r3, [r3, #28]
  404492:	f423 53f0 	bic.w	r3, r3, #7680	; 0x1e00
  404496:	60fb      	str	r3, [r7, #12]
	p_supc->SUPC_PWMR = SUPC_PWMR_KEY_PASSWD | ul_pwmr | SUPC_PWMR_ECPWRS
		| ((value & 0xFu) << 9);
  404498:	683b      	ldr	r3, [r7, #0]
  40449a:	025b      	lsls	r3, r3, #9
  40449c:	f403 52f0 	and.w	r2, r3, #7680	; 0x1e00
  4044a0:	68fb      	ldr	r3, [r7, #12]
  4044a2:	4313      	orrs	r3, r2
  4044a4:	f043 43b4 	orr.w	r3, r3, #1509949440	; 0x5a000000
  4044a8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	p_supc->SUPC_PWMR = SUPC_PWMR_KEY_PASSWD | ul_pwmr | SUPC_PWMR_ECPWRS
  4044ac:	687a      	ldr	r2, [r7, #4]
  4044ae:	61d3      	str	r3, [r2, #28]
#endif
}
  4044b0:	bf00      	nop
  4044b2:	3714      	adds	r7, #20
  4044b4:	46bd      	mov	sp, r7
  4044b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4044ba:	4770      	bx	lr

004044bc <cpu_irq_save>:
{
  4044bc:	b480      	push	{r7}
  4044be:	b083      	sub	sp, #12
  4044c0:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4044c2:	f3ef 8310 	mrs	r3, PRIMASK
  4044c6:	607b      	str	r3, [r7, #4]
  return(result);
  4044c8:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  4044ca:	2b00      	cmp	r3, #0
  4044cc:	bf0c      	ite	eq
  4044ce:	2301      	moveq	r3, #1
  4044d0:	2300      	movne	r3, #0
  4044d2:	b2db      	uxtb	r3, r3
  4044d4:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4044d6:	b672      	cpsid	i
  4044d8:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  4044dc:	4b04      	ldr	r3, [pc, #16]	; (4044f0 <cpu_irq_save+0x34>)
  4044de:	2200      	movs	r2, #0
  4044e0:	701a      	strb	r2, [r3, #0]
	return flags;
  4044e2:	683b      	ldr	r3, [r7, #0]
}
  4044e4:	4618      	mov	r0, r3
  4044e6:	370c      	adds	r7, #12
  4044e8:	46bd      	mov	sp, r7
  4044ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  4044ee:	4770      	bx	lr
  4044f0:	20000119 	.word	0x20000119

004044f4 <cpu_irq_is_enabled_flags>:
{
  4044f4:	b480      	push	{r7}
  4044f6:	b083      	sub	sp, #12
  4044f8:	af00      	add	r7, sp, #0
  4044fa:	6078      	str	r0, [r7, #4]
	return (flags);
  4044fc:	687b      	ldr	r3, [r7, #4]
  4044fe:	2b00      	cmp	r3, #0
  404500:	bf14      	ite	ne
  404502:	2301      	movne	r3, #1
  404504:	2300      	moveq	r3, #0
  404506:	b2db      	uxtb	r3, r3
}
  404508:	4618      	mov	r0, r3
  40450a:	370c      	adds	r7, #12
  40450c:	46bd      	mov	sp, r7
  40450e:	f85d 7b04 	ldr.w	r7, [sp], #4
  404512:	4770      	bx	lr

00404514 <cpu_irq_restore>:
{
  404514:	b580      	push	{r7, lr}
  404516:	b082      	sub	sp, #8
  404518:	af00      	add	r7, sp, #0
  40451a:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  40451c:	6878      	ldr	r0, [r7, #4]
  40451e:	4b07      	ldr	r3, [pc, #28]	; (40453c <cpu_irq_restore+0x28>)
  404520:	4798      	blx	r3
  404522:	4603      	mov	r3, r0
  404524:	2b00      	cmp	r3, #0
  404526:	d005      	beq.n	404534 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  404528:	4b05      	ldr	r3, [pc, #20]	; (404540 <cpu_irq_restore+0x2c>)
  40452a:	2201      	movs	r2, #1
  40452c:	701a      	strb	r2, [r3, #0]
  40452e:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  404532:	b662      	cpsie	i
}
  404534:	bf00      	nop
  404536:	3708      	adds	r7, #8
  404538:	46bd      	mov	sp, r7
  40453a:	bd80      	pop	{r7, pc}
  40453c:	004044f5 	.word	0x004044f5
  404540:	20000119 	.word	0x20000119

00404544 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  404544:	b580      	push	{r7, lr}
  404546:	b084      	sub	sp, #16
  404548:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
  40454a:	4b25      	ldr	r3, [pc, #148]	; (4045e0 <Reset_Handler+0x9c>)
  40454c:	60fb      	str	r3, [r7, #12]
        pDest = &_srelocate;
  40454e:	4b25      	ldr	r3, [pc, #148]	; (4045e4 <Reset_Handler+0xa0>)
  404550:	60bb      	str	r3, [r7, #8]

        if (pSrc != pDest) {
  404552:	68fa      	ldr	r2, [r7, #12]
  404554:	68bb      	ldr	r3, [r7, #8]
  404556:	429a      	cmp	r2, r3
  404558:	d00c      	beq.n	404574 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
  40455a:	e007      	b.n	40456c <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
  40455c:	68bb      	ldr	r3, [r7, #8]
  40455e:	1d1a      	adds	r2, r3, #4
  404560:	60ba      	str	r2, [r7, #8]
  404562:	68fa      	ldr	r2, [r7, #12]
  404564:	1d11      	adds	r1, r2, #4
  404566:	60f9      	str	r1, [r7, #12]
  404568:	6812      	ldr	r2, [r2, #0]
  40456a:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
  40456c:	68bb      	ldr	r3, [r7, #8]
  40456e:	4a1e      	ldr	r2, [pc, #120]	; (4045e8 <Reset_Handler+0xa4>)
  404570:	4293      	cmp	r3, r2
  404572:	d3f3      	bcc.n	40455c <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  404574:	4b1d      	ldr	r3, [pc, #116]	; (4045ec <Reset_Handler+0xa8>)
  404576:	60bb      	str	r3, [r7, #8]
  404578:	e004      	b.n	404584 <Reset_Handler+0x40>
                *pDest++ = 0;
  40457a:	68bb      	ldr	r3, [r7, #8]
  40457c:	1d1a      	adds	r2, r3, #4
  40457e:	60ba      	str	r2, [r7, #8]
  404580:	2200      	movs	r2, #0
  404582:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
  404584:	68bb      	ldr	r3, [r7, #8]
  404586:	4a1a      	ldr	r2, [pc, #104]	; (4045f0 <Reset_Handler+0xac>)
  404588:	4293      	cmp	r3, r2
  40458a:	d3f6      	bcc.n	40457a <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
  40458c:	4b19      	ldr	r3, [pc, #100]	; (4045f4 <Reset_Handler+0xb0>)
  40458e:	60fb      	str	r3, [r7, #12]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  404590:	4a19      	ldr	r2, [pc, #100]	; (4045f8 <Reset_Handler+0xb4>)
  404592:	68fb      	ldr	r3, [r7, #12]
  404594:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  404598:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  40459a:	4b18      	ldr	r3, [pc, #96]	; (4045fc <Reset_Handler+0xb8>)
  40459c:	4798      	blx	r3
  40459e:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  4045a0:	4a17      	ldr	r2, [pc, #92]	; (404600 <Reset_Handler+0xbc>)
  4045a2:	4b17      	ldr	r3, [pc, #92]	; (404600 <Reset_Handler+0xbc>)
  4045a4:	681b      	ldr	r3, [r3, #0]
  4045a6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  4045aa:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb");
  4045ac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb");
  4045b0:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  4045b4:	6878      	ldr	r0, [r7, #4]
  4045b6:	4b13      	ldr	r3, [pc, #76]	; (404604 <Reset_Handler+0xc0>)
  4045b8:	4798      	blx	r3

#if __FPU_USED
	fpu_enable();
#endif

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  4045ba:	68fb      	ldr	r3, [r7, #12]
  4045bc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  4045c0:	d309      	bcc.n	4045d6 <Reset_Handler+0x92>
  4045c2:	68fb      	ldr	r3, [r7, #12]
  4045c4:	4a10      	ldr	r2, [pc, #64]	; (404608 <Reset_Handler+0xc4>)
  4045c6:	4293      	cmp	r3, r2
  4045c8:	d805      	bhi.n	4045d6 <Reset_Handler+0x92>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4045ca:	4a0b      	ldr	r2, [pc, #44]	; (4045f8 <Reset_Handler+0xb4>)
  4045cc:	4b0a      	ldr	r3, [pc, #40]	; (4045f8 <Reset_Handler+0xb4>)
  4045ce:	689b      	ldr	r3, [r3, #8]
  4045d0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  4045d4:	6093      	str	r3, [r2, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4045d6:	4b0d      	ldr	r3, [pc, #52]	; (40460c <Reset_Handler+0xc8>)
  4045d8:	4798      	blx	r3

        /* Branch to main function */
        main();
  4045da:	4b0d      	ldr	r3, [pc, #52]	; (404610 <Reset_Handler+0xcc>)
  4045dc:	4798      	blx	r3

        /* Infinite loop */
        while (1);
  4045de:	e7fe      	b.n	4045de <Reset_Handler+0x9a>
  4045e0:	0041dab4 	.word	0x0041dab4
  4045e4:	20000000 	.word	0x20000000
  4045e8:	20000d08 	.word	0x20000d08
  4045ec:	20000d08 	.word	0x20000d08
  4045f0:	20001fac 	.word	0x20001fac
  4045f4:	00400000 	.word	0x00400000
  4045f8:	e000ed00 	.word	0xe000ed00
  4045fc:	004044bd 	.word	0x004044bd
  404600:	e000ed88 	.word	0xe000ed88
  404604:	00404515 	.word	0x00404515
  404608:	20027fff 	.word	0x20027fff
  40460c:	00414185 	.word	0x00414185
  404610:	0040117d 	.word	0x0040117d

00404614 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  404614:	b480      	push	{r7}
  404616:	af00      	add	r7, sp, #0
        while (1) {
  404618:	e7fe      	b.n	404618 <Dummy_Handler+0x4>
	...

0040461c <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void)
{
  40461c:	b480      	push	{r7}
  40461e:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  404620:	4b41      	ldr	r3, [pc, #260]	; (404728 <SystemCoreClockUpdate+0x10c>)
  404622:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404624:	f003 0303 	and.w	r3, r3, #3
  404628:	2b01      	cmp	r3, #1
  40462a:	d014      	beq.n	404656 <SystemCoreClockUpdate+0x3a>
  40462c:	2b01      	cmp	r3, #1
  40462e:	d302      	bcc.n	404636 <SystemCoreClockUpdate+0x1a>
  404630:	2b02      	cmp	r3, #2
  404632:	d038      	beq.n	4046a6 <SystemCoreClockUpdate+0x8a>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
					CKGR_PLLAR_MULA_Pos) + 1U);
		}
		break;
	default:
		break;
  404634:	e059      	b.n	4046ea <SystemCoreClockUpdate+0xce>
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  404636:	4b3d      	ldr	r3, [pc, #244]	; (40472c <SystemCoreClockUpdate+0x110>)
  404638:	695b      	ldr	r3, [r3, #20]
  40463a:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40463e:	2b00      	cmp	r3, #0
  404640:	d004      	beq.n	40464c <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  404642:	4b3b      	ldr	r3, [pc, #236]	; (404730 <SystemCoreClockUpdate+0x114>)
  404644:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  404648:	601a      	str	r2, [r3, #0]
		break;
  40464a:	e04e      	b.n	4046ea <SystemCoreClockUpdate+0xce>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40464c:	4b38      	ldr	r3, [pc, #224]	; (404730 <SystemCoreClockUpdate+0x114>)
  40464e:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  404652:	601a      	str	r2, [r3, #0]
		break;
  404654:	e049      	b.n	4046ea <SystemCoreClockUpdate+0xce>
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  404656:	4b34      	ldr	r3, [pc, #208]	; (404728 <SystemCoreClockUpdate+0x10c>)
  404658:	6a1b      	ldr	r3, [r3, #32]
  40465a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  40465e:	2b00      	cmp	r3, #0
  404660:	d003      	beq.n	40466a <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL;
  404662:	4b33      	ldr	r3, [pc, #204]	; (404730 <SystemCoreClockUpdate+0x114>)
  404664:	4a33      	ldr	r2, [pc, #204]	; (404734 <SystemCoreClockUpdate+0x118>)
  404666:	601a      	str	r2, [r3, #0]
		break;
  404668:	e03f      	b.n	4046ea <SystemCoreClockUpdate+0xce>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  40466a:	4b31      	ldr	r3, [pc, #196]	; (404730 <SystemCoreClockUpdate+0x114>)
  40466c:	4a32      	ldr	r2, [pc, #200]	; (404738 <SystemCoreClockUpdate+0x11c>)
  40466e:	601a      	str	r2, [r3, #0]
			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  404670:	4b2d      	ldr	r3, [pc, #180]	; (404728 <SystemCoreClockUpdate+0x10c>)
  404672:	6a1b      	ldr	r3, [r3, #32]
  404674:	f003 0370 	and.w	r3, r3, #112	; 0x70
  404678:	2b10      	cmp	r3, #16
  40467a:	d004      	beq.n	404686 <SystemCoreClockUpdate+0x6a>
  40467c:	2b20      	cmp	r3, #32
  40467e:	d008      	beq.n	404692 <SystemCoreClockUpdate+0x76>
  404680:	2b00      	cmp	r3, #0
  404682:	d00e      	beq.n	4046a2 <SystemCoreClockUpdate+0x86>
				break;
  404684:	e00e      	b.n	4046a4 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  404686:	4b2a      	ldr	r3, [pc, #168]	; (404730 <SystemCoreClockUpdate+0x114>)
  404688:	681b      	ldr	r3, [r3, #0]
  40468a:	005b      	lsls	r3, r3, #1
  40468c:	4a28      	ldr	r2, [pc, #160]	; (404730 <SystemCoreClockUpdate+0x114>)
  40468e:	6013      	str	r3, [r2, #0]
				break;
  404690:	e008      	b.n	4046a4 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  404692:	4b27      	ldr	r3, [pc, #156]	; (404730 <SystemCoreClockUpdate+0x114>)
  404694:	681a      	ldr	r2, [r3, #0]
  404696:	4613      	mov	r3, r2
  404698:	005b      	lsls	r3, r3, #1
  40469a:	4413      	add	r3, r2
  40469c:	4a24      	ldr	r2, [pc, #144]	; (404730 <SystemCoreClockUpdate+0x114>)
  40469e:	6013      	str	r3, [r2, #0]
				break;
  4046a0:	e000      	b.n	4046a4 <SystemCoreClockUpdate+0x88>
				break;
  4046a2:	bf00      	nop
		break;
  4046a4:	e021      	b.n	4046ea <SystemCoreClockUpdate+0xce>
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  4046a6:	4b21      	ldr	r3, [pc, #132]	; (40472c <SystemCoreClockUpdate+0x110>)
  4046a8:	695b      	ldr	r3, [r3, #20]
  4046aa:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4046ae:	2b00      	cmp	r3, #0
  4046b0:	d004      	beq.n	4046bc <SystemCoreClockUpdate+0xa0>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  4046b2:	4b1f      	ldr	r3, [pc, #124]	; (404730 <SystemCoreClockUpdate+0x114>)
  4046b4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  4046b8:	601a      	str	r2, [r3, #0]
  4046ba:	e003      	b.n	4046c4 <SystemCoreClockUpdate+0xa8>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  4046bc:	4b1c      	ldr	r3, [pc, #112]	; (404730 <SystemCoreClockUpdate+0x114>)
  4046be:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  4046c2:	601a      	str	r2, [r3, #0]
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  4046c4:	4b18      	ldr	r3, [pc, #96]	; (404728 <SystemCoreClockUpdate+0x10c>)
  4046c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4046c8:	f003 0303 	and.w	r3, r3, #3
  4046cc:	2b02      	cmp	r3, #2
  4046ce:	d10b      	bne.n	4046e8 <SystemCoreClockUpdate+0xcc>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  4046d0:	4b15      	ldr	r3, [pc, #84]	; (404728 <SystemCoreClockUpdate+0x10c>)
  4046d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  4046d4:	0c1b      	lsrs	r3, r3, #16
  4046d6:	f3c3 030c 	ubfx	r3, r3, #0, #13
					CKGR_PLLAR_MULA_Pos) + 1U);
  4046da:	3301      	adds	r3, #1
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  4046dc:	4a14      	ldr	r2, [pc, #80]	; (404730 <SystemCoreClockUpdate+0x114>)
  4046de:	6812      	ldr	r2, [r2, #0]
  4046e0:	fb02 f303 	mul.w	r3, r2, r3
  4046e4:	4a12      	ldr	r2, [pc, #72]	; (404730 <SystemCoreClockUpdate+0x114>)
  4046e6:	6013      	str	r3, [r2, #0]
		break;
  4046e8:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  4046ea:	4b0f      	ldr	r3, [pc, #60]	; (404728 <SystemCoreClockUpdate+0x10c>)
  4046ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4046ee:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4046f2:	2b70      	cmp	r3, #112	; 0x70
  4046f4:	d108      	bne.n	404708 <SystemCoreClockUpdate+0xec>
		SystemCoreClock /= 3U;
  4046f6:	4b0e      	ldr	r3, [pc, #56]	; (404730 <SystemCoreClockUpdate+0x114>)
  4046f8:	681b      	ldr	r3, [r3, #0]
  4046fa:	4a10      	ldr	r2, [pc, #64]	; (40473c <SystemCoreClockUpdate+0x120>)
  4046fc:	fba2 2303 	umull	r2, r3, r2, r3
  404700:	085b      	lsrs	r3, r3, #1
  404702:	4a0b      	ldr	r2, [pc, #44]	; (404730 <SystemCoreClockUpdate+0x114>)
  404704:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
	}
}
  404706:	e00a      	b.n	40471e <SystemCoreClockUpdate+0x102>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  404708:	4b07      	ldr	r3, [pc, #28]	; (404728 <SystemCoreClockUpdate+0x10c>)
  40470a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40470c:	091b      	lsrs	r3, r3, #4
  40470e:	f003 0307 	and.w	r3, r3, #7
  404712:	4a07      	ldr	r2, [pc, #28]	; (404730 <SystemCoreClockUpdate+0x114>)
  404714:	6812      	ldr	r2, [r2, #0]
  404716:	fa22 f303 	lsr.w	r3, r2, r3
  40471a:	4a05      	ldr	r2, [pc, #20]	; (404730 <SystemCoreClockUpdate+0x114>)
  40471c:	6013      	str	r3, [r2, #0]
}
  40471e:	bf00      	nop
  404720:	46bd      	mov	sp, r7
  404722:	f85d 7b04 	ldr.w	r7, [sp], #4
  404726:	4770      	bx	lr
  404728:	400e0400 	.word	0x400e0400
  40472c:	400e1410 	.word	0x400e1410
  404730:	2000011c 	.word	0x2000011c
  404734:	00b71b00 	.word	0x00b71b00
  404738:	007a1200 	.word	0x007a1200
  40473c:	aaaaaaab 	.word	0xaaaaaaab

00404740 <system_init_flash>:

/** 
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
  404740:	b480      	push	{r7}
  404742:	b083      	sub	sp, #12
  404744:	af00      	add	r7, sp, #0
  404746:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  404748:	687b      	ldr	r3, [r7, #4]
  40474a:	4a19      	ldr	r2, [pc, #100]	; (4047b0 <system_init_flash+0x70>)
  40474c:	4293      	cmp	r3, r2
  40474e:	d804      	bhi.n	40475a <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  404750:	4b18      	ldr	r3, [pc, #96]	; (4047b4 <system_init_flash+0x74>)
  404752:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  404756:	601a      	str	r2, [r3, #0]
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
	}
}
  404758:	e023      	b.n	4047a2 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  40475a:	687b      	ldr	r3, [r7, #4]
  40475c:	4a16      	ldr	r2, [pc, #88]	; (4047b8 <system_init_flash+0x78>)
  40475e:	4293      	cmp	r3, r2
  404760:	d803      	bhi.n	40476a <system_init_flash+0x2a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  404762:	4b14      	ldr	r3, [pc, #80]	; (4047b4 <system_init_flash+0x74>)
  404764:	4a15      	ldr	r2, [pc, #84]	; (4047bc <system_init_flash+0x7c>)
  404766:	601a      	str	r2, [r3, #0]
}
  404768:	e01b      	b.n	4047a2 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  40476a:	687b      	ldr	r3, [r7, #4]
  40476c:	4a14      	ldr	r2, [pc, #80]	; (4047c0 <system_init_flash+0x80>)
  40476e:	4293      	cmp	r3, r2
  404770:	d803      	bhi.n	40477a <system_init_flash+0x3a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  404772:	4b10      	ldr	r3, [pc, #64]	; (4047b4 <system_init_flash+0x74>)
  404774:	4a13      	ldr	r2, [pc, #76]	; (4047c4 <system_init_flash+0x84>)
  404776:	601a      	str	r2, [r3, #0]
}
  404778:	e013      	b.n	4047a2 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  40477a:	687b      	ldr	r3, [r7, #4]
  40477c:	4a12      	ldr	r2, [pc, #72]	; (4047c8 <system_init_flash+0x88>)
  40477e:	4293      	cmp	r3, r2
  404780:	d803      	bhi.n	40478a <system_init_flash+0x4a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  404782:	4b0c      	ldr	r3, [pc, #48]	; (4047b4 <system_init_flash+0x74>)
  404784:	4a11      	ldr	r2, [pc, #68]	; (4047cc <system_init_flash+0x8c>)
  404786:	601a      	str	r2, [r3, #0]
}
  404788:	e00b      	b.n	4047a2 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
  40478a:	687b      	ldr	r3, [r7, #4]
  40478c:	4a10      	ldr	r2, [pc, #64]	; (4047d0 <system_init_flash+0x90>)
  40478e:	4293      	cmp	r3, r2
  404790:	d804      	bhi.n	40479c <system_init_flash+0x5c>
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  404792:	4b08      	ldr	r3, [pc, #32]	; (4047b4 <system_init_flash+0x74>)
  404794:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  404798:	601a      	str	r2, [r3, #0]
}
  40479a:	e002      	b.n	4047a2 <system_init_flash+0x62>
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  40479c:	4b05      	ldr	r3, [pc, #20]	; (4047b4 <system_init_flash+0x74>)
  40479e:	4a0d      	ldr	r2, [pc, #52]	; (4047d4 <system_init_flash+0x94>)
  4047a0:	601a      	str	r2, [r3, #0]
}
  4047a2:	bf00      	nop
  4047a4:	370c      	adds	r7, #12
  4047a6:	46bd      	mov	sp, r7
  4047a8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4047ac:	4770      	bx	lr
  4047ae:	bf00      	nop
  4047b0:	01312cff 	.word	0x01312cff
  4047b4:	400e0a00 	.word	0x400e0a00
  4047b8:	026259ff 	.word	0x026259ff
  4047bc:	04000100 	.word	0x04000100
  4047c0:	039386ff 	.word	0x039386ff
  4047c4:	04000200 	.word	0x04000200
  4047c8:	04c4b3ff 	.word	0x04c4b3ff
  4047cc:	04000300 	.word	0x04000300
  4047d0:	05f5e0ff 	.word	0x05f5e0ff
  4047d4:	04000500 	.word	0x04000500

004047d8 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
  4047d8:	b480      	push	{r7}
  4047da:	b085      	sub	sp, #20
  4047dc:	af00      	add	r7, sp, #0
  4047de:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  4047e0:	4b10      	ldr	r3, [pc, #64]	; (404824 <_sbrk+0x4c>)
  4047e2:	60fb      	str	r3, [r7, #12]

	if (heap == NULL) {
  4047e4:	4b10      	ldr	r3, [pc, #64]	; (404828 <_sbrk+0x50>)
  4047e6:	681b      	ldr	r3, [r3, #0]
  4047e8:	2b00      	cmp	r3, #0
  4047ea:	d102      	bne.n	4047f2 <_sbrk+0x1a>
		heap = (unsigned char *)&_end;
  4047ec:	4b0e      	ldr	r3, [pc, #56]	; (404828 <_sbrk+0x50>)
  4047ee:	4a0f      	ldr	r2, [pc, #60]	; (40482c <_sbrk+0x54>)
  4047f0:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  4047f2:	4b0d      	ldr	r3, [pc, #52]	; (404828 <_sbrk+0x50>)
  4047f4:	681b      	ldr	r3, [r3, #0]
  4047f6:	60bb      	str	r3, [r7, #8]

	if (((int)prev_heap + incr) > ramend) {
  4047f8:	68ba      	ldr	r2, [r7, #8]
  4047fa:	687b      	ldr	r3, [r7, #4]
  4047fc:	441a      	add	r2, r3
  4047fe:	68fb      	ldr	r3, [r7, #12]
  404800:	429a      	cmp	r2, r3
  404802:	dd02      	ble.n	40480a <_sbrk+0x32>
		return (caddr_t) -1;	
  404804:	f04f 33ff 	mov.w	r3, #4294967295
  404808:	e006      	b.n	404818 <_sbrk+0x40>
	}

	heap += incr;
  40480a:	4b07      	ldr	r3, [pc, #28]	; (404828 <_sbrk+0x50>)
  40480c:	681a      	ldr	r2, [r3, #0]
  40480e:	687b      	ldr	r3, [r7, #4]
  404810:	4413      	add	r3, r2
  404812:	4a05      	ldr	r2, [pc, #20]	; (404828 <_sbrk+0x50>)
  404814:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
  404816:	68bb      	ldr	r3, [r7, #8]
}
  404818:	4618      	mov	r0, r3
  40481a:	3714      	adds	r7, #20
  40481c:	46bd      	mov	sp, r7
  40481e:	f85d 7b04 	ldr.w	r7, [sp], #4
  404822:	4770      	bx	lr
  404824:	20027ffc 	.word	0x20027ffc
  404828:	2000141c 	.word	0x2000141c
  40482c:	20004fb0 	.word	0x20004fb0

00404830 <inv_icm20648_register_aux_compass>:
static const short AK09916_ST_Lower[3] = {-200, -200, -1000};
static const short AK09916_ST_Upper[3] = {200, 200, -200};

void inv_icm20648_register_aux_compass(struct inv_icm20648 * s,
		enum inv_icm20648_compass_id compass_id, uint8_t compass_i2c_addr)
{
  404830:	b480      	push	{r7}
  404832:	b083      	sub	sp, #12
  404834:	af00      	add	r7, sp, #0
  404836:	6078      	str	r0, [r7, #4]
  404838:	460b      	mov	r3, r1
  40483a:	70fb      	strb	r3, [r7, #3]
  40483c:	4613      	mov	r3, r2
  40483e:	70bb      	strb	r3, [r7, #2]
	switch(compass_id) {
  404840:	78fb      	ldrb	r3, [r7, #3]
  404842:	3b01      	subs	r3, #1
  404844:	2b03      	cmp	r3, #3
  404846:	d86f      	bhi.n	404928 <inv_icm20648_register_aux_compass+0xf8>
  404848:	a201      	add	r2, pc, #4	; (adr r2, 404850 <inv_icm20648_register_aux_compass+0x20>)
  40484a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40484e:	bf00      	nop
  404850:	00404861 	.word	0x00404861
  404854:	00404893 	.word	0x00404893
  404858:	004048f7 	.word	0x004048f7
  40485c:	004048c5 	.word	0x004048c5
#if (MEMS_CHIP == HW_ICM20648)
	case INV_ICM20648_COMPASS_ID_AK09911:
		s->secondary_state.compass_slave_id = HW_AK09911;
  404860:	687b      	ldr	r3, [r7, #4]
  404862:	2223      	movs	r2, #35	; 0x23
  404864:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  404868:	78ba      	ldrb	r2, [r7, #2]
  40486a:	687b      	ldr	r3, [r7, #4]
  40486c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20648_COMPASS_INITED;
  404870:	687b      	ldr	r3, [r7, #4]
  404872:	2201      	movs	r2, #1
  404874:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm9911 */
		s->mounting_matrix_secondary_compass[0] = 1;
  404878:	687b      	ldr	r3, [r7, #4]
  40487a:	2201      	movs	r2, #1
  40487c:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = 1;
  404880:	687b      	ldr	r3, [r7, #4]
  404882:	2201      	movs	r2, #1
  404884:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = 1;
  404888:	687b      	ldr	r3, [r7, #4]
  40488a:	2201      	movs	r2, #1
  40488c:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  404890:	e056      	b.n	404940 <inv_icm20648_register_aux_compass+0x110>
	case INV_ICM20648_COMPASS_ID_AK09912:
		s->secondary_state.compass_slave_id = HW_AK09912;
  404892:	687b      	ldr	r3, [r7, #4]
  404894:	2224      	movs	r2, #36	; 0x24
  404896:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  40489a:	78ba      	ldrb	r2, [r7, #2]
  40489c:	687b      	ldr	r3, [r7, #4]
  40489e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20648_COMPASS_INITED;
  4048a2:	687b      	ldr	r3, [r7, #4]
  4048a4:	2201      	movs	r2, #1
  4048a6:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm9912 */
		s->mounting_matrix_secondary_compass[0] = 1;
  4048aa:	687b      	ldr	r3, [r7, #4]
  4048ac:	2201      	movs	r2, #1
  4048ae:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = 1;
  4048b2:	687b      	ldr	r3, [r7, #4]
  4048b4:	2201      	movs	r2, #1
  4048b6:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = 1;
  4048ba:	687b      	ldr	r3, [r7, #4]
  4048bc:	2201      	movs	r2, #1
  4048be:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  4048c2:	e03d      	b.n	404940 <inv_icm20648_register_aux_compass+0x110>
	case INV_ICM20648_COMPASS_ID_AK08963:
		s->secondary_state.compass_slave_id = HW_AK8963;
  4048c4:	687b      	ldr	r3, [r7, #4]
  4048c6:	2220      	movs	r2, #32
  4048c8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  4048cc:	78ba      	ldrb	r2, [r7, #2]
  4048ce:	687b      	ldr	r3, [r7, #4]
  4048d0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20648_COMPASS_INITED;
  4048d4:	687b      	ldr	r3, [r7, #4]
  4048d6:	2201      	movs	r2, #1
  4048d8:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm8963 */
		s->mounting_matrix_secondary_compass[0] = 1;
  4048dc:	687b      	ldr	r3, [r7, #4]
  4048de:	2201      	movs	r2, #1
  4048e0:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = 1;
  4048e4:	687b      	ldr	r3, [r7, #4]
  4048e6:	2201      	movs	r2, #1
  4048e8:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = 1;
  4048ec:	687b      	ldr	r3, [r7, #4]
  4048ee:	2201      	movs	r2, #1
  4048f0:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  4048f4:	e024      	b.n	404940 <inv_icm20648_register_aux_compass+0x110>
#endif
	case INV_ICM20648_COMPASS_ID_AK09916:
		s->secondary_state.compass_slave_id = HW_AK09916;
  4048f6:	687b      	ldr	r3, [r7, #4]
  4048f8:	2225      	movs	r2, #37	; 0x25
  4048fa:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  4048fe:	78ba      	ldrb	r2, [r7, #2]
  404900:	687b      	ldr	r3, [r7, #4]
  404902:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20648_COMPASS_INITED;
  404906:	687b      	ldr	r3, [r7, #4]
  404908:	2201      	movs	r2, #1
  40490a:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm9916 */
		s->mounting_matrix_secondary_compass[0] =  1;
  40490e:	687b      	ldr	r3, [r7, #4]
  404910:	2201      	movs	r2, #1
  404912:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = -1;
  404916:	687b      	ldr	r3, [r7, #4]
  404918:	22ff      	movs	r2, #255	; 0xff
  40491a:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = -1;
  40491e:	687b      	ldr	r3, [r7, #4]
  404920:	22ff      	movs	r2, #255	; 0xff
  404922:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  404926:	e00b      	b.n	404940 <inv_icm20648_register_aux_compass+0x110>
	default:
		s->secondary_state.compass_slave_id  = 0;
  404928:	687b      	ldr	r3, [r7, #4]
  40492a:	2200      	movs	r2, #0
  40492c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = 0;
  404930:	687b      	ldr	r3, [r7, #4]
  404932:	2200      	movs	r2, #0
  404934:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20648_COMPASS_RESET;
  404938:	687b      	ldr	r3, [r7, #4]
  40493a:	2200      	movs	r2, #0
  40493c:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	}
}
  404940:	bf00      	nop
  404942:	370c      	adds	r7, #12
  404944:	46bd      	mov	sp, r7
  404946:	f85d 7b04 	ldr.w	r7, [sp], #4
  40494a:	4770      	bx	lr

0040494c <inv_icm20648_setup_compass_akm>:

/*
 *  inv_icm20648_setup_compass_akm() - Configure akm series compass.
 */
int inv_icm20648_setup_compass_akm(struct inv_icm20648 * s)
{
  40494c:	b590      	push	{r4, r7, lr}
  40494e:	b089      	sub	sp, #36	; 0x24
  404950:	af02      	add	r7, sp, #8
  404952:	6078      	str	r0, [r7, #4]
	unsigned char data[4];
#if (MEMS_CHIP != HW_ICM20948)
	uint8_t sens, cmd;
#endif
	//reset variable to initial values
	memset(s->secondary_state.final_matrix, 0, sizeof(s->secondary_state.final_matrix));
  404954:	687b      	ldr	r3, [r7, #4]
  404956:	3350      	adds	r3, #80	; 0x50
  404958:	2224      	movs	r2, #36	; 0x24
  40495a:	2100      	movs	r1, #0
  40495c:	4618      	mov	r0, r3
  40495e:	4b91      	ldr	r3, [pc, #580]	; (404ba4 <inv_icm20648_setup_compass_akm+0x258>)
  404960:	4798      	blx	r3
	memset(s->secondary_state.compass_sens, 0, sizeof(s->secondary_state.compass_sens));
  404962:	687b      	ldr	r3, [r7, #4]
  404964:	334d      	adds	r3, #77	; 0x4d
  404966:	2203      	movs	r2, #3
  404968:	2100      	movs	r1, #0
  40496a:	4618      	mov	r0, r3
  40496c:	4b8d      	ldr	r3, [pc, #564]	; (404ba4 <inv_icm20648_setup_compass_akm+0x258>)
  40496e:	4798      	blx	r3
	s->secondary_state.scale = 0;
  404970:	687b      	ldr	r3, [r7, #4]
  404972:	2200      	movs	r2, #0
  404974:	67da      	str	r2, [r3, #124]	; 0x7c
	s->secondary_state.dmp_on = 1;
  404976:	687b      	ldr	r3, [r7, #4]
  404978:	2201      	movs	r2, #1
  40497a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	s->secondary_state.secondary_resume_compass_state = 0;
  40497e:	687b      	ldr	r3, [r7, #4]
  404980:	2200      	movs	r2, #0
  404982:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
	
	/* Read WHOAMI through I2C SLV for compass */
	result = inv_icm20648_execute_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, REG_AKM_ID, 1, data);
  404986:	687b      	ldr	r3, [r7, #4]
  404988:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  40498c:	b2da      	uxtb	r2, r3
  40498e:	f107 030c 	add.w	r3, r7, #12
  404992:	9301      	str	r3, [sp, #4]
  404994:	2301      	movs	r3, #1
  404996:	9300      	str	r3, [sp, #0]
  404998:	2300      	movs	r3, #0
  40499a:	2100      	movs	r1, #0
  40499c:	6878      	ldr	r0, [r7, #4]
  40499e:	4c82      	ldr	r4, [pc, #520]	; (404ba8 <inv_icm20648_setup_compass_akm+0x25c>)
  4049a0:	47a0      	blx	r4
  4049a2:	6138      	str	r0, [r7, #16]
	if (result) {
  4049a4:	693b      	ldr	r3, [r7, #16]
  4049a6:	2b00      	cmp	r3, #0
  4049a8:	d001      	beq.n	4049ae <inv_icm20648_setup_compass_akm+0x62>
        // inv_log("Read secondary error: Compass.\r\n");
		return result;
  4049aa:	693b      	ldr	r3, [r7, #16]
  4049ac:	e0f5      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
    }
	if (data[0] != DATA_AKM_ID) {
  4049ae:	7b3b      	ldrb	r3, [r7, #12]
  4049b0:	2b48      	cmp	r3, #72	; 0x48
  4049b2:	d002      	beq.n	4049ba <inv_icm20648_setup_compass_akm+0x6e>
        // inv_log("Compass not found!!\r\n");
		return -1;
  4049b4:	f04f 33ff 	mov.w	r3, #4294967295
  4049b8:	e0ef      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
	/* setup upper and lower limit of self-test */
#if (MEMS_CHIP == HW_ICM20948)
	s->secondary_state.st_upper = AK09916_ST_Upper;
	s->secondary_state.st_lower = AK09916_ST_Lower;
#else
	if (HW_AK8975 == s->secondary_state.compass_slave_id) {
  4049ba:	687b      	ldr	r3, [r7, #4]
  4049bc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  4049c0:	2b21      	cmp	r3, #33	; 0x21
  4049c2:	d106      	bne.n	4049d2 <inv_icm20648_setup_compass_akm+0x86>
		s->secondary_state.st_upper = AKM8975_ST_Upper;
  4049c4:	687b      	ldr	r3, [r7, #4]
  4049c6:	4a79      	ldr	r2, [pc, #484]	; (404bac <inv_icm20648_setup_compass_akm+0x260>)
  4049c8:	675a      	str	r2, [r3, #116]	; 0x74
		s->secondary_state.st_lower = AKM8975_ST_Lower;
  4049ca:	687b      	ldr	r3, [r7, #4]
  4049cc:	4a78      	ldr	r2, [pc, #480]	; (404bb0 <inv_icm20648_setup_compass_akm+0x264>)
  4049ce:	679a      	str	r2, [r3, #120]	; 0x78
  4049d0:	e03e      	b.n	404a50 <inv_icm20648_setup_compass_akm+0x104>
	} else if (HW_AK8972 == s->secondary_state.compass_slave_id) {
  4049d2:	687b      	ldr	r3, [r7, #4]
  4049d4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  4049d8:	2b22      	cmp	r3, #34	; 0x22
  4049da:	d106      	bne.n	4049ea <inv_icm20648_setup_compass_akm+0x9e>
		s->secondary_state.st_upper = AKM8972_ST_Upper;
  4049dc:	687b      	ldr	r3, [r7, #4]
  4049de:	4a75      	ldr	r2, [pc, #468]	; (404bb4 <inv_icm20648_setup_compass_akm+0x268>)
  4049e0:	675a      	str	r2, [r3, #116]	; 0x74
		s->secondary_state.st_lower = AKM8972_ST_Lower;
  4049e2:	687b      	ldr	r3, [r7, #4]
  4049e4:	4a74      	ldr	r2, [pc, #464]	; (404bb8 <inv_icm20648_setup_compass_akm+0x26c>)
  4049e6:	679a      	str	r2, [r3, #120]	; 0x78
  4049e8:	e032      	b.n	404a50 <inv_icm20648_setup_compass_akm+0x104>
	} else if (HW_AK8963 == s->secondary_state.compass_slave_id) {
  4049ea:	687b      	ldr	r3, [r7, #4]
  4049ec:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  4049f0:	2b20      	cmp	r3, #32
  4049f2:	d106      	bne.n	404a02 <inv_icm20648_setup_compass_akm+0xb6>
		s->secondary_state.st_upper = AKM8963_ST_Upper;
  4049f4:	687b      	ldr	r3, [r7, #4]
  4049f6:	4a71      	ldr	r2, [pc, #452]	; (404bbc <inv_icm20648_setup_compass_akm+0x270>)
  4049f8:	675a      	str	r2, [r3, #116]	; 0x74
		s->secondary_state.st_lower = AKM8963_ST_Lower;
  4049fa:	687b      	ldr	r3, [r7, #4]
  4049fc:	4a70      	ldr	r2, [pc, #448]	; (404bc0 <inv_icm20648_setup_compass_akm+0x274>)
  4049fe:	679a      	str	r2, [r3, #120]	; 0x78
  404a00:	e026      	b.n	404a50 <inv_icm20648_setup_compass_akm+0x104>
	} else if (HW_AK09911 == s->secondary_state.compass_slave_id) {
  404a02:	687b      	ldr	r3, [r7, #4]
  404a04:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404a08:	2b23      	cmp	r3, #35	; 0x23
  404a0a:	d106      	bne.n	404a1a <inv_icm20648_setup_compass_akm+0xce>
		s->secondary_state.st_upper = AK09911_ST_Upper;
  404a0c:	687b      	ldr	r3, [r7, #4]
  404a0e:	4a6d      	ldr	r2, [pc, #436]	; (404bc4 <inv_icm20648_setup_compass_akm+0x278>)
  404a10:	675a      	str	r2, [r3, #116]	; 0x74
		s->secondary_state.st_lower = AK09911_ST_Lower;
  404a12:	687b      	ldr	r3, [r7, #4]
  404a14:	4a6c      	ldr	r2, [pc, #432]	; (404bc8 <inv_icm20648_setup_compass_akm+0x27c>)
  404a16:	679a      	str	r2, [r3, #120]	; 0x78
  404a18:	e01a      	b.n	404a50 <inv_icm20648_setup_compass_akm+0x104>
	} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
  404a1a:	687b      	ldr	r3, [r7, #4]
  404a1c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404a20:	2b24      	cmp	r3, #36	; 0x24
  404a22:	d106      	bne.n	404a32 <inv_icm20648_setup_compass_akm+0xe6>
		s->secondary_state.st_upper = AK09912_ST_Upper;
  404a24:	687b      	ldr	r3, [r7, #4]
  404a26:	4a69      	ldr	r2, [pc, #420]	; (404bcc <inv_icm20648_setup_compass_akm+0x280>)
  404a28:	675a      	str	r2, [r3, #116]	; 0x74
		s->secondary_state.st_lower = AK09912_ST_Lower;
  404a2a:	687b      	ldr	r3, [r7, #4]
  404a2c:	4a68      	ldr	r2, [pc, #416]	; (404bd0 <inv_icm20648_setup_compass_akm+0x284>)
  404a2e:	679a      	str	r2, [r3, #120]	; 0x78
  404a30:	e00e      	b.n	404a50 <inv_icm20648_setup_compass_akm+0x104>
	} else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
  404a32:	687b      	ldr	r3, [r7, #4]
  404a34:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404a38:	2b25      	cmp	r3, #37	; 0x25
  404a3a:	d106      	bne.n	404a4a <inv_icm20648_setup_compass_akm+0xfe>
		s->secondary_state.st_upper = AK09916_ST_Upper;
  404a3c:	687b      	ldr	r3, [r7, #4]
  404a3e:	4a65      	ldr	r2, [pc, #404]	; (404bd4 <inv_icm20648_setup_compass_akm+0x288>)
  404a40:	675a      	str	r2, [r3, #116]	; 0x74
		s->secondary_state.st_lower = AK09916_ST_Lower;
  404a42:	687b      	ldr	r3, [r7, #4]
  404a44:	4a64      	ldr	r2, [pc, #400]	; (404bd8 <inv_icm20648_setup_compass_akm+0x28c>)
  404a46:	679a      	str	r2, [r3, #120]	; 0x78
  404a48:	e002      	b.n	404a50 <inv_icm20648_setup_compass_akm+0x104>
	} else {
		return -1;
  404a4a:	f04f 33ff 	mov.w	r3, #4294967295
  404a4e:	e0a4      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
	s->secondary_state.compass_sens[0] = 128;
	s->secondary_state.compass_sens[1] = 128;
	s->secondary_state.compass_sens[2] = 128;
#else
	/* Read conf and configure compass through I2C SLV for compass and subsequent channel */
	if (HW_AK09916 == s->secondary_state.compass_slave_id) {
  404a50:	687b      	ldr	r3, [r7, #4]
  404a52:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404a56:	2b25      	cmp	r3, #37	; 0x25
  404a58:	d110      	bne.n	404a7c <inv_icm20648_setup_compass_akm+0x130>
		s->secondary_state.mode_reg_addr = REG_AK09916_CNTL2;
  404a5a:	687b      	ldr	r3, [r7, #4]
  404a5c:	2231      	movs	r2, #49	; 0x31
  404a5e:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
		// no sensitivity adjustment value
		s->secondary_state.compass_sens[0] = 128;
  404a62:	687b      	ldr	r3, [r7, #4]
  404a64:	2280      	movs	r2, #128	; 0x80
  404a66:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
		s->secondary_state.compass_sens[1] = 128;
  404a6a:	687b      	ldr	r3, [r7, #4]
  404a6c:	2280      	movs	r2, #128	; 0x80
  404a6e:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		s->secondary_state.compass_sens[2] = 128;
  404a72:	687b      	ldr	r3, [r7, #4]
  404a74:	2280      	movs	r2, #128	; 0x80
  404a76:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
  404a7a:	e057      	b.n	404b2c <inv_icm20648_setup_compass_akm+0x1e0>
	}
	else {
		// Fuse ROM access not possible for ak9916
		/* set AKM to Fuse ROM access mode */
		if (HW_AK09911 == s->secondary_state.compass_slave_id) {
  404a7c:	687b      	ldr	r3, [r7, #4]
  404a7e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404a82:	2b23      	cmp	r3, #35	; 0x23
  404a84:	d108      	bne.n	404a98 <inv_icm20648_setup_compass_akm+0x14c>
			s->secondary_state.mode_reg_addr = REG_AK09911_CNTL2;
  404a86:	687b      	ldr	r3, [r7, #4]
  404a88:	2231      	movs	r2, #49	; 0x31
  404a8a:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
			sens = REG_AK09911_SENSITIVITY;
  404a8e:	2360      	movs	r3, #96	; 0x60
  404a90:	75fb      	strb	r3, [r7, #23]
			cmd = DATA_AK09911_MODE_FR;
  404a92:	231f      	movs	r3, #31
  404a94:	75bb      	strb	r3, [r7, #22]
  404a96:	e015      	b.n	404ac4 <inv_icm20648_setup_compass_akm+0x178>
		} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
  404a98:	687b      	ldr	r3, [r7, #4]
  404a9a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404a9e:	2b24      	cmp	r3, #36	; 0x24
  404aa0:	d108      	bne.n	404ab4 <inv_icm20648_setup_compass_akm+0x168>
			s->secondary_state.mode_reg_addr = REG_AK09912_CNTL2;
  404aa2:	687b      	ldr	r3, [r7, #4]
  404aa4:	2231      	movs	r2, #49	; 0x31
  404aa6:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
			sens = REG_AK09912_SENSITIVITY;
  404aaa:	2360      	movs	r3, #96	; 0x60
  404aac:	75fb      	strb	r3, [r7, #23]
			cmd = DATA_AK09912_MODE_FR;
  404aae:	231f      	movs	r3, #31
  404ab0:	75bb      	strb	r3, [r7, #22]
  404ab2:	e007      	b.n	404ac4 <inv_icm20648_setup_compass_akm+0x178>
		} else {
			s->secondary_state.mode_reg_addr = REG_AKM_MODE;
  404ab4:	687b      	ldr	r3, [r7, #4]
  404ab6:	220a      	movs	r2, #10
  404ab8:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
			sens = REG_AKM_SENSITIVITY;
  404abc:	2310      	movs	r3, #16
  404abe:	75fb      	strb	r3, [r7, #23]
			cmd = DATA_AKM_MODE_FR;
  404ac0:	230f      	movs	r3, #15
  404ac2:	75bb      	strb	r3, [r7, #22]
		}

		result = inv_icm20648_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, sens, THREE_AXES);
  404ac4:	687b      	ldr	r3, [r7, #4]
  404ac6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404aca:	b2da      	uxtb	r2, r3
  404acc:	7df9      	ldrb	r1, [r7, #23]
  404ace:	2303      	movs	r3, #3
  404ad0:	9300      	str	r3, [sp, #0]
  404ad2:	460b      	mov	r3, r1
  404ad4:	2100      	movs	r1, #0
  404ad6:	6878      	ldr	r0, [r7, #4]
  404ad8:	4c40      	ldr	r4, [pc, #256]	; (404bdc <inv_icm20648_setup_compass_akm+0x290>)
  404ada:	47a0      	blx	r4
  404adc:	6138      	str	r0, [r7, #16]
		if (result)
  404ade:	693b      	ldr	r3, [r7, #16]
  404ae0:	2b00      	cmp	r3, #0
  404ae2:	d001      	beq.n	404ae8 <inv_icm20648_setup_compass_akm+0x19c>
			return result;
  404ae4:	693b      	ldr	r3, [r7, #16]
  404ae6:	e058      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
		// activate FUSE_ROM mode to CNTL2
		result = inv_icm20648_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, 
  404ae8:	687b      	ldr	r3, [r7, #4]
  404aea:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404aee:	b2da      	uxtb	r2, r3
				s->secondary_state.mode_reg_addr, cmd);
  404af0:	687b      	ldr	r3, [r7, #4]
  404af2:	f893 3082 	ldrb.w	r3, [r3, #130]	; 0x82
		result = inv_icm20648_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, 
  404af6:	4619      	mov	r1, r3
  404af8:	7dbb      	ldrb	r3, [r7, #22]
  404afa:	9300      	str	r3, [sp, #0]
  404afc:	460b      	mov	r3, r1
  404afe:	2101      	movs	r1, #1
  404b00:	6878      	ldr	r0, [r7, #4]
  404b02:	4c37      	ldr	r4, [pc, #220]	; (404be0 <inv_icm20648_setup_compass_akm+0x294>)
  404b04:	47a0      	blx	r4
  404b06:	6138      	str	r0, [r7, #16]

		if (result)
  404b08:	693b      	ldr	r3, [r7, #16]
  404b0a:	2b00      	cmp	r3, #0
  404b0c:	d001      	beq.n	404b12 <inv_icm20648_setup_compass_akm+0x1c6>
			return result;
  404b0e:	693b      	ldr	r3, [r7, #16]
  404b10:	e043      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
		// read sensitivity
		result = inv_icm20648_read_mems_reg(s, REG_EXT_SLV_SENS_DATA_00, THREE_AXES, s->secondary_state.compass_sens);
  404b12:	687b      	ldr	r3, [r7, #4]
  404b14:	334d      	adds	r3, #77	; 0x4d
  404b16:	2203      	movs	r2, #3
  404b18:	213b      	movs	r1, #59	; 0x3b
  404b1a:	6878      	ldr	r0, [r7, #4]
  404b1c:	4c31      	ldr	r4, [pc, #196]	; (404be4 <inv_icm20648_setup_compass_akm+0x298>)
  404b1e:	47a0      	blx	r4
  404b20:	6138      	str	r0, [r7, #16]
		if (result)
  404b22:	693b      	ldr	r3, [r7, #16]
  404b24:	2b00      	cmp	r3, #0
  404b26:	d001      	beq.n	404b2c <inv_icm20648_setup_compass_akm+0x1e0>
			return result;
  404b28:	693b      	ldr	r3, [r7, #16]
  404b2a:	e036      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
	}
	//aply noise suppression filter (only available for 9912)
	if (HW_AK09912 == s->secondary_state.compass_slave_id) {
  404b2c:	687b      	ldr	r3, [r7, #4]
  404b2e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404b32:	2b24      	cmp	r3, #36	; 0x24
  404b34:	d110      	bne.n	404b58 <inv_icm20648_setup_compass_akm+0x20c>
		result = inv_icm20648_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, REG_AK09912_CNTL1,
  404b36:	687b      	ldr	r3, [r7, #4]
  404b38:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404b3c:	b2da      	uxtb	r2, r3
  404b3e:	2320      	movs	r3, #32
  404b40:	9300      	str	r3, [sp, #0]
  404b42:	2330      	movs	r3, #48	; 0x30
  404b44:	2101      	movs	r1, #1
  404b46:	6878      	ldr	r0, [r7, #4]
  404b48:	4c25      	ldr	r4, [pc, #148]	; (404be0 <inv_icm20648_setup_compass_akm+0x294>)
  404b4a:	47a0      	blx	r4
  404b4c:	6138      	str	r0, [r7, #16]
                                     DATA_AK9912_NSF << DATA_AK9912_NSF_SHIFT);
		if (result)
  404b4e:	693b      	ldr	r3, [r7, #16]
  404b50:	2b00      	cmp	r3, #0
  404b52:	d001      	beq.n	404b58 <inv_icm20648_setup_compass_akm+0x20c>
			return result;
  404b54:	693b      	ldr	r3, [r7, #16]
  404b56:	e020      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
	}
#endif
	/* Set compass in power down through I2C SLV for compass */
	result = inv_icm20648_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, s->secondary_state.mode_reg_addr, DATA_AKM_MODE_PD);
  404b58:	687b      	ldr	r3, [r7, #4]
  404b5a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404b5e:	b2da      	uxtb	r2, r3
  404b60:	687b      	ldr	r3, [r7, #4]
  404b62:	f893 3082 	ldrb.w	r3, [r3, #130]	; 0x82
  404b66:	4619      	mov	r1, r3
  404b68:	2300      	movs	r3, #0
  404b6a:	9300      	str	r3, [sp, #0]
  404b6c:	460b      	mov	r3, r1
  404b6e:	2101      	movs	r1, #1
  404b70:	6878      	ldr	r0, [r7, #4]
  404b72:	4c1b      	ldr	r4, [pc, #108]	; (404be0 <inv_icm20648_setup_compass_akm+0x294>)
  404b74:	47a0      	blx	r4
  404b76:	6138      	str	r0, [r7, #16]
	if (result)
  404b78:	693b      	ldr	r3, [r7, #16]
  404b7a:	2b00      	cmp	r3, #0
  404b7c:	d001      	beq.n	404b82 <inv_icm20648_setup_compass_akm+0x236>
		return result;
  404b7e:	693b      	ldr	r3, [r7, #16]
  404b80:	e00b      	b.n	404b9a <inv_icm20648_setup_compass_akm+0x24e>
    
	s->secondary_state.secondary_resume_compass_state = 1;
  404b82:	687b      	ldr	r3, [r7, #4]
  404b84:	2201      	movs	r2, #1
  404b86:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
	s->secondary_state.compass_state = INV_ICM20648_COMPASS_SETUP;
  404b8a:	687b      	ldr	r3, [r7, #4]
  404b8c:	2202      	movs	r2, #2
  404b8e:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	return inv_icm20648_suspend_akm(s);
  404b92:	6878      	ldr	r0, [r7, #4]
  404b94:	4b14      	ldr	r3, [pc, #80]	; (404be8 <inv_icm20648_setup_compass_akm+0x29c>)
  404b96:	4798      	blx	r3
  404b98:	4603      	mov	r3, r0
}
  404b9a:	4618      	mov	r0, r3
  404b9c:	371c      	adds	r7, #28
  404b9e:	46bd      	mov	sp, r7
  404ba0:	bd90      	pop	{r4, r7, pc}
  404ba2:	bf00      	nop
  404ba4:	00414431 	.word	0x00414431
  404ba8:	00405861 	.word	0x00405861
  404bac:	0041bec4 	.word	0x0041bec4
  404bb0:	0041bebc 	.word	0x0041bebc
  404bb4:	0041bed4 	.word	0x0041bed4
  404bb8:	0041becc 	.word	0x0041becc
  404bbc:	0041bee4 	.word	0x0041bee4
  404bc0:	0041bedc 	.word	0x0041bedc
  404bc4:	0041bef4 	.word	0x0041bef4
  404bc8:	0041beec 	.word	0x0041beec
  404bcc:	0041bf04 	.word	0x0041bf04
  404bd0:	0041befc 	.word	0x0041befc
  404bd4:	0041bf14 	.word	0x0041bf14
  404bd8:	0041bf0c 	.word	0x0041bf0c
  404bdc:	004057bd 	.word	0x004057bd
  404be0:	004059b9 	.word	0x004059b9
  404be4:	0040caa1 	.word	0x0040caa1
  404be8:	004050dd 	.word	0x004050dd

00404bec <inv_icm20648_check_akm_self_test>:

int inv_icm20648_check_akm_self_test(struct inv_icm20648 * s)
{
  404bec:	b590      	push	{r4, r7, lr}
  404bee:	b08f      	sub	sp, #60	; 0x3c
  404bf0:	af02      	add	r7, sp, #8
  404bf2:	6078      	str	r0, [r7, #4]
	unsigned char slv_ctrl[2];
	unsigned char odr_cfg;
#if (MEMS_CHIP != HW_ICM20948)
	unsigned char cntl;
#endif
	addr = s->secondary_state.compass_chip_addr;
  404bf4:	687b      	ldr	r3, [r7, #4]
  404bf6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404bfa:	77fb      	strb	r3, [r7, #31]
	sens = s->secondary_state.compass_sens;
  404bfc:	687b      	ldr	r3, [r7, #4]
  404bfe:	334d      	adds	r3, #77	; 0x4d
  404c00:	61bb      	str	r3, [r7, #24]

	/* back up registers */
	/* SLV0_CTRL */
	result = inv_icm20648_read_mems_reg(s, REG_I2C_SLV0_CTRL, 1, &slv_ctrl[0]);
  404c02:	f107 030c 	add.w	r3, r7, #12
  404c06:	2201      	movs	r2, #1
  404c08:	f240 1185 	movw	r1, #389	; 0x185
  404c0c:	6878      	ldr	r0, [r7, #4]
  404c0e:	4ca5      	ldr	r4, [pc, #660]	; (404ea4 <inv_icm20648_check_akm_self_test+0x2b8>)
  404c10:	47a0      	blx	r4
  404c12:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (result)
  404c14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c16:	2b00      	cmp	r3, #0
  404c18:	d001      	beq.n	404c1e <inv_icm20648_check_akm_self_test+0x32>
		return result;
  404c1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c1c:	e256      	b.n	4050cc <inv_icm20648_check_akm_self_test+0x4e0>
	result = inv_icm20648_write_single_mems_reg(s, REG_I2C_SLV0_CTRL, 0);
  404c1e:	2200      	movs	r2, #0
  404c20:	f240 1185 	movw	r1, #389	; 0x185
  404c24:	6878      	ldr	r0, [r7, #4]
  404c26:	4ba0      	ldr	r3, [pc, #640]	; (404ea8 <inv_icm20648_check_akm_self_test+0x2bc>)
  404c28:	4798      	blx	r3
  404c2a:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (result)
  404c2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c2e:	2b00      	cmp	r3, #0
  404c30:	d001      	beq.n	404c36 <inv_icm20648_check_akm_self_test+0x4a>
		return result;
  404c32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c34:	e24a      	b.n	4050cc <inv_icm20648_check_akm_self_test+0x4e0>
	/* SLV1_CTRL */
	result = inv_icm20648_read_mems_reg(s, REG_I2C_SLV1_CTRL, 1, &slv_ctrl[1]);
  404c36:	f107 030c 	add.w	r3, r7, #12
  404c3a:	3301      	adds	r3, #1
  404c3c:	2201      	movs	r2, #1
  404c3e:	f240 1189 	movw	r1, #393	; 0x189
  404c42:	6878      	ldr	r0, [r7, #4]
  404c44:	4c97      	ldr	r4, [pc, #604]	; (404ea4 <inv_icm20648_check_akm_self_test+0x2b8>)
  404c46:	47a0      	blx	r4
  404c48:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (result)
  404c4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c4c:	2b00      	cmp	r3, #0
  404c4e:	d001      	beq.n	404c54 <inv_icm20648_check_akm_self_test+0x68>
		return result;
  404c50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c52:	e23b      	b.n	4050cc <inv_icm20648_check_akm_self_test+0x4e0>
	result = inv_icm20648_write_single_mems_reg(s, REG_I2C_SLV1_CTRL, 0);
  404c54:	2200      	movs	r2, #0
  404c56:	f240 1189 	movw	r1, #393	; 0x189
  404c5a:	6878      	ldr	r0, [r7, #4]
  404c5c:	4b92      	ldr	r3, [pc, #584]	; (404ea8 <inv_icm20648_check_akm_self_test+0x2bc>)
  404c5e:	4798      	blx	r3
  404c60:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (result)
  404c62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c64:	2b00      	cmp	r3, #0
  404c66:	d001      	beq.n	404c6c <inv_icm20648_check_akm_self_test+0x80>
		return result;
  404c68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c6a:	e22f      	b.n	4050cc <inv_icm20648_check_akm_self_test+0x4e0>
	/* I2C_MST ODR */
	result = inv_icm20648_read_mems_reg(s, REG_I2C_MST_ODR_CONFIG, 1, &odr_cfg);
  404c6c:	f107 030b 	add.w	r3, r7, #11
  404c70:	2201      	movs	r2, #1
  404c72:	f44f 71c0 	mov.w	r1, #384	; 0x180
  404c76:	6878      	ldr	r0, [r7, #4]
  404c78:	4c8a      	ldr	r4, [pc, #552]	; (404ea4 <inv_icm20648_check_akm_self_test+0x2b8>)
  404c7a:	47a0      	blx	r4
  404c7c:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (result)
  404c7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c80:	2b00      	cmp	r3, #0
  404c82:	d001      	beq.n	404c88 <inv_icm20648_check_akm_self_test+0x9c>
		return result;
  404c84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c86:	e221      	b.n	4050cc <inv_icm20648_check_akm_self_test+0x4e0>
	result = inv_icm20648_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, 0);
  404c88:	2200      	movs	r2, #0
  404c8a:	f44f 71c0 	mov.w	r1, #384	; 0x180
  404c8e:	6878      	ldr	r0, [r7, #4]
  404c90:	4b85      	ldr	r3, [pc, #532]	; (404ea8 <inv_icm20648_check_akm_self_test+0x2bc>)
  404c92:	4798      	blx	r3
  404c94:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (result)
  404c96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c98:	2b00      	cmp	r3, #0
  404c9a:	d001      	beq.n	404ca0 <inv_icm20648_check_akm_self_test+0xb4>
		return result;
  404c9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404c9e:	e215      	b.n	4050cc <inv_icm20648_check_akm_self_test+0x4e0>

#if (MEMS_CHIP == HW_ICM20948)
	mode = REG_AK09916_CNTL2;
#else
	if (HW_AK09911 == s->secondary_state.compass_slave_id)
  404ca0:	687b      	ldr	r3, [r7, #4]
  404ca2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404ca6:	2b23      	cmp	r3, #35	; 0x23
  404ca8:	d103      	bne.n	404cb2 <inv_icm20648_check_akm_self_test+0xc6>
		mode = REG_AK09911_CNTL2;
  404caa:	2331      	movs	r3, #49	; 0x31
  404cac:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  404cb0:	e014      	b.n	404cdc <inv_icm20648_check_akm_self_test+0xf0>
	else if (HW_AK09912 == s->secondary_state.compass_slave_id)
  404cb2:	687b      	ldr	r3, [r7, #4]
  404cb4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404cb8:	2b24      	cmp	r3, #36	; 0x24
  404cba:	d103      	bne.n	404cc4 <inv_icm20648_check_akm_self_test+0xd8>
		mode = REG_AK09912_CNTL2;
  404cbc:	2331      	movs	r3, #49	; 0x31
  404cbe:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  404cc2:	e00b      	b.n	404cdc <inv_icm20648_check_akm_self_test+0xf0>
	else if (HW_AK09916 == s->secondary_state.compass_slave_id)
  404cc4:	687b      	ldr	r3, [r7, #4]
  404cc6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404cca:	2b25      	cmp	r3, #37	; 0x25
  404ccc:	d103      	bne.n	404cd6 <inv_icm20648_check_akm_self_test+0xea>
		mode = REG_AK09916_CNTL2;
  404cce:	2331      	movs	r3, #49	; 0x31
  404cd0:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  404cd4:	e002      	b.n	404cdc <inv_icm20648_check_akm_self_test+0xf0>
	else
		mode = REG_AKM_MODE;
  404cd6:	230a      	movs	r3, #10
  404cd8:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
#endif
	/* set to power down mode */
	result = inv_icm20648_execute_write_secondary(s, 0, addr, mode, DATA_AKM_MODE_PD);
  404cdc:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
  404ce0:	7ffa      	ldrb	r2, [r7, #31]
  404ce2:	2300      	movs	r3, #0
  404ce4:	9300      	str	r3, [sp, #0]
  404ce6:	460b      	mov	r3, r1
  404ce8:	2100      	movs	r1, #0
  404cea:	6878      	ldr	r0, [r7, #4]
  404cec:	4c6f      	ldr	r4, [pc, #444]	; (404eac <inv_icm20648_check_akm_self_test+0x2c0>)
  404cee:	47a0      	blx	r4
  404cf0:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (result)
  404cf2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404cf4:	2b00      	cmp	r3, #0
  404cf6:	f040 81b4 	bne.w	405062 <inv_icm20648_check_akm_self_test+0x476>
		goto AKM_fail;
		
	/* write 1 to ASTC register */
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  404cfa:	687b      	ldr	r3, [r7, #4]
  404cfc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404d00:	2b23      	cmp	r3, #35	; 0x23
  404d02:	d011      	beq.n	404d28 <inv_icm20648_check_akm_self_test+0x13c>
		(HW_AK09912 != s->secondary_state.compass_slave_id)) {
  404d04:	687b      	ldr	r3, [r7, #4]
  404d06:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  404d0a:	2b24      	cmp	r3, #36	; 0x24
  404d0c:	d00c      	beq.n	404d28 <inv_icm20648_check_akm_self_test+0x13c>
		result = inv_icm20648_execute_write_secondary(s, 0, addr, REG_AKM_ST_CTRL, DATA_AKM_SELF_TEST);
  404d0e:	7ffa      	ldrb	r2, [r7, #31]
  404d10:	2340      	movs	r3, #64	; 0x40
  404d12:	9300      	str	r3, [sp, #0]
  404d14:	230c      	movs	r3, #12
  404d16:	2100      	movs	r1, #0
  404d18:	6878      	ldr	r0, [r7, #4]
  404d1a:	4c64      	ldr	r4, [pc, #400]	; (404eac <inv_icm20648_check_akm_self_test+0x2c0>)
  404d1c:	47a0      	blx	r4
  404d1e:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (result)
  404d20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404d22:	2b00      	cmp	r3, #0
  404d24:	f040 819f 	bne.w	405066 <inv_icm20648_check_akm_self_test+0x47a>
	}
#if (MEMS_CHIP == HW_ICM20948)
	result = inv_icm20648_execute_write_secondary(s, 0, addr, mode, DATA_AK09916_MODE_ST);
#else
	/* set self test mode */
	if (HW_AK09911 == s->secondary_state.compass_slave_id)
  404d28:	687b      	ldr	r3, [r7, #4]
  404d2a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404d2e:	2b23      	cmp	r3, #35	; 0x23
  404d30:	d10b      	bne.n	404d4a <inv_icm20648_check_akm_self_test+0x15e>
		result = inv_icm20648_execute_write_secondary(s, 0, addr, mode, DATA_AK09911_MODE_ST);
  404d32:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
  404d36:	7ffa      	ldrb	r2, [r7, #31]
  404d38:	2310      	movs	r3, #16
  404d3a:	9300      	str	r3, [sp, #0]
  404d3c:	460b      	mov	r3, r1
  404d3e:	2100      	movs	r1, #0
  404d40:	6878      	ldr	r0, [r7, #4]
  404d42:	4c5a      	ldr	r4, [pc, #360]	; (404eac <inv_icm20648_check_akm_self_test+0x2c0>)
  404d44:	47a0      	blx	r4
  404d46:	62f8      	str	r0, [r7, #44]	; 0x2c
  404d48:	e02c      	b.n	404da4 <inv_icm20648_check_akm_self_test+0x1b8>
	else if (HW_AK09912 == s->secondary_state.compass_slave_id)
  404d4a:	687b      	ldr	r3, [r7, #4]
  404d4c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404d50:	2b24      	cmp	r3, #36	; 0x24
  404d52:	d10b      	bne.n	404d6c <inv_icm20648_check_akm_self_test+0x180>
		result = inv_icm20648_execute_write_secondary(s, 0, addr, mode, DATA_AK09912_MODE_ST);
  404d54:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
  404d58:	7ffa      	ldrb	r2, [r7, #31]
  404d5a:	2310      	movs	r3, #16
  404d5c:	9300      	str	r3, [sp, #0]
  404d5e:	460b      	mov	r3, r1
  404d60:	2100      	movs	r1, #0
  404d62:	6878      	ldr	r0, [r7, #4]
  404d64:	4c51      	ldr	r4, [pc, #324]	; (404eac <inv_icm20648_check_akm_self_test+0x2c0>)
  404d66:	47a0      	blx	r4
  404d68:	62f8      	str	r0, [r7, #44]	; 0x2c
  404d6a:	e01b      	b.n	404da4 <inv_icm20648_check_akm_self_test+0x1b8>
	else if (HW_AK09916 == s->secondary_state.compass_slave_id)
  404d6c:	687b      	ldr	r3, [r7, #4]
  404d6e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404d72:	2b25      	cmp	r3, #37	; 0x25
  404d74:	d10b      	bne.n	404d8e <inv_icm20648_check_akm_self_test+0x1a2>
		result = inv_icm20648_execute_write_secondary(s, 0, addr, mode, DATA_AK09916_MODE_ST);
  404d76:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
  404d7a:	7ffa      	ldrb	r2, [r7, #31]
  404d7c:	2310      	movs	r3, #16
  404d7e:	9300      	str	r3, [sp, #0]
  404d80:	460b      	mov	r3, r1
  404d82:	2100      	movs	r1, #0
  404d84:	6878      	ldr	r0, [r7, #4]
  404d86:	4c49      	ldr	r4, [pc, #292]	; (404eac <inv_icm20648_check_akm_self_test+0x2c0>)
  404d88:	47a0      	blx	r4
  404d8a:	62f8      	str	r0, [r7, #44]	; 0x2c
  404d8c:	e00a      	b.n	404da4 <inv_icm20648_check_akm_self_test+0x1b8>
	else
		result = inv_icm20648_execute_write_secondary(s, 0, addr, mode,	DATA_AKM_MODE_ST);
  404d8e:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
  404d92:	7ffa      	ldrb	r2, [r7, #31]
  404d94:	2308      	movs	r3, #8
  404d96:	9300      	str	r3, [sp, #0]
  404d98:	460b      	mov	r3, r1
  404d9a:	2100      	movs	r1, #0
  404d9c:	6878      	ldr	r0, [r7, #4]
  404d9e:	4c43      	ldr	r4, [pc, #268]	; (404eac <inv_icm20648_check_akm_self_test+0x2c0>)
  404da0:	47a0      	blx	r4
  404da2:	62f8      	str	r0, [r7, #44]	; 0x2c
#endif
	if (result)
  404da4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404da6:	2b00      	cmp	r3, #0
  404da8:	f040 815f 	bne.w	40506a <inv_icm20648_check_akm_self_test+0x47e>
		goto AKM_fail;
	counter = DEF_ST_COMPASS_TRY_TIMES;
  404dac:	230a      	movs	r3, #10
  404dae:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
	while (counter > 0) {
  404db2:	e057      	b.n	404e64 <inv_icm20648_check_akm_self_test+0x278>
//		usleep_range(DEF_ST_COMPASS_WAIT_MIN, DEF_ST_COMPASS_WAIT_MAX);
        inv_icm20648_sleep_us(15000);
  404db4:	f643 2098 	movw	r0, #15000	; 0x3a98
  404db8:	4b3d      	ldr	r3, [pc, #244]	; (404eb0 <inv_icm20648_check_akm_self_test+0x2c4>)
  404dba:	4798      	blx	r3

#if (MEMS_CHIP == HW_ICM20948)
		result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09916_STATUS1, 1, data);
#else
		if (HW_AK09911 == s->secondary_state.compass_slave_id)
  404dbc:	687b      	ldr	r3, [r7, #4]
  404dbe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404dc2:	2b23      	cmp	r3, #35	; 0x23
  404dc4:	d10c      	bne.n	404de0 <inv_icm20648_check_akm_self_test+0x1f4>
			result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09911_STATUS1, 1, data);
  404dc6:	7ffa      	ldrb	r2, [r7, #31]
  404dc8:	f107 0310 	add.w	r3, r7, #16
  404dcc:	9301      	str	r3, [sp, #4]
  404dce:	2301      	movs	r3, #1
  404dd0:	9300      	str	r3, [sp, #0]
  404dd2:	2310      	movs	r3, #16
  404dd4:	2100      	movs	r1, #0
  404dd6:	6878      	ldr	r0, [r7, #4]
  404dd8:	4c36      	ldr	r4, [pc, #216]	; (404eb4 <inv_icm20648_check_akm_self_test+0x2c8>)
  404dda:	47a0      	blx	r4
  404ddc:	62f8      	str	r0, [r7, #44]	; 0x2c
  404dde:	e02f      	b.n	404e40 <inv_icm20648_check_akm_self_test+0x254>
		else if (HW_AK09912 == s->secondary_state.compass_slave_id)
  404de0:	687b      	ldr	r3, [r7, #4]
  404de2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404de6:	2b24      	cmp	r3, #36	; 0x24
  404de8:	d10c      	bne.n	404e04 <inv_icm20648_check_akm_self_test+0x218>
			result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09912_STATUS1, 1, data);
  404dea:	7ffa      	ldrb	r2, [r7, #31]
  404dec:	f107 0310 	add.w	r3, r7, #16
  404df0:	9301      	str	r3, [sp, #4]
  404df2:	2301      	movs	r3, #1
  404df4:	9300      	str	r3, [sp, #0]
  404df6:	2310      	movs	r3, #16
  404df8:	2100      	movs	r1, #0
  404dfa:	6878      	ldr	r0, [r7, #4]
  404dfc:	4c2d      	ldr	r4, [pc, #180]	; (404eb4 <inv_icm20648_check_akm_self_test+0x2c8>)
  404dfe:	47a0      	blx	r4
  404e00:	62f8      	str	r0, [r7, #44]	; 0x2c
  404e02:	e01d      	b.n	404e40 <inv_icm20648_check_akm_self_test+0x254>
		else if (HW_AK09916 == s->secondary_state.compass_slave_id)
  404e04:	687b      	ldr	r3, [r7, #4]
  404e06:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404e0a:	2b25      	cmp	r3, #37	; 0x25
  404e0c:	d10c      	bne.n	404e28 <inv_icm20648_check_akm_self_test+0x23c>
			result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09916_STATUS1, 1, data);
  404e0e:	7ffa      	ldrb	r2, [r7, #31]
  404e10:	f107 0310 	add.w	r3, r7, #16
  404e14:	9301      	str	r3, [sp, #4]
  404e16:	2301      	movs	r3, #1
  404e18:	9300      	str	r3, [sp, #0]
  404e1a:	2310      	movs	r3, #16
  404e1c:	2100      	movs	r1, #0
  404e1e:	6878      	ldr	r0, [r7, #4]
  404e20:	4c24      	ldr	r4, [pc, #144]	; (404eb4 <inv_icm20648_check_akm_self_test+0x2c8>)
  404e22:	47a0      	blx	r4
  404e24:	62f8      	str	r0, [r7, #44]	; 0x2c
  404e26:	e00b      	b.n	404e40 <inv_icm20648_check_akm_self_test+0x254>
		else
			result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AKM_STATUS, 1, data);
  404e28:	7ffa      	ldrb	r2, [r7, #31]
  404e2a:	f107 0310 	add.w	r3, r7, #16
  404e2e:	9301      	str	r3, [sp, #4]
  404e30:	2301      	movs	r3, #1
  404e32:	9300      	str	r3, [sp, #0]
  404e34:	2302      	movs	r3, #2
  404e36:	2100      	movs	r1, #0
  404e38:	6878      	ldr	r0, [r7, #4]
  404e3a:	4c1e      	ldr	r4, [pc, #120]	; (404eb4 <inv_icm20648_check_akm_self_test+0x2c8>)
  404e3c:	47a0      	blx	r4
  404e3e:	62f8      	str	r0, [r7, #44]	; 0x2c
#endif
		if (result)
  404e40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404e42:	2b00      	cmp	r3, #0
  404e44:	f040 8113 	bne.w	40506e <inv_icm20648_check_akm_self_test+0x482>
			goto AKM_fail;
		if ((data[0] & DATA_AKM_DRDY) == 0)
  404e48:	7c3b      	ldrb	r3, [r7, #16]
  404e4a:	f003 0301 	and.w	r3, r3, #1
  404e4e:	2b00      	cmp	r3, #0
  404e50:	d105      	bne.n	404e5e <inv_icm20648_check_akm_self_test+0x272>
			counter--;
  404e52:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
  404e56:	3b01      	subs	r3, #1
  404e58:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
  404e5c:	e002      	b.n	404e64 <inv_icm20648_check_akm_self_test+0x278>
		else
			counter = 0;
  404e5e:	2300      	movs	r3, #0
  404e60:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
	while (counter > 0) {
  404e64:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
  404e68:	2b00      	cmp	r3, #0
  404e6a:	d1a3      	bne.n	404db4 <inv_icm20648_check_akm_self_test+0x1c8>
	}
	if ((data[0] & DATA_AKM_DRDY) == 0) {
  404e6c:	7c3b      	ldrb	r3, [r7, #16]
  404e6e:	f003 0301 	and.w	r3, r3, #1
  404e72:	2b00      	cmp	r3, #0
  404e74:	d103      	bne.n	404e7e <inv_icm20648_check_akm_self_test+0x292>
		result = -1;
  404e76:	f04f 33ff 	mov.w	r3, #4294967295
  404e7a:	62fb      	str	r3, [r7, #44]	; 0x2c
		goto AKM_fail;
  404e7c:	e0fc      	b.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
	}
#if (MEMS_CHIP == HW_ICM20948)
	result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09916_MEASURE_DATA, BYTES_PER_SENSOR, data);
#else
	if (HW_AK09911 == s->secondary_state.compass_slave_id) {
  404e7e:	687b      	ldr	r3, [r7, #4]
  404e80:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404e84:	2b23      	cmp	r3, #35	; 0x23
  404e86:	d117      	bne.n	404eb8 <inv_icm20648_check_akm_self_test+0x2cc>
		result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09911_MEASURE_DATA, BYTES_PER_SENSOR, data);
  404e88:	7ffa      	ldrb	r2, [r7, #31]
  404e8a:	f107 0310 	add.w	r3, r7, #16
  404e8e:	9301      	str	r3, [sp, #4]
  404e90:	2306      	movs	r3, #6
  404e92:	9300      	str	r3, [sp, #0]
  404e94:	2311      	movs	r3, #17
  404e96:	2100      	movs	r1, #0
  404e98:	6878      	ldr	r0, [r7, #4]
  404e9a:	4c06      	ldr	r4, [pc, #24]	; (404eb4 <inv_icm20648_check_akm_self_test+0x2c8>)
  404e9c:	47a0      	blx	r4
  404e9e:	62f8      	str	r0, [r7, #44]	; 0x2c
  404ea0:	e03a      	b.n	404f18 <inv_icm20648_check_akm_self_test+0x32c>
  404ea2:	bf00      	nop
  404ea4:	0040caa1 	.word	0x0040caa1
  404ea8:	0040c9d5 	.word	0x0040c9d5
  404eac:	004059b9 	.word	0x004059b9
  404eb0:	004015d9 	.word	0x004015d9
  404eb4:	00405861 	.word	0x00405861
	} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
  404eb8:	687b      	ldr	r3, [r7, #4]
  404eba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404ebe:	2b24      	cmp	r3, #36	; 0x24
  404ec0:	d10c      	bne.n	404edc <inv_icm20648_check_akm_self_test+0x2f0>
		result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09912_MEASURE_DATA, BYTES_PER_SENSOR, data);
  404ec2:	7ffa      	ldrb	r2, [r7, #31]
  404ec4:	f107 0310 	add.w	r3, r7, #16
  404ec8:	9301      	str	r3, [sp, #4]
  404eca:	2306      	movs	r3, #6
  404ecc:	9300      	str	r3, [sp, #0]
  404ece:	2311      	movs	r3, #17
  404ed0:	2100      	movs	r1, #0
  404ed2:	6878      	ldr	r0, [r7, #4]
  404ed4:	4c7f      	ldr	r4, [pc, #508]	; (4050d4 <inv_icm20648_check_akm_self_test+0x4e8>)
  404ed6:	47a0      	blx	r4
  404ed8:	62f8      	str	r0, [r7, #44]	; 0x2c
  404eda:	e01d      	b.n	404f18 <inv_icm20648_check_akm_self_test+0x32c>
	} else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
  404edc:	687b      	ldr	r3, [r7, #4]
  404ede:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404ee2:	2b25      	cmp	r3, #37	; 0x25
  404ee4:	d10c      	bne.n	404f00 <inv_icm20648_check_akm_self_test+0x314>
		result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AK09916_MEASURE_DATA, BYTES_PER_SENSOR, data);
  404ee6:	7ffa      	ldrb	r2, [r7, #31]
  404ee8:	f107 0310 	add.w	r3, r7, #16
  404eec:	9301      	str	r3, [sp, #4]
  404eee:	2306      	movs	r3, #6
  404ef0:	9300      	str	r3, [sp, #0]
  404ef2:	2311      	movs	r3, #17
  404ef4:	2100      	movs	r1, #0
  404ef6:	6878      	ldr	r0, [r7, #4]
  404ef8:	4c76      	ldr	r4, [pc, #472]	; (4050d4 <inv_icm20648_check_akm_self_test+0x4e8>)
  404efa:	47a0      	blx	r4
  404efc:	62f8      	str	r0, [r7, #44]	; 0x2c
  404efe:	e00b      	b.n	404f18 <inv_icm20648_check_akm_self_test+0x32c>
	} else {
		result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AKM_MEASURE_DATA, BYTES_PER_SENSOR, data);
  404f00:	7ffa      	ldrb	r2, [r7, #31]
  404f02:	f107 0310 	add.w	r3, r7, #16
  404f06:	9301      	str	r3, [sp, #4]
  404f08:	2306      	movs	r3, #6
  404f0a:	9300      	str	r3, [sp, #0]
  404f0c:	2303      	movs	r3, #3
  404f0e:	2100      	movs	r1, #0
  404f10:	6878      	ldr	r0, [r7, #4]
  404f12:	4c70      	ldr	r4, [pc, #448]	; (4050d4 <inv_icm20648_check_akm_self_test+0x4e8>)
  404f14:	47a0      	blx	r4
  404f16:	62f8      	str	r0, [r7, #44]	; 0x2c
	}
#endif
	if (result)
  404f18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404f1a:	2b00      	cmp	r3, #0
  404f1c:	f040 80a9 	bne.w	405072 <inv_icm20648_check_akm_self_test+0x486>
		goto AKM_fail;

    x = ((short)data[1])<<8|data[0];
  404f20:	7c7b      	ldrb	r3, [r7, #17]
  404f22:	021b      	lsls	r3, r3, #8
  404f24:	b21a      	sxth	r2, r3
  404f26:	7c3b      	ldrb	r3, [r7, #16]
  404f28:	b21b      	sxth	r3, r3
  404f2a:	4313      	orrs	r3, r2
  404f2c:	853b      	strh	r3, [r7, #40]	; 0x28
    y = ((short)data[3])<<8|data[2];
  404f2e:	7cfb      	ldrb	r3, [r7, #19]
  404f30:	021b      	lsls	r3, r3, #8
  404f32:	b21a      	sxth	r2, r3
  404f34:	7cbb      	ldrb	r3, [r7, #18]
  404f36:	b21b      	sxth	r3, r3
  404f38:	4313      	orrs	r3, r2
  404f3a:	84fb      	strh	r3, [r7, #38]	; 0x26
    z = ((short)data[5])<<8|data[4];
  404f3c:	7d7b      	ldrb	r3, [r7, #21]
  404f3e:	021b      	lsls	r3, r3, #8
  404f40:	b21a      	sxth	r2, r3
  404f42:	7d3b      	ldrb	r3, [r7, #20]
  404f44:	b21b      	sxth	r3, r3
  404f46:	4313      	orrs	r3, r2
  404f48:	84bb      	strh	r3, [r7, #36]	; 0x24
    
	if (HW_AK09911 == s->secondary_state.compass_slave_id)
  404f4a:	687b      	ldr	r3, [r7, #4]
  404f4c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404f50:	2b23      	cmp	r3, #35	; 0x23
  404f52:	d102      	bne.n	404f5a <inv_icm20648_check_akm_self_test+0x36e>
		shift = 7;
  404f54:	2307      	movs	r3, #7
  404f56:	623b      	str	r3, [r7, #32]
  404f58:	e001      	b.n	404f5e <inv_icm20648_check_akm_self_test+0x372>
	else
		shift = 8;
  404f5a:	2308      	movs	r3, #8
  404f5c:	623b      	str	r3, [r7, #32]
	x = ((x * (sens[0] + 128)) >> shift);
  404f5e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
  404f62:	69ba      	ldr	r2, [r7, #24]
  404f64:	7812      	ldrb	r2, [r2, #0]
  404f66:	3280      	adds	r2, #128	; 0x80
  404f68:	fb02 f203 	mul.w	r2, r2, r3
  404f6c:	6a3b      	ldr	r3, [r7, #32]
  404f6e:	fa42 f303 	asr.w	r3, r2, r3
  404f72:	853b      	strh	r3, [r7, #40]	; 0x28
	y = ((y * (sens[1] + 128)) >> shift);
  404f74:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
  404f78:	69ba      	ldr	r2, [r7, #24]
  404f7a:	3201      	adds	r2, #1
  404f7c:	7812      	ldrb	r2, [r2, #0]
  404f7e:	3280      	adds	r2, #128	; 0x80
  404f80:	fb02 f203 	mul.w	r2, r2, r3
  404f84:	6a3b      	ldr	r3, [r7, #32]
  404f86:	fa42 f303 	asr.w	r3, r2, r3
  404f8a:	84fb      	strh	r3, [r7, #38]	; 0x26
	z = ((z * (sens[2] + 128)) >> shift);
  404f8c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
  404f90:	69ba      	ldr	r2, [r7, #24]
  404f92:	3202      	adds	r2, #2
  404f94:	7812      	ldrb	r2, [r2, #0]
  404f96:	3280      	adds	r2, #128	; 0x80
  404f98:	fb02 f203 	mul.w	r2, r2, r3
  404f9c:	6a3b      	ldr	r3, [r7, #32]
  404f9e:	fa42 f303 	asr.w	r3, r2, r3
  404fa2:	84bb      	strh	r3, [r7, #36]	; 0x24
#if (MEMS_CHIP == HW_ICM20648)
	if (HW_AK8963 == s->secondary_state.compass_slave_id) {
  404fa4:	687b      	ldr	r3, [r7, #4]
  404fa6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404faa:	2b20      	cmp	r3, #32
  404fac:	d11f      	bne.n	404fee <inv_icm20648_check_akm_self_test+0x402>
		result = inv_icm20648_execute_read_secondary(s, 0, addr, REG_AKM8963_CNTL1, 1, &cntl);
  404fae:	7ffa      	ldrb	r2, [r7, #31]
  404fb0:	f107 030a 	add.w	r3, r7, #10
  404fb4:	9301      	str	r3, [sp, #4]
  404fb6:	2301      	movs	r3, #1
  404fb8:	9300      	str	r3, [sp, #0]
  404fba:	230a      	movs	r3, #10
  404fbc:	2100      	movs	r1, #0
  404fbe:	6878      	ldr	r0, [r7, #4]
  404fc0:	4c44      	ldr	r4, [pc, #272]	; (4050d4 <inv_icm20648_check_akm_self_test+0x4e8>)
  404fc2:	47a0      	blx	r4
  404fc4:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (result)
  404fc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404fc8:	2b00      	cmp	r3, #0
  404fca:	d154      	bne.n	405076 <inv_icm20648_check_akm_self_test+0x48a>
			goto AKM_fail;
		if (0 == (cntl & DATA_AKM8963_BIT)) {
  404fcc:	7abb      	ldrb	r3, [r7, #10]
  404fce:	f003 0310 	and.w	r3, r3, #16
  404fd2:	2b00      	cmp	r3, #0
  404fd4:	d10b      	bne.n	404fee <inv_icm20648_check_akm_self_test+0x402>
			x <<= DEF_ST_COMPASS_8963_SHIFT;
  404fd6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
  404fda:	009b      	lsls	r3, r3, #2
  404fdc:	853b      	strh	r3, [r7, #40]	; 0x28
			y <<= DEF_ST_COMPASS_8963_SHIFT;
  404fde:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
  404fe2:	009b      	lsls	r3, r3, #2
  404fe4:	84fb      	strh	r3, [r7, #38]	; 0x26
			z <<= DEF_ST_COMPASS_8963_SHIFT;
  404fe6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
  404fea:	009b      	lsls	r3, r3, #2
  404fec:	84bb      	strh	r3, [r7, #36]	; 0x24
		}
	}
#endif

	result = -1;
  404fee:	f04f 33ff 	mov.w	r3, #4294967295
  404ff2:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (x > s->secondary_state.st_upper[0] || x < s->secondary_state.st_lower[0])
  404ff4:	687b      	ldr	r3, [r7, #4]
  404ff6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  404ff8:	f9b3 3000 	ldrsh.w	r3, [r3]
  404ffc:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
  405000:	429a      	cmp	r2, r3
  405002:	dc39      	bgt.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
  405004:	687b      	ldr	r3, [r7, #4]
  405006:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  405008:	f9b3 3000 	ldrsh.w	r3, [r3]
  40500c:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
  405010:	429a      	cmp	r2, r3
  405012:	db31      	blt.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
		goto AKM_fail;
	if (y > s->secondary_state.st_upper[1] || y < s->secondary_state.st_lower[1])
  405014:	687b      	ldr	r3, [r7, #4]
  405016:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  405018:	3302      	adds	r3, #2
  40501a:	f9b3 3000 	ldrsh.w	r3, [r3]
  40501e:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
  405022:	429a      	cmp	r2, r3
  405024:	dc28      	bgt.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
  405026:	687b      	ldr	r3, [r7, #4]
  405028:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  40502a:	3302      	adds	r3, #2
  40502c:	f9b3 3000 	ldrsh.w	r3, [r3]
  405030:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
  405034:	429a      	cmp	r2, r3
  405036:	db1f      	blt.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
		goto AKM_fail;
	if (z > s->secondary_state.st_upper[2] || z < s->secondary_state.st_lower[2])
  405038:	687b      	ldr	r3, [r7, #4]
  40503a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40503c:	3304      	adds	r3, #4
  40503e:	f9b3 3000 	ldrsh.w	r3, [r3]
  405042:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
  405046:	429a      	cmp	r2, r3
  405048:	dc16      	bgt.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
  40504a:	687b      	ldr	r3, [r7, #4]
  40504c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  40504e:	3304      	adds	r3, #4
  405050:	f9b3 3000 	ldrsh.w	r3, [r3]
  405054:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
  405058:	429a      	cmp	r2, r3
  40505a:	db0d      	blt.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
		goto AKM_fail;
	result = 0;
  40505c:	2300      	movs	r3, #0
  40505e:	62fb      	str	r3, [r7, #44]	; 0x2c
  405060:	e00a      	b.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
		goto AKM_fail;
  405062:	bf00      	nop
  405064:	e008      	b.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
			goto AKM_fail;
  405066:	bf00      	nop
  405068:	e006      	b.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
		goto AKM_fail;
  40506a:	bf00      	nop
  40506c:	e004      	b.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
			goto AKM_fail;
  40506e:	bf00      	nop
  405070:	e002      	b.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
		goto AKM_fail;
  405072:	bf00      	nop
  405074:	e000      	b.n	405078 <inv_icm20648_check_akm_self_test+0x48c>
			goto AKM_fail;
  405076:	bf00      	nop
AKM_fail:
	/*write 0 to ASTC register */
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  405078:	687b      	ldr	r3, [r7, #4]
  40507a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40507e:	2b23      	cmp	r3, #35	; 0x23
  405080:	d015      	beq.n	4050ae <inv_icm20648_check_akm_self_test+0x4c2>
		(HW_AK09912 != s->secondary_state.compass_slave_id) &&
  405082:	687b      	ldr	r3, [r7, #4]
  405084:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  405088:	2b24      	cmp	r3, #36	; 0x24
  40508a:	d010      	beq.n	4050ae <inv_icm20648_check_akm_self_test+0x4c2>
		(HW_AK09916 != s->secondary_state.compass_slave_id)) {
  40508c:	687b      	ldr	r3, [r7, #4]
  40508e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
		(HW_AK09912 != s->secondary_state.compass_slave_id) &&
  405092:	2b25      	cmp	r3, #37	; 0x25
  405094:	d00b      	beq.n	4050ae <inv_icm20648_check_akm_self_test+0x4c2>
		result |= inv_icm20648_execute_write_secondary(s, 0, addr, REG_AKM_ST_CTRL, 0);
  405096:	7ffa      	ldrb	r2, [r7, #31]
  405098:	2300      	movs	r3, #0
  40509a:	9300      	str	r3, [sp, #0]
  40509c:	230c      	movs	r3, #12
  40509e:	2100      	movs	r1, #0
  4050a0:	6878      	ldr	r0, [r7, #4]
  4050a2:	4c0d      	ldr	r4, [pc, #52]	; (4050d8 <inv_icm20648_check_akm_self_test+0x4ec>)
  4050a4:	47a0      	blx	r4
  4050a6:	4602      	mov	r2, r0
  4050a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4050aa:	4313      	orrs	r3, r2
  4050ac:	62fb      	str	r3, [r7, #44]	; 0x2c
	}
	/*set to power down mode */
	result |= inv_icm20648_execute_write_secondary(s, 0, addr, mode, DATA_AKM_MODE_PD);
  4050ae:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
  4050b2:	7ffa      	ldrb	r2, [r7, #31]
  4050b4:	2300      	movs	r3, #0
  4050b6:	9300      	str	r3, [sp, #0]
  4050b8:	460b      	mov	r3, r1
  4050ba:	2100      	movs	r1, #0
  4050bc:	6878      	ldr	r0, [r7, #4]
  4050be:	4c06      	ldr	r4, [pc, #24]	; (4050d8 <inv_icm20648_check_akm_self_test+0x4ec>)
  4050c0:	47a0      	blx	r4
  4050c2:	4602      	mov	r2, r0
  4050c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4050c6:	4313      	orrs	r3, r2
  4050c8:	62fb      	str	r3, [r7, #44]	; 0x2c

    return result;
  4050ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  4050cc:	4618      	mov	r0, r3
  4050ce:	3734      	adds	r7, #52	; 0x34
  4050d0:	46bd      	mov	sp, r7
  4050d2:	bd90      	pop	{r4, r7, pc}
  4050d4:	00405861 	.word	0x00405861
  4050d8:	004059b9 	.word	0x004059b9

004050dc <inv_icm20648_suspend_akm>:
#endif
	return 0;
}

int inv_icm20648_suspend_akm(struct inv_icm20648 * s)
{
  4050dc:	b580      	push	{r7, lr}
  4050de:	b084      	sub	sp, #16
  4050e0:	af00      	add	r7, sp, #0
  4050e2:	6078      	str	r0, [r7, #4]
	int result;
    
	if (!s->secondary_state.secondary_resume_compass_state)
  4050e4:	687b      	ldr	r3, [r7, #4]
  4050e6:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
  4050ea:	2b00      	cmp	r3, #0
  4050ec:	d101      	bne.n	4050f2 <inv_icm20648_suspend_akm+0x16>
		return 0;
  4050ee:	2300      	movs	r3, #0
  4050f0:	e01d      	b.n	40512e <inv_icm20648_suspend_akm+0x52>
    
	/* slave 0 is disabled */
	result = inv_icm20648_secondary_stop_channel(s, COMPASS_I2C_SLV_READ);
  4050f2:	2100      	movs	r1, #0
  4050f4:	6878      	ldr	r0, [r7, #4]
  4050f6:	4b10      	ldr	r3, [pc, #64]	; (405138 <inv_icm20648_suspend_akm+0x5c>)
  4050f8:	4798      	blx	r3
  4050fa:	60f8      	str	r0, [r7, #12]
	/* slave 1 is disabled */
	result |= inv_icm20648_secondary_stop_channel(s, COMPASS_I2C_SLV_WRITE);
  4050fc:	2101      	movs	r1, #1
  4050fe:	6878      	ldr	r0, [r7, #4]
  405100:	4b0d      	ldr	r3, [pc, #52]	; (405138 <inv_icm20648_suspend_akm+0x5c>)
  405102:	4798      	blx	r3
  405104:	4602      	mov	r2, r0
  405106:	68fb      	ldr	r3, [r7, #12]
  405108:	4313      	orrs	r3, r2
  40510a:	60fb      	str	r3, [r7, #12]
	if (result)
  40510c:	68fb      	ldr	r3, [r7, #12]
  40510e:	2b00      	cmp	r3, #0
  405110:	d001      	beq.n	405116 <inv_icm20648_suspend_akm+0x3a>
		return result;
  405112:	68fb      	ldr	r3, [r7, #12]
  405114:	e00b      	b.n	40512e <inv_icm20648_suspend_akm+0x52>
	
	// Switch off I2C Interface as compass is alone
	result |= inv_icm20648_secondary_disable_i2c(s);
  405116:	6878      	ldr	r0, [r7, #4]
  405118:	4b08      	ldr	r3, [pc, #32]	; (40513c <inv_icm20648_suspend_akm+0x60>)
  40511a:	4798      	blx	r3
  40511c:	4602      	mov	r2, r0
  40511e:	68fb      	ldr	r3, [r7, #12]
  405120:	4313      	orrs	r3, r2
  405122:	60fb      	str	r3, [r7, #12]
	
	s->secondary_state.secondary_resume_compass_state = 0;
  405124:	687b      	ldr	r3, [r7, #4]
  405126:	2200      	movs	r2, #0
  405128:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
    
	return result;
  40512c:	68fb      	ldr	r3, [r7, #12]
}
  40512e:	4618      	mov	r0, r3
  405130:	3710      	adds	r7, #16
  405132:	46bd      	mov	sp, r7
  405134:	bd80      	pop	{r7, pc}
  405136:	bf00      	nop
  405138:	00405a3d 	.word	0x00405a3d
  40513c:	00405aa1 	.word	0x00405aa1

00405140 <inv_icm20648_resume_akm>:

int inv_icm20648_resume_akm(struct inv_icm20648 * s)
{
  405140:	b590      	push	{r4, r7, lr}
  405142:	b087      	sub	sp, #28
  405144:	af02      	add	r7, sp, #8
  405146:	6078      	str	r0, [r7, #4]
	int result;
	uint8_t reg_addr, bytes;
    unsigned char lDataToWrite;
    
	if (s->secondary_state.secondary_resume_compass_state)
  405148:	687b      	ldr	r3, [r7, #4]
  40514a:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
  40514e:	2b00      	cmp	r3, #0
  405150:	d001      	beq.n	405156 <inv_icm20648_resume_akm+0x16>
		return 0;
  405152:	2300      	movs	r3, #0
  405154:	e0bc      	b.n	4052d0 <inv_icm20648_resume_akm+0x190>
		reg_addr = REG_AK09916_STATUS1;
		bytes = DATA_AKM_99_BYTES_DMP - 1;
	}
#else
	/* AKM status register address is 1 */
	if (HW_AK09911 == s->secondary_state.compass_slave_id) {
  405156:	687b      	ldr	r3, [r7, #4]
  405158:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40515c:	2b23      	cmp	r3, #35	; 0x23
  40515e:	d10e      	bne.n	40517e <inv_icm20648_resume_akm+0x3e>
		if (s->secondary_state.dmp_on) {
  405160:	687b      	ldr	r3, [r7, #4]
  405162:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  405166:	2b00      	cmp	r3, #0
  405168:	d004      	beq.n	405174 <inv_icm20648_resume_akm+0x34>
			reg_addr = REG_AK09911_DMP_READ;
  40516a:	2303      	movs	r3, #3
  40516c:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_99_BYTES_DMP;
  40516e:	230a      	movs	r3, #10
  405170:	73bb      	strb	r3, [r7, #14]
  405172:	e03a      	b.n	4051ea <inv_icm20648_resume_akm+0xaa>
		} else {
			reg_addr = REG_AK09911_STATUS1;
  405174:	2310      	movs	r3, #16
  405176:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_99_BYTES_DMP - 1;
  405178:	2309      	movs	r3, #9
  40517a:	73bb      	strb	r3, [r7, #14]
  40517c:	e035      	b.n	4051ea <inv_icm20648_resume_akm+0xaa>
		}
	} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
  40517e:	687b      	ldr	r3, [r7, #4]
  405180:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  405184:	2b24      	cmp	r3, #36	; 0x24
  405186:	d10e      	bne.n	4051a6 <inv_icm20648_resume_akm+0x66>
		if (s->secondary_state.dmp_on) {
  405188:	687b      	ldr	r3, [r7, #4]
  40518a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  40518e:	2b00      	cmp	r3, #0
  405190:	d004      	beq.n	40519c <inv_icm20648_resume_akm+0x5c>
			reg_addr = REG_AK09912_DMP_READ;
  405192:	2303      	movs	r3, #3
  405194:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_99_BYTES_DMP;
  405196:	230a      	movs	r3, #10
  405198:	73bb      	strb	r3, [r7, #14]
  40519a:	e026      	b.n	4051ea <inv_icm20648_resume_akm+0xaa>
		} else {
			reg_addr = REG_AK09912_STATUS1;
  40519c:	2310      	movs	r3, #16
  40519e:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_99_BYTES_DMP - 1;
  4051a0:	2309      	movs	r3, #9
  4051a2:	73bb      	strb	r3, [r7, #14]
  4051a4:	e021      	b.n	4051ea <inv_icm20648_resume_akm+0xaa>
		}
	} else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
  4051a6:	687b      	ldr	r3, [r7, #4]
  4051a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  4051ac:	2b25      	cmp	r3, #37	; 0x25
  4051ae:	d10e      	bne.n	4051ce <inv_icm20648_resume_akm+0x8e>
		if (s->secondary_state.dmp_on) {
  4051b0:	687b      	ldr	r3, [r7, #4]
  4051b2:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  4051b6:	2b00      	cmp	r3, #0
  4051b8:	d004      	beq.n	4051c4 <inv_icm20648_resume_akm+0x84>
			reg_addr = REG_AK09916_DMP_READ;
  4051ba:	2303      	movs	r3, #3
  4051bc:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_99_BYTES_DMP;
  4051be:	230a      	movs	r3, #10
  4051c0:	73bb      	strb	r3, [r7, #14]
  4051c2:	e012      	b.n	4051ea <inv_icm20648_resume_akm+0xaa>
		} else {
			reg_addr = REG_AK09916_STATUS1;
  4051c4:	2310      	movs	r3, #16
  4051c6:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_99_BYTES_DMP - 1;
  4051c8:	2309      	movs	r3, #9
  4051ca:	73bb      	strb	r3, [r7, #14]
  4051cc:	e00d      	b.n	4051ea <inv_icm20648_resume_akm+0xaa>
		}
	} else {
		if (s->secondary_state.dmp_on) {
  4051ce:	687b      	ldr	r3, [r7, #4]
  4051d0:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  4051d4:	2b00      	cmp	r3, #0
  4051d6:	d004      	beq.n	4051e2 <inv_icm20648_resume_akm+0xa2>
			reg_addr = REG_AKM_INFO;
  4051d8:	2301      	movs	r3, #1
  4051da:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_89_BYTES_DMP;
  4051dc:	2309      	movs	r3, #9
  4051de:	73bb      	strb	r3, [r7, #14]
  4051e0:	e003      	b.n	4051ea <inv_icm20648_resume_akm+0xaa>
		} else {
			reg_addr = REG_AKM_STATUS;
  4051e2:	2302      	movs	r3, #2
  4051e4:	73fb      	strb	r3, [r7, #15]
			bytes = DATA_AKM_89_BYTES_DMP - 1;
  4051e6:	2308      	movs	r3, #8
  4051e8:	73bb      	strb	r3, [r7, #14]
		}
	}
#endif
	/* slave 0 is enabled, read 10 or 8 bytes from here depending on compass type, swap bytes to feed DMP */
	result = inv_icm20648_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, reg_addr, INV_MPU_BIT_GRP | INV_MPU_BIT_BYTE_SW | bytes);
  4051ea:	687b      	ldr	r3, [r7, #4]
  4051ec:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  4051f0:	b2da      	uxtb	r2, r3
  4051f2:	7bbb      	ldrb	r3, [r7, #14]
  4051f4:	f043 0350 	orr.w	r3, r3, #80	; 0x50
  4051f8:	b2db      	uxtb	r3, r3
  4051fa:	b25b      	sxtb	r3, r3
  4051fc:	7bf9      	ldrb	r1, [r7, #15]
  4051fe:	9300      	str	r3, [sp, #0]
  405200:	460b      	mov	r3, r1
  405202:	2100      	movs	r1, #0
  405204:	6878      	ldr	r0, [r7, #4]
  405206:	4c34      	ldr	r4, [pc, #208]	; (4052d8 <inv_icm20648_resume_akm+0x198>)
  405208:	47a0      	blx	r4
  40520a:	60b8      	str	r0, [r7, #8]
	if (result)
  40520c:	68bb      	ldr	r3, [r7, #8]
  40520e:	2b00      	cmp	r3, #0
  405210:	d001      	beq.n	405216 <inv_icm20648_resume_akm+0xd6>
		return result;
  405212:	68bb      	ldr	r3, [r7, #8]
  405214:	e05c      	b.n	4052d0 <inv_icm20648_resume_akm+0x190>
#if (MEMS_CHIP == HW_ICM20948)
	lDataToWrite = DATA_AKM_MODE_SM;
#else
	/* slave 1 is used to write one-shot accquisition configuration to compass */
	/* output data for slave 1 is fixed, single measure mode */
	s->secondary_state.scale = 1;
  405216:	687b      	ldr	r3, [r7, #4]
  405218:	2201      	movs	r2, #1
  40521a:	67da      	str	r2, [r3, #124]	; 0x7c
	if (HW_AK8975 == s->secondary_state.compass_slave_id) {
  40521c:	687b      	ldr	r3, [r7, #4]
  40521e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  405222:	2b21      	cmp	r3, #33	; 0x21
  405224:	d102      	bne.n	40522c <inv_icm20648_resume_akm+0xec>
		lDataToWrite = DATA_AKM_MODE_SM;
  405226:	2301      	movs	r3, #1
  405228:	737b      	strb	r3, [r7, #13]
  40522a:	e030      	b.n	40528e <inv_icm20648_resume_akm+0x14e>
	} else if (HW_AK8972 == s->secondary_state.compass_slave_id) {
  40522c:	687b      	ldr	r3, [r7, #4]
  40522e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  405232:	2b22      	cmp	r3, #34	; 0x22
  405234:	d102      	bne.n	40523c <inv_icm20648_resume_akm+0xfc>
		lDataToWrite = DATA_AKM_MODE_SM;
  405236:	2301      	movs	r3, #1
  405238:	737b      	strb	r3, [r7, #13]
  40523a:	e028      	b.n	40528e <inv_icm20648_resume_akm+0x14e>
	} else if (HW_AK8963 == s->secondary_state.compass_slave_id) {
  40523c:	687b      	ldr	r3, [r7, #4]
  40523e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  405242:	2b20      	cmp	r3, #32
  405244:	d108      	bne.n	405258 <inv_icm20648_resume_akm+0x118>
		lDataToWrite = DATA_AKM_MODE_SM |
			(s->secondary_state.scale << DATA_AKM8963_SCALE_SHIFT);
  405246:	687b      	ldr	r3, [r7, #4]
  405248:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  40524a:	011b      	lsls	r3, r3, #4
		lDataToWrite = DATA_AKM_MODE_SM |
  40524c:	b25b      	sxtb	r3, r3
  40524e:	f043 0301 	orr.w	r3, r3, #1
  405252:	b25b      	sxtb	r3, r3
  405254:	737b      	strb	r3, [r7, #13]
  405256:	e01a      	b.n	40528e <inv_icm20648_resume_akm+0x14e>
	}  else if (HW_AK09911 == s->secondary_state.compass_slave_id) {
  405258:	687b      	ldr	r3, [r7, #4]
  40525a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40525e:	2b23      	cmp	r3, #35	; 0x23
  405260:	d102      	bne.n	405268 <inv_icm20648_resume_akm+0x128>
		lDataToWrite = DATA_AKM_MODE_SM;
  405262:	2301      	movs	r3, #1
  405264:	737b      	strb	r3, [r7, #13]
  405266:	e012      	b.n	40528e <inv_icm20648_resume_akm+0x14e>
	}  else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
  405268:	687b      	ldr	r3, [r7, #4]
  40526a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40526e:	2b24      	cmp	r3, #36	; 0x24
  405270:	d102      	bne.n	405278 <inv_icm20648_resume_akm+0x138>
		lDataToWrite = DATA_AKM_MODE_SM;
  405272:	2301      	movs	r3, #1
  405274:	737b      	strb	r3, [r7, #13]
  405276:	e00a      	b.n	40528e <inv_icm20648_resume_akm+0x14e>
	}  else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
  405278:	687b      	ldr	r3, [r7, #4]
  40527a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40527e:	2b25      	cmp	r3, #37	; 0x25
  405280:	d102      	bne.n	405288 <inv_icm20648_resume_akm+0x148>
		lDataToWrite = DATA_AKM_MODE_SM;
  405282:	2301      	movs	r3, #1
  405284:	737b      	strb	r3, [r7, #13]
  405286:	e002      	b.n	40528e <inv_icm20648_resume_akm+0x14e>
	} else {
		return -1;
  405288:	f04f 33ff 	mov.w	r3, #4294967295
  40528c:	e020      	b.n	4052d0 <inv_icm20648_resume_akm+0x190>
	}
#endif
	result = inv_icm20648_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, s->secondary_state.mode_reg_addr, lDataToWrite);
  40528e:	687b      	ldr	r3, [r7, #4]
  405290:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  405294:	b2da      	uxtb	r2, r3
  405296:	687b      	ldr	r3, [r7, #4]
  405298:	f893 1082 	ldrb.w	r1, [r3, #130]	; 0x82
  40529c:	f997 300d 	ldrsb.w	r3, [r7, #13]
  4052a0:	9300      	str	r3, [sp, #0]
  4052a2:	460b      	mov	r3, r1
  4052a4:	2101      	movs	r1, #1
  4052a6:	6878      	ldr	r0, [r7, #4]
  4052a8:	4c0c      	ldr	r4, [pc, #48]	; (4052dc <inv_icm20648_resume_akm+0x19c>)
  4052aa:	47a0      	blx	r4
  4052ac:	60b8      	str	r0, [r7, #8]
	if (result)
  4052ae:	68bb      	ldr	r3, [r7, #8]
  4052b0:	2b00      	cmp	r3, #0
  4052b2:	d001      	beq.n	4052b8 <inv_icm20648_resume_akm+0x178>
		return result;
  4052b4:	68bb      	ldr	r3, [r7, #8]
  4052b6:	e00b      	b.n	4052d0 <inv_icm20648_resume_akm+0x190>
	
	result |= inv_icm20648_secondary_enable_i2c(s);
  4052b8:	6878      	ldr	r0, [r7, #4]
  4052ba:	4b09      	ldr	r3, [pc, #36]	; (4052e0 <inv_icm20648_resume_akm+0x1a0>)
  4052bc:	4798      	blx	r3
  4052be:	4602      	mov	r2, r0
  4052c0:	68bb      	ldr	r3, [r7, #8]
  4052c2:	4313      	orrs	r3, r2
  4052c4:	60bb      	str	r3, [r7, #8]

    s->secondary_state.secondary_resume_compass_state = 1;
  4052c6:	687b      	ldr	r3, [r7, #4]
  4052c8:	2201      	movs	r2, #1
  4052ca:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
    
	return result;
  4052ce:	68bb      	ldr	r3, [r7, #8]
}
  4052d0:	4618      	mov	r0, r3
  4052d2:	3714      	adds	r7, #20
  4052d4:	46bd      	mov	sp, r7
  4052d6:	bd90      	pop	{r4, r7, pc}
  4052d8:	004057bd 	.word	0x004057bd
  4052dc:	004058fd 	.word	0x004058fd
  4052e0:	00405a6d 	.word	0x00405a6d

004052e4 <inv_icm20648_compass_dmp_cal>:
*  @param[in]  Compass mounting matrix
*  @return     0 if successful.
*/

int inv_icm20648_compass_dmp_cal(struct inv_icm20648 * s, const signed char *m, const signed char *compass_m)
{
  4052e4:	b590      	push	{r4, r7, lr}
  4052e6:	b0a3      	sub	sp, #140	; 0x8c
  4052e8:	af00      	add	r7, sp, #0
  4052ea:	60f8      	str	r0, [r7, #12]
  4052ec:	60b9      	str	r1, [r7, #8]
  4052ee:	607a      	str	r2, [r7, #4]
	int sens[THREE_AXES];
	int scale;
	int shift;
    int current_compass_matrix[NINE_ELEM];
    
	for (i = 0; i < THREE_AXES; i++)
  4052f0:	2300      	movs	r3, #0
  4052f2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  4052f6:	e02b      	b.n	405350 <inv_icm20648_compass_dmp_cal+0x6c>
		for (j = 0; j < THREE_AXES; j++)
  4052f8:	2300      	movs	r3, #0
  4052fa:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  4052fe:	e01e      	b.n	40533e <inv_icm20648_compass_dmp_cal+0x5a>
			trans[THREE_AXES * j + i] = m[THREE_AXES * i + j];
  405300:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  405304:	4613      	mov	r3, r2
  405306:	005b      	lsls	r3, r3, #1
  405308:	441a      	add	r2, r3
  40530a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  40530e:	18d1      	adds	r1, r2, r3
  405310:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  405314:	4613      	mov	r3, r2
  405316:	005b      	lsls	r3, r3, #1
  405318:	441a      	add	r2, r3
  40531a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40531e:	4413      	add	r3, r2
  405320:	461a      	mov	r2, r3
  405322:	68bb      	ldr	r3, [r7, #8]
  405324:	4413      	add	r3, r2
  405326:	f993 2000 	ldrsb.w	r2, [r3]
  40532a:	f107 0388 	add.w	r3, r7, #136	; 0x88
  40532e:	440b      	add	r3, r1
  405330:	f803 2c20 	strb.w	r2, [r3, #-32]
		for (j = 0; j < THREE_AXES; j++)
  405334:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405338:	3301      	adds	r3, #1
  40533a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  40533e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405342:	2b02      	cmp	r3, #2
  405344:	dddc      	ble.n	405300 <inv_icm20648_compass_dmp_cal+0x1c>
	for (i = 0; i < THREE_AXES; i++)
  405346:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  40534a:	3301      	adds	r3, #1
  40534c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  405350:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405354:	2b02      	cmp	r3, #2
  405356:	ddcf      	ble.n	4052f8 <inv_icm20648_compass_dmp_cal+0x14>
	
    switch (s->secondary_state.compass_slave_id) 
  405358:	68fb      	ldr	r3, [r7, #12]
  40535a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40535e:	3b20      	subs	r3, #32
  405360:	2b04      	cmp	r3, #4
  405362:	d826      	bhi.n	4053b2 <inv_icm20648_compass_dmp_cal+0xce>
  405364:	a201      	add	r2, pc, #4	; (adr r2, 40536c <inv_icm20648_compass_dmp_cal+0x88>)
  405366:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40536a:	bf00      	nop
  40536c:	00405395 	.word	0x00405395
  405370:	0040538b 	.word	0x0040538b
  405374:	00405381 	.word	0x00405381
  405378:	0040539f 	.word	0x0040539f
  40537c:	004053a9 	.word	0x004053a9
    {
#if (MEMS_CHIP == HW_ICM20648)
        case HW_AK8972:
            scale = DATA_AKM8972_SCALE;
  405380:	4bac      	ldr	r3, [pc, #688]	; (405634 <inv_icm20648_compass_dmp_cal+0x350>)
  405382:	67bb      	str	r3, [r7, #120]	; 0x78
            shift = AK89XX_SHIFT;
  405384:	2316      	movs	r3, #22
  405386:	677b      	str	r3, [r7, #116]	; 0x74
            break;
  405388:	e018      	b.n	4053bc <inv_icm20648_compass_dmp_cal+0xd8>
        case HW_AK8975:
            scale = DATA_AKM8975_SCALE;
  40538a:	4bab      	ldr	r3, [pc, #684]	; (405638 <inv_icm20648_compass_dmp_cal+0x354>)
  40538c:	67bb      	str	r3, [r7, #120]	; 0x78
            shift = AK89XX_SHIFT;
  40538e:	2316      	movs	r3, #22
  405390:	677b      	str	r3, [r7, #116]	; 0x74
            break;
  405392:	e013      	b.n	4053bc <inv_icm20648_compass_dmp_cal+0xd8>
        case HW_AK8963:
            scale = DATA_AKM8963_SCALE1;
  405394:	4ba9      	ldr	r3, [pc, #676]	; (40563c <inv_icm20648_compass_dmp_cal+0x358>)
  405396:	67bb      	str	r3, [r7, #120]	; 0x78
            shift = AK89XX_SHIFT;
  405398:	2316      	movs	r3, #22
  40539a:	677b      	str	r3, [r7, #116]	; 0x74
            break;
  40539c:	e00e      	b.n	4053bc <inv_icm20648_compass_dmp_cal+0xd8>
        case HW_AK09911:
            scale = DATA_AK09911_SCALE;
  40539e:	4ba5      	ldr	r3, [pc, #660]	; (405634 <inv_icm20648_compass_dmp_cal+0x350>)
  4053a0:	67bb      	str	r3, [r7, #120]	; 0x78
            shift = AK99XX_SHIFT;
  4053a2:	2317      	movs	r3, #23
  4053a4:	677b      	str	r3, [r7, #116]	; 0x74
            break;
  4053a6:	e009      	b.n	4053bc <inv_icm20648_compass_dmp_cal+0xd8>
        case HW_AK09912:        
            scale = DATA_AK09912_SCALE;
  4053a8:	4ba4      	ldr	r3, [pc, #656]	; (40563c <inv_icm20648_compass_dmp_cal+0x358>)
  4053aa:	67bb      	str	r3, [r7, #120]	; 0x78
            shift = AK89XX_SHIFT;
  4053ac:	2316      	movs	r3, #22
  4053ae:	677b      	str	r3, [r7, #116]	; 0x74
            break;
  4053b0:	e004      	b.n	4053bc <inv_icm20648_compass_dmp_cal+0xd8>
            scale = DATA_AK09916_SCALE;
            shift = AK89XX_SHIFT;
            break;
#endif
		default:
				scale = DATA_AKM8963_SCALE1;
  4053b2:	4ba2      	ldr	r3, [pc, #648]	; (40563c <inv_icm20648_compass_dmp_cal+0x358>)
  4053b4:	67bb      	str	r3, [r7, #120]	; 0x78
				shift = AK89XX_SHIFT;
  4053b6:	2316      	movs	r3, #22
  4053b8:	677b      	str	r3, [r7, #116]	; 0x74
				break;
  4053ba:	bf00      	nop
    }
    
	for (i = 0; i < THREE_AXES; i++) {
  4053bc:	2300      	movs	r3, #0
  4053be:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  4053c2:	e02c      	b.n	40541e <inv_icm20648_compass_dmp_cal+0x13a>
		sens[i] = s->secondary_state.compass_sens[i] + 128;
  4053c4:	68fa      	ldr	r2, [r7, #12]
  4053c6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  4053ca:	4413      	add	r3, r2
  4053cc:	334d      	adds	r3, #77	; 0x4d
  4053ce:	781b      	ldrb	r3, [r3, #0]
  4053d0:	f103 0280 	add.w	r2, r3, #128	; 0x80
  4053d4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  4053d8:	009b      	lsls	r3, r3, #2
  4053da:	f107 0188 	add.w	r1, r7, #136	; 0x88
  4053de:	440b      	add	r3, r1
  4053e0:	f843 2c50 	str.w	r2, [r3, #-80]
		sens[i] = inv_icm20648_convert_mult_q30_fxp(sens[i] << shift, scale);
  4053e4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  4053e8:	009b      	lsls	r3, r3, #2
  4053ea:	f107 0288 	add.w	r2, r7, #136	; 0x88
  4053ee:	4413      	add	r3, r2
  4053f0:	f853 2c50 	ldr.w	r2, [r3, #-80]
  4053f4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  4053f6:	fa02 f303 	lsl.w	r3, r2, r3
  4053fa:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  4053fc:	4618      	mov	r0, r3
  4053fe:	4b90      	ldr	r3, [pc, #576]	; (405640 <inv_icm20648_compass_dmp_cal+0x35c>)
  405400:	4798      	blx	r3
  405402:	4602      	mov	r2, r0
  405404:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405408:	009b      	lsls	r3, r3, #2
  40540a:	f107 0188 	add.w	r1, r7, #136	; 0x88
  40540e:	440b      	add	r3, r1
  405410:	f843 2c50 	str.w	r2, [r3, #-80]
	for (i = 0; i < THREE_AXES; i++) {
  405414:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405418:	3301      	adds	r3, #1
  40541a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40541e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405422:	2b02      	cmp	r3, #2
  405424:	ddce      	ble.n	4053c4 <inv_icm20648_compass_dmp_cal+0xe0>
	}
	for (i = 0; i < NINE_ELEM; i++) {
  405426:	2300      	movs	r3, #0
  405428:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40542c:	e02f      	b.n	40548e <inv_icm20648_compass_dmp_cal+0x1aa>
		current_compass_matrix[i] = compass_m[i] * sens[i % THREE_AXES];
  40542e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405432:	687a      	ldr	r2, [r7, #4]
  405434:	4413      	add	r3, r2
  405436:	f993 3000 	ldrsb.w	r3, [r3]
  40543a:	4618      	mov	r0, r3
  40543c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  405440:	4b80      	ldr	r3, [pc, #512]	; (405644 <inv_icm20648_compass_dmp_cal+0x360>)
  405442:	fb83 3201 	smull	r3, r2, r3, r1
  405446:	17cb      	asrs	r3, r1, #31
  405448:	1ad2      	subs	r2, r2, r3
  40544a:	4613      	mov	r3, r2
  40544c:	005b      	lsls	r3, r3, #1
  40544e:	4413      	add	r3, r2
  405450:	1aca      	subs	r2, r1, r3
  405452:	0093      	lsls	r3, r2, #2
  405454:	f107 0288 	add.w	r2, r7, #136	; 0x88
  405458:	4413      	add	r3, r2
  40545a:	f853 3c50 	ldr.w	r3, [r3, #-80]
  40545e:	fb03 f200 	mul.w	r2, r3, r0
  405462:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405466:	009b      	lsls	r3, r3, #2
  405468:	f107 0188 	add.w	r1, r7, #136	; 0x88
  40546c:	440b      	add	r3, r1
  40546e:	f843 2c74 	str.w	r2, [r3, #-116]
		tmp_m[i] = 0;
  405472:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405476:	009b      	lsls	r3, r3, #2
  405478:	f107 0288 	add.w	r2, r7, #136	; 0x88
  40547c:	4413      	add	r3, r2
  40547e:	2200      	movs	r2, #0
  405480:	f843 2c44 	str.w	r2, [r3, #-68]
	for (i = 0; i < NINE_ELEM; i++) {
  405484:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405488:	3301      	adds	r3, #1
  40548a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40548e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405492:	2b08      	cmp	r3, #8
  405494:	ddcb      	ble.n	40542e <inv_icm20648_compass_dmp_cal+0x14a>
	}
    
    for (i = 0; i < THREE_AXES; i++) {
  405496:	2300      	movs	r3, #0
  405498:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40549c:	e060      	b.n	405560 <inv_icm20648_compass_dmp_cal+0x27c>
		for (j = 0; j < THREE_AXES; j++) {
  40549e:	2300      	movs	r3, #0
  4054a0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  4054a4:	e053      	b.n	40554e <inv_icm20648_compass_dmp_cal+0x26a>
			s->secondary_state.final_matrix[i * THREE_AXES + j] = 0;
  4054a6:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4054aa:	4613      	mov	r3, r2
  4054ac:	005b      	lsls	r3, r3, #1
  4054ae:	441a      	add	r2, r3
  4054b0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4054b4:	4413      	add	r3, r2
  4054b6:	68fa      	ldr	r2, [r7, #12]
  4054b8:	3312      	adds	r3, #18
  4054ba:	009b      	lsls	r3, r3, #2
  4054bc:	4413      	add	r3, r2
  4054be:	2200      	movs	r2, #0
  4054c0:	609a      	str	r2, [r3, #8]
			for (k = 0; k < THREE_AXES; k++)
  4054c2:	2300      	movs	r3, #0
  4054c4:	67fb      	str	r3, [r7, #124]	; 0x7c
  4054c6:	e03a      	b.n	40553e <inv_icm20648_compass_dmp_cal+0x25a>
				s->secondary_state.final_matrix[i * THREE_AXES + j] +=
					inv_icm20648_convert_mult_q30_fxp(s->soft_iron_matrix[i * THREE_AXES + k],
  4054c8:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4054cc:	4613      	mov	r3, r2
  4054ce:	005b      	lsls	r3, r3, #1
  4054d0:	441a      	add	r2, r3
  4054d2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4054d4:	441a      	add	r2, r3
  4054d6:	68fb      	ldr	r3, [r7, #12]
  4054d8:	32a2      	adds	r2, #162	; 0xa2
  4054da:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
                                 current_compass_matrix[j + k * THREE_AXES]);
  4054de:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  4054e0:	4613      	mov	r3, r2
  4054e2:	005b      	lsls	r3, r3, #1
  4054e4:	441a      	add	r2, r3
  4054e6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4054ea:	4413      	add	r3, r2
  4054ec:	009b      	lsls	r3, r3, #2
  4054ee:	f107 0288 	add.w	r2, r7, #136	; 0x88
  4054f2:	4413      	add	r3, r2
  4054f4:	f853 3c74 	ldr.w	r3, [r3, #-116]
					inv_icm20648_convert_mult_q30_fxp(s->soft_iron_matrix[i * THREE_AXES + k],
  4054f8:	4619      	mov	r1, r3
  4054fa:	4b51      	ldr	r3, [pc, #324]	; (405640 <inv_icm20648_compass_dmp_cal+0x35c>)
  4054fc:	4798      	blx	r3
  4054fe:	4601      	mov	r1, r0
				s->secondary_state.final_matrix[i * THREE_AXES + j] +=
  405500:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  405504:	4613      	mov	r3, r2
  405506:	005b      	lsls	r3, r3, #1
  405508:	441a      	add	r2, r3
  40550a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40550e:	18d0      	adds	r0, r2, r3
  405510:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  405514:	4613      	mov	r3, r2
  405516:	005b      	lsls	r3, r3, #1
  405518:	441a      	add	r2, r3
  40551a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40551e:	4413      	add	r3, r2
  405520:	68fa      	ldr	r2, [r7, #12]
  405522:	3312      	adds	r3, #18
  405524:	009b      	lsls	r3, r3, #2
  405526:	4413      	add	r3, r2
  405528:	689b      	ldr	r3, [r3, #8]
  40552a:	185a      	adds	r2, r3, r1
  40552c:	68f9      	ldr	r1, [r7, #12]
  40552e:	f100 0312 	add.w	r3, r0, #18
  405532:	009b      	lsls	r3, r3, #2
  405534:	440b      	add	r3, r1
  405536:	609a      	str	r2, [r3, #8]
			for (k = 0; k < THREE_AXES; k++)
  405538:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  40553a:	3301      	adds	r3, #1
  40553c:	67fb      	str	r3, [r7, #124]	; 0x7c
  40553e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  405540:	2b02      	cmp	r3, #2
  405542:	ddc1      	ble.n	4054c8 <inv_icm20648_compass_dmp_cal+0x1e4>
		for (j = 0; j < THREE_AXES; j++) {
  405544:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405548:	3301      	adds	r3, #1
  40554a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  40554e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405552:	2b02      	cmp	r3, #2
  405554:	dda7      	ble.n	4054a6 <inv_icm20648_compass_dmp_cal+0x1c2>
    for (i = 0; i < THREE_AXES; i++) {
  405556:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  40555a:	3301      	adds	r3, #1
  40555c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  405560:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405564:	2b02      	cmp	r3, #2
  405566:	dd9a      	ble.n	40549e <inv_icm20648_compass_dmp_cal+0x1ba>
		}
	}
    
    for (i = 0; i < THREE_AXES; i++)
  405568:	2300      	movs	r3, #0
  40556a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40556e:	e052      	b.n	405616 <inv_icm20648_compass_dmp_cal+0x332>
		for (j = 0; j < THREE_AXES; j++)
  405570:	2300      	movs	r3, #0
  405572:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  405576:	e045      	b.n	405604 <inv_icm20648_compass_dmp_cal+0x320>
			for (k = 0; k < THREE_AXES; k++)
  405578:	2300      	movs	r3, #0
  40557a:	67fb      	str	r3, [r7, #124]	; 0x7c
  40557c:	e03a      	b.n	4055f4 <inv_icm20648_compass_dmp_cal+0x310>
				tmp_m[THREE_AXES * i + j] +=
  40557e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  405582:	4613      	mov	r3, r2
  405584:	005b      	lsls	r3, r3, #1
  405586:	441a      	add	r2, r3
  405588:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40558c:	18d1      	adds	r1, r2, r3
  40558e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  405592:	4613      	mov	r3, r2
  405594:	005b      	lsls	r3, r3, #1
  405596:	441a      	add	r2, r3
  405598:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40559c:	4413      	add	r3, r2
  40559e:	009b      	lsls	r3, r3, #2
  4055a0:	f107 0288 	add.w	r2, r7, #136	; 0x88
  4055a4:	4413      	add	r3, r2
  4055a6:	f853 0c44 	ldr.w	r0, [r3, #-68]
					trans[THREE_AXES * i + k] *
  4055aa:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4055ae:	4613      	mov	r3, r2
  4055b0:	005b      	lsls	r3, r3, #1
  4055b2:	441a      	add	r2, r3
  4055b4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4055b6:	4413      	add	r3, r2
  4055b8:	f107 0288 	add.w	r2, r7, #136	; 0x88
  4055bc:	4413      	add	r3, r2
  4055be:	f913 3c20 	ldrsb.w	r3, [r3, #-32]
  4055c2:	461c      	mov	r4, r3
						s->secondary_state.final_matrix[THREE_AXES * k + j];
  4055c4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  4055c6:	4613      	mov	r3, r2
  4055c8:	005b      	lsls	r3, r3, #1
  4055ca:	441a      	add	r2, r3
  4055cc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4055d0:	4413      	add	r3, r2
  4055d2:	68fa      	ldr	r2, [r7, #12]
  4055d4:	3312      	adds	r3, #18
  4055d6:	009b      	lsls	r3, r3, #2
  4055d8:	4413      	add	r3, r2
  4055da:	689b      	ldr	r3, [r3, #8]
					trans[THREE_AXES * i + k] *
  4055dc:	fb03 f304 	mul.w	r3, r3, r4
				tmp_m[THREE_AXES * i + j] +=
  4055e0:	18c2      	adds	r2, r0, r3
  4055e2:	008b      	lsls	r3, r1, #2
  4055e4:	f107 0188 	add.w	r1, r7, #136	; 0x88
  4055e8:	440b      	add	r3, r1
  4055ea:	f843 2c44 	str.w	r2, [r3, #-68]
			for (k = 0; k < THREE_AXES; k++)
  4055ee:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4055f0:	3301      	adds	r3, #1
  4055f2:	67fb      	str	r3, [r7, #124]	; 0x7c
  4055f4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4055f6:	2b02      	cmp	r3, #2
  4055f8:	ddc1      	ble.n	40557e <inv_icm20648_compass_dmp_cal+0x29a>
		for (j = 0; j < THREE_AXES; j++)
  4055fa:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4055fe:	3301      	adds	r3, #1
  405600:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  405604:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405608:	2b02      	cmp	r3, #2
  40560a:	ddb5      	ble.n	405578 <inv_icm20648_compass_dmp_cal+0x294>
    for (i = 0; i < THREE_AXES; i++)
  40560c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405610:	3301      	adds	r3, #1
  405612:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  405616:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  40561a:	2b02      	cmp	r3, #2
  40561c:	dda8      	ble.n	405570 <inv_icm20648_compass_dmp_cal+0x28c>
    
    return dmp_icm20648_set_compass_matrix(s, tmp_m);
  40561e:	f107 0344 	add.w	r3, r7, #68	; 0x44
  405622:	4619      	mov	r1, r3
  405624:	68f8      	ldr	r0, [r7, #12]
  405626:	4b08      	ldr	r3, [pc, #32]	; (405648 <inv_icm20648_compass_dmp_cal+0x364>)
  405628:	4798      	blx	r3
  40562a:	4603      	mov	r3, r0
}
  40562c:	4618      	mov	r0, r3
  40562e:	378c      	adds	r7, #140	; 0x8c
  405630:	46bd      	mov	sp, r7
  405632:	bd90      	pop	{r4, r7, pc}
  405634:	26666666 	.word	0x26666666
  405638:	13333333 	.word	0x13333333
  40563c:	09999999 	.word	0x09999999
  405640:	004070d1 	.word	0x004070d1
  405644:	55555556 	.word	0x55555556
  405648:	004084d9 	.word	0x004084d9

0040564c <inv_icm20648_apply_raw_compass_matrix>:
*  @param[in]  Compensated compass data
*  @return     0 if successful.
*/

int inv_icm20648_apply_raw_compass_matrix(struct inv_icm20648 * s, short *raw_data, long *compensated_out)
{
  40564c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40564e:	b089      	sub	sp, #36	; 0x24
  405650:	af00      	add	r7, sp, #0
  405652:	60f8      	str	r0, [r7, #12]
  405654:	60b9      	str	r1, [r7, #8]
  405656:	607a      	str	r2, [r7, #4]
	int i, j;
	long long tmp;
    
	for (i = 0; i < THREE_AXES; i++) {
  405658:	2200      	movs	r2, #0
  40565a:	61fa      	str	r2, [r7, #28]
  40565c:	e045      	b.n	4056ea <inv_icm20648_apply_raw_compass_matrix+0x9e>
		tmp = 0;
  40565e:	f04f 0100 	mov.w	r1, #0
  405662:	f04f 0200 	mov.w	r2, #0
  405666:	e9c7 1204 	strd	r1, r2, [r7, #16]
		for (j = 0; j < THREE_AXES; j++)
  40566a:	2200      	movs	r2, #0
  40566c:	61ba      	str	r2, [r7, #24]
  40566e:	e02a      	b.n	4056c6 <inv_icm20648_apply_raw_compass_matrix+0x7a>
			tmp  +=
			(long long)s->secondary_state.final_matrix[i * THREE_AXES + j] * (((int)raw_data[j]) << 16);
  405670:	69f9      	ldr	r1, [r7, #28]
  405672:	460a      	mov	r2, r1
  405674:	0052      	lsls	r2, r2, #1
  405676:	4411      	add	r1, r2
  405678:	69ba      	ldr	r2, [r7, #24]
  40567a:	440a      	add	r2, r1
  40567c:	68f9      	ldr	r1, [r7, #12]
  40567e:	3212      	adds	r2, #18
  405680:	0092      	lsls	r2, r2, #2
  405682:	440a      	add	r2, r1
  405684:	6892      	ldr	r2, [r2, #8]
  405686:	4615      	mov	r5, r2
  405688:	ea4f 76e5 	mov.w	r6, r5, asr #31
  40568c:	69ba      	ldr	r2, [r7, #24]
  40568e:	0052      	lsls	r2, r2, #1
  405690:	68b9      	ldr	r1, [r7, #8]
  405692:	440a      	add	r2, r1
  405694:	f9b2 2000 	ldrsh.w	r2, [r2]
  405698:	0412      	lsls	r2, r2, #16
  40569a:	4611      	mov	r1, r2
  40569c:	ea4f 72e1 	mov.w	r2, r1, asr #31
  4056a0:	fb01 fe06 	mul.w	lr, r1, r6
  4056a4:	fb05 f002 	mul.w	r0, r5, r2
  4056a8:	4470      	add	r0, lr
  4056aa:	fba5 1201 	umull	r1, r2, r5, r1
  4056ae:	4410      	add	r0, r2
  4056b0:	4602      	mov	r2, r0
			tmp  +=
  4056b2:	e9d7 5604 	ldrd	r5, r6, [r7, #16]
  4056b6:	1949      	adds	r1, r1, r5
  4056b8:	eb42 0206 	adc.w	r2, r2, r6
  4056bc:	e9c7 1204 	strd	r1, r2, [r7, #16]
		for (j = 0; j < THREE_AXES; j++)
  4056c0:	69ba      	ldr	r2, [r7, #24]
  4056c2:	3201      	adds	r2, #1
  4056c4:	61ba      	str	r2, [r7, #24]
  4056c6:	69ba      	ldr	r2, [r7, #24]
  4056c8:	2a02      	cmp	r2, #2
  4056ca:	ddd1      	ble.n	405670 <inv_icm20648_apply_raw_compass_matrix+0x24>
		compensated_out[i] = (long)(tmp >> 30);
  4056cc:	69fa      	ldr	r2, [r7, #28]
  4056ce:	0092      	lsls	r2, r2, #2
  4056d0:	6879      	ldr	r1, [r7, #4]
  4056d2:	1888      	adds	r0, r1, r2
  4056d4:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
  4056d8:	0f8b      	lsrs	r3, r1, #30
  4056da:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
  4056de:	1794      	asrs	r4, r2, #30
  4056e0:	461a      	mov	r2, r3
  4056e2:	6002      	str	r2, [r0, #0]
	for (i = 0; i < THREE_AXES; i++) {
  4056e4:	69fa      	ldr	r2, [r7, #28]
  4056e6:	3201      	adds	r2, #1
  4056e8:	61fa      	str	r2, [r7, #28]
  4056ea:	69fa      	ldr	r2, [r7, #28]
  4056ec:	2a02      	cmp	r2, #2
  4056ee:	ddb6      	ble.n	40565e <inv_icm20648_apply_raw_compass_matrix+0x12>
	}
    
	return 0;
  4056f0:	2300      	movs	r3, #0
}
  4056f2:	4618      	mov	r0, r3
  4056f4:	3724      	adds	r7, #36	; 0x24
  4056f6:	46bd      	mov	sp, r7
  4056f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

004056fc <inv_icm20648_init_secondary>:
#include "Icm20648DataBaseDriver.h"

#include "Icm20648AuxTransport.h"

void inv_icm20648_init_secondary(struct inv_icm20648 * s)
{
  4056fc:	b580      	push	{r7, lr}
  4056fe:	b082      	sub	sp, #8
  405700:	af00      	add	r7, sp, #0
  405702:	6078      	str	r0, [r7, #4]
	s->secondary_state.slv_reg[0].addr = REG_I2C_SLV0_ADDR;
  405704:	687b      	ldr	r3, [r7, #4]
  405706:	f240 1283 	movw	r2, #387	; 0x183
  40570a:	859a      	strh	r2, [r3, #44]	; 0x2c
	s->secondary_state.slv_reg[0].reg  = REG_I2C_SLV0_REG;
  40570c:	687b      	ldr	r3, [r7, #4]
  40570e:	f44f 72c2 	mov.w	r2, #388	; 0x184
  405712:	85da      	strh	r2, [r3, #46]	; 0x2e
	s->secondary_state.slv_reg[0].ctrl = REG_I2C_SLV0_CTRL;
  405714:	687b      	ldr	r3, [r7, #4]
  405716:	f240 1285 	movw	r2, #389	; 0x185
  40571a:	861a      	strh	r2, [r3, #48]	; 0x30
	s->secondary_state.slv_reg[0].d0   = REG_I2C_SLV0_DO;
  40571c:	687b      	ldr	r3, [r7, #4]
  40571e:	f44f 72c3 	mov.w	r2, #390	; 0x186
  405722:	865a      	strh	r2, [r3, #50]	; 0x32
    
    s->secondary_state.slv_reg[1].addr = REG_I2C_SLV1_ADDR;
  405724:	687b      	ldr	r3, [r7, #4]
  405726:	f240 1287 	movw	r2, #391	; 0x187
  40572a:	869a      	strh	r2, [r3, #52]	; 0x34
	s->secondary_state.slv_reg[1].reg  = REG_I2C_SLV1_REG;
  40572c:	687b      	ldr	r3, [r7, #4]
  40572e:	f44f 72c4 	mov.w	r2, #392	; 0x188
  405732:	86da      	strh	r2, [r3, #54]	; 0x36
	s->secondary_state.slv_reg[1].ctrl = REG_I2C_SLV1_CTRL;
  405734:	687b      	ldr	r3, [r7, #4]
  405736:	f240 1289 	movw	r2, #393	; 0x189
  40573a:	871a      	strh	r2, [r3, #56]	; 0x38
	s->secondary_state.slv_reg[1].d0   = REG_I2C_SLV1_DO;
  40573c:	687b      	ldr	r3, [r7, #4]
  40573e:	f44f 72c5 	mov.w	r2, #394	; 0x18a
  405742:	875a      	strh	r2, [r3, #58]	; 0x3a
    
    s->secondary_state.slv_reg[2].addr = REG_I2C_SLV2_ADDR;
  405744:	687b      	ldr	r3, [r7, #4]
  405746:	f240 128b 	movw	r2, #395	; 0x18b
  40574a:	879a      	strh	r2, [r3, #60]	; 0x3c
	s->secondary_state.slv_reg[2].reg  = REG_I2C_SLV2_REG;
  40574c:	687b      	ldr	r3, [r7, #4]
  40574e:	f44f 72c6 	mov.w	r2, #396	; 0x18c
  405752:	87da      	strh	r2, [r3, #62]	; 0x3e
	s->secondary_state.slv_reg[2].ctrl = REG_I2C_SLV2_CTRL;
  405754:	687b      	ldr	r3, [r7, #4]
  405756:	f240 128d 	movw	r2, #397	; 0x18d
  40575a:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
	s->secondary_state.slv_reg[2].d0   = REG_I2C_SLV2_DO;
  40575e:	687b      	ldr	r3, [r7, #4]
  405760:	f44f 72c7 	mov.w	r2, #398	; 0x18e
  405764:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
    
	s->secondary_state.slv_reg[3].addr = REG_I2C_SLV3_ADDR;
  405768:	687b      	ldr	r3, [r7, #4]
  40576a:	f240 128f 	movw	r2, #399	; 0x18f
  40576e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
	s->secondary_state.slv_reg[3].reg  = REG_I2C_SLV3_REG;
  405772:	687b      	ldr	r3, [r7, #4]
  405774:	f44f 72c8 	mov.w	r2, #400	; 0x190
  405778:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
	s->secondary_state.slv_reg[3].ctrl = REG_I2C_SLV3_CTRL;
  40577c:	687b      	ldr	r3, [r7, #4]
  40577e:	f240 1291 	movw	r2, #401	; 0x191
  405782:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
	s->secondary_state.slv_reg[3].d0   = REG_I2C_SLV3_DO;
  405786:	687b      	ldr	r3, [r7, #4]
  405788:	f44f 72c9 	mov.w	r2, #402	; 0x192
  40578c:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
	
	/* Make sure that by default all channels are disabled 
	To not inherit from a previous configuration from a previous run*/
	inv_icm20648_secondary_stop_channel(s, 0);
  405790:	2100      	movs	r1, #0
  405792:	6878      	ldr	r0, [r7, #4]
  405794:	4b08      	ldr	r3, [pc, #32]	; (4057b8 <inv_icm20648_init_secondary+0xbc>)
  405796:	4798      	blx	r3
	inv_icm20648_secondary_stop_channel(s, 1);
  405798:	2101      	movs	r1, #1
  40579a:	6878      	ldr	r0, [r7, #4]
  40579c:	4b06      	ldr	r3, [pc, #24]	; (4057b8 <inv_icm20648_init_secondary+0xbc>)
  40579e:	4798      	blx	r3
	inv_icm20648_secondary_stop_channel(s, 2);
  4057a0:	2102      	movs	r1, #2
  4057a2:	6878      	ldr	r0, [r7, #4]
  4057a4:	4b04      	ldr	r3, [pc, #16]	; (4057b8 <inv_icm20648_init_secondary+0xbc>)
  4057a6:	4798      	blx	r3
	inv_icm20648_secondary_stop_channel(s, 3);
  4057a8:	2103      	movs	r1, #3
  4057aa:	6878      	ldr	r0, [r7, #4]
  4057ac:	4b02      	ldr	r3, [pc, #8]	; (4057b8 <inv_icm20648_init_secondary+0xbc>)
  4057ae:	4798      	blx	r3
}
  4057b0:	bf00      	nop
  4057b2:	3708      	adds	r7, #8
  4057b4:	46bd      	mov	sp, r7
  4057b6:	bd80      	pop	{r7, pc}
  4057b8:	00405a3d 	.word	0x00405a3d

004057bc <inv_icm20648_read_secondary>:
* reg is the device register we wish to access
* len is the number of bytes to be read
* 
*/
int inv_icm20648_read_secondary(struct inv_icm20648 * s, int index, unsigned char addr, unsigned char reg, char len)
{
  4057bc:	b590      	push	{r4, r7, lr}
  4057be:	b087      	sub	sp, #28
  4057c0:	af00      	add	r7, sp, #0
  4057c2:	60f8      	str	r0, [r7, #12]
  4057c4:	60b9      	str	r1, [r7, #8]
  4057c6:	4611      	mov	r1, r2
  4057c8:	461a      	mov	r2, r3
  4057ca:	460b      	mov	r3, r1
  4057cc:	71fb      	strb	r3, [r7, #7]
  4057ce:	4613      	mov	r3, r2
  4057d0:	71bb      	strb	r3, [r7, #6]
	int result = 0;
  4057d2:	2300      	movs	r3, #0
  4057d4:	617b      	str	r3, [r7, #20]
    unsigned char data;

    data = INV_MPU_BIT_I2C_READ | addr;
  4057d6:	79fb      	ldrb	r3, [r7, #7]
  4057d8:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4057dc:	b2db      	uxtb	r3, r3
  4057de:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20648_write_mems_reg(s, s->secondary_state.slv_reg[index].addr, 1, &data);
  4057e0:	68fa      	ldr	r2, [r7, #12]
  4057e2:	68bb      	ldr	r3, [r7, #8]
  4057e4:	3305      	adds	r3, #5
  4057e6:	00db      	lsls	r3, r3, #3
  4057e8:	4413      	add	r3, r2
  4057ea:	8899      	ldrh	r1, [r3, #4]
  4057ec:	f107 0313 	add.w	r3, r7, #19
  4057f0:	2201      	movs	r2, #1
  4057f2:	68f8      	ldr	r0, [r7, #12]
  4057f4:	4c19      	ldr	r4, [pc, #100]	; (40585c <inv_icm20648_read_secondary+0xa0>)
  4057f6:	47a0      	blx	r4
  4057f8:	4602      	mov	r2, r0
  4057fa:	697b      	ldr	r3, [r7, #20]
  4057fc:	4313      	orrs	r3, r2
  4057fe:	617b      	str	r3, [r7, #20]

    data = reg;
  405800:	79bb      	ldrb	r3, [r7, #6]
  405802:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20648_write_mems_reg(s, s->secondary_state.slv_reg[index].reg, 1, &data);
  405804:	68fa      	ldr	r2, [r7, #12]
  405806:	68bb      	ldr	r3, [r7, #8]
  405808:	3305      	adds	r3, #5
  40580a:	00db      	lsls	r3, r3, #3
  40580c:	4413      	add	r3, r2
  40580e:	88d9      	ldrh	r1, [r3, #6]
  405810:	f107 0313 	add.w	r3, r7, #19
  405814:	2201      	movs	r2, #1
  405816:	68f8      	ldr	r0, [r7, #12]
  405818:	4c10      	ldr	r4, [pc, #64]	; (40585c <inv_icm20648_read_secondary+0xa0>)
  40581a:	47a0      	blx	r4
  40581c:	4602      	mov	r2, r0
  40581e:	697b      	ldr	r3, [r7, #20]
  405820:	4313      	orrs	r3, r2
  405822:	617b      	str	r3, [r7, #20]
    
    data = INV_MPU_BIT_SLV_EN | len;
  405824:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
  405828:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40582c:	b25b      	sxtb	r3, r3
  40582e:	b2db      	uxtb	r3, r3
  405830:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20648_write_mems_reg(s, s->secondary_state.slv_reg[index].ctrl, 1, &data);
  405832:	68fa      	ldr	r2, [r7, #12]
  405834:	68bb      	ldr	r3, [r7, #8]
  405836:	3305      	adds	r3, #5
  405838:	00db      	lsls	r3, r3, #3
  40583a:	4413      	add	r3, r2
  40583c:	8919      	ldrh	r1, [r3, #8]
  40583e:	f107 0313 	add.w	r3, r7, #19
  405842:	2201      	movs	r2, #1
  405844:	68f8      	ldr	r0, [r7, #12]
  405846:	4c05      	ldr	r4, [pc, #20]	; (40585c <inv_icm20648_read_secondary+0xa0>)
  405848:	47a0      	blx	r4
  40584a:	4602      	mov	r2, r0
  40584c:	697b      	ldr	r3, [r7, #20]
  40584e:	4313      	orrs	r3, r2
  405850:	617b      	str	r3, [r7, #20]
    
	return result;
  405852:	697b      	ldr	r3, [r7, #20]
}
  405854:	4618      	mov	r0, r3
  405856:	371c      	adds	r7, #28
  405858:	46bd      	mov	sp, r7
  40585a:	bd90      	pop	{r4, r7, pc}
  40585c:	0040c8cd 	.word	0x0040c8cd

00405860 <inv_icm20648_execute_read_secondary>:

int inv_icm20648_execute_read_secondary(struct inv_icm20648 * s, int index, unsigned char addr, int reg, int len, uint8_t *d)
{
  405860:	b590      	push	{r4, r7, lr}
  405862:	b089      	sub	sp, #36	; 0x24
  405864:	af02      	add	r7, sp, #8
  405866:	60f8      	str	r0, [r7, #12]
  405868:	60b9      	str	r1, [r7, #8]
  40586a:	603b      	str	r3, [r7, #0]
  40586c:	4613      	mov	r3, r2
  40586e:	71fb      	strb	r3, [r7, #7]
	int result = 0;
  405870:	2300      	movs	r3, #0
  405872:	617b      	str	r3, [r7, #20]

	result |= inv_icm20648_read_secondary(s, index, addr, reg, len);
  405874:	683b      	ldr	r3, [r7, #0]
  405876:	b2d9      	uxtb	r1, r3
  405878:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40587a:	b25b      	sxtb	r3, r3
  40587c:	79fa      	ldrb	r2, [r7, #7]
  40587e:	9300      	str	r3, [sp, #0]
  405880:	460b      	mov	r3, r1
  405882:	68b9      	ldr	r1, [r7, #8]
  405884:	68f8      	ldr	r0, [r7, #12]
  405886:	4c17      	ldr	r4, [pc, #92]	; (4058e4 <inv_icm20648_execute_read_secondary+0x84>)
  405888:	47a0      	blx	r4
  40588a:	4602      	mov	r2, r0
  40588c:	697b      	ldr	r3, [r7, #20]
  40588e:	4313      	orrs	r3, r2
  405890:	617b      	str	r3, [r7, #20]
	
	result |= inv_icm20648_secondary_enable_i2c(s);
  405892:	68f8      	ldr	r0, [r7, #12]
  405894:	4b14      	ldr	r3, [pc, #80]	; (4058e8 <inv_icm20648_execute_read_secondary+0x88>)
  405896:	4798      	blx	r3
  405898:	4602      	mov	r2, r0
  40589a:	697b      	ldr	r3, [r7, #20]
  40589c:	4313      	orrs	r3, r2
  40589e:	617b      	str	r3, [r7, #20]
    
	inv_icm20648_sleep_us(SECONDARY_INIT_WAIT*1000);
  4058a0:	f64e 2060 	movw	r0, #60000	; 0xea60
  4058a4:	4b11      	ldr	r3, [pc, #68]	; (4058ec <inv_icm20648_execute_read_secondary+0x8c>)
  4058a6:	4798      	blx	r3
    
	result |= inv_icm20648_secondary_disable_i2c(s);
  4058a8:	68f8      	ldr	r0, [r7, #12]
  4058aa:	4b11      	ldr	r3, [pc, #68]	; (4058f0 <inv_icm20648_execute_read_secondary+0x90>)
  4058ac:	4798      	blx	r3
  4058ae:	4602      	mov	r2, r0
  4058b0:	697b      	ldr	r3, [r7, #20]
  4058b2:	4313      	orrs	r3, r2
  4058b4:	617b      	str	r3, [r7, #20]

    result |= inv_icm20648_read_mems_reg(s, REG_EXT_SLV_SENS_DATA_00, len, d); 
  4058b6:	6aba      	ldr	r2, [r7, #40]	; 0x28
  4058b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4058ba:	213b      	movs	r1, #59	; 0x3b
  4058bc:	68f8      	ldr	r0, [r7, #12]
  4058be:	4c0d      	ldr	r4, [pc, #52]	; (4058f4 <inv_icm20648_execute_read_secondary+0x94>)
  4058c0:	47a0      	blx	r4
  4058c2:	4602      	mov	r2, r0
  4058c4:	697b      	ldr	r3, [r7, #20]
  4058c6:	4313      	orrs	r3, r2
  4058c8:	617b      	str	r3, [r7, #20]

	result |= inv_icm20648_secondary_stop_channel(s, index);
  4058ca:	68b9      	ldr	r1, [r7, #8]
  4058cc:	68f8      	ldr	r0, [r7, #12]
  4058ce:	4b0a      	ldr	r3, [pc, #40]	; (4058f8 <inv_icm20648_execute_read_secondary+0x98>)
  4058d0:	4798      	blx	r3
  4058d2:	4602      	mov	r2, r0
  4058d4:	697b      	ldr	r3, [r7, #20]
  4058d6:	4313      	orrs	r3, r2
  4058d8:	617b      	str	r3, [r7, #20]

	return result;
  4058da:	697b      	ldr	r3, [r7, #20]
}
  4058dc:	4618      	mov	r0, r3
  4058de:	371c      	adds	r7, #28
  4058e0:	46bd      	mov	sp, r7
  4058e2:	bd90      	pop	{r4, r7, pc}
  4058e4:	004057bd 	.word	0x004057bd
  4058e8:	00405a6d 	.word	0x00405a6d
  4058ec:	004015d9 	.word	0x004015d9
  4058f0:	00405aa1 	.word	0x00405aa1
  4058f4:	0040caa1 	.word	0x0040caa1
  4058f8:	00405a3d 	.word	0x00405a3d

004058fc <inv_icm20648_write_secondary>:
* reg is the device register we wish to access
* len is the number of bytes to be read
* 
*/
int inv_icm20648_write_secondary(struct inv_icm20648 * s, int index, unsigned char addr, unsigned char reg, char v)
{
  4058fc:	b590      	push	{r4, r7, lr}
  4058fe:	b087      	sub	sp, #28
  405900:	af00      	add	r7, sp, #0
  405902:	60f8      	str	r0, [r7, #12]
  405904:	60b9      	str	r1, [r7, #8]
  405906:	4611      	mov	r1, r2
  405908:	461a      	mov	r2, r3
  40590a:	460b      	mov	r3, r1
  40590c:	71fb      	strb	r3, [r7, #7]
  40590e:	4613      	mov	r3, r2
  405910:	71bb      	strb	r3, [r7, #6]
	int result = 0;
  405912:	2300      	movs	r3, #0
  405914:	617b      	str	r3, [r7, #20]
    unsigned char data;
    
    data = (unsigned char)addr;
  405916:	79fb      	ldrb	r3, [r7, #7]
  405918:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20648_write_mems_reg(s, s->secondary_state.slv_reg[index].addr, 1, &data);
  40591a:	68fa      	ldr	r2, [r7, #12]
  40591c:	68bb      	ldr	r3, [r7, #8]
  40591e:	3305      	adds	r3, #5
  405920:	00db      	lsls	r3, r3, #3
  405922:	4413      	add	r3, r2
  405924:	8899      	ldrh	r1, [r3, #4]
  405926:	f107 0313 	add.w	r3, r7, #19
  40592a:	2201      	movs	r2, #1
  40592c:	68f8      	ldr	r0, [r7, #12]
  40592e:	4c21      	ldr	r4, [pc, #132]	; (4059b4 <inv_icm20648_write_secondary+0xb8>)
  405930:	47a0      	blx	r4
  405932:	4602      	mov	r2, r0
  405934:	697b      	ldr	r3, [r7, #20]
  405936:	4313      	orrs	r3, r2
  405938:	617b      	str	r3, [r7, #20]

    data = reg;
  40593a:	79bb      	ldrb	r3, [r7, #6]
  40593c:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20648_write_mems_reg(s, s->secondary_state.slv_reg[index].reg, 1, &data);
  40593e:	68fa      	ldr	r2, [r7, #12]
  405940:	68bb      	ldr	r3, [r7, #8]
  405942:	3305      	adds	r3, #5
  405944:	00db      	lsls	r3, r3, #3
  405946:	4413      	add	r3, r2
  405948:	88d9      	ldrh	r1, [r3, #6]
  40594a:	f107 0313 	add.w	r3, r7, #19
  40594e:	2201      	movs	r2, #1
  405950:	68f8      	ldr	r0, [r7, #12]
  405952:	4c18      	ldr	r4, [pc, #96]	; (4059b4 <inv_icm20648_write_secondary+0xb8>)
  405954:	47a0      	blx	r4
  405956:	4602      	mov	r2, r0
  405958:	697b      	ldr	r3, [r7, #20]
  40595a:	4313      	orrs	r3, r2
  40595c:	617b      	str	r3, [r7, #20]

    data = v;
  40595e:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
  405962:	74fb      	strb	r3, [r7, #19]
    result |= inv_icm20648_write_mems_reg(s, s->secondary_state.slv_reg[index].d0, 1, &data);
  405964:	68fa      	ldr	r2, [r7, #12]
  405966:	68bb      	ldr	r3, [r7, #8]
  405968:	3305      	adds	r3, #5
  40596a:	00db      	lsls	r3, r3, #3
  40596c:	4413      	add	r3, r2
  40596e:	8959      	ldrh	r1, [r3, #10]
  405970:	f107 0313 	add.w	r3, r7, #19
  405974:	2201      	movs	r2, #1
  405976:	68f8      	ldr	r0, [r7, #12]
  405978:	4c0e      	ldr	r4, [pc, #56]	; (4059b4 <inv_icm20648_write_secondary+0xb8>)
  40597a:	47a0      	blx	r4
  40597c:	4602      	mov	r2, r0
  40597e:	697b      	ldr	r3, [r7, #20]
  405980:	4313      	orrs	r3, r2
  405982:	617b      	str	r3, [r7, #20]
    
    data = INV_MPU_BIT_SLV_EN | 1;
  405984:	2381      	movs	r3, #129	; 0x81
  405986:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20648_write_mems_reg(s, s->secondary_state.slv_reg[index].ctrl, 1, &data);
  405988:	68fa      	ldr	r2, [r7, #12]
  40598a:	68bb      	ldr	r3, [r7, #8]
  40598c:	3305      	adds	r3, #5
  40598e:	00db      	lsls	r3, r3, #3
  405990:	4413      	add	r3, r2
  405992:	8919      	ldrh	r1, [r3, #8]
  405994:	f107 0313 	add.w	r3, r7, #19
  405998:	2201      	movs	r2, #1
  40599a:	68f8      	ldr	r0, [r7, #12]
  40599c:	4c05      	ldr	r4, [pc, #20]	; (4059b4 <inv_icm20648_write_secondary+0xb8>)
  40599e:	47a0      	blx	r4
  4059a0:	4602      	mov	r2, r0
  4059a2:	697b      	ldr	r3, [r7, #20]
  4059a4:	4313      	orrs	r3, r2
  4059a6:	617b      	str	r3, [r7, #20]
    
    return result;
  4059a8:	697b      	ldr	r3, [r7, #20]
}
  4059aa:	4618      	mov	r0, r3
  4059ac:	371c      	adds	r7, #28
  4059ae:	46bd      	mov	sp, r7
  4059b0:	bd90      	pop	{r4, r7, pc}
  4059b2:	bf00      	nop
  4059b4:	0040c8cd 	.word	0x0040c8cd

004059b8 <inv_icm20648_execute_write_secondary>:

int inv_icm20648_execute_write_secondary(struct inv_icm20648 * s, int index, unsigned char addr, int reg, uint8_t v)
{
  4059b8:	b590      	push	{r4, r7, lr}
  4059ba:	b089      	sub	sp, #36	; 0x24
  4059bc:	af02      	add	r7, sp, #8
  4059be:	60f8      	str	r0, [r7, #12]
  4059c0:	60b9      	str	r1, [r7, #8]
  4059c2:	603b      	str	r3, [r7, #0]
  4059c4:	4613      	mov	r3, r2
  4059c6:	71fb      	strb	r3, [r7, #7]
	int result = 0;
  4059c8:	2300      	movs	r3, #0
  4059ca:	617b      	str	r3, [r7, #20]

	result |= inv_icm20648_write_secondary(s, index, addr, reg, v);
  4059cc:	683b      	ldr	r3, [r7, #0]
  4059ce:	b2d9      	uxtb	r1, r3
  4059d0:	f997 3028 	ldrsb.w	r3, [r7, #40]	; 0x28
  4059d4:	79fa      	ldrb	r2, [r7, #7]
  4059d6:	9300      	str	r3, [sp, #0]
  4059d8:	460b      	mov	r3, r1
  4059da:	68b9      	ldr	r1, [r7, #8]
  4059dc:	68f8      	ldr	r0, [r7, #12]
  4059de:	4c12      	ldr	r4, [pc, #72]	; (405a28 <inv_icm20648_execute_write_secondary+0x70>)
  4059e0:	47a0      	blx	r4
  4059e2:	4602      	mov	r2, r0
  4059e4:	697b      	ldr	r3, [r7, #20]
  4059e6:	4313      	orrs	r3, r2
  4059e8:	617b      	str	r3, [r7, #20]
	
	result |= inv_icm20648_secondary_enable_i2c(s);
  4059ea:	68f8      	ldr	r0, [r7, #12]
  4059ec:	4b0f      	ldr	r3, [pc, #60]	; (405a2c <inv_icm20648_execute_write_secondary+0x74>)
  4059ee:	4798      	blx	r3
  4059f0:	4602      	mov	r2, r0
  4059f2:	697b      	ldr	r3, [r7, #20]
  4059f4:	4313      	orrs	r3, r2
  4059f6:	617b      	str	r3, [r7, #20]
    
	inv_icm20648_sleep_us(SECONDARY_INIT_WAIT*1000);
  4059f8:	f64e 2060 	movw	r0, #60000	; 0xea60
  4059fc:	4b0c      	ldr	r3, [pc, #48]	; (405a30 <inv_icm20648_execute_write_secondary+0x78>)
  4059fe:	4798      	blx	r3
    
	result |= inv_icm20648_secondary_disable_i2c(s);
  405a00:	68f8      	ldr	r0, [r7, #12]
  405a02:	4b0c      	ldr	r3, [pc, #48]	; (405a34 <inv_icm20648_execute_write_secondary+0x7c>)
  405a04:	4798      	blx	r3
  405a06:	4602      	mov	r2, r0
  405a08:	697b      	ldr	r3, [r7, #20]
  405a0a:	4313      	orrs	r3, r2
  405a0c:	617b      	str	r3, [r7, #20]

	result |= inv_icm20648_secondary_stop_channel(s, index);
  405a0e:	68b9      	ldr	r1, [r7, #8]
  405a10:	68f8      	ldr	r0, [r7, #12]
  405a12:	4b09      	ldr	r3, [pc, #36]	; (405a38 <inv_icm20648_execute_write_secondary+0x80>)
  405a14:	4798      	blx	r3
  405a16:	4602      	mov	r2, r0
  405a18:	697b      	ldr	r3, [r7, #20]
  405a1a:	4313      	orrs	r3, r2
  405a1c:	617b      	str	r3, [r7, #20]

	return result;
  405a1e:	697b      	ldr	r3, [r7, #20]
}
  405a20:	4618      	mov	r0, r3
  405a22:	371c      	adds	r7, #28
  405a24:	46bd      	mov	sp, r7
  405a26:	bd90      	pop	{r4, r7, pc}
  405a28:	004058fd 	.word	0x004058fd
  405a2c:	00405a6d 	.word	0x00405a6d
  405a30:	004015d9 	.word	0x004015d9
  405a34:	00405aa1 	.word	0x00405aa1
  405a38:	00405a3d 	.word	0x00405a3d

00405a3c <inv_icm20648_secondary_stop_channel>:
{
	inv_icm20648_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG,s->secondary_state.sSavedI2cOdr);
}

int inv_icm20648_secondary_stop_channel(struct inv_icm20648 * s, int index)
{
  405a3c:	b580      	push	{r7, lr}
  405a3e:	b082      	sub	sp, #8
  405a40:	af00      	add	r7, sp, #0
  405a42:	6078      	str	r0, [r7, #4]
  405a44:	6039      	str	r1, [r7, #0]
	return inv_icm20648_write_single_mems_reg(s, s->secondary_state.slv_reg[index].ctrl, 0);
  405a46:	687a      	ldr	r2, [r7, #4]
  405a48:	683b      	ldr	r3, [r7, #0]
  405a4a:	3305      	adds	r3, #5
  405a4c:	00db      	lsls	r3, r3, #3
  405a4e:	4413      	add	r3, r2
  405a50:	891b      	ldrh	r3, [r3, #8]
  405a52:	2200      	movs	r2, #0
  405a54:	4619      	mov	r1, r3
  405a56:	6878      	ldr	r0, [r7, #4]
  405a58:	4b03      	ldr	r3, [pc, #12]	; (405a68 <inv_icm20648_secondary_stop_channel+0x2c>)
  405a5a:	4798      	blx	r3
  405a5c:	4603      	mov	r3, r0
}
  405a5e:	4618      	mov	r0, r3
  405a60:	3708      	adds	r7, #8
  405a62:	46bd      	mov	sp, r7
  405a64:	bd80      	pop	{r7, pc}
  405a66:	bf00      	nop
  405a68:	0040c9d5 	.word	0x0040c9d5

00405a6c <inv_icm20648_secondary_enable_i2c>:

int inv_icm20648_secondary_enable_i2c(struct inv_icm20648 * s)
{
  405a6c:	b580      	push	{r7, lr}
  405a6e:	b082      	sub	sp, #8
  405a70:	af00      	add	r7, sp, #0
  405a72:	6078      	str	r0, [r7, #4]
	s->base_state.user_ctrl |= BIT_I2C_MST_EN;
  405a74:	687b      	ldr	r3, [r7, #4]
  405a76:	7f1b      	ldrb	r3, [r3, #28]
  405a78:	f043 0320 	orr.w	r3, r3, #32
  405a7c:	b2da      	uxtb	r2, r3
  405a7e:	687b      	ldr	r3, [r7, #4]
  405a80:	771a      	strb	r2, [r3, #28]
	return inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl); 
  405a82:	687b      	ldr	r3, [r7, #4]
  405a84:	7f1b      	ldrb	r3, [r3, #28]
  405a86:	461a      	mov	r2, r3
  405a88:	2103      	movs	r1, #3
  405a8a:	6878      	ldr	r0, [r7, #4]
  405a8c:	4b03      	ldr	r3, [pc, #12]	; (405a9c <inv_icm20648_secondary_enable_i2c+0x30>)
  405a8e:	4798      	blx	r3
  405a90:	4603      	mov	r3, r0
}
  405a92:	4618      	mov	r0, r3
  405a94:	3708      	adds	r7, #8
  405a96:	46bd      	mov	sp, r7
  405a98:	bd80      	pop	{r7, pc}
  405a9a:	bf00      	nop
  405a9c:	0040c9d5 	.word	0x0040c9d5

00405aa0 <inv_icm20648_secondary_disable_i2c>:

int inv_icm20648_secondary_disable_i2c(struct inv_icm20648 * s)
{
  405aa0:	b580      	push	{r7, lr}
  405aa2:	b082      	sub	sp, #8
  405aa4:	af00      	add	r7, sp, #0
  405aa6:	6078      	str	r0, [r7, #4]
	s->base_state.user_ctrl &= ~BIT_I2C_MST_EN;
  405aa8:	687b      	ldr	r3, [r7, #4]
  405aaa:	7f1b      	ldrb	r3, [r3, #28]
  405aac:	f023 0320 	bic.w	r3, r3, #32
  405ab0:	b2da      	uxtb	r2, r3
  405ab2:	687b      	ldr	r3, [r7, #4]
  405ab4:	771a      	strb	r2, [r3, #28]
	return inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl); 
  405ab6:	687b      	ldr	r3, [r7, #4]
  405ab8:	7f1b      	ldrb	r3, [r3, #28]
  405aba:	461a      	mov	r2, r3
  405abc:	2103      	movs	r1, #3
  405abe:	6878      	ldr	r0, [r7, #4]
  405ac0:	4b03      	ldr	r3, [pc, #12]	; (405ad0 <inv_icm20648_secondary_disable_i2c+0x30>)
  405ac2:	4798      	blx	r3
  405ac4:	4603      	mov	r3, r0
}
  405ac6:	4618      	mov	r0, r3
  405ac8:	3708      	adds	r7, #8
  405aca:	46bd      	mov	sp, r7
  405acc:	bd80      	pop	{r7, pc}
  405ace:	bf00      	nop
  405ad0:	0040c9d5 	.word	0x0040c9d5

00405ad4 <inv_icm20648_secondary_set_odr>:


int inv_icm20648_secondary_set_odr(struct inv_icm20648 * s, int divider, unsigned int* effectiveDivider)
{
  405ad4:	b580      	push	{r7, lr}
  405ad6:	b086      	sub	sp, #24
  405ad8:	af00      	add	r7, sp, #0
  405ada:	60f8      	str	r0, [r7, #12]
  405adc:	60b9      	str	r1, [r7, #8]
  405ade:	607a      	str	r2, [r7, #4]
	int mst_odr_config = 0;
  405ae0:	2300      	movs	r3, #0
  405ae2:	617b      	str	r3, [r7, #20]

    // find 2^x = divider to fit BASE_SAMPLE_RATE/2^REG_I2C_MST_ODR_CONFIG
    do
    {
		divider>>=1;
  405ae4:	68bb      	ldr	r3, [r7, #8]
  405ae6:	105b      	asrs	r3, r3, #1
  405ae8:	60bb      	str	r3, [r7, #8]
		mst_odr_config++;
  405aea:	697b      	ldr	r3, [r7, #20]
  405aec:	3301      	adds	r3, #1
  405aee:	617b      	str	r3, [r7, #20]
    } while(divider>>1);
  405af0:	68bb      	ldr	r3, [r7, #8]
  405af2:	105b      	asrs	r3, r3, #1
  405af4:	2b00      	cmp	r3, #0
  405af6:	d1f5      	bne.n	405ae4 <inv_icm20648_secondary_set_odr+0x10>
    
	if (mst_odr_config < MIN_MST_ODR_CONFIG)
  405af8:	697b      	ldr	r3, [r7, #20]
  405afa:	2b03      	cmp	r3, #3
  405afc:	dc01      	bgt.n	405b02 <inv_icm20648_secondary_set_odr+0x2e>
		mst_odr_config = MIN_MST_ODR_CONFIG;
  405afe:	2304      	movs	r3, #4
  405b00:	617b      	str	r3, [r7, #20]

	*effectiveDivider = 1<<mst_odr_config;
  405b02:	2201      	movs	r2, #1
  405b04:	697b      	ldr	r3, [r7, #20]
  405b06:	fa02 f303 	lsl.w	r3, r2, r3
  405b0a:	461a      	mov	r2, r3
  405b0c:	687b      	ldr	r3, [r7, #4]
  405b0e:	601a      	str	r2, [r3, #0]

	return	inv_icm20648_set_secondary_divider(s, (unsigned char)mst_odr_config);
  405b10:	697b      	ldr	r3, [r7, #20]
  405b12:	b2db      	uxtb	r3, r3
  405b14:	4619      	mov	r1, r3
  405b16:	68f8      	ldr	r0, [r7, #12]
  405b18:	4b03      	ldr	r3, [pc, #12]	; (405b28 <inv_icm20648_secondary_set_odr+0x54>)
  405b1a:	4798      	blx	r3
  405b1c:	4603      	mov	r3, r0
}
  405b1e:	4618      	mov	r0, r3
  405b20:	3718      	adds	r7, #24
  405b22:	46bd      	mov	sp, r7
  405b24:	bd80      	pop	{r7, pc}
  405b26:	bf00      	nop
  405b28:	004062bd 	.word	0x004062bd

00405b2c <inv_icm20648_prevent_lpen_control>:
#include "Icm20648Dmp3Driver.h"

static unsigned char inv_is_gyro_enabled(struct inv_icm20648 * s);

void inv_icm20648_prevent_lpen_control(struct inv_icm20648 * s)
{
  405b2c:	b480      	push	{r7}
  405b2e:	b083      	sub	sp, #12
  405b30:	af00      	add	r7, sp, #0
  405b32:	6078      	str	r0, [r7, #4]
	s->sAllowLpEn = 0;
  405b34:	687b      	ldr	r3, [r7, #4]
  405b36:	2200      	movs	r2, #0
  405b38:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
}
  405b3c:	bf00      	nop
  405b3e:	370c      	adds	r7, #12
  405b40:	46bd      	mov	sp, r7
  405b42:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b46:	4770      	bx	lr

00405b48 <inv_icm20648_allow_lpen_control>:
void inv_icm20648_allow_lpen_control(struct inv_icm20648 * s)
{
  405b48:	b580      	push	{r7, lr}
  405b4a:	b082      	sub	sp, #8
  405b4c:	af00      	add	r7, sp, #0
  405b4e:	6078      	str	r0, [r7, #4]
	s->sAllowLpEn = 1;
  405b50:	687b      	ldr	r3, [r7, #4]
  405b52:	2201      	movs	r2, #1
  405b54:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  405b58:	2201      	movs	r2, #1
  405b5a:	2102      	movs	r1, #2
  405b5c:	6878      	ldr	r0, [r7, #4]
  405b5e:	4b03      	ldr	r3, [pc, #12]	; (405b6c <inv_icm20648_allow_lpen_control+0x24>)
  405b60:	4798      	blx	r3
}
  405b62:	bf00      	nop
  405b64:	3708      	adds	r7, #8
  405b66:	46bd      	mov	sp, r7
  405b68:	bd80      	pop	{r7, pc}
  405b6a:	bf00      	nop
  405b6c:	00405b8d 	.word	0x00405b8d

00405b70 <inv_icm20648_get_lpen_control>:
static uint8_t inv_icm20648_get_lpen_control(struct inv_icm20648 * s)
{
  405b70:	b480      	push	{r7}
  405b72:	b083      	sub	sp, #12
  405b74:	af00      	add	r7, sp, #0
  405b76:	6078      	str	r0, [r7, #4]
	return s->sAllowLpEn;
  405b78:	687b      	ldr	r3, [r7, #4]
  405b7a:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
}
  405b7e:	4618      	mov	r0, r3
  405b80:	370c      	adds	r7, #12
  405b82:	46bd      	mov	sp, r7
  405b84:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b88:	4770      	bx	lr
	...

00405b8c <inv_icm20648_set_chip_power_state>:
 *   @param[in] On/Off - The functions are enabled if previously disabled and
                disabled if previously enabled based on the value of On/Off.
 ******************************************************************************
 */
int inv_icm20648_set_chip_power_state(struct inv_icm20648 * s, unsigned char func, unsigned char on_off)
{
  405b8c:	b580      	push	{r7, lr}
  405b8e:	b084      	sub	sp, #16
  405b90:	af00      	add	r7, sp, #0
  405b92:	6078      	str	r0, [r7, #4]
  405b94:	460b      	mov	r3, r1
  405b96:	70fb      	strb	r3, [r7, #3]
  405b98:	4613      	mov	r3, r2
  405b9a:	70bb      	strb	r3, [r7, #2]
	int status = 0;
  405b9c:	2300      	movs	r3, #0
  405b9e:	60fb      	str	r3, [r7, #12]

	switch(func) {
  405ba0:	78fb      	ldrb	r3, [r7, #3]
  405ba2:	2b01      	cmp	r3, #1
  405ba4:	d002      	beq.n	405bac <inv_icm20648_set_chip_power_state+0x20>
  405ba6:	2b02      	cmp	r3, #2
  405ba8:	d044      	beq.n	405c34 <inv_icm20648_set_chip_power_state+0xa8>
				}
			}
		break;

		default:
		break;
  405baa:	e094      	b.n	405cd6 <inv_icm20648_set_chip_power_state+0x14a>
			if(on_off){
  405bac:	78bb      	ldrb	r3, [r7, #2]
  405bae:	2b00      	cmp	r3, #0
  405bb0:	d020      	beq.n	405bf4 <inv_icm20648_set_chip_power_state+0x68>
				if((s->base_state.wake_state & CHIP_AWAKE) == 0) {// undo sleep_en
  405bb2:	687b      	ldr	r3, [r7, #4]
  405bb4:	7e1b      	ldrb	r3, [r3, #24]
  405bb6:	f003 0301 	and.w	r3, r3, #1
  405bba:	2b00      	cmp	r3, #0
  405bbc:	f040 8088 	bne.w	405cd0 <inv_icm20648_set_chip_power_state+0x144>
					s->base_state.pwr_mgmt_1 &= ~BIT_SLEEP;
  405bc0:	687b      	ldr	r3, [r7, #4]
  405bc2:	7e9b      	ldrb	r3, [r3, #26]
  405bc4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  405bc8:	b2da      	uxtb	r2, r3
  405bca:	687b      	ldr	r3, [r7, #4]
  405bcc:	769a      	strb	r2, [r3, #26]
					status = inv_icm20648_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  405bce:	687b      	ldr	r3, [r7, #4]
  405bd0:	7e9b      	ldrb	r3, [r3, #26]
  405bd2:	461a      	mov	r2, r3
  405bd4:	2106      	movs	r1, #6
  405bd6:	6878      	ldr	r0, [r7, #4]
  405bd8:	4b41      	ldr	r3, [pc, #260]	; (405ce0 <inv_icm20648_set_chip_power_state+0x154>)
  405bda:	4798      	blx	r3
  405bdc:	60f8      	str	r0, [r7, #12]
					s->base_state.wake_state |= CHIP_AWAKE;
  405bde:	687b      	ldr	r3, [r7, #4]
  405be0:	7e1b      	ldrb	r3, [r3, #24]
  405be2:	f043 0301 	orr.w	r3, r3, #1
  405be6:	b2da      	uxtb	r2, r3
  405be8:	687b      	ldr	r3, [r7, #4]
  405bea:	761a      	strb	r2, [r3, #24]
					inv_icm20648_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
  405bec:	2001      	movs	r0, #1
  405bee:	4b3d      	ldr	r3, [pc, #244]	; (405ce4 <inv_icm20648_set_chip_power_state+0x158>)
  405bf0:	4798      	blx	r3
		break;
  405bf2:	e06d      	b.n	405cd0 <inv_icm20648_set_chip_power_state+0x144>
				if(s->base_state.wake_state & CHIP_AWAKE) {// set sleep_en
  405bf4:	687b      	ldr	r3, [r7, #4]
  405bf6:	7e1b      	ldrb	r3, [r3, #24]
  405bf8:	f003 0301 	and.w	r3, r3, #1
  405bfc:	2b00      	cmp	r3, #0
  405bfe:	d067      	beq.n	405cd0 <inv_icm20648_set_chip_power_state+0x144>
					s->base_state.pwr_mgmt_1 |= BIT_SLEEP;
  405c00:	687b      	ldr	r3, [r7, #4]
  405c02:	7e9b      	ldrb	r3, [r3, #26]
  405c04:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  405c08:	b2da      	uxtb	r2, r3
  405c0a:	687b      	ldr	r3, [r7, #4]
  405c0c:	769a      	strb	r2, [r3, #26]
					status = inv_icm20648_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  405c0e:	687b      	ldr	r3, [r7, #4]
  405c10:	7e9b      	ldrb	r3, [r3, #26]
  405c12:	461a      	mov	r2, r3
  405c14:	2106      	movs	r1, #6
  405c16:	6878      	ldr	r0, [r7, #4]
  405c18:	4b31      	ldr	r3, [pc, #196]	; (405ce0 <inv_icm20648_set_chip_power_state+0x154>)
  405c1a:	4798      	blx	r3
  405c1c:	60f8      	str	r0, [r7, #12]
					s->base_state.wake_state &= ~CHIP_AWAKE;
  405c1e:	687b      	ldr	r3, [r7, #4]
  405c20:	7e1b      	ldrb	r3, [r3, #24]
  405c22:	f023 0301 	bic.w	r3, r3, #1
  405c26:	b2da      	uxtb	r2, r3
  405c28:	687b      	ldr	r3, [r7, #4]
  405c2a:	761a      	strb	r2, [r3, #24]
					inv_icm20648_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
  405c2c:	2001      	movs	r0, #1
  405c2e:	4b2d      	ldr	r3, [pc, #180]	; (405ce4 <inv_icm20648_set_chip_power_state+0x158>)
  405c30:	4798      	blx	r3
		break;
  405c32:	e04d      	b.n	405cd0 <inv_icm20648_set_chip_power_state+0x144>
			if(s->base_state.lp_en_support == 1) {
  405c34:	687b      	ldr	r3, [r7, #4]
  405c36:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  405c3a:	f003 0301 	and.w	r3, r3, #1
  405c3e:	b2db      	uxtb	r3, r3
  405c40:	2b00      	cmp	r3, #0
  405c42:	d047      	beq.n	405cd4 <inv_icm20648_set_chip_power_state+0x148>
				if(on_off) {
  405c44:	78bb      	ldrb	r3, [r7, #2]
  405c46:	2b00      	cmp	r3, #0
  405c48:	d022      	beq.n	405c90 <inv_icm20648_set_chip_power_state+0x104>
					if( (inv_icm20648_get_lpen_control(s)) && ((s->base_state.wake_state & CHIP_LP_ENABLE) == 0)){
  405c4a:	6878      	ldr	r0, [r7, #4]
  405c4c:	4b26      	ldr	r3, [pc, #152]	; (405ce8 <inv_icm20648_set_chip_power_state+0x15c>)
  405c4e:	4798      	blx	r3
  405c50:	4603      	mov	r3, r0
  405c52:	2b00      	cmp	r3, #0
  405c54:	d03e      	beq.n	405cd4 <inv_icm20648_set_chip_power_state+0x148>
  405c56:	687b      	ldr	r3, [r7, #4]
  405c58:	7e1b      	ldrb	r3, [r3, #24]
  405c5a:	f003 0302 	and.w	r3, r3, #2
  405c5e:	2b00      	cmp	r3, #0
  405c60:	d138      	bne.n	405cd4 <inv_icm20648_set_chip_power_state+0x148>
						s->base_state.pwr_mgmt_1 |= BIT_LP_EN; // lp_en ON
  405c62:	687b      	ldr	r3, [r7, #4]
  405c64:	7e9b      	ldrb	r3, [r3, #26]
  405c66:	f043 0320 	orr.w	r3, r3, #32
  405c6a:	b2da      	uxtb	r2, r3
  405c6c:	687b      	ldr	r3, [r7, #4]
  405c6e:	769a      	strb	r2, [r3, #26]
						status = inv_icm20648_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  405c70:	687b      	ldr	r3, [r7, #4]
  405c72:	7e9b      	ldrb	r3, [r3, #26]
  405c74:	461a      	mov	r2, r3
  405c76:	2106      	movs	r1, #6
  405c78:	6878      	ldr	r0, [r7, #4]
  405c7a:	4b19      	ldr	r3, [pc, #100]	; (405ce0 <inv_icm20648_set_chip_power_state+0x154>)
  405c7c:	4798      	blx	r3
  405c7e:	60f8      	str	r0, [r7, #12]
						s->base_state.wake_state |= CHIP_LP_ENABLE;
  405c80:	687b      	ldr	r3, [r7, #4]
  405c82:	7e1b      	ldrb	r3, [r3, #24]
  405c84:	f043 0302 	orr.w	r3, r3, #2
  405c88:	b2da      	uxtb	r2, r3
  405c8a:	687b      	ldr	r3, [r7, #4]
  405c8c:	761a      	strb	r2, [r3, #24]
		break;
  405c8e:	e021      	b.n	405cd4 <inv_icm20648_set_chip_power_state+0x148>
					if(s->base_state.wake_state & CHIP_LP_ENABLE){
  405c90:	687b      	ldr	r3, [r7, #4]
  405c92:	7e1b      	ldrb	r3, [r3, #24]
  405c94:	f003 0302 	and.w	r3, r3, #2
  405c98:	2b00      	cmp	r3, #0
  405c9a:	d01b      	beq.n	405cd4 <inv_icm20648_set_chip_power_state+0x148>
						s->base_state.pwr_mgmt_1 &= ~BIT_LP_EN; // lp_en off
  405c9c:	687b      	ldr	r3, [r7, #4]
  405c9e:	7e9b      	ldrb	r3, [r3, #26]
  405ca0:	f023 0320 	bic.w	r3, r3, #32
  405ca4:	b2da      	uxtb	r2, r3
  405ca6:	687b      	ldr	r3, [r7, #4]
  405ca8:	769a      	strb	r2, [r3, #26]
						status = inv_icm20648_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  405caa:	687b      	ldr	r3, [r7, #4]
  405cac:	7e9b      	ldrb	r3, [r3, #26]
  405cae:	461a      	mov	r2, r3
  405cb0:	2106      	movs	r1, #6
  405cb2:	6878      	ldr	r0, [r7, #4]
  405cb4:	4b0a      	ldr	r3, [pc, #40]	; (405ce0 <inv_icm20648_set_chip_power_state+0x154>)
  405cb6:	4798      	blx	r3
  405cb8:	60f8      	str	r0, [r7, #12]
						s->base_state.wake_state &= ~CHIP_LP_ENABLE;
  405cba:	687b      	ldr	r3, [r7, #4]
  405cbc:	7e1b      	ldrb	r3, [r3, #24]
  405cbe:	f023 0302 	bic.w	r3, r3, #2
  405cc2:	b2da      	uxtb	r2, r3
  405cc4:	687b      	ldr	r3, [r7, #4]
  405cc6:	761a      	strb	r2, [r3, #24]
						inv_icm20648_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
  405cc8:	2001      	movs	r0, #1
  405cca:	4b06      	ldr	r3, [pc, #24]	; (405ce4 <inv_icm20648_set_chip_power_state+0x158>)
  405ccc:	4798      	blx	r3
		break;
  405cce:	e001      	b.n	405cd4 <inv_icm20648_set_chip_power_state+0x148>
		break;
  405cd0:	bf00      	nop
  405cd2:	e000      	b.n	405cd6 <inv_icm20648_set_chip_power_state+0x14a>
		break;
  405cd4:	bf00      	nop

	}// end switch

	return status;
  405cd6:	68fb      	ldr	r3, [r7, #12]
}
  405cd8:	4618      	mov	r0, r3
  405cda:	3710      	adds	r7, #16
  405cdc:	46bd      	mov	sp, r7
  405cde:	bd80      	pop	{r7, pc}
  405ce0:	0040cf41 	.word	0x0040cf41
  405ce4:	0040c799 	.word	0x0040c799
  405ce8:	00405b71 	.word	0x00405b71

00405cec <inv_icm20648_get_chip_power_state>:
 ******************************************************************************
 *   @return    Current wake status of the Ivory chip.
 ******************************************************************************
 */
uint8_t inv_icm20648_get_chip_power_state(struct inv_icm20648 * s)
{
  405cec:	b480      	push	{r7}
  405cee:	b083      	sub	sp, #12
  405cf0:	af00      	add	r7, sp, #0
  405cf2:	6078      	str	r0, [r7, #4]
	return s->base_state.wake_state;
  405cf4:	687b      	ldr	r3, [r7, #4]
  405cf6:	7e1b      	ldrb	r3, [r3, #24]
}
  405cf8:	4618      	mov	r0, r3
  405cfa:	370c      	adds	r7, #12
  405cfc:	46bd      	mov	sp, r7
  405cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
  405d02:	4770      	bx	lr

00405d04 <inv_icm20648_wakeup_mems>:

/** Wakes up DMP3 (SMARTSENSOR).
*/
int inv_icm20648_wakeup_mems(struct inv_icm20648 * s)
{
  405d04:	b590      	push	{r4, r7, lr}
  405d06:	b085      	sub	sp, #20
  405d08:	af00      	add	r7, sp, #0
  405d0a:	6078      	str	r0, [r7, #4]
	unsigned char data;
	int result = 0;
  405d0c:	2300      	movs	r3, #0
  405d0e:	60fb      	str	r3, [r7, #12]

	result = inv_icm20648_set_chip_power_state(s, CHIP_AWAKE, 1);
  405d10:	2201      	movs	r2, #1
  405d12:	2101      	movs	r1, #1
  405d14:	6878      	ldr	r0, [r7, #4]
  405d16:	4b25      	ldr	r3, [pc, #148]	; (405dac <inv_icm20648_wakeup_mems+0xa8>)
  405d18:	4798      	blx	r3
  405d1a:	60f8      	str	r0, [r7, #12]

	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  405d1c:	687b      	ldr	r3, [r7, #4]
  405d1e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  405d22:	2b02      	cmp	r3, #2
  405d24:	d10d      	bne.n	405d42 <inv_icm20648_wakeup_mems+0x3e>
		s->base_state.user_ctrl |= BIT_I2C_IF_DIS;
  405d26:	687b      	ldr	r3, [r7, #4]
  405d28:	7f1b      	ldrb	r3, [r3, #28]
  405d2a:	f043 0310 	orr.w	r3, r3, #16
  405d2e:	b2da      	uxtb	r2, r3
  405d30:	687b      	ldr	r3, [r7, #4]
  405d32:	771a      	strb	r2, [r3, #28]
		inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  405d34:	687b      	ldr	r3, [r7, #4]
  405d36:	7f1b      	ldrb	r3, [r3, #28]
  405d38:	461a      	mov	r2, r3
  405d3a:	2103      	movs	r1, #3
  405d3c:	6878      	ldr	r0, [r7, #4]
  405d3e:	4b1c      	ldr	r3, [pc, #112]	; (405db0 <inv_icm20648_wakeup_mems+0xac>)
  405d40:	4798      	blx	r3
	}

	data = 0x47;	// FIXME, should set up according to sensor/engines enabled.
  405d42:	2347      	movs	r3, #71	; 0x47
  405d44:	72fb      	strb	r3, [r7, #11]
	result |= inv_icm20648_write_mems_reg(s, REG_PWR_MGMT_2, 1, &data);
  405d46:	f107 030b 	add.w	r3, r7, #11
  405d4a:	2201      	movs	r2, #1
  405d4c:	2107      	movs	r1, #7
  405d4e:	6878      	ldr	r0, [r7, #4]
  405d50:	4c18      	ldr	r4, [pc, #96]	; (405db4 <inv_icm20648_wakeup_mems+0xb0>)
  405d52:	47a0      	blx	r4
  405d54:	4602      	mov	r2, r0
  405d56:	68fb      	ldr	r3, [r7, #12]
  405d58:	4313      	orrs	r3, r2
  405d5a:	60fb      	str	r3, [r7, #12]

	if(s->base_state.firmware_loaded == 1) {
  405d5c:	687b      	ldr	r3, [r7, #4]
  405d5e:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  405d62:	f003 0302 	and.w	r3, r3, #2
  405d66:	b2db      	uxtb	r3, r3
  405d68:	2b00      	cmp	r3, #0
  405d6a:	d011      	beq.n	405d90 <inv_icm20648_wakeup_mems+0x8c>
		s->base_state.user_ctrl |= BIT_DMP_EN | BIT_FIFO_EN;
  405d6c:	687b      	ldr	r3, [r7, #4]
  405d6e:	7f1b      	ldrb	r3, [r3, #28]
  405d70:	f063 033f 	orn	r3, r3, #63	; 0x3f
  405d74:	b2da      	uxtb	r2, r3
  405d76:	687b      	ldr	r3, [r7, #4]
  405d78:	771a      	strb	r2, [r3, #28]
		result |= inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  405d7a:	687b      	ldr	r3, [r7, #4]
  405d7c:	7f1b      	ldrb	r3, [r3, #28]
  405d7e:	461a      	mov	r2, r3
  405d80:	2103      	movs	r1, #3
  405d82:	6878      	ldr	r0, [r7, #4]
  405d84:	4b0a      	ldr	r3, [pc, #40]	; (405db0 <inv_icm20648_wakeup_mems+0xac>)
  405d86:	4798      	blx	r3
  405d88:	4602      	mov	r2, r0
  405d8a:	68fb      	ldr	r3, [r7, #12]
  405d8c:	4313      	orrs	r3, r2
  405d8e:	60fb      	str	r3, [r7, #12]
	}

	result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  405d90:	2201      	movs	r2, #1
  405d92:	2102      	movs	r1, #2
  405d94:	6878      	ldr	r0, [r7, #4]
  405d96:	4b05      	ldr	r3, [pc, #20]	; (405dac <inv_icm20648_wakeup_mems+0xa8>)
  405d98:	4798      	blx	r3
  405d9a:	4602      	mov	r2, r0
  405d9c:	68fb      	ldr	r3, [r7, #12]
  405d9e:	4313      	orrs	r3, r2
  405da0:	60fb      	str	r3, [r7, #12]
	return result;
  405da2:	68fb      	ldr	r3, [r7, #12]
}
  405da4:	4618      	mov	r0, r3
  405da6:	3714      	adds	r7, #20
  405da8:	46bd      	mov	sp, r7
  405daa:	bd90      	pop	{r4, r7, pc}
  405dac:	00405b8d 	.word	0x00405b8d
  405db0:	0040c9d5 	.word	0x0040c9d5
  405db4:	0040c8cd 	.word	0x0040c8cd

00405db8 <inv_icm20648_sleep_mems>:

/** Puts DMP3 (SMARTSENSOR) into the lowest power state. Assumes sensors are all off.
*/
int inv_icm20648_sleep_mems(struct inv_icm20648 * s)
{
  405db8:	b590      	push	{r4, r7, lr}
  405dba:	b085      	sub	sp, #20
  405dbc:	af00      	add	r7, sp, #0
  405dbe:	6078      	str	r0, [r7, #4]
	int result;
	unsigned char data;

	data = 0x7F;
  405dc0:	237f      	movs	r3, #127	; 0x7f
  405dc2:	72fb      	strb	r3, [r7, #11]
	result = inv_icm20648_write_mems_reg(s, REG_PWR_MGMT_2, 1, &data);
  405dc4:	f107 030b 	add.w	r3, r7, #11
  405dc8:	2201      	movs	r2, #1
  405dca:	2107      	movs	r1, #7
  405dcc:	6878      	ldr	r0, [r7, #4]
  405dce:	4c08      	ldr	r4, [pc, #32]	; (405df0 <inv_icm20648_sleep_mems+0x38>)
  405dd0:	47a0      	blx	r4
  405dd2:	60f8      	str	r0, [r7, #12]

	result |= inv_icm20648_set_chip_power_state(s, CHIP_AWAKE, 0);
  405dd4:	2200      	movs	r2, #0
  405dd6:	2101      	movs	r1, #1
  405dd8:	6878      	ldr	r0, [r7, #4]
  405dda:	4b06      	ldr	r3, [pc, #24]	; (405df4 <inv_icm20648_sleep_mems+0x3c>)
  405ddc:	4798      	blx	r3
  405dde:	4602      	mov	r2, r0
  405de0:	68fb      	ldr	r3, [r7, #12]
  405de2:	4313      	orrs	r3, r2
  405de4:	60fb      	str	r3, [r7, #12]

	return result;
  405de6:	68fb      	ldr	r3, [r7, #12]
}
  405de8:	4618      	mov	r0, r3
  405dea:	3714      	adds	r7, #20
  405dec:	46bd      	mov	sp, r7
  405dee:	bd90      	pop	{r4, r7, pc}
  405df0:	0040c8cd 	.word	0x0040c8cd
  405df4:	00405b8d 	.word	0x00405b8d

00405df8 <inv_icm20648_set_dmp_address>:

int inv_icm20648_set_dmp_address(struct inv_icm20648 * s)
{
  405df8:	b590      	push	{r4, r7, lr}
  405dfa:	b087      	sub	sp, #28
  405dfc:	af00      	add	r7, sp, #0
  405dfe:	6078      	str	r0, [r7, #4]
	int result;
	unsigned char dmp_cfg[2] = {0};
  405e00:	2300      	movs	r3, #0
  405e02:	823b      	strh	r3, [r7, #16]
	unsigned short config;

	// Write DMP Start address
	inv_icm20648_get_dmp_start_address(s, &config);
  405e04:	f107 030e 	add.w	r3, r7, #14
  405e08:	4619      	mov	r1, r3
  405e0a:	6878      	ldr	r0, [r7, #4]
  405e0c:	4b0b      	ldr	r3, [pc, #44]	; (405e3c <inv_icm20648_set_dmp_address+0x44>)
  405e0e:	4798      	blx	r3
	/* setup DMP start address and firmware */
	dmp_cfg[0] = (unsigned char)((config >> 8) & 0xff);
  405e10:	89fb      	ldrh	r3, [r7, #14]
  405e12:	0a1b      	lsrs	r3, r3, #8
  405e14:	b29b      	uxth	r3, r3
  405e16:	b2db      	uxtb	r3, r3
  405e18:	743b      	strb	r3, [r7, #16]
	dmp_cfg[1] = (unsigned char)(config & 0xff);
  405e1a:	89fb      	ldrh	r3, [r7, #14]
  405e1c:	b2db      	uxtb	r3, r3
  405e1e:	747b      	strb	r3, [r7, #17]

	result = inv_icm20648_write_mems_reg(s, REG_PRGM_START_ADDRH, 2, dmp_cfg);
  405e20:	f107 0310 	add.w	r3, r7, #16
  405e24:	2202      	movs	r2, #2
  405e26:	f44f 71a8 	mov.w	r1, #336	; 0x150
  405e2a:	6878      	ldr	r0, [r7, #4]
  405e2c:	4c04      	ldr	r4, [pc, #16]	; (405e40 <inv_icm20648_set_dmp_address+0x48>)
  405e2e:	47a0      	blx	r4
  405e30:	6178      	str	r0, [r7, #20]
	return result;
  405e32:	697b      	ldr	r3, [r7, #20]
}
  405e34:	4618      	mov	r0, r3
  405e36:	371c      	adds	r7, #28
  405e38:	46bd      	mov	sp, r7
  405e3a:	bd90      	pop	{r4, r7, pc}
  405e3c:	00408001 	.word	0x00408001
  405e40:	0040c8cd 	.word	0x0040c8cd

00405e44 <inv_icm20648_set_secondary>:
*  @param[in]  MPU state varible
*  @return     0 if successful.
*/

int inv_icm20648_set_secondary(struct inv_icm20648 * s)
{
  405e44:	b580      	push	{r7, lr}
  405e46:	b084      	sub	sp, #16
  405e48:	af00      	add	r7, sp, #0
  405e4a:	6078      	str	r0, [r7, #4]
	int r = 0;
  405e4c:	2300      	movs	r3, #0
  405e4e:	60fb      	str	r3, [r7, #12]
	static uint8_t lIsInited = 0;

	if(lIsInited == 0) {
  405e50:	4b0e      	ldr	r3, [pc, #56]	; (405e8c <inv_icm20648_set_secondary+0x48>)
  405e52:	781b      	ldrb	r3, [r3, #0]
  405e54:	2b00      	cmp	r3, #0
  405e56:	d113      	bne.n	405e80 <inv_icm20648_set_secondary+0x3c>
		r  = inv_icm20648_write_single_mems_reg(s, REG_I2C_MST_CTRL, BIT_I2C_MST_P_NSR);
  405e58:	2210      	movs	r2, #16
  405e5a:	f240 1181 	movw	r1, #385	; 0x181
  405e5e:	6878      	ldr	r0, [r7, #4]
  405e60:	4b0b      	ldr	r3, [pc, #44]	; (405e90 <inv_icm20648_set_secondary+0x4c>)
  405e62:	4798      	blx	r3
  405e64:	60f8      	str	r0, [r7, #12]
		r |= inv_icm20648_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, MIN_MST_ODR_CONFIG);
  405e66:	2204      	movs	r2, #4
  405e68:	f44f 71c0 	mov.w	r1, #384	; 0x180
  405e6c:	6878      	ldr	r0, [r7, #4]
  405e6e:	4b08      	ldr	r3, [pc, #32]	; (405e90 <inv_icm20648_set_secondary+0x4c>)
  405e70:	4798      	blx	r3
  405e72:	4602      	mov	r2, r0
  405e74:	68fb      	ldr	r3, [r7, #12]
  405e76:	4313      	orrs	r3, r2
  405e78:	60fb      	str	r3, [r7, #12]

		lIsInited = 1;
  405e7a:	4b04      	ldr	r3, [pc, #16]	; (405e8c <inv_icm20648_set_secondary+0x48>)
  405e7c:	2201      	movs	r2, #1
  405e7e:	701a      	strb	r2, [r3, #0]
	}
	return r;
  405e80:	68fb      	ldr	r3, [r7, #12]
}
  405e82:	4618      	mov	r0, r3
  405e84:	3710      	adds	r7, #16
  405e86:	46bd      	mov	sp, r7
  405e88:	bd80      	pop	{r7, pc}
  405e8a:	bf00      	nop
  405e8c:	20001420 	.word	0x20001420
  405e90:	0040c9d5 	.word	0x0040c9d5

00405e94 <inv_icm20648_enter_duty_cycle_mode>:

int inv_icm20648_enter_duty_cycle_mode(struct inv_icm20648 * s)
{
  405e94:	b590      	push	{r4, r7, lr}
  405e96:	b085      	sub	sp, #20
  405e98:	af00      	add	r7, sp, #0
  405e9a:	6078      	str	r0, [r7, #4]
	/* secondary cycle mode should be set all the time */
	unsigned char data  = BIT_I2C_MST_CYCLE|BIT_ACCEL_CYCLE|BIT_GYRO_CYCLE;
  405e9c:	2370      	movs	r3, #112	; 0x70
  405e9e:	73fb      	strb	r3, [r7, #15]

	s->base_state.chip_lp_ln_mode = CHIP_LOW_POWER_ICM20648;
  405ea0:	687b      	ldr	r3, [r7, #4]
  405ea2:	2201      	movs	r2, #1
  405ea4:	765a      	strb	r2, [r3, #25]
	return inv_icm20648_write_mems_reg(s, REG_LP_CONFIG, 1, &data);
  405ea6:	f107 030f 	add.w	r3, r7, #15
  405eaa:	2201      	movs	r2, #1
  405eac:	2105      	movs	r1, #5
  405eae:	6878      	ldr	r0, [r7, #4]
  405eb0:	4c03      	ldr	r4, [pc, #12]	; (405ec0 <inv_icm20648_enter_duty_cycle_mode+0x2c>)
  405eb2:	47a0      	blx	r4
  405eb4:	4603      	mov	r3, r0
}
  405eb6:	4618      	mov	r0, r3
  405eb8:	3714      	adds	r7, #20
  405eba:	46bd      	mov	sp, r7
  405ebc:	bd90      	pop	{r4, r7, pc}
  405ebe:	bf00      	nop
  405ec0:	0040c8cd 	.word	0x0040c8cd

00405ec4 <inv_icm20648_enter_low_noise_mode>:

int inv_icm20648_enter_low_noise_mode(struct inv_icm20648 * s)
{
  405ec4:	b590      	push	{r4, r7, lr}
  405ec6:	b085      	sub	sp, #20
  405ec8:	af00      	add	r7, sp, #0
  405eca:	6078      	str	r0, [r7, #4]
	/* secondary cycle mode should be set all the time */
	unsigned char data  = BIT_I2C_MST_CYCLE;
  405ecc:	2340      	movs	r3, #64	; 0x40
  405ece:	73fb      	strb	r3, [r7, #15]

	s->base_state.chip_lp_ln_mode = CHIP_LOW_NOISE_ICM20648;
  405ed0:	687b      	ldr	r3, [r7, #4]
  405ed2:	2200      	movs	r2, #0
  405ed4:	765a      	strb	r2, [r3, #25]
	return inv_icm20648_write_mems_reg(s, REG_LP_CONFIG, 1, &data);
  405ed6:	f107 030f 	add.w	r3, r7, #15
  405eda:	2201      	movs	r2, #1
  405edc:	2105      	movs	r1, #5
  405ede:	6878      	ldr	r0, [r7, #4]
  405ee0:	4c03      	ldr	r4, [pc, #12]	; (405ef0 <inv_icm20648_enter_low_noise_mode+0x2c>)
  405ee2:	47a0      	blx	r4
  405ee4:	4603      	mov	r3, r0
}
  405ee6:	4618      	mov	r0, r3
  405ee8:	3714      	adds	r7, #20
  405eea:	46bd      	mov	sp, r7
  405eec:	bd90      	pop	{r4, r7, pc}
  405eee:	bf00      	nop
  405ef0:	0040c8cd 	.word	0x0040c8cd

00405ef4 <inv_icm20648_initialize_lower_driver>:
/** Should be called once on power up. Loads DMP3, initializes internal variables needed
*   for other lower driver functions.
*/
int inv_icm20648_initialize_lower_driver(struct inv_icm20648 * s, enum SMARTSENSOR_SERIAL_INTERFACE type,
	const uint8_t *dmp3_image, uint32_t dmp3_image_size)
{
  405ef4:	b590      	push	{r4, r7, lr}
  405ef6:	b087      	sub	sp, #28
  405ef8:	af00      	add	r7, sp, #0
  405efa:	60f8      	str	r0, [r7, #12]
  405efc:	607a      	str	r2, [r7, #4]
  405efe:	603b      	str	r3, [r7, #0]
  405f00:	460b      	mov	r3, r1
  405f02:	72fb      	strb	r3, [r7, #11]
	int result = 0;
  405f04:	2300      	movs	r3, #0
  405f06:	617b      	str	r3, [r7, #20]
	static unsigned char data;
	// set static variable
	s->sAllowLpEn = 1;
  405f08:	68fb      	ldr	r3, [r7, #12]
  405f0a:	2201      	movs	r2, #1
  405f0c:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	s->s_compass_available = 0;
  405f10:	68fb      	ldr	r3, [r7, #12]
  405f12:	2200      	movs	r2, #0
  405f14:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
	// ICM20648 do not support the proximity sensor for the moment.
	// s_proximity_available variable is nerver changes
	s->s_proximity_available = 0;
  405f18:	68fb      	ldr	r3, [r7, #12]
  405f1a:	2200      	movs	r2, #0
  405f1c:	f883 20ba 	strb.w	r2, [r3, #186]	; 0xba

	// Set varialbes to default values
	memset(&s->base_state, 0, sizeof(s->base_state));
  405f20:	68fb      	ldr	r3, [r7, #12]
  405f22:	3318      	adds	r3, #24
  405f24:	2212      	movs	r2, #18
  405f26:	2100      	movs	r1, #0
  405f28:	4618      	mov	r0, r3
  405f2a:	4b8a      	ldr	r3, [pc, #552]	; (406154 <inv_icm20648_initialize_lower_driver+0x260>)
  405f2c:	4798      	blx	r3
	s->base_state.pwr_mgmt_1 = BIT_CLK_PLL;
  405f2e:	68fb      	ldr	r3, [r7, #12]
  405f30:	2201      	movs	r2, #1
  405f32:	769a      	strb	r2, [r3, #26]
	s->base_state.pwr_mgmt_2 = BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY | BIT_PWR_PRESSURE_STBY;
  405f34:	68fb      	ldr	r3, [r7, #12]
  405f36:	227f      	movs	r2, #127	; 0x7f
  405f38:	76da      	strb	r2, [r3, #27]
	s->base_state.serial_interface = type;
  405f3a:	68fb      	ldr	r3, [r7, #12]
  405f3c:	7afa      	ldrb	r2, [r7, #11]
  405f3e:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
	result |= inv_icm20648_read_mems_reg(s, REG_USER_CTRL, 1, &s->base_state.user_ctrl);
  405f42:	68fb      	ldr	r3, [r7, #12]
  405f44:	331c      	adds	r3, #28
  405f46:	2201      	movs	r2, #1
  405f48:	2103      	movs	r1, #3
  405f4a:	68f8      	ldr	r0, [r7, #12]
  405f4c:	4c82      	ldr	r4, [pc, #520]	; (406158 <inv_icm20648_initialize_lower_driver+0x264>)
  405f4e:	47a0      	blx	r4
  405f50:	4602      	mov	r2, r0
  405f52:	697b      	ldr	r3, [r7, #20]
  405f54:	4313      	orrs	r3, r2
  405f56:	617b      	str	r3, [r7, #20]

	result |= inv_icm20648_wakeup_mems(s);
  405f58:	68f8      	ldr	r0, [r7, #12]
  405f5a:	4b80      	ldr	r3, [pc, #512]	; (40615c <inv_icm20648_initialize_lower_driver+0x268>)
  405f5c:	4798      	blx	r3
  405f5e:	4602      	mov	r2, r0
  405f60:	697b      	ldr	r3, [r7, #20]
  405f62:	4313      	orrs	r3, r2
  405f64:	617b      	str	r3, [r7, #20]

	result |= inv_icm20648_read_mems_reg(s, REG_WHO_AM_I, 1, &data);
  405f66:	4b7e      	ldr	r3, [pc, #504]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  405f68:	2201      	movs	r2, #1
  405f6a:	2100      	movs	r1, #0
  405f6c:	68f8      	ldr	r0, [r7, #12]
  405f6e:	4c7a      	ldr	r4, [pc, #488]	; (406158 <inv_icm20648_initialize_lower_driver+0x264>)
  405f70:	47a0      	blx	r4
  405f72:	4602      	mov	r2, r0
  405f74:	697b      	ldr	r3, [r7, #20]
  405f76:	4313      	orrs	r3, r2
  405f78:	617b      	str	r3, [r7, #20]

	/* secondary cycle mode should be set all the time */
	data = BIT_I2C_MST_CYCLE|BIT_ACCEL_CYCLE|BIT_GYRO_CYCLE;
  405f7a:	4b79      	ldr	r3, [pc, #484]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  405f7c:	2270      	movs	r2, #112	; 0x70
  405f7e:	701a      	strb	r2, [r3, #0]

	// Set default mode to low power mode
	result |= inv_icm20648_set_lowpower_or_highperformance(s, 0);
  405f80:	2100      	movs	r1, #0
  405f82:	68f8      	ldr	r0, [r7, #12]
  405f84:	4b77      	ldr	r3, [pc, #476]	; (406164 <inv_icm20648_initialize_lower_driver+0x270>)
  405f86:	4798      	blx	r3
  405f88:	4602      	mov	r2, r0
  405f8a:	697b      	ldr	r3, [r7, #20]
  405f8c:	4313      	orrs	r3, r2
  405f8e:	617b      	str	r3, [r7, #20]

	// Disable Ivory DMP.
	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI)
  405f90:	68fb      	ldr	r3, [r7, #12]
  405f92:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  405f96:	2b02      	cmp	r3, #2
  405f98:	d103      	bne.n	405fa2 <inv_icm20648_initialize_lower_driver+0xae>
		s->base_state.user_ctrl = BIT_I2C_IF_DIS;
  405f9a:	68fb      	ldr	r3, [r7, #12]
  405f9c:	2210      	movs	r2, #16
  405f9e:	771a      	strb	r2, [r3, #28]
  405fa0:	e002      	b.n	405fa8 <inv_icm20648_initialize_lower_driver+0xb4>
	else
		s->base_state.user_ctrl = 0;
  405fa2:	68fb      	ldr	r3, [r7, #12]
  405fa4:	2200      	movs	r2, #0
  405fa6:	771a      	strb	r2, [r3, #28]

	result |= inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  405fa8:	68fb      	ldr	r3, [r7, #12]
  405faa:	7f1b      	ldrb	r3, [r3, #28]
  405fac:	461a      	mov	r2, r3
  405fae:	2103      	movs	r1, #3
  405fb0:	68f8      	ldr	r0, [r7, #12]
  405fb2:	4b6d      	ldr	r3, [pc, #436]	; (406168 <inv_icm20648_initialize_lower_driver+0x274>)
  405fb4:	4798      	blx	r3
  405fb6:	4602      	mov	r2, r0
  405fb8:	697b      	ldr	r3, [r7, #20]
  405fba:	4313      	orrs	r3, r2
  405fbc:	617b      	str	r3, [r7, #20]

	//Setup Ivory DMP.
	result |= inv_icm20648_load_firmware(s, dmp3_image, dmp3_image_size);
  405fbe:	683a      	ldr	r2, [r7, #0]
  405fc0:	6879      	ldr	r1, [r7, #4]
  405fc2:	68f8      	ldr	r0, [r7, #12]
  405fc4:	4b69      	ldr	r3, [pc, #420]	; (40616c <inv_icm20648_initialize_lower_driver+0x278>)
  405fc6:	4798      	blx	r3
  405fc8:	4602      	mov	r2, r0
  405fca:	697b      	ldr	r3, [r7, #20]
  405fcc:	4313      	orrs	r3, r2
  405fce:	617b      	str	r3, [r7, #20]
	if(result)
  405fd0:	697b      	ldr	r3, [r7, #20]
  405fd2:	2b00      	cmp	r3, #0
  405fd4:	d001      	beq.n	405fda <inv_icm20648_initialize_lower_driver+0xe6>
		return result;
  405fd6:	697b      	ldr	r3, [r7, #20]
  405fd8:	e0b8      	b.n	40614c <inv_icm20648_initialize_lower_driver+0x258>
	else
		s->base_state.firmware_loaded = 1;
  405fda:	68fa      	ldr	r2, [r7, #12]
  405fdc:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
  405fe0:	f043 0302 	orr.w	r3, r3, #2
  405fe4:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
	result |= inv_icm20648_set_dmp_address(s);
  405fe8:	68f8      	ldr	r0, [r7, #12]
  405fea:	4b61      	ldr	r3, [pc, #388]	; (406170 <inv_icm20648_initialize_lower_driver+0x27c>)
  405fec:	4798      	blx	r3
  405fee:	4602      	mov	r2, r0
  405ff0:	697b      	ldr	r3, [r7, #20]
  405ff2:	4313      	orrs	r3, r2
  405ff4:	617b      	str	r3, [r7, #20]
	// Turn off all sensors on DMP by default.
	//result |= dmp_set_data_output_control1(0);   // FIXME in DMP, these should be off by default.
	result |= dmp_icm20648_reset_control_registers(s);
  405ff6:	68f8      	ldr	r0, [r7, #12]
  405ff8:	4b5e      	ldr	r3, [pc, #376]	; (406174 <inv_icm20648_initialize_lower_driver+0x280>)
  405ffa:	4798      	blx	r3
  405ffc:	4602      	mov	r2, r0
  405ffe:	697b      	ldr	r3, [r7, #20]
  406000:	4313      	orrs	r3, r2
  406002:	617b      	str	r3, [r7, #20]

	// set FIFO watermark to 80% of actual FIFO size
	result |= dmp_icm20648_set_FIFO_watermark(s, 800);
  406004:	f44f 7148 	mov.w	r1, #800	; 0x320
  406008:	68f8      	ldr	r0, [r7, #12]
  40600a:	4b5b      	ldr	r3, [pc, #364]	; (406178 <inv_icm20648_initialize_lower_driver+0x284>)
  40600c:	4798      	blx	r3
  40600e:	4602      	mov	r2, r0
  406010:	697b      	ldr	r3, [r7, #20]
  406012:	4313      	orrs	r3, r2
  406014:	617b      	str	r3, [r7, #20]

	// Enable Interrupts.
	data = 0x2;
  406016:	4b52      	ldr	r3, [pc, #328]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  406018:	2202      	movs	r2, #2
  40601a:	701a      	strb	r2, [r3, #0]
	result |= inv_icm20648_write_mems_reg(s, REG_INT_ENABLE, 1, &data); // Enable DMP Interrupt
  40601c:	4b50      	ldr	r3, [pc, #320]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  40601e:	2201      	movs	r2, #1
  406020:	2110      	movs	r1, #16
  406022:	68f8      	ldr	r0, [r7, #12]
  406024:	4c55      	ldr	r4, [pc, #340]	; (40617c <inv_icm20648_initialize_lower_driver+0x288>)
  406026:	47a0      	blx	r4
  406028:	4602      	mov	r2, r0
  40602a:	697b      	ldr	r3, [r7, #20]
  40602c:	4313      	orrs	r3, r2
  40602e:	617b      	str	r3, [r7, #20]
	data = 0x1;
  406030:	4b4b      	ldr	r3, [pc, #300]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  406032:	2201      	movs	r2, #1
  406034:	701a      	strb	r2, [r3, #0]
	result |= inv_icm20648_write_mems_reg(s, REG_INT_ENABLE_2, 1, &data); // Enable FIFO Overflow Interrupt
  406036:	4b4a      	ldr	r3, [pc, #296]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  406038:	2201      	movs	r2, #1
  40603a:	2112      	movs	r1, #18
  40603c:	68f8      	ldr	r0, [r7, #12]
  40603e:	4c4f      	ldr	r4, [pc, #316]	; (40617c <inv_icm20648_initialize_lower_driver+0x288>)
  406040:	47a0      	blx	r4
  406042:	4602      	mov	r2, r0
  406044:	697b      	ldr	r3, [r7, #20]
  406046:	4313      	orrs	r3, r2
  406048:	617b      	str	r3, [r7, #20]

	// TRACKING : To have accelerometers datas and the interrupt without gyro enables.
	data = 0XE4;
  40604a:	4b45      	ldr	r3, [pc, #276]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  40604c:	22e4      	movs	r2, #228	; 0xe4
  40604e:	701a      	strb	r2, [r3, #0]
	result |= inv_icm20648_write_mems_reg(s, REG_SINGLE_FIFO_PRIORITY_SEL, 1, &data);
  406050:	4b43      	ldr	r3, [pc, #268]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  406052:	2201      	movs	r2, #1
  406054:	2126      	movs	r1, #38	; 0x26
  406056:	68f8      	ldr	r0, [r7, #12]
  406058:	4c48      	ldr	r4, [pc, #288]	; (40617c <inv_icm20648_initialize_lower_driver+0x288>)
  40605a:	47a0      	blx	r4
  40605c:	4602      	mov	r2, r0
  40605e:	697b      	ldr	r3, [r7, #20]
  406060:	4313      	orrs	r3, r2
  406062:	617b      	str	r3, [r7, #20]

	// Disable HW temp fix
	inv_icm20648_read_mems_reg(s, REG_HW_FIX_DISABLE,1,&data);
  406064:	4b3e      	ldr	r3, [pc, #248]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  406066:	2201      	movs	r2, #1
  406068:	2175      	movs	r1, #117	; 0x75
  40606a:	68f8      	ldr	r0, [r7, #12]
  40606c:	4c3a      	ldr	r4, [pc, #232]	; (406158 <inv_icm20648_initialize_lower_driver+0x264>)
  40606e:	47a0      	blx	r4
	data |= 0x08;
  406070:	4b3b      	ldr	r3, [pc, #236]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  406072:	781b      	ldrb	r3, [r3, #0]
  406074:	f043 0308 	orr.w	r3, r3, #8
  406078:	b2da      	uxtb	r2, r3
  40607a:	4b39      	ldr	r3, [pc, #228]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  40607c:	701a      	strb	r2, [r3, #0]
	inv_icm20648_write_mems_reg(s, REG_HW_FIX_DISABLE,1,&data);
  40607e:	4b38      	ldr	r3, [pc, #224]	; (406160 <inv_icm20648_initialize_lower_driver+0x26c>)
  406080:	2201      	movs	r2, #1
  406082:	2175      	movs	r1, #117	; 0x75
  406084:	68f8      	ldr	r0, [r7, #12]
  406086:	4c3d      	ldr	r4, [pc, #244]	; (40617c <inv_icm20648_initialize_lower_driver+0x288>)
  406088:	47a0      	blx	r4

	// Setup MEMs properties.
	s->base_state.accel_averaging = 1; //Change this value if higher sensor sample avergaing is required.
  40608a:	68fb      	ldr	r3, [r7, #12]
  40608c:	2201      	movs	r2, #1
  40608e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	s->base_state.gyro_averaging = 1;  //Change this value if higher sensor sample avergaing is required.
  406092:	68fb      	ldr	r3, [r7, #12]
  406094:	2201      	movs	r2, #1
  406096:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
	inv_icm20648_set_gyro_divider(s, FIFO_DIVIDER);       //Initial sampling rate 1125Hz/19+1 = 56Hz.
  40609a:	2113      	movs	r1, #19
  40609c:	68f8      	ldr	r0, [r7, #12]
  40609e:	4b38      	ldr	r3, [pc, #224]	; (406180 <inv_icm20648_initialize_lower_driver+0x28c>)
  4060a0:	4798      	blx	r3
	inv_icm20648_set_accel_divider(s, FIFO_DIVIDER);      //Initial sampling rate 1125Hz/19+1 = 56Hz.
  4060a2:	2113      	movs	r1, #19
  4060a4:	68f8      	ldr	r0, [r7, #12]
  4060a6:	4b37      	ldr	r3, [pc, #220]	; (406184 <inv_icm20648_initialize_lower_driver+0x290>)
  4060a8:	4798      	blx	r3

	// Init the sample rate to 56 Hz for BAC,STEPC and B2S
	dmp_icm20648_set_bac_rate(s, DMP_ALGO_FREQ_56);
  4060aa:	2138      	movs	r1, #56	; 0x38
  4060ac:	68f8      	ldr	r0, [r7, #12]
  4060ae:	4b36      	ldr	r3, [pc, #216]	; (406188 <inv_icm20648_initialize_lower_driver+0x294>)
  4060b0:	4798      	blx	r3
	dmp_icm20648_set_b2s_rate(s, DMP_ALGO_FREQ_56);
  4060b2:	2138      	movs	r1, #56	; 0x38
  4060b4:	68f8      	ldr	r0, [r7, #12]
  4060b6:	4b35      	ldr	r3, [pc, #212]	; (40618c <inv_icm20648_initialize_lower_driver+0x298>)
  4060b8:	4798      	blx	r3

	// FIFO Setup.
	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_CFG, BIT_SINGLE_FIFO_CFG); // FIFO Config. fixme do once? burst write?
  4060ba:	2200      	movs	r2, #0
  4060bc:	2176      	movs	r1, #118	; 0x76
  4060be:	68f8      	ldr	r0, [r7, #12]
  4060c0:	4b29      	ldr	r3, [pc, #164]	; (406168 <inv_icm20648_initialize_lower_driver+0x274>)
  4060c2:	4798      	blx	r3
  4060c4:	4602      	mov	r2, r0
  4060c6:	697b      	ldr	r3, [r7, #20]
  4060c8:	4313      	orrs	r3, r2
  4060ca:	617b      	str	r3, [r7, #20]
	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_RST, 0x1f); // Reset all FIFOs.
  4060cc:	221f      	movs	r2, #31
  4060ce:	2168      	movs	r1, #104	; 0x68
  4060d0:	68f8      	ldr	r0, [r7, #12]
  4060d2:	4b25      	ldr	r3, [pc, #148]	; (406168 <inv_icm20648_initialize_lower_driver+0x274>)
  4060d4:	4798      	blx	r3
  4060d6:	4602      	mov	r2, r0
  4060d8:	697b      	ldr	r3, [r7, #20]
  4060da:	4313      	orrs	r3, r2
  4060dc:	617b      	str	r3, [r7, #20]
	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_RST, 0x1e); // Keep all but Gyro FIFO in reset.
  4060de:	221e      	movs	r2, #30
  4060e0:	2168      	movs	r1, #104	; 0x68
  4060e2:	68f8      	ldr	r0, [r7, #12]
  4060e4:	4b20      	ldr	r3, [pc, #128]	; (406168 <inv_icm20648_initialize_lower_driver+0x274>)
  4060e6:	4798      	blx	r3
  4060e8:	4602      	mov	r2, r0
  4060ea:	697b      	ldr	r3, [r7, #20]
  4060ec:	4313      	orrs	r3, r2
  4060ee:	617b      	str	r3, [r7, #20]
	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_EN, 0x0); // Slave FIFO turned off.
  4060f0:	2200      	movs	r2, #0
  4060f2:	2166      	movs	r1, #102	; 0x66
  4060f4:	68f8      	ldr	r0, [r7, #12]
  4060f6:	4b1c      	ldr	r3, [pc, #112]	; (406168 <inv_icm20648_initialize_lower_driver+0x274>)
  4060f8:	4798      	blx	r3
  4060fa:	4602      	mov	r2, r0
  4060fc:	697b      	ldr	r3, [r7, #20]
  4060fe:	4313      	orrs	r3, r2
  406100:	617b      	str	r3, [r7, #20]
	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_EN_2, 0x0); // Hardware FIFO turned off.
  406102:	2200      	movs	r2, #0
  406104:	2167      	movs	r1, #103	; 0x67
  406106:	68f8      	ldr	r0, [r7, #12]
  406108:	4b17      	ldr	r3, [pc, #92]	; (406168 <inv_icm20648_initialize_lower_driver+0x274>)
  40610a:	4798      	blx	r3
  40610c:	4602      	mov	r2, r0
  40610e:	697b      	ldr	r3, [r7, #20]
  406110:	4313      	orrs	r3, r2
  406112:	617b      	str	r3, [r7, #20]

	s->base_state.lp_en_support = 1;
  406114:	68fa      	ldr	r2, [r7, #12]
  406116:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
  40611a:	f043 0301 	orr.w	r3, r3, #1
  40611e:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26

	if(s->base_state.lp_en_support == 1)
  406122:	68fb      	ldr	r3, [r7, #12]
  406124:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  406128:	f003 0301 	and.w	r3, r3, #1
  40612c:	b2db      	uxtb	r3, r3
  40612e:	2b00      	cmp	r3, #0
  406130:	d004      	beq.n	40613c <inv_icm20648_initialize_lower_driver+0x248>
		inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  406132:	2201      	movs	r2, #1
  406134:	2102      	movs	r1, #2
  406136:	68f8      	ldr	r0, [r7, #12]
  406138:	4b15      	ldr	r3, [pc, #84]	; (406190 <inv_icm20648_initialize_lower_driver+0x29c>)
  40613a:	4798      	blx	r3

	result |= inv_icm20648_sleep_mems(s);
  40613c:	68f8      	ldr	r0, [r7, #12]
  40613e:	4b15      	ldr	r3, [pc, #84]	; (406194 <inv_icm20648_initialize_lower_driver+0x2a0>)
  406140:	4798      	blx	r3
  406142:	4602      	mov	r2, r0
  406144:	697b      	ldr	r3, [r7, #20]
  406146:	4313      	orrs	r3, r2
  406148:	617b      	str	r3, [r7, #20]

	return result;
  40614a:	697b      	ldr	r3, [r7, #20]
}
  40614c:	4618      	mov	r0, r3
  40614e:	371c      	adds	r7, #28
  406150:	46bd      	mov	sp, r7
  406152:	bd90      	pop	{r4, r7, pc}
  406154:	00414431 	.word	0x00414431
  406158:	0040caa1 	.word	0x0040caa1
  40615c:	00405d05 	.word	0x00405d05
  406160:	20001421 	.word	0x20001421
  406164:	0040ac7d 	.word	0x0040ac7d
  406168:	0040c9d5 	.word	0x0040c9d5
  40616c:	00407fd9 	.word	0x00407fd9
  406170:	00405df9 	.word	0x00405df9
  406174:	00408095 	.word	0x00408095
  406178:	00408169 	.word	0x00408169
  40617c:	0040c8cd 	.word	0x0040c8cd
  406180:	00406275 	.word	0x00406275
  406184:	004062f5 	.word	0x004062f5
  406188:	00408955 	.word	0x00408955
  40618c:	004089e9 	.word	0x004089e9
  406190:	00405b8d 	.word	0x00405b8d
  406194:	00405db9 	.word	0x00405db9

00406198 <activate_compass>:

static void activate_compass(struct inv_icm20648 * s)
{
  406198:	b480      	push	{r7}
  40619a:	b083      	sub	sp, #12
  40619c:	af00      	add	r7, sp, #0
  40619e:	6078      	str	r0, [r7, #4]
	s->s_compass_available = 1;
  4061a0:	687b      	ldr	r3, [r7, #4]
  4061a2:	2201      	movs	r2, #1
  4061a4:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
}
  4061a8:	bf00      	nop
  4061aa:	370c      	adds	r7, #12
  4061ac:	46bd      	mov	sp, r7
  4061ae:	f85d 7b04 	ldr.w	r7, [sp], #4
  4061b2:	4770      	bx	lr

004061b4 <desactivate_compass>:

static void desactivate_compass(struct inv_icm20648 * s)
{
  4061b4:	b480      	push	{r7}
  4061b6:	b083      	sub	sp, #12
  4061b8:	af00      	add	r7, sp, #0
  4061ba:	6078      	str	r0, [r7, #4]
	s->s_compass_available = 0;
  4061bc:	687b      	ldr	r3, [r7, #4]
  4061be:	2200      	movs	r2, #0
  4061c0:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
}
  4061c4:	bf00      	nop
  4061c6:	370c      	adds	r7, #12
  4061c8:	46bd      	mov	sp, r7
  4061ca:	f85d 7b04 	ldr.w	r7, [sp], #4
  4061ce:	4770      	bx	lr

004061d0 <inv_icm20648_get_compass_availability>:

int inv_icm20648_get_compass_availability(struct inv_icm20648 * s)
{
  4061d0:	b480      	push	{r7}
  4061d2:	b083      	sub	sp, #12
  4061d4:	af00      	add	r7, sp, #0
  4061d6:	6078      	str	r0, [r7, #4]
	return s->s_compass_available;
  4061d8:	687b      	ldr	r3, [r7, #4]
  4061da:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
}
  4061de:	4618      	mov	r0, r3
  4061e0:	370c      	adds	r7, #12
  4061e2:	46bd      	mov	sp, r7
  4061e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4061e8:	4770      	bx	lr
	...

004061ec <inv_icm20648_set_slave_compass_id>:
{
	return s->s_proximity_available;
}

int inv_icm20648_set_slave_compass_id(struct inv_icm20648 * s, int id)
{
  4061ec:	b580      	push	{r7, lr}
  4061ee:	b084      	sub	sp, #16
  4061f0:	af00      	add	r7, sp, #0
  4061f2:	6078      	str	r0, [r7, #4]
  4061f4:	6039      	str	r1, [r7, #0]
	int result = 0;
  4061f6:	2300      	movs	r3, #0
  4061f8:	60fb      	str	r3, [r7, #12]

	//result = inv_icm20648_wakeup_mems(s);
	//if (result)
	//	return result;

	inv_icm20648_prevent_lpen_control(s);
  4061fa:	6878      	ldr	r0, [r7, #4]
  4061fc:	4b15      	ldr	r3, [pc, #84]	; (406254 <inv_icm20648_set_slave_compass_id+0x68>)
  4061fe:	4798      	blx	r3
	activate_compass(s);
  406200:	6878      	ldr	r0, [r7, #4]
  406202:	4b15      	ldr	r3, [pc, #84]	; (406258 <inv_icm20648_set_slave_compass_id+0x6c>)
  406204:	4798      	blx	r3

	inv_icm20648_init_secondary(s);
  406206:	6878      	ldr	r0, [r7, #4]
  406208:	4b14      	ldr	r3, [pc, #80]	; (40625c <inv_icm20648_set_slave_compass_id+0x70>)
  40620a:	4798      	blx	r3

	// Set up the secondary I2C bus on 20630.
	inv_icm20648_set_secondary(s);
  40620c:	6878      	ldr	r0, [r7, #4]
  40620e:	4b14      	ldr	r3, [pc, #80]	; (406260 <inv_icm20648_set_slave_compass_id+0x74>)
  406210:	4798      	blx	r3

	//Setup Compass
	result = inv_icm20648_setup_compass_akm(s);
  406212:	6878      	ldr	r0, [r7, #4]
  406214:	4b13      	ldr	r3, [pc, #76]	; (406264 <inv_icm20648_set_slave_compass_id+0x78>)
  406216:	4798      	blx	r3
  406218:	60f8      	str	r0, [r7, #12]

	//Setup Compass mounting matrix into DMP
	result |= inv_icm20648_compass_dmp_cal(s, s->mounting_matrix, s->mounting_matrix_secondary_compass);
  40621a:	687b      	ldr	r3, [r7, #4]
  40621c:	f503 711d 	add.w	r1, r3, #628	; 0x274
  406220:	687b      	ldr	r3, [r7, #4]
  406222:	f203 237d 	addw	r3, r3, #637	; 0x27d
  406226:	461a      	mov	r2, r3
  406228:	6878      	ldr	r0, [r7, #4]
  40622a:	4b0f      	ldr	r3, [pc, #60]	; (406268 <inv_icm20648_set_slave_compass_id+0x7c>)
  40622c:	4798      	blx	r3
  40622e:	4602      	mov	r2, r0
  406230:	68fb      	ldr	r3, [r7, #12]
  406232:	4313      	orrs	r3, r2
  406234:	60fb      	str	r3, [r7, #12]

	if (result)
  406236:	68fb      	ldr	r3, [r7, #12]
  406238:	2b00      	cmp	r3, #0
  40623a:	d002      	beq.n	406242 <inv_icm20648_set_slave_compass_id+0x56>
		desactivate_compass(s);
  40623c:	6878      	ldr	r0, [r7, #4]
  40623e:	4b0b      	ldr	r3, [pc, #44]	; (40626c <inv_icm20648_set_slave_compass_id+0x80>)
  406240:	4798      	blx	r3

	//result = inv_icm20648_sleep_mems(s);
	inv_icm20648_allow_lpen_control(s);
  406242:	6878      	ldr	r0, [r7, #4]
  406244:	4b0a      	ldr	r3, [pc, #40]	; (406270 <inv_icm20648_set_slave_compass_id+0x84>)
  406246:	4798      	blx	r3
	return result;
  406248:	68fb      	ldr	r3, [r7, #12]
}
  40624a:	4618      	mov	r0, r3
  40624c:	3710      	adds	r7, #16
  40624e:	46bd      	mov	sp, r7
  406250:	bd80      	pop	{r7, pc}
  406252:	bf00      	nop
  406254:	00405b2d 	.word	0x00405b2d
  406258:	00406199 	.word	0x00406199
  40625c:	004056fd 	.word	0x004056fd
  406260:	00405e45 	.word	0x00405e45
  406264:	0040494d 	.word	0x0040494d
  406268:	004052e5 	.word	0x004052e5
  40626c:	004061b5 	.word	0x004061b5
  406270:	00405b49 	.word	0x00405b49

00406274 <inv_icm20648_set_gyro_divider>:

int inv_icm20648_set_gyro_divider(struct inv_icm20648 * s, unsigned char div)
{
  406274:	b590      	push	{r4, r7, lr}
  406276:	b083      	sub	sp, #12
  406278:	af00      	add	r7, sp, #0
  40627a:	6078      	str	r0, [r7, #4]
  40627c:	460b      	mov	r3, r1
  40627e:	70fb      	strb	r3, [r7, #3]
	s->base_state.gyro_div = div;
  406280:	78fa      	ldrb	r2, [r7, #3]
  406282:	687b      	ldr	r3, [r7, #4]
  406284:	775a      	strb	r2, [r3, #29]
	return inv_icm20648_write_mems_reg(s, REG_GYRO_SMPLRT_DIV, 1, &div);
  406286:	1cfb      	adds	r3, r7, #3
  406288:	2201      	movs	r2, #1
  40628a:	f44f 7180 	mov.w	r1, #256	; 0x100
  40628e:	6878      	ldr	r0, [r7, #4]
  406290:	4c03      	ldr	r4, [pc, #12]	; (4062a0 <inv_icm20648_set_gyro_divider+0x2c>)
  406292:	47a0      	blx	r4
  406294:	4603      	mov	r3, r0
}
  406296:	4618      	mov	r0, r3
  406298:	370c      	adds	r7, #12
  40629a:	46bd      	mov	sp, r7
  40629c:	bd90      	pop	{r4, r7, pc}
  40629e:	bf00      	nop
  4062a0:	0040c8cd 	.word	0x0040c8cd

004062a4 <inv_icm20648_get_gyro_divider>:

unsigned char inv_icm20648_get_gyro_divider(struct inv_icm20648 * s)
{
  4062a4:	b480      	push	{r7}
  4062a6:	b083      	sub	sp, #12
  4062a8:	af00      	add	r7, sp, #0
  4062aa:	6078      	str	r0, [r7, #4]
	return s->base_state.gyro_div;
  4062ac:	687b      	ldr	r3, [r7, #4]
  4062ae:	7f5b      	ldrb	r3, [r3, #29]
}
  4062b0:	4618      	mov	r0, r3
  4062b2:	370c      	adds	r7, #12
  4062b4:	46bd      	mov	sp, r7
  4062b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4062ba:	4770      	bx	lr

004062bc <inv_icm20648_set_secondary_divider>:

int inv_icm20648_set_secondary_divider(struct inv_icm20648 * s, unsigned char div)
{
  4062bc:	b580      	push	{r7, lr}
  4062be:	b082      	sub	sp, #8
  4062c0:	af00      	add	r7, sp, #0
  4062c2:	6078      	str	r0, [r7, #4]
  4062c4:	460b      	mov	r3, r1
  4062c6:	70fb      	strb	r3, [r7, #3]
	s->base_state.secondary_div = 1UL<<div;
  4062c8:	78fb      	ldrb	r3, [r7, #3]
  4062ca:	2201      	movs	r2, #1
  4062cc:	fa02 f303 	lsl.w	r3, r2, r3
  4062d0:	b29a      	uxth	r2, r3
  4062d2:	687b      	ldr	r3, [r7, #4]
  4062d4:	83da      	strh	r2, [r3, #30]
	return inv_icm20648_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, div);
  4062d6:	78fb      	ldrb	r3, [r7, #3]
  4062d8:	461a      	mov	r2, r3
  4062da:	f44f 71c0 	mov.w	r1, #384	; 0x180
  4062de:	6878      	ldr	r0, [r7, #4]
  4062e0:	4b03      	ldr	r3, [pc, #12]	; (4062f0 <inv_icm20648_set_secondary_divider+0x34>)
  4062e2:	4798      	blx	r3
  4062e4:	4603      	mov	r3, r0
}
  4062e6:	4618      	mov	r0, r3
  4062e8:	3708      	adds	r7, #8
  4062ea:	46bd      	mov	sp, r7
  4062ec:	bd80      	pop	{r7, pc}
  4062ee:	bf00      	nop
  4062f0:	0040c9d5 	.word	0x0040c9d5

004062f4 <inv_icm20648_set_accel_divider>:
{
	return s->base_state.secondary_div;
}

int inv_icm20648_set_accel_divider(struct inv_icm20648 * s, short div)
{
  4062f4:	b590      	push	{r4, r7, lr}
  4062f6:	b085      	sub	sp, #20
  4062f8:	af00      	add	r7, sp, #0
  4062fa:	6078      	str	r0, [r7, #4]
  4062fc:	460b      	mov	r3, r1
  4062fe:	807b      	strh	r3, [r7, #2]
	unsigned char data[2] = {0};
  406300:	2300      	movs	r3, #0
  406302:	81bb      	strh	r3, [r7, #12]

	s->base_state.accel_div = div;
  406304:	687b      	ldr	r3, [r7, #4]
  406306:	887a      	ldrh	r2, [r7, #2]
  406308:	841a      	strh	r2, [r3, #32]
	data[0] = (unsigned char)(div >> 8);
  40630a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  40630e:	121b      	asrs	r3, r3, #8
  406310:	b21b      	sxth	r3, r3
  406312:	b2db      	uxtb	r3, r3
  406314:	733b      	strb	r3, [r7, #12]
	data[1] = (unsigned char)(div & 0xff);
  406316:	887b      	ldrh	r3, [r7, #2]
  406318:	b2db      	uxtb	r3, r3
  40631a:	737b      	strb	r3, [r7, #13]

	return inv_icm20648_write_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, 2, data);
  40631c:	f107 030c 	add.w	r3, r7, #12
  406320:	2202      	movs	r2, #2
  406322:	f44f 7188 	mov.w	r1, #272	; 0x110
  406326:	6878      	ldr	r0, [r7, #4]
  406328:	4c03      	ldr	r4, [pc, #12]	; (406338 <inv_icm20648_set_accel_divider+0x44>)
  40632a:	47a0      	blx	r4
  40632c:	4603      	mov	r3, r0
}
  40632e:	4618      	mov	r0, r3
  406330:	3714      	adds	r7, #20
  406332:	46bd      	mov	sp, r7
  406334:	bd90      	pop	{r4, r7, pc}
  406336:	bf00      	nop
  406338:	0040c8cd 	.word	0x0040c8cd
  40633c:	00000000 	.word	0x00000000

00406340 <inv_icm20648_set_gyro_sf>:
*            0=1125Hz sample rate, 1=562.5Hz sample rate, ... 4=225Hz sample rate, ...
*            10=102.2727Hz sample rate, ... etc.
* @param[in] gyro_level 0=250 dps, 1=500 dps, 2=1000 dps, 3=2000 dps
*/
int inv_icm20648_set_gyro_sf(struct inv_icm20648 * s, unsigned char div, int gyro_level)
{
  406340:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  406344:	b08d      	sub	sp, #52	; 0x34
  406346:	af00      	add	r7, sp, #0
  406348:	60f8      	str	r0, [r7, #12]
  40634a:	460b      	mov	r3, r1
  40634c:	607a      	str	r2, [r7, #4]
  40634e:	72fb      	strb	r3, [r7, #11]
	long gyro_sf;
	static long lLastGyroSf = 0;
	int result = 0;
  406350:	2300      	movs	r3, #0
  406352:	62bb      	str	r3, [r7, #40]	; 0x28

	// gyro_level should be set to 4 regardless of fullscale, due to the addition of API dmp_icm20648_set_gyro_fsr()
	gyro_level = 4;
  406354:	2304      	movs	r3, #4
  406356:	607b      	str	r3, [r7, #4]

	if(s->base_state.timebase_correction_pll == 0)
  406358:	68fb      	ldr	r3, [r7, #12]
  40635a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  40635e:	2b00      	cmp	r3, #0
  406360:	d10a      	bne.n	406378 <inv_icm20648_set_gyro_sf+0x38>
		result |= inv_icm20648_read_mems_reg(s, REG_TIMEBASE_CORRECTION_PLL, 1, &s->base_state.timebase_correction_pll);
  406362:	68fb      	ldr	r3, [r7, #12]
  406364:	3328      	adds	r3, #40	; 0x28
  406366:	2201      	movs	r2, #1
  406368:	21a8      	movs	r1, #168	; 0xa8
  40636a:	68f8      	ldr	r0, [r7, #12]
  40636c:	4e58      	ldr	r6, [pc, #352]	; (4064d0 <inv_icm20648_set_gyro_sf+0x190>)
  40636e:	47b0      	blx	r6
  406370:	4602      	mov	r2, r0
  406372:	6abb      	ldr	r3, [r7, #40]	; 0x28
  406374:	4313      	orrs	r3, r2
  406376:	62bb      	str	r3, [r7, #40]	; 0x28

	{
		unsigned long long const MagicConstant = 264446880937391LL;
  406378:	a353      	add	r3, pc, #332	; (adr r3, 4064c8 <inv_icm20648_set_gyro_sf+0x188>)
  40637a:	e9d3 2300 	ldrd	r2, r3, [r3]
  40637e:	e9c7 2306 	strd	r2, r3, [r7, #24]
		unsigned long long const MagicConstantScale = 100000LL;
  406382:	4a54      	ldr	r2, [pc, #336]	; (4064d4 <inv_icm20648_set_gyro_sf+0x194>)
  406384:	f04f 0300 	mov.w	r3, #0
  406388:	e9c7 2304 	strd	r2, r3, [r7, #16]
		unsigned long long ResultLL;

		if (s->base_state.timebase_correction_pll & 0x80) {
  40638c:	68fb      	ldr	r3, [r7, #12]
  40638e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  406392:	b25b      	sxtb	r3, r3
  406394:	2b00      	cmp	r3, #0
  406396:	da3a      	bge.n	40640e <inv_icm20648_set_gyro_sf+0xce>
			ResultLL = (MagicConstant * (long long)(1ULL << gyro_level) * (1 + div) / (1270 - (s->base_state.timebase_correction_pll & 0x7F)) / MagicConstantScale);
  406398:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
  40639c:	687a      	ldr	r2, [r7, #4]
  40639e:	f1a2 0020 	sub.w	r0, r2, #32
  4063a2:	f1c2 0120 	rsb	r1, r2, #32
  4063a6:	fa04 f902 	lsl.w	r9, r4, r2
  4063aa:	fa03 f000 	lsl.w	r0, r3, r0
  4063ae:	ea49 0900 	orr.w	r9, r9, r0
  4063b2:	fa23 f101 	lsr.w	r1, r3, r1
  4063b6:	ea49 0901 	orr.w	r9, r9, r1
  4063ba:	fa03 f802 	lsl.w	r8, r3, r2
  4063be:	7afb      	ldrb	r3, [r7, #11]
  4063c0:	3301      	adds	r3, #1
  4063c2:	ea4f 74e3 	mov.w	r4, r3, asr #31
  4063c6:	fb03 f109 	mul.w	r1, r3, r9
  4063ca:	fb08 f204 	mul.w	r2, r8, r4
  4063ce:	440a      	add	r2, r1
  4063d0:	fba8 0103 	umull	r0, r1, r8, r3
  4063d4:	1853      	adds	r3, r2, r1
  4063d6:	4619      	mov	r1, r3
  4063d8:	68fb      	ldr	r3, [r7, #12]
  4063da:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  4063de:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  4063e2:	f5c3 639e 	rsb	r3, r3, #1264	; 0x4f0
  4063e6:	3306      	adds	r3, #6
  4063e8:	ea4f 74e3 	mov.w	r4, r3, asr #31
  4063ec:	4d3a      	ldr	r5, [pc, #232]	; (4064d8 <inv_icm20648_set_gyro_sf+0x198>)
  4063ee:	461a      	mov	r2, r3
  4063f0:	4623      	mov	r3, r4
  4063f2:	47a8      	blx	r5
  4063f4:	4603      	mov	r3, r0
  4063f6:	460c      	mov	r4, r1
  4063f8:	4618      	mov	r0, r3
  4063fa:	4621      	mov	r1, r4
  4063fc:	4c36      	ldr	r4, [pc, #216]	; (4064d8 <inv_icm20648_set_gyro_sf+0x198>)
  4063fe:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
  406402:	47a0      	blx	r4
  406404:	4603      	mov	r3, r0
  406406:	460c      	mov	r4, r1
  406408:	e9c7 3408 	strd	r3, r4, [r7, #32]
  40640c:	e035      	b.n	40647a <inv_icm20648_set_gyro_sf+0x13a>
		}
		else {
			ResultLL = (MagicConstant * (long long)(1ULL << gyro_level) * (1 + div) / (1270 + s->base_state.timebase_correction_pll) / MagicConstantScale);
  40640e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
  406412:	6879      	ldr	r1, [r7, #4]
  406414:	f1a1 0620 	sub.w	r6, r1, #32
  406418:	f1c1 0020 	rsb	r0, r1, #32
  40641c:	fa03 f501 	lsl.w	r5, r3, r1
  406420:	fa02 f606 	lsl.w	r6, r2, r6
  406424:	4335      	orrs	r5, r6
  406426:	fa22 f000 	lsr.w	r0, r2, r0
  40642a:	4305      	orrs	r5, r0
  40642c:	fa02 f401 	lsl.w	r4, r2, r1
  406430:	7afb      	ldrb	r3, [r7, #11]
  406432:	3301      	adds	r3, #1
  406434:	461a      	mov	r2, r3
  406436:	ea4f 73e2 	mov.w	r3, r2, asr #31
  40643a:	fb02 f005 	mul.w	r0, r2, r5
  40643e:	fb04 f103 	mul.w	r1, r4, r3
  406442:	1846      	adds	r6, r0, r1
  406444:	fba4 0102 	umull	r0, r1, r4, r2
  406448:	1873      	adds	r3, r6, r1
  40644a:	4619      	mov	r1, r3
  40644c:	68fb      	ldr	r3, [r7, #12]
  40644e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  406452:	f203 43f6 	addw	r3, r3, #1270	; 0x4f6
  406456:	ea4f 74e3 	mov.w	r4, r3, asr #31
  40645a:	4d1f      	ldr	r5, [pc, #124]	; (4064d8 <inv_icm20648_set_gyro_sf+0x198>)
  40645c:	461a      	mov	r2, r3
  40645e:	4623      	mov	r3, r4
  406460:	47a8      	blx	r5
  406462:	4603      	mov	r3, r0
  406464:	460c      	mov	r4, r1
  406466:	4618      	mov	r0, r3
  406468:	4621      	mov	r1, r4
  40646a:	4c1b      	ldr	r4, [pc, #108]	; (4064d8 <inv_icm20648_set_gyro_sf+0x198>)
  40646c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
  406470:	47a0      	blx	r4
  406472:	4603      	mov	r3, r0
  406474:	460c      	mov	r4, r1
  406476:	e9c7 3408 	strd	r3, r4, [r7, #32]
		/*
		    In above deprecated FP version, worst case arguments can produce a result that overflows a signed long.
		    Here, for such cases, we emulate the FP behavior of setting the result to the maximum positive value, as
		    the compiler's conversion of a u64 to an s32 is simple truncation of the u64's high half, sadly....
		*/
		if  (ResultLL > 0x7FFFFFFF)
  40647a:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
  40647e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
  406482:	f04f 0200 	mov.w	r2, #0
  406486:	42a2      	cmp	r2, r4
  406488:	bf08      	it	eq
  40648a:	4299      	cmpeq	r1, r3
  40648c:	d203      	bcs.n	406496 <inv_icm20648_set_gyro_sf+0x156>
			gyro_sf = 0x7FFFFFFF;
  40648e:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
  406492:	62fb      	str	r3, [r7, #44]	; 0x2c
  406494:	e001      	b.n	40649a <inv_icm20648_set_gyro_sf+0x15a>
		else
			gyro_sf = (long)ResultLL;
  406496:	6a3b      	ldr	r3, [r7, #32]
  406498:	62fb      	str	r3, [r7, #44]	; 0x2c
	}

	if (gyro_sf != lLastGyroSf) {
  40649a:	4b10      	ldr	r3, [pc, #64]	; (4064dc <inv_icm20648_set_gyro_sf+0x19c>)
  40649c:	681b      	ldr	r3, [r3, #0]
  40649e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  4064a0:	429a      	cmp	r2, r3
  4064a2:	d00a      	beq.n	4064ba <inv_icm20648_set_gyro_sf+0x17a>
		result |= dmp_icm20648_set_gyro_sf(s, gyro_sf);
  4064a4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  4064a6:	68f8      	ldr	r0, [r7, #12]
  4064a8:	4b0d      	ldr	r3, [pc, #52]	; (4064e0 <inv_icm20648_set_gyro_sf+0x1a0>)
  4064aa:	4798      	blx	r3
  4064ac:	4602      	mov	r2, r0
  4064ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4064b0:	4313      	orrs	r3, r2
  4064b2:	62bb      	str	r3, [r7, #40]	; 0x28
		lLastGyroSf = gyro_sf;
  4064b4:	4a09      	ldr	r2, [pc, #36]	; (4064dc <inv_icm20648_set_gyro_sf+0x19c>)
  4064b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4064b8:	6013      	str	r3, [r2, #0]
	}

	return result;
  4064ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
  4064bc:	4618      	mov	r0, r3
  4064be:	3734      	adds	r7, #52	; 0x34
  4064c0:	46bd      	mov	sp, r7
  4064c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4064c6:	bf00      	nop
  4064c8:	566675af 	.word	0x566675af
  4064cc:	0000f083 	.word	0x0000f083
  4064d0:	0040caa1 	.word	0x0040caa1
  4064d4:	000186a0 	.word	0x000186a0
  4064d8:	00413e69 	.word	0x00413e69
  4064dc:	20001424 	.word	0x20001424
  4064e0:	004083b9 	.word	0x004083b9

004064e4 <inv_icm20648_set_gyro_fullscale>:

int inv_icm20648_set_gyro_fullscale(struct inv_icm20648 * s, int level)
{
  4064e4:	b580      	push	{r7, lr}
  4064e6:	b084      	sub	sp, #16
  4064e8:	af00      	add	r7, sp, #0
  4064ea:	6078      	str	r0, [r7, #4]
  4064ec:	6039      	str	r1, [r7, #0]
	int result;
	s->base_state.gyro_fullscale = level;
  4064ee:	683b      	ldr	r3, [r7, #0]
  4064f0:	b2da      	uxtb	r2, r3
  4064f2:	687b      	ldr	r3, [r7, #4]
  4064f4:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	result = inv_icm20648_set_icm20648_gyro_fullscale(s, level);
  4064f8:	6839      	ldr	r1, [r7, #0]
  4064fa:	6878      	ldr	r0, [r7, #4]
  4064fc:	4b0f      	ldr	r3, [pc, #60]	; (40653c <inv_icm20648_set_gyro_fullscale+0x58>)
  4064fe:	4798      	blx	r3
  406500:	60f8      	str	r0, [r7, #12]
	result |= inv_icm20648_set_gyro_sf(s, s->base_state.gyro_div, level);
  406502:	687b      	ldr	r3, [r7, #4]
  406504:	7f5b      	ldrb	r3, [r3, #29]
  406506:	683a      	ldr	r2, [r7, #0]
  406508:	4619      	mov	r1, r3
  40650a:	6878      	ldr	r0, [r7, #4]
  40650c:	4b0c      	ldr	r3, [pc, #48]	; (406540 <inv_icm20648_set_gyro_fullscale+0x5c>)
  40650e:	4798      	blx	r3
  406510:	4602      	mov	r2, r0
  406512:	68fb      	ldr	r3, [r7, #12]
  406514:	4313      	orrs	r3, r2
  406516:	60fb      	str	r3, [r7, #12]
	result |= dmp_icm20648_set_gyro_fsr(s, 250<<level);
  406518:	22fa      	movs	r2, #250	; 0xfa
  40651a:	683b      	ldr	r3, [r7, #0]
  40651c:	fa02 f303 	lsl.w	r3, r2, r3
  406520:	b21b      	sxth	r3, r3
  406522:	4619      	mov	r1, r3
  406524:	6878      	ldr	r0, [r7, #4]
  406526:	4b07      	ldr	r3, [pc, #28]	; (406544 <inv_icm20648_set_gyro_fullscale+0x60>)
  406528:	4798      	blx	r3
  40652a:	4602      	mov	r2, r0
  40652c:	68fb      	ldr	r3, [r7, #12]
  40652e:	4313      	orrs	r3, r2
  406530:	60fb      	str	r3, [r7, #12]

	return result;
  406532:	68fb      	ldr	r3, [r7, #12]
}
  406534:	4618      	mov	r0, r3
  406536:	3710      	adds	r7, #16
  406538:	46bd      	mov	sp, r7
  40653a:	bd80      	pop	{r7, pc}
  40653c:	00406565 	.word	0x00406565
  406540:	00406341 	.word	0x00406341
  406544:	004086b9 	.word	0x004086b9

00406548 <inv_icm20648_get_gyro_fullscale>:

uint8_t inv_icm20648_get_gyro_fullscale(struct inv_icm20648 * s)
{
  406548:	b480      	push	{r7}
  40654a:	b083      	sub	sp, #12
  40654c:	af00      	add	r7, sp, #0
  40654e:	6078      	str	r0, [r7, #4]
	return s->base_state.gyro_fullscale;
  406550:	687b      	ldr	r3, [r7, #4]
  406552:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
}
  406556:	4618      	mov	r0, r3
  406558:	370c      	adds	r7, #12
  40655a:	46bd      	mov	sp, r7
  40655c:	f85d 7b04 	ldr.w	r7, [sp], #4
  406560:	4770      	bx	lr
	...

00406564 <inv_icm20648_set_icm20648_gyro_fullscale>:


int inv_icm20648_set_icm20648_gyro_fullscale(struct inv_icm20648 * s, int level)
{
  406564:	b590      	push	{r4, r7, lr}
  406566:	b087      	sub	sp, #28
  406568:	af00      	add	r7, sp, #0
  40656a:	6078      	str	r0, [r7, #4]
  40656c:	6039      	str	r1, [r7, #0]
	int result = 0;
  40656e:	2300      	movs	r3, #0
  406570:	613b      	str	r3, [r7, #16]
	unsigned char gyro_config_1_reg;
	unsigned char gyro_config_2_reg;
	unsigned char dec3_cfg;
	if (level >= NUM_MPU_GFS)
  406572:	683b      	ldr	r3, [r7, #0]
  406574:	2b03      	cmp	r3, #3
  406576:	dd02      	ble.n	40657e <inv_icm20648_set_icm20648_gyro_fullscale+0x1a>
		return -1;
  406578:	f04f 33ff 	mov.w	r3, #4294967295
  40657c:	e07d      	b.n	40667a <inv_icm20648_set_icm20648_gyro_fullscale+0x116>

	result |= inv_icm20648_read_mems_reg(s, REG_GYRO_CONFIG_1, 1, &gyro_config_1_reg);
  40657e:	f107 030f 	add.w	r3, r7, #15
  406582:	2201      	movs	r2, #1
  406584:	f240 1101 	movw	r1, #257	; 0x101
  406588:	6878      	ldr	r0, [r7, #4]
  40658a:	4c3e      	ldr	r4, [pc, #248]	; (406684 <inv_icm20648_set_icm20648_gyro_fullscale+0x120>)
  40658c:	47a0      	blx	r4
  40658e:	4602      	mov	r2, r0
  406590:	693b      	ldr	r3, [r7, #16]
  406592:	4313      	orrs	r3, r2
  406594:	613b      	str	r3, [r7, #16]
	gyro_config_1_reg &= 0xC0;
  406596:	7bfb      	ldrb	r3, [r7, #15]
  406598:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  40659c:	b2db      	uxtb	r3, r3
  40659e:	73fb      	strb	r3, [r7, #15]
	gyro_config_1_reg |= (level << 1) | 1;  //fchoice = 1, filter = 0.
  4065a0:	683b      	ldr	r3, [r7, #0]
  4065a2:	005b      	lsls	r3, r3, #1
  4065a4:	b2da      	uxtb	r2, r3
  4065a6:	7bfb      	ldrb	r3, [r7, #15]
  4065a8:	4313      	orrs	r3, r2
  4065aa:	b2db      	uxtb	r3, r3
  4065ac:	f043 0301 	orr.w	r3, r3, #1
  4065b0:	b2db      	uxtb	r3, r3
  4065b2:	73fb      	strb	r3, [r7, #15]
	result |= inv_icm20648_write_mems_reg(s, REG_GYRO_CONFIG_1, 1, &gyro_config_1_reg);
  4065b4:	f107 030f 	add.w	r3, r7, #15
  4065b8:	2201      	movs	r2, #1
  4065ba:	f240 1101 	movw	r1, #257	; 0x101
  4065be:	6878      	ldr	r0, [r7, #4]
  4065c0:	4c31      	ldr	r4, [pc, #196]	; (406688 <inv_icm20648_set_icm20648_gyro_fullscale+0x124>)
  4065c2:	47a0      	blx	r4
  4065c4:	4602      	mov	r2, r0
  4065c6:	693b      	ldr	r3, [r7, #16]
  4065c8:	4313      	orrs	r3, r2
  4065ca:	613b      	str	r3, [r7, #16]

	result |= inv_icm20648_read_mems_reg(s, REG_GYRO_CONFIG_2, 1, &gyro_config_2_reg);
  4065cc:	f107 030e 	add.w	r3, r7, #14
  4065d0:	2201      	movs	r2, #1
  4065d2:	f44f 7181 	mov.w	r1, #258	; 0x102
  4065d6:	6878      	ldr	r0, [r7, #4]
  4065d8:	4c2a      	ldr	r4, [pc, #168]	; (406684 <inv_icm20648_set_icm20648_gyro_fullscale+0x120>)
  4065da:	47a0      	blx	r4
  4065dc:	4602      	mov	r2, r0
  4065de:	693b      	ldr	r3, [r7, #16]
  4065e0:	4313      	orrs	r3, r2
  4065e2:	613b      	str	r3, [r7, #16]
	gyro_config_2_reg &= 0xF8;
  4065e4:	7bbb      	ldrb	r3, [r7, #14]
  4065e6:	f023 0307 	bic.w	r3, r3, #7
  4065ea:	b2db      	uxtb	r3, r3
  4065ec:	73bb      	strb	r3, [r7, #14]

	switch(s->base_state.gyro_averaging) {
  4065ee:	687b      	ldr	r3, [r7, #4]
  4065f0:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
  4065f4:	2b08      	cmp	r3, #8
  4065f6:	d01d      	beq.n	406634 <inv_icm20648_set_icm20648_gyro_fullscale+0xd0>
  4065f8:	2b08      	cmp	r3, #8
  4065fa:	dc06      	bgt.n	40660a <inv_icm20648_set_icm20648_gyro_fullscale+0xa6>
  4065fc:	2b02      	cmp	r3, #2
  4065fe:	d013      	beq.n	406628 <inv_icm20648_set_icm20648_gyro_fullscale+0xc4>
  406600:	2b04      	cmp	r3, #4
  406602:	d014      	beq.n	40662e <inv_icm20648_set_icm20648_gyro_fullscale+0xca>
  406604:	2b01      	cmp	r3, #1
  406606:	d00c      	beq.n	406622 <inv_icm20648_set_icm20648_gyro_fullscale+0xbe>
  406608:	e023      	b.n	406652 <inv_icm20648_set_icm20648_gyro_fullscale+0xee>
  40660a:	2b20      	cmp	r3, #32
  40660c:	d018      	beq.n	406640 <inv_icm20648_set_icm20648_gyro_fullscale+0xdc>
  40660e:	2b20      	cmp	r3, #32
  406610:	dc02      	bgt.n	406618 <inv_icm20648_set_icm20648_gyro_fullscale+0xb4>
  406612:	2b10      	cmp	r3, #16
  406614:	d011      	beq.n	40663a <inv_icm20648_set_icm20648_gyro_fullscale+0xd6>
  406616:	e01c      	b.n	406652 <inv_icm20648_set_icm20648_gyro_fullscale+0xee>
  406618:	2b40      	cmp	r3, #64	; 0x40
  40661a:	d014      	beq.n	406646 <inv_icm20648_set_icm20648_gyro_fullscale+0xe2>
  40661c:	2b80      	cmp	r3, #128	; 0x80
  40661e:	d015      	beq.n	40664c <inv_icm20648_set_icm20648_gyro_fullscale+0xe8>
  406620:	e017      	b.n	406652 <inv_icm20648_set_icm20648_gyro_fullscale+0xee>
		case 1:
			dec3_cfg = 0;
  406622:	2300      	movs	r3, #0
  406624:	75fb      	strb	r3, [r7, #23]
			break;
  406626:	e017      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		case 2:
			dec3_cfg = 1;
  406628:	2301      	movs	r3, #1
  40662a:	75fb      	strb	r3, [r7, #23]
			break;
  40662c:	e014      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		case 4:
			dec3_cfg = 2;
  40662e:	2302      	movs	r3, #2
  406630:	75fb      	strb	r3, [r7, #23]
			break;
  406632:	e011      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		case 8:
			dec3_cfg = 3;
  406634:	2303      	movs	r3, #3
  406636:	75fb      	strb	r3, [r7, #23]
			break;
  406638:	e00e      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		case 16:
			dec3_cfg = 4;
  40663a:	2304      	movs	r3, #4
  40663c:	75fb      	strb	r3, [r7, #23]
			break;
  40663e:	e00b      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		case 32:
			dec3_cfg = 5;
  406640:	2305      	movs	r3, #5
  406642:	75fb      	strb	r3, [r7, #23]
			break;
  406644:	e008      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		case 64:
			dec3_cfg = 6;
  406646:	2306      	movs	r3, #6
  406648:	75fb      	strb	r3, [r7, #23]
			break;
  40664a:	e005      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		case 128:
			dec3_cfg = 7;
  40664c:	2307      	movs	r3, #7
  40664e:	75fb      	strb	r3, [r7, #23]
			break;
  406650:	e002      	b.n	406658 <inv_icm20648_set_icm20648_gyro_fullscale+0xf4>

		default:
			dec3_cfg = 0;
  406652:	2300      	movs	r3, #0
  406654:	75fb      	strb	r3, [r7, #23]
			break;
  406656:	bf00      	nop
	}
	gyro_config_2_reg |= dec3_cfg;
  406658:	7bba      	ldrb	r2, [r7, #14]
  40665a:	7dfb      	ldrb	r3, [r7, #23]
  40665c:	4313      	orrs	r3, r2
  40665e:	b2db      	uxtb	r3, r3
  406660:	73bb      	strb	r3, [r7, #14]
	result |= inv_icm20648_write_single_mems_reg(s, REG_GYRO_CONFIG_2, gyro_config_2_reg);
  406662:	7bbb      	ldrb	r3, [r7, #14]
  406664:	461a      	mov	r2, r3
  406666:	f44f 7181 	mov.w	r1, #258	; 0x102
  40666a:	6878      	ldr	r0, [r7, #4]
  40666c:	4b07      	ldr	r3, [pc, #28]	; (40668c <inv_icm20648_set_icm20648_gyro_fullscale+0x128>)
  40666e:	4798      	blx	r3
  406670:	4602      	mov	r2, r0
  406672:	693b      	ldr	r3, [r7, #16]
  406674:	4313      	orrs	r3, r2
  406676:	613b      	str	r3, [r7, #16]
	return result;
  406678:	693b      	ldr	r3, [r7, #16]
}
  40667a:	4618      	mov	r0, r3
  40667c:	371c      	adds	r7, #28
  40667e:	46bd      	mov	sp, r7
  406680:	bd90      	pop	{r4, r7, pc}
  406682:	bf00      	nop
  406684:	0040caa1 	.word	0x0040caa1
  406688:	0040c8cd 	.word	0x0040c8cd
  40668c:	0040c9d5 	.word	0x0040c9d5

00406690 <inv_icm20648_set_accel_fullscale>:


int inv_icm20648_set_accel_fullscale(struct inv_icm20648 * s, int level)
{
  406690:	b580      	push	{r7, lr}
  406692:	b084      	sub	sp, #16
  406694:	af00      	add	r7, sp, #0
  406696:	6078      	str	r0, [r7, #4]
  406698:	6039      	str	r1, [r7, #0]
	int result;
	s->base_state.accel_fullscale = level;
  40669a:	683b      	ldr	r3, [r7, #0]
  40669c:	b2da      	uxtb	r2, r3
  40669e:	687b      	ldr	r3, [r7, #4]
  4066a0:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	result = inv_icm20648_set_icm20648_accel_fullscale(s, level);
  4066a4:	6839      	ldr	r1, [r7, #0]
  4066a6:	6878      	ldr	r0, [r7, #4]
  4066a8:	4b10      	ldr	r3, [pc, #64]	; (4066ec <inv_icm20648_set_accel_fullscale+0x5c>)
  4066aa:	4798      	blx	r3
  4066ac:	60f8      	str	r0, [r7, #12]
	result |= dmp_icm20648_set_accel_fsr(s, 2<<level);
  4066ae:	2202      	movs	r2, #2
  4066b0:	683b      	ldr	r3, [r7, #0]
  4066b2:	fa02 f303 	lsl.w	r3, r2, r3
  4066b6:	b21b      	sxth	r3, r3
  4066b8:	4619      	mov	r1, r3
  4066ba:	6878      	ldr	r0, [r7, #4]
  4066bc:	4b0c      	ldr	r3, [pc, #48]	; (4066f0 <inv_icm20648_set_accel_fullscale+0x60>)
  4066be:	4798      	blx	r3
  4066c0:	4602      	mov	r2, r0
  4066c2:	68fb      	ldr	r3, [r7, #12]
  4066c4:	4313      	orrs	r3, r2
  4066c6:	60fb      	str	r3, [r7, #12]
	result |= dmp_icm20648_set_accel_scale2(s, 2<<level);
  4066c8:	2202      	movs	r2, #2
  4066ca:	683b      	ldr	r3, [r7, #0]
  4066cc:	fa02 f303 	lsl.w	r3, r2, r3
  4066d0:	b21b      	sxth	r3, r3
  4066d2:	4619      	mov	r1, r3
  4066d4:	6878      	ldr	r0, [r7, #4]
  4066d6:	4b07      	ldr	r3, [pc, #28]	; (4066f4 <inv_icm20648_set_accel_fullscale+0x64>)
  4066d8:	4798      	blx	r3
  4066da:	4602      	mov	r2, r0
  4066dc:	68fb      	ldr	r3, [r7, #12]
  4066de:	4313      	orrs	r3, r2
  4066e0:	60fb      	str	r3, [r7, #12]
	return result;
  4066e2:	68fb      	ldr	r3, [r7, #12]
}
  4066e4:	4618      	mov	r0, r3
  4066e6:	3710      	adds	r7, #16
  4066e8:	46bd      	mov	sp, r7
  4066ea:	bd80      	pop	{r7, pc}
  4066ec:	00406715 	.word	0x00406715
  4066f0:	00408755 	.word	0x00408755
  4066f4:	00408855 	.word	0x00408855

004066f8 <inv_icm20648_get_accel_fullscale>:

uint8_t inv_icm20648_get_accel_fullscale(struct inv_icm20648 * s)
{
  4066f8:	b480      	push	{r7}
  4066fa:	b083      	sub	sp, #12
  4066fc:	af00      	add	r7, sp, #0
  4066fe:	6078      	str	r0, [r7, #4]
	return s->base_state.accel_fullscale;
  406700:	687b      	ldr	r3, [r7, #4]
  406702:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
}
  406706:	4618      	mov	r0, r3
  406708:	370c      	adds	r7, #12
  40670a:	46bd      	mov	sp, r7
  40670c:	f85d 7b04 	ldr.w	r7, [sp], #4
  406710:	4770      	bx	lr
	...

00406714 <inv_icm20648_set_icm20648_accel_fullscale>:


int inv_icm20648_set_icm20648_accel_fullscale(struct inv_icm20648 * s, int level)
{
  406714:	b590      	push	{r4, r7, lr}
  406716:	b087      	sub	sp, #28
  406718:	af00      	add	r7, sp, #0
  40671a:	6078      	str	r0, [r7, #4]
  40671c:	6039      	str	r1, [r7, #0]
	int result = 0;
  40671e:	2300      	movs	r3, #0
  406720:	613b      	str	r3, [r7, #16]
	unsigned char accel_config_1_reg;
	unsigned char accel_config_2_reg;
	unsigned char dec3_cfg;

	if (level >= NUM_MPU_AFS)
  406722:	683b      	ldr	r3, [r7, #0]
  406724:	2b03      	cmp	r3, #3
  406726:	dd02      	ble.n	40672e <inv_icm20648_set_icm20648_accel_fullscale+0x1a>
		return -1;
  406728:	f04f 33ff 	mov.w	r3, #4294967295
  40672c:	e0b2      	b.n	406894 <inv_icm20648_set_icm20648_accel_fullscale+0x180>

	result |= inv_icm20648_read_mems_reg(s, REG_ACCEL_CONFIG, 1, &accel_config_1_reg);
  40672e:	f107 030f 	add.w	r3, r7, #15
  406732:	2201      	movs	r2, #1
  406734:	f44f 718a 	mov.w	r1, #276	; 0x114
  406738:	6878      	ldr	r0, [r7, #4]
  40673a:	4c58      	ldr	r4, [pc, #352]	; (40689c <inv_icm20648_set_icm20648_accel_fullscale+0x188>)
  40673c:	47a0      	blx	r4
  40673e:	4602      	mov	r2, r0
  406740:	693b      	ldr	r3, [r7, #16]
  406742:	4313      	orrs	r3, r2
  406744:	613b      	str	r3, [r7, #16]
	accel_config_1_reg &= 0xC0;
  406746:	7bfb      	ldrb	r3, [r7, #15]
  406748:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  40674c:	b2db      	uxtb	r3, r3
  40674e:	73fb      	strb	r3, [r7, #15]

	if(s->base_state.accel_averaging > 1)
  406750:	687b      	ldr	r3, [r7, #4]
  406752:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
  406756:	2b01      	cmp	r3, #1
  406758:	d90a      	bls.n	406770 <inv_icm20648_set_icm20648_accel_fullscale+0x5c>
		accel_config_1_reg |= (7 << 3) | (level << 1) | 1;   //fchoice = 1, filter = 7.
  40675a:	683b      	ldr	r3, [r7, #0]
  40675c:	005b      	lsls	r3, r3, #1
  40675e:	b2da      	uxtb	r2, r3
  406760:	7bfb      	ldrb	r3, [r7, #15]
  406762:	4313      	orrs	r3, r2
  406764:	b2db      	uxtb	r3, r3
  406766:	f043 0339 	orr.w	r3, r3, #57	; 0x39
  40676a:	b2db      	uxtb	r3, r3
  40676c:	73fb      	strb	r3, [r7, #15]
  40676e:	e008      	b.n	406782 <inv_icm20648_set_icm20648_accel_fullscale+0x6e>
	else
		accel_config_1_reg |= (level << 1) | 0;  //fchoice = 0, filter = 0.
  406770:	683b      	ldr	r3, [r7, #0]
  406772:	005b      	lsls	r3, r3, #1
  406774:	b25a      	sxtb	r2, r3
  406776:	7bfb      	ldrb	r3, [r7, #15]
  406778:	b25b      	sxtb	r3, r3
  40677a:	4313      	orrs	r3, r2
  40677c:	b25b      	sxtb	r3, r3
  40677e:	b2db      	uxtb	r3, r3
  406780:	73fb      	strb	r3, [r7, #15]
	/* /!\ FCHOICE=0 considers we are in low power mode always and allows us to have correct values on raw data since not averaged,
	in case low noise mode is to be supported for 20649, please reconsider this value and update base sample rate from 1125 to 4500...
	*/
	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_CONFIG, accel_config_1_reg);
  406782:	7bfb      	ldrb	r3, [r7, #15]
  406784:	461a      	mov	r2, r3
  406786:	f44f 718a 	mov.w	r1, #276	; 0x114
  40678a:	6878      	ldr	r0, [r7, #4]
  40678c:	4b44      	ldr	r3, [pc, #272]	; (4068a0 <inv_icm20648_set_icm20648_accel_fullscale+0x18c>)
  40678e:	4798      	blx	r3
  406790:	4602      	mov	r2, r0
  406792:	693b      	ldr	r3, [r7, #16]
  406794:	4313      	orrs	r3, r2
  406796:	613b      	str	r3, [r7, #16]

	switch(s->base_state.accel_averaging) {
  406798:	687b      	ldr	r3, [r7, #4]
  40679a:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
  40679e:	3b01      	subs	r3, #1
  4067a0:	2b1f      	cmp	r3, #31
  4067a2:	d852      	bhi.n	40684a <inv_icm20648_set_icm20648_accel_fullscale+0x136>
  4067a4:	a201      	add	r2, pc, #4	; (adr r2, 4067ac <inv_icm20648_set_icm20648_accel_fullscale+0x98>)
  4067a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4067aa:	bf00      	nop
  4067ac:	0040682d 	.word	0x0040682d
  4067b0:	0040684b 	.word	0x0040684b
  4067b4:	0040684b 	.word	0x0040684b
  4067b8:	00406833 	.word	0x00406833
  4067bc:	0040684b 	.word	0x0040684b
  4067c0:	0040684b 	.word	0x0040684b
  4067c4:	0040684b 	.word	0x0040684b
  4067c8:	00406839 	.word	0x00406839
  4067cc:	0040684b 	.word	0x0040684b
  4067d0:	0040684b 	.word	0x0040684b
  4067d4:	0040684b 	.word	0x0040684b
  4067d8:	0040684b 	.word	0x0040684b
  4067dc:	0040684b 	.word	0x0040684b
  4067e0:	0040684b 	.word	0x0040684b
  4067e4:	0040684b 	.word	0x0040684b
  4067e8:	0040683f 	.word	0x0040683f
  4067ec:	0040684b 	.word	0x0040684b
  4067f0:	0040684b 	.word	0x0040684b
  4067f4:	0040684b 	.word	0x0040684b
  4067f8:	0040684b 	.word	0x0040684b
  4067fc:	0040684b 	.word	0x0040684b
  406800:	0040684b 	.word	0x0040684b
  406804:	0040684b 	.word	0x0040684b
  406808:	0040684b 	.word	0x0040684b
  40680c:	0040684b 	.word	0x0040684b
  406810:	0040684b 	.word	0x0040684b
  406814:	0040684b 	.word	0x0040684b
  406818:	0040684b 	.word	0x0040684b
  40681c:	0040684b 	.word	0x0040684b
  406820:	0040684b 	.word	0x0040684b
  406824:	0040684b 	.word	0x0040684b
  406828:	00406845 	.word	0x00406845
		case 1:
			dec3_cfg = 0;
  40682c:	2300      	movs	r3, #0
  40682e:	75fb      	strb	r3, [r7, #23]
			break;
  406830:	e00e      	b.n	406850 <inv_icm20648_set_icm20648_accel_fullscale+0x13c>

		case 4:
			dec3_cfg = 0;
  406832:	2300      	movs	r3, #0
  406834:	75fb      	strb	r3, [r7, #23]
			break;
  406836:	e00b      	b.n	406850 <inv_icm20648_set_icm20648_accel_fullscale+0x13c>

		case 8:
			dec3_cfg = 1;
  406838:	2301      	movs	r3, #1
  40683a:	75fb      	strb	r3, [r7, #23]
			break;
  40683c:	e008      	b.n	406850 <inv_icm20648_set_icm20648_accel_fullscale+0x13c>

		case 16:
			dec3_cfg = 2;
  40683e:	2302      	movs	r3, #2
  406840:	75fb      	strb	r3, [r7, #23]
			break;
  406842:	e005      	b.n	406850 <inv_icm20648_set_icm20648_accel_fullscale+0x13c>

		case 32:
			dec3_cfg = 3;
  406844:	2303      	movs	r3, #3
  406846:	75fb      	strb	r3, [r7, #23]
			break;
  406848:	e002      	b.n	406850 <inv_icm20648_set_icm20648_accel_fullscale+0x13c>

		default:
			dec3_cfg = 0;
  40684a:	2300      	movs	r3, #0
  40684c:	75fb      	strb	r3, [r7, #23]
			break;
  40684e:	bf00      	nop
	}

	result |= inv_icm20648_read_mems_reg(s, REG_ACCEL_CONFIG_2, 1, &accel_config_2_reg);
  406850:	f107 030e 	add.w	r3, r7, #14
  406854:	2201      	movs	r2, #1
  406856:	f240 1115 	movw	r1, #277	; 0x115
  40685a:	6878      	ldr	r0, [r7, #4]
  40685c:	4c0f      	ldr	r4, [pc, #60]	; (40689c <inv_icm20648_set_icm20648_accel_fullscale+0x188>)
  40685e:	47a0      	blx	r4
  406860:	4602      	mov	r2, r0
  406862:	693b      	ldr	r3, [r7, #16]
  406864:	4313      	orrs	r3, r2
  406866:	613b      	str	r3, [r7, #16]
	accel_config_2_reg &= 0xFC;
  406868:	7bbb      	ldrb	r3, [r7, #14]
  40686a:	f023 0303 	bic.w	r3, r3, #3
  40686e:	b2db      	uxtb	r3, r3
  406870:	73bb      	strb	r3, [r7, #14]

	accel_config_2_reg |=  dec3_cfg;
  406872:	7bba      	ldrb	r2, [r7, #14]
  406874:	7dfb      	ldrb	r3, [r7, #23]
  406876:	4313      	orrs	r3, r2
  406878:	b2db      	uxtb	r3, r3
  40687a:	73bb      	strb	r3, [r7, #14]
	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, accel_config_2_reg);
  40687c:	7bbb      	ldrb	r3, [r7, #14]
  40687e:	461a      	mov	r2, r3
  406880:	f240 1115 	movw	r1, #277	; 0x115
  406884:	6878      	ldr	r0, [r7, #4]
  406886:	4b06      	ldr	r3, [pc, #24]	; (4068a0 <inv_icm20648_set_icm20648_accel_fullscale+0x18c>)
  406888:	4798      	blx	r3
  40688a:	4602      	mov	r2, r0
  40688c:	693b      	ldr	r3, [r7, #16]
  40688e:	4313      	orrs	r3, r2
  406890:	613b      	str	r3, [r7, #16]

	return result;
  406892:	693b      	ldr	r3, [r7, #16]
}
  406894:	4618      	mov	r0, r3
  406896:	371c      	adds	r7, #28
  406898:	46bd      	mov	sp, r7
  40689a:	bd90      	pop	{r4, r7, pc}
  40689c:	0040caa1 	.word	0x0040caa1
  4068a0:	0040c9d5 	.word	0x0040c9d5

004068a4 <inv_icm20648_enable_hw_sensors>:


int inv_icm20648_enable_hw_sensors(struct inv_icm20648 * s, int bit_mask)
{
  4068a4:	b590      	push	{r4, r7, lr}
  4068a6:	b085      	sub	sp, #20
  4068a8:	af00      	add	r7, sp, #0
  4068aa:	6078      	str	r0, [r7, #4]
  4068ac:	6039      	str	r1, [r7, #0]
	int rc = 0;
  4068ae:	2300      	movs	r3, #0
  4068b0:	60fb      	str	r3, [r7, #12]

	if ((s->base_state.pwr_mgmt_2 == (BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY | BIT_PWR_PRESSURE_STBY)) | (bit_mask & 0x80)) {
  4068b2:	687b      	ldr	r3, [r7, #4]
  4068b4:	7edb      	ldrb	r3, [r3, #27]
  4068b6:	2b7f      	cmp	r3, #127	; 0x7f
  4068b8:	bf0c      	ite	eq
  4068ba:	2301      	moveq	r3, #1
  4068bc:	2300      	movne	r3, #0
  4068be:	b2db      	uxtb	r3, r3
  4068c0:	461a      	mov	r2, r3
  4068c2:	683b      	ldr	r3, [r7, #0]
  4068c4:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4068c8:	4313      	orrs	r3, r2
  4068ca:	2b00      	cmp	r3, #0
  4068cc:	d02d      	beq.n	40692a <inv_icm20648_enable_hw_sensors+0x86>
		// All sensors off, or override is on
		s->base_state.pwr_mgmt_2 = 0; // Zero means all sensors are on
  4068ce:	687b      	ldr	r3, [r7, #4]
  4068d0:	2200      	movs	r2, #0
  4068d2:	76da      	strb	r2, [r3, #27]
		// Gyro and Accel were off
		if ((bit_mask & 2) == 0) {
  4068d4:	683b      	ldr	r3, [r7, #0]
  4068d6:	f003 0302 	and.w	r3, r3, #2
  4068da:	2b00      	cmp	r3, #0
  4068dc:	d102      	bne.n	4068e4 <inv_icm20648_enable_hw_sensors+0x40>
			s->base_state.pwr_mgmt_2 = BIT_PWR_ACCEL_STBY; // Turn off accel
  4068de:	687b      	ldr	r3, [r7, #4]
  4068e0:	2238      	movs	r2, #56	; 0x38
  4068e2:	76da      	strb	r2, [r3, #27]
		}
		if ((bit_mask & 1) == 0) {
  4068e4:	683b      	ldr	r3, [r7, #0]
  4068e6:	f003 0301 	and.w	r3, r3, #1
  4068ea:	2b00      	cmp	r3, #0
  4068ec:	d106      	bne.n	4068fc <inv_icm20648_enable_hw_sensors+0x58>
			s->base_state.pwr_mgmt_2 |= BIT_PWR_GYRO_STBY; // Turn off gyro
  4068ee:	687b      	ldr	r3, [r7, #4]
  4068f0:	7edb      	ldrb	r3, [r3, #27]
  4068f2:	f043 0307 	orr.w	r3, r3, #7
  4068f6:	b2da      	uxtb	r2, r3
  4068f8:	687b      	ldr	r3, [r7, #4]
  4068fa:	76da      	strb	r2, [r3, #27]
		}
		if ((bit_mask & 4) == 0) {
  4068fc:	683b      	ldr	r3, [r7, #0]
  4068fe:	f003 0304 	and.w	r3, r3, #4
  406902:	2b00      	cmp	r3, #0
  406904:	d106      	bne.n	406914 <inv_icm20648_enable_hw_sensors+0x70>
			s->base_state.pwr_mgmt_2 |= BIT_PWR_PRESSURE_STBY; // Turn off pressure
  406906:	687b      	ldr	r3, [r7, #4]
  406908:	7edb      	ldrb	r3, [r3, #27]
  40690a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40690e:	b2da      	uxtb	r2, r3
  406910:	687b      	ldr	r3, [r7, #4]
  406912:	76da      	strb	r2, [r3, #27]
		}

		rc |= inv_icm20648_write_mems_reg(s, REG_PWR_MGMT_2, 1, &s->base_state.pwr_mgmt_2);
  406914:	687b      	ldr	r3, [r7, #4]
  406916:	331b      	adds	r3, #27
  406918:	2201      	movs	r2, #1
  40691a:	2107      	movs	r1, #7
  40691c:	6878      	ldr	r0, [r7, #4]
  40691e:	4c0f      	ldr	r4, [pc, #60]	; (40695c <inv_icm20648_enable_hw_sensors+0xb8>)
  406920:	47a0      	blx	r4
  406922:	4602      	mov	r2, r0
  406924:	68fb      	ldr	r3, [r7, #12]
  406926:	4313      	orrs	r3, r2
  406928:	60fb      	str	r3, [r7, #12]
	}

	if (bit_mask & SECONDARY_COMPASS_AVAILABLE) {
  40692a:	683b      	ldr	r3, [r7, #0]
  40692c:	f003 0308 	and.w	r3, r3, #8
  406930:	2b00      	cmp	r3, #0
  406932:	d007      	beq.n	406944 <inv_icm20648_enable_hw_sensors+0xa0>
		rc |= inv_icm20648_resume_akm(s);
  406934:	6878      	ldr	r0, [r7, #4]
  406936:	4b0a      	ldr	r3, [pc, #40]	; (406960 <inv_icm20648_enable_hw_sensors+0xbc>)
  406938:	4798      	blx	r3
  40693a:	4602      	mov	r2, r0
  40693c:	68fb      	ldr	r3, [r7, #12]
  40693e:	4313      	orrs	r3, r2
  406940:	60fb      	str	r3, [r7, #12]
  406942:	e006      	b.n	406952 <inv_icm20648_enable_hw_sensors+0xae>
	}
	else {
		rc |= inv_icm20648_suspend_akm(s);
  406944:	6878      	ldr	r0, [r7, #4]
  406946:	4b07      	ldr	r3, [pc, #28]	; (406964 <inv_icm20648_enable_hw_sensors+0xc0>)
  406948:	4798      	blx	r3
  40694a:	4602      	mov	r2, r0
  40694c:	68fb      	ldr	r3, [r7, #12]
  40694e:	4313      	orrs	r3, r2
  406950:	60fb      	str	r3, [r7, #12]
	}

	return rc;
  406952:	68fb      	ldr	r3, [r7, #12]
}
  406954:	4618      	mov	r0, r3
  406956:	3714      	adds	r7, #20
  406958:	46bd      	mov	sp, r7
  40695a:	bd90      	pop	{r4, r7, pc}
  40695c:	0040c8cd 	.word	0x0040c8cd
  406960:	00405141 	.word	0x00405141
  406964:	004050dd 	.word	0x004050dd

00406968 <invn_convert_quat_mult_fxp>:
#include <math.h>

static void invn_convert_quat_invert_fxp(const long *quat_q30, long *invQuat_q30);

static void invn_convert_quat_mult_fxp(const long *quat1_q30, const long *quat2_q30, long *quatProd_q30)
{
  406968:	b5b0      	push	{r4, r5, r7, lr}
  40696a:	b084      	sub	sp, #16
  40696c:	af00      	add	r7, sp, #0
  40696e:	60f8      	str	r0, [r7, #12]
  406970:	60b9      	str	r1, [r7, #8]
  406972:	607a      	str	r2, [r7, #4]
    quatProd_q30[0] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[0]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[1]) -
  406974:	68fb      	ldr	r3, [r7, #12]
  406976:	681a      	ldr	r2, [r3, #0]
  406978:	68bb      	ldr	r3, [r7, #8]
  40697a:	681b      	ldr	r3, [r3, #0]
  40697c:	4619      	mov	r1, r3
  40697e:	4610      	mov	r0, r2
  406980:	4b5f      	ldr	r3, [pc, #380]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406982:	4798      	blx	r3
  406984:	4604      	mov	r4, r0
  406986:	68fb      	ldr	r3, [r7, #12]
  406988:	3304      	adds	r3, #4
  40698a:	681a      	ldr	r2, [r3, #0]
  40698c:	68bb      	ldr	r3, [r7, #8]
  40698e:	3304      	adds	r3, #4
  406990:	681b      	ldr	r3, [r3, #0]
  406992:	4619      	mov	r1, r3
  406994:	4610      	mov	r0, r2
  406996:	4b5a      	ldr	r3, [pc, #360]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406998:	4798      	blx	r3
  40699a:	4603      	mov	r3, r0
  40699c:	1ae4      	subs	r4, r4, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[2]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[3]);
  40699e:	68fb      	ldr	r3, [r7, #12]
  4069a0:	3308      	adds	r3, #8
  4069a2:	681a      	ldr	r2, [r3, #0]
  4069a4:	68bb      	ldr	r3, [r7, #8]
  4069a6:	3308      	adds	r3, #8
  4069a8:	681b      	ldr	r3, [r3, #0]
  4069aa:	4619      	mov	r1, r3
  4069ac:	4610      	mov	r0, r2
  4069ae:	4b54      	ldr	r3, [pc, #336]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  4069b0:	4798      	blx	r3
  4069b2:	4603      	mov	r3, r0
    quatProd_q30[0] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[0]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[1]) -
  4069b4:	1ae4      	subs	r4, r4, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[2]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[3]);
  4069b6:	68fb      	ldr	r3, [r7, #12]
  4069b8:	330c      	adds	r3, #12
  4069ba:	681a      	ldr	r2, [r3, #0]
  4069bc:	68bb      	ldr	r3, [r7, #8]
  4069be:	330c      	adds	r3, #12
  4069c0:	681b      	ldr	r3, [r3, #0]
  4069c2:	4619      	mov	r1, r3
  4069c4:	4610      	mov	r0, r2
  4069c6:	4b4e      	ldr	r3, [pc, #312]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  4069c8:	4798      	blx	r3
  4069ca:	4603      	mov	r3, r0
  4069cc:	1ae2      	subs	r2, r4, r3
    quatProd_q30[0] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[0]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[1]) -
  4069ce:	687b      	ldr	r3, [r7, #4]
  4069d0:	601a      	str	r2, [r3, #0]

    quatProd_q30[1] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[1]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[0]) +
  4069d2:	687b      	ldr	r3, [r7, #4]
  4069d4:	1d1c      	adds	r4, r3, #4
  4069d6:	68fb      	ldr	r3, [r7, #12]
  4069d8:	681a      	ldr	r2, [r3, #0]
  4069da:	68bb      	ldr	r3, [r7, #8]
  4069dc:	3304      	adds	r3, #4
  4069de:	681b      	ldr	r3, [r3, #0]
  4069e0:	4619      	mov	r1, r3
  4069e2:	4610      	mov	r0, r2
  4069e4:	4b46      	ldr	r3, [pc, #280]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  4069e6:	4798      	blx	r3
  4069e8:	4605      	mov	r5, r0
  4069ea:	68fb      	ldr	r3, [r7, #12]
  4069ec:	3304      	adds	r3, #4
  4069ee:	681a      	ldr	r2, [r3, #0]
  4069f0:	68bb      	ldr	r3, [r7, #8]
  4069f2:	681b      	ldr	r3, [r3, #0]
  4069f4:	4619      	mov	r1, r3
  4069f6:	4610      	mov	r0, r2
  4069f8:	4b41      	ldr	r3, [pc, #260]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  4069fa:	4798      	blx	r3
  4069fc:	4603      	mov	r3, r0
  4069fe:	441d      	add	r5, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[3]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[2]);
  406a00:	68fb      	ldr	r3, [r7, #12]
  406a02:	3308      	adds	r3, #8
  406a04:	681a      	ldr	r2, [r3, #0]
  406a06:	68bb      	ldr	r3, [r7, #8]
  406a08:	330c      	adds	r3, #12
  406a0a:	681b      	ldr	r3, [r3, #0]
  406a0c:	4619      	mov	r1, r3
  406a0e:	4610      	mov	r0, r2
  406a10:	4b3b      	ldr	r3, [pc, #236]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406a12:	4798      	blx	r3
  406a14:	4603      	mov	r3, r0
    quatProd_q30[1] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[1]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[0]) +
  406a16:	441d      	add	r5, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[3]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[2]);
  406a18:	68fb      	ldr	r3, [r7, #12]
  406a1a:	330c      	adds	r3, #12
  406a1c:	681a      	ldr	r2, [r3, #0]
  406a1e:	68bb      	ldr	r3, [r7, #8]
  406a20:	3308      	adds	r3, #8
  406a22:	681b      	ldr	r3, [r3, #0]
  406a24:	4619      	mov	r1, r3
  406a26:	4610      	mov	r0, r2
  406a28:	4b35      	ldr	r3, [pc, #212]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406a2a:	4798      	blx	r3
  406a2c:	4603      	mov	r3, r0
  406a2e:	1aeb      	subs	r3, r5, r3
    quatProd_q30[1] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[1]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[0]) +
  406a30:	6023      	str	r3, [r4, #0]

    quatProd_q30[2] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[2]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[3]) +
  406a32:	687b      	ldr	r3, [r7, #4]
  406a34:	f103 0408 	add.w	r4, r3, #8
  406a38:	68fb      	ldr	r3, [r7, #12]
  406a3a:	681a      	ldr	r2, [r3, #0]
  406a3c:	68bb      	ldr	r3, [r7, #8]
  406a3e:	3308      	adds	r3, #8
  406a40:	681b      	ldr	r3, [r3, #0]
  406a42:	4619      	mov	r1, r3
  406a44:	4610      	mov	r0, r2
  406a46:	4b2e      	ldr	r3, [pc, #184]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406a48:	4798      	blx	r3
  406a4a:	4605      	mov	r5, r0
  406a4c:	68fb      	ldr	r3, [r7, #12]
  406a4e:	3304      	adds	r3, #4
  406a50:	681a      	ldr	r2, [r3, #0]
  406a52:	68bb      	ldr	r3, [r7, #8]
  406a54:	330c      	adds	r3, #12
  406a56:	681b      	ldr	r3, [r3, #0]
  406a58:	4619      	mov	r1, r3
  406a5a:	4610      	mov	r0, r2
  406a5c:	4b28      	ldr	r3, [pc, #160]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406a5e:	4798      	blx	r3
  406a60:	4603      	mov	r3, r0
  406a62:	1aed      	subs	r5, r5, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[0]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[1]);
  406a64:	68fb      	ldr	r3, [r7, #12]
  406a66:	3308      	adds	r3, #8
  406a68:	681a      	ldr	r2, [r3, #0]
  406a6a:	68bb      	ldr	r3, [r7, #8]
  406a6c:	681b      	ldr	r3, [r3, #0]
  406a6e:	4619      	mov	r1, r3
  406a70:	4610      	mov	r0, r2
  406a72:	4b23      	ldr	r3, [pc, #140]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406a74:	4798      	blx	r3
  406a76:	4603      	mov	r3, r0
    quatProd_q30[2] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[2]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[3]) +
  406a78:	441d      	add	r5, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[0]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[1]);
  406a7a:	68fb      	ldr	r3, [r7, #12]
  406a7c:	330c      	adds	r3, #12
  406a7e:	681a      	ldr	r2, [r3, #0]
  406a80:	68bb      	ldr	r3, [r7, #8]
  406a82:	3304      	adds	r3, #4
  406a84:	681b      	ldr	r3, [r3, #0]
  406a86:	4619      	mov	r1, r3
  406a88:	4610      	mov	r0, r2
  406a8a:	4b1d      	ldr	r3, [pc, #116]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406a8c:	4798      	blx	r3
  406a8e:	4603      	mov	r3, r0
  406a90:	442b      	add	r3, r5
    quatProd_q30[2] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[2]) - inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[3]) +
  406a92:	6023      	str	r3, [r4, #0]

    quatProd_q30[3] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[3]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[2]) -
  406a94:	687b      	ldr	r3, [r7, #4]
  406a96:	f103 040c 	add.w	r4, r3, #12
  406a9a:	68fb      	ldr	r3, [r7, #12]
  406a9c:	681a      	ldr	r2, [r3, #0]
  406a9e:	68bb      	ldr	r3, [r7, #8]
  406aa0:	330c      	adds	r3, #12
  406aa2:	681b      	ldr	r3, [r3, #0]
  406aa4:	4619      	mov	r1, r3
  406aa6:	4610      	mov	r0, r2
  406aa8:	4b15      	ldr	r3, [pc, #84]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406aaa:	4798      	blx	r3
  406aac:	4605      	mov	r5, r0
  406aae:	68fb      	ldr	r3, [r7, #12]
  406ab0:	3304      	adds	r3, #4
  406ab2:	681a      	ldr	r2, [r3, #0]
  406ab4:	68bb      	ldr	r3, [r7, #8]
  406ab6:	3308      	adds	r3, #8
  406ab8:	681b      	ldr	r3, [r3, #0]
  406aba:	4619      	mov	r1, r3
  406abc:	4610      	mov	r0, r2
  406abe:	4b10      	ldr	r3, [pc, #64]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406ac0:	4798      	blx	r3
  406ac2:	4603      	mov	r3, r0
  406ac4:	441d      	add	r5, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[1]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[0]);
  406ac6:	68fb      	ldr	r3, [r7, #12]
  406ac8:	3308      	adds	r3, #8
  406aca:	681a      	ldr	r2, [r3, #0]
  406acc:	68bb      	ldr	r3, [r7, #8]
  406ace:	3304      	adds	r3, #4
  406ad0:	681b      	ldr	r3, [r3, #0]
  406ad2:	4619      	mov	r1, r3
  406ad4:	4610      	mov	r0, r2
  406ad6:	4b0a      	ldr	r3, [pc, #40]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406ad8:	4798      	blx	r3
  406ada:	4603      	mov	r3, r0
    quatProd_q30[3] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[3]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[2]) -
  406adc:	1aed      	subs	r5, r5, r3
               inv_icm20648_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[1]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[0]);
  406ade:	68fb      	ldr	r3, [r7, #12]
  406ae0:	330c      	adds	r3, #12
  406ae2:	681a      	ldr	r2, [r3, #0]
  406ae4:	68bb      	ldr	r3, [r7, #8]
  406ae6:	681b      	ldr	r3, [r3, #0]
  406ae8:	4619      	mov	r1, r3
  406aea:	4610      	mov	r0, r2
  406aec:	4b04      	ldr	r3, [pc, #16]	; (406b00 <invn_convert_quat_mult_fxp+0x198>)
  406aee:	4798      	blx	r3
  406af0:	4603      	mov	r3, r0
  406af2:	442b      	add	r3, r5
    quatProd_q30[3] = inv_icm20648_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[3]) + inv_icm20648_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[2]) -
  406af4:	6023      	str	r3, [r4, #0]
}
  406af6:	bf00      	nop
  406af8:	3710      	adds	r7, #16
  406afa:	46bd      	mov	sp, r7
  406afc:	bdb0      	pop	{r4, r5, r7, pc}
  406afe:	bf00      	nop
  406b00:	004070d1 	.word	0x004070d1

00406b04 <invn_convert_quat_invert_fxp>:

static void invn_convert_quat_invert_fxp(const long *quat_q30, long *invQuat_q30)
{
  406b04:	b480      	push	{r7}
  406b06:	b083      	sub	sp, #12
  406b08:	af00      	add	r7, sp, #0
  406b0a:	6078      	str	r0, [r7, #4]
  406b0c:	6039      	str	r1, [r7, #0]
    invQuat_q30[0] = quat_q30[0];
  406b0e:	687b      	ldr	r3, [r7, #4]
  406b10:	681a      	ldr	r2, [r3, #0]
  406b12:	683b      	ldr	r3, [r7, #0]
  406b14:	601a      	str	r2, [r3, #0]
    invQuat_q30[1] = -quat_q30[1];
  406b16:	683b      	ldr	r3, [r7, #0]
  406b18:	3304      	adds	r3, #4
  406b1a:	687a      	ldr	r2, [r7, #4]
  406b1c:	3204      	adds	r2, #4
  406b1e:	6812      	ldr	r2, [r2, #0]
  406b20:	4252      	negs	r2, r2
  406b22:	601a      	str	r2, [r3, #0]
    invQuat_q30[2] = -quat_q30[2];
  406b24:	683b      	ldr	r3, [r7, #0]
  406b26:	3308      	adds	r3, #8
  406b28:	687a      	ldr	r2, [r7, #4]
  406b2a:	3208      	adds	r2, #8
  406b2c:	6812      	ldr	r2, [r2, #0]
  406b2e:	4252      	negs	r2, r2
  406b30:	601a      	str	r2, [r3, #0]
    invQuat_q30[3] = -quat_q30[3];
  406b32:	683b      	ldr	r3, [r7, #0]
  406b34:	330c      	adds	r3, #12
  406b36:	687a      	ldr	r2, [r7, #4]
  406b38:	320c      	adds	r2, #12
  406b3a:	6812      	ldr	r2, [r2, #0]
  406b3c:	4252      	negs	r2, r2
  406b3e:	601a      	str	r2, [r3, #0]
}
  406b40:	bf00      	nop
  406b42:	370c      	adds	r7, #12
  406b44:	46bd      	mov	sp, r7
  406b46:	f85d 7b04 	ldr.w	r7, [sp], #4
  406b4a:	4770      	bx	lr

00406b4c <inv_icm20648_q_mult_q_qi>:

void inv_icm20648_q_mult_q_qi(const long *q1, const long *q2, long *qProd)
{
  406b4c:	b5b0      	push	{r4, r5, r7, lr}
  406b4e:	b084      	sub	sp, #16
  406b50:	af00      	add	r7, sp, #0
  406b52:	60f8      	str	r0, [r7, #12]
  406b54:	60b9      	str	r1, [r7, #8]
  406b56:	607a      	str	r2, [r7, #4]
    qProd[0] = inv_icm20648_convert_mult_q30_fxp(q1[0], q2[0]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[1]) +
  406b58:	68fb      	ldr	r3, [r7, #12]
  406b5a:	681a      	ldr	r2, [r3, #0]
  406b5c:	68bb      	ldr	r3, [r7, #8]
  406b5e:	681b      	ldr	r3, [r3, #0]
  406b60:	4619      	mov	r1, r3
  406b62:	4610      	mov	r0, r2
  406b64:	4b5f      	ldr	r3, [pc, #380]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406b66:	4798      	blx	r3
  406b68:	4604      	mov	r4, r0
  406b6a:	68fb      	ldr	r3, [r7, #12]
  406b6c:	3304      	adds	r3, #4
  406b6e:	681a      	ldr	r2, [r3, #0]
  406b70:	68bb      	ldr	r3, [r7, #8]
  406b72:	3304      	adds	r3, #4
  406b74:	681b      	ldr	r3, [r3, #0]
  406b76:	4619      	mov	r1, r3
  406b78:	4610      	mov	r0, r2
  406b7a:	4b5a      	ldr	r3, [pc, #360]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406b7c:	4798      	blx	r3
  406b7e:	4603      	mov	r3, r0
  406b80:	441c      	add	r4, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[2]) + inv_icm20648_convert_mult_q30_fxp(q1[3], q2[3]);
  406b82:	68fb      	ldr	r3, [r7, #12]
  406b84:	3308      	adds	r3, #8
  406b86:	681a      	ldr	r2, [r3, #0]
  406b88:	68bb      	ldr	r3, [r7, #8]
  406b8a:	3308      	adds	r3, #8
  406b8c:	681b      	ldr	r3, [r3, #0]
  406b8e:	4619      	mov	r1, r3
  406b90:	4610      	mov	r0, r2
  406b92:	4b54      	ldr	r3, [pc, #336]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406b94:	4798      	blx	r3
  406b96:	4603      	mov	r3, r0
    qProd[0] = inv_icm20648_convert_mult_q30_fxp(q1[0], q2[0]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[1]) +
  406b98:	441c      	add	r4, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[2]) + inv_icm20648_convert_mult_q30_fxp(q1[3], q2[3]);
  406b9a:	68fb      	ldr	r3, [r7, #12]
  406b9c:	330c      	adds	r3, #12
  406b9e:	681a      	ldr	r2, [r3, #0]
  406ba0:	68bb      	ldr	r3, [r7, #8]
  406ba2:	330c      	adds	r3, #12
  406ba4:	681b      	ldr	r3, [r3, #0]
  406ba6:	4619      	mov	r1, r3
  406ba8:	4610      	mov	r0, r2
  406baa:	4b4e      	ldr	r3, [pc, #312]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406bac:	4798      	blx	r3
  406bae:	4603      	mov	r3, r0
  406bb0:	18e2      	adds	r2, r4, r3
    qProd[0] = inv_icm20648_convert_mult_q30_fxp(q1[0], q2[0]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[1]) +
  406bb2:	687b      	ldr	r3, [r7, #4]
  406bb4:	601a      	str	r2, [r3, #0]

    qProd[1] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[1]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[0]) -
  406bb6:	687b      	ldr	r3, [r7, #4]
  406bb8:	1d1c      	adds	r4, r3, #4
  406bba:	68fb      	ldr	r3, [r7, #12]
  406bbc:	3304      	adds	r3, #4
  406bbe:	681a      	ldr	r2, [r3, #0]
  406bc0:	68bb      	ldr	r3, [r7, #8]
  406bc2:	681b      	ldr	r3, [r3, #0]
  406bc4:	4619      	mov	r1, r3
  406bc6:	4610      	mov	r0, r2
  406bc8:	4b46      	ldr	r3, [pc, #280]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406bca:	4798      	blx	r3
  406bcc:	4605      	mov	r5, r0
  406bce:	68fb      	ldr	r3, [r7, #12]
  406bd0:	681a      	ldr	r2, [r3, #0]
  406bd2:	68bb      	ldr	r3, [r7, #8]
  406bd4:	3304      	adds	r3, #4
  406bd6:	681b      	ldr	r3, [r3, #0]
  406bd8:	4619      	mov	r1, r3
  406bda:	4610      	mov	r0, r2
  406bdc:	4b41      	ldr	r3, [pc, #260]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406bde:	4798      	blx	r3
  406be0:	4603      	mov	r3, r0
  406be2:	1aed      	subs	r5, r5, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[3]) + inv_icm20648_convert_mult_q30_fxp(q1[3], q2[2]);
  406be4:	68fb      	ldr	r3, [r7, #12]
  406be6:	3308      	adds	r3, #8
  406be8:	681a      	ldr	r2, [r3, #0]
  406bea:	68bb      	ldr	r3, [r7, #8]
  406bec:	330c      	adds	r3, #12
  406bee:	681b      	ldr	r3, [r3, #0]
  406bf0:	4619      	mov	r1, r3
  406bf2:	4610      	mov	r0, r2
  406bf4:	4b3b      	ldr	r3, [pc, #236]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406bf6:	4798      	blx	r3
  406bf8:	4603      	mov	r3, r0
    qProd[1] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[1]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[0]) -
  406bfa:	1aed      	subs	r5, r5, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[3]) + inv_icm20648_convert_mult_q30_fxp(q1[3], q2[2]);
  406bfc:	68fb      	ldr	r3, [r7, #12]
  406bfe:	330c      	adds	r3, #12
  406c00:	681a      	ldr	r2, [r3, #0]
  406c02:	68bb      	ldr	r3, [r7, #8]
  406c04:	3308      	adds	r3, #8
  406c06:	681b      	ldr	r3, [r3, #0]
  406c08:	4619      	mov	r1, r3
  406c0a:	4610      	mov	r0, r2
  406c0c:	4b35      	ldr	r3, [pc, #212]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406c0e:	4798      	blx	r3
  406c10:	4603      	mov	r3, r0
  406c12:	442b      	add	r3, r5
    qProd[1] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[1]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[0]) -
  406c14:	6023      	str	r3, [r4, #0]

    qProd[2] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[2]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[3]) +
  406c16:	687b      	ldr	r3, [r7, #4]
  406c18:	f103 0408 	add.w	r4, r3, #8
  406c1c:	68fb      	ldr	r3, [r7, #12]
  406c1e:	3304      	adds	r3, #4
  406c20:	681a      	ldr	r2, [r3, #0]
  406c22:	68bb      	ldr	r3, [r7, #8]
  406c24:	330c      	adds	r3, #12
  406c26:	681b      	ldr	r3, [r3, #0]
  406c28:	4619      	mov	r1, r3
  406c2a:	4610      	mov	r0, r2
  406c2c:	4b2d      	ldr	r3, [pc, #180]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406c2e:	4798      	blx	r3
  406c30:	4605      	mov	r5, r0
  406c32:	68fb      	ldr	r3, [r7, #12]
  406c34:	681a      	ldr	r2, [r3, #0]
  406c36:	68bb      	ldr	r3, [r7, #8]
  406c38:	3308      	adds	r3, #8
  406c3a:	681b      	ldr	r3, [r3, #0]
  406c3c:	4619      	mov	r1, r3
  406c3e:	4610      	mov	r0, r2
  406c40:	4b28      	ldr	r3, [pc, #160]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406c42:	4798      	blx	r3
  406c44:	4603      	mov	r3, r0
  406c46:	1aed      	subs	r5, r5, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[0]) - inv_icm20648_convert_mult_q30_fxp(q1[3], q2[1]);
  406c48:	68fb      	ldr	r3, [r7, #12]
  406c4a:	3308      	adds	r3, #8
  406c4c:	681a      	ldr	r2, [r3, #0]
  406c4e:	68bb      	ldr	r3, [r7, #8]
  406c50:	681b      	ldr	r3, [r3, #0]
  406c52:	4619      	mov	r1, r3
  406c54:	4610      	mov	r0, r2
  406c56:	4b23      	ldr	r3, [pc, #140]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406c58:	4798      	blx	r3
  406c5a:	4603      	mov	r3, r0
    qProd[2] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[2]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[3]) +
  406c5c:	441d      	add	r5, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[0]) - inv_icm20648_convert_mult_q30_fxp(q1[3], q2[1]);
  406c5e:	68fb      	ldr	r3, [r7, #12]
  406c60:	330c      	adds	r3, #12
  406c62:	681a      	ldr	r2, [r3, #0]
  406c64:	68bb      	ldr	r3, [r7, #8]
  406c66:	3304      	adds	r3, #4
  406c68:	681b      	ldr	r3, [r3, #0]
  406c6a:	4619      	mov	r1, r3
  406c6c:	4610      	mov	r0, r2
  406c6e:	4b1d      	ldr	r3, [pc, #116]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406c70:	4798      	blx	r3
  406c72:	4603      	mov	r3, r0
  406c74:	1aeb      	subs	r3, r5, r3
    qProd[2] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[2]) + inv_icm20648_convert_mult_q30_fxp(q1[1], q2[3]) +
  406c76:	6023      	str	r3, [r4, #0]

    qProd[3] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[3]) - inv_icm20648_convert_mult_q30_fxp(q1[1], q2[2]) +
  406c78:	687b      	ldr	r3, [r7, #4]
  406c7a:	f103 040c 	add.w	r4, r3, #12
  406c7e:	68fb      	ldr	r3, [r7, #12]
  406c80:	681a      	ldr	r2, [r3, #0]
  406c82:	68bb      	ldr	r3, [r7, #8]
  406c84:	330c      	adds	r3, #12
  406c86:	681b      	ldr	r3, [r3, #0]
  406c88:	4619      	mov	r1, r3
  406c8a:	4610      	mov	r0, r2
  406c8c:	4b15      	ldr	r3, [pc, #84]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406c8e:	4798      	blx	r3
  406c90:	4603      	mov	r3, r0
  406c92:	425d      	negs	r5, r3
  406c94:	68fb      	ldr	r3, [r7, #12]
  406c96:	3304      	adds	r3, #4
  406c98:	681a      	ldr	r2, [r3, #0]
  406c9a:	68bb      	ldr	r3, [r7, #8]
  406c9c:	3308      	adds	r3, #8
  406c9e:	681b      	ldr	r3, [r3, #0]
  406ca0:	4619      	mov	r1, r3
  406ca2:	4610      	mov	r0, r2
  406ca4:	4b0f      	ldr	r3, [pc, #60]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406ca6:	4798      	blx	r3
  406ca8:	4603      	mov	r3, r0
  406caa:	1aed      	subs	r5, r5, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[1]) + inv_icm20648_convert_mult_q30_fxp(q1[3], q2[0]);
  406cac:	68fb      	ldr	r3, [r7, #12]
  406cae:	3308      	adds	r3, #8
  406cb0:	681a      	ldr	r2, [r3, #0]
  406cb2:	68bb      	ldr	r3, [r7, #8]
  406cb4:	3304      	adds	r3, #4
  406cb6:	681b      	ldr	r3, [r3, #0]
  406cb8:	4619      	mov	r1, r3
  406cba:	4610      	mov	r0, r2
  406cbc:	4b09      	ldr	r3, [pc, #36]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406cbe:	4798      	blx	r3
  406cc0:	4603      	mov	r3, r0
    qProd[3] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[3]) - inv_icm20648_convert_mult_q30_fxp(q1[1], q2[2]) +
  406cc2:	441d      	add	r5, r3
               inv_icm20648_convert_mult_q30_fxp(q1[2], q2[1]) + inv_icm20648_convert_mult_q30_fxp(q1[3], q2[0]);
  406cc4:	68fb      	ldr	r3, [r7, #12]
  406cc6:	330c      	adds	r3, #12
  406cc8:	681a      	ldr	r2, [r3, #0]
  406cca:	68bb      	ldr	r3, [r7, #8]
  406ccc:	681b      	ldr	r3, [r3, #0]
  406cce:	4619      	mov	r1, r3
  406cd0:	4610      	mov	r0, r2
  406cd2:	4b04      	ldr	r3, [pc, #16]	; (406ce4 <inv_icm20648_q_mult_q_qi+0x198>)
  406cd4:	4798      	blx	r3
  406cd6:	4603      	mov	r3, r0
  406cd8:	442b      	add	r3, r5
    qProd[3] = -inv_icm20648_convert_mult_q30_fxp(q1[0], q2[3]) - inv_icm20648_convert_mult_q30_fxp(q1[1], q2[2]) +
  406cda:	6023      	str	r3, [r4, #0]
}
  406cdc:	bf00      	nop
  406cde:	3710      	adds	r7, #16
  406ce0:	46bd      	mov	sp, r7
  406ce2:	bdb0      	pop	{r4, r5, r7, pc}
  406ce4:	004070d1 	.word	0x004070d1

00406ce8 <inv_icm20648_convert_quat_rotate_fxp>:

void inv_icm20648_convert_quat_rotate_fxp(const long *quat_q30, const long *in, long *out)
{
  406ce8:	b580      	push	{r7, lr}
  406cea:	b094      	sub	sp, #80	; 0x50
  406cec:	af00      	add	r7, sp, #0
  406cee:	60f8      	str	r0, [r7, #12]
  406cf0:	60b9      	str	r1, [r7, #8]
  406cf2:	607a      	str	r2, [r7, #4]
    long q_temp1[4], q_temp2[4];
    long in4[4], out4[4];

    // Fixme optimize
    in4[0] = 0;
  406cf4:	2300      	movs	r3, #0
  406cf6:	623b      	str	r3, [r7, #32]
    memcpy(&in4[1], in, 3 * sizeof(long));
  406cf8:	f107 0320 	add.w	r3, r7, #32
  406cfc:	3304      	adds	r3, #4
  406cfe:	220c      	movs	r2, #12
  406d00:	68b9      	ldr	r1, [r7, #8]
  406d02:	4618      	mov	r0, r3
  406d04:	4b12      	ldr	r3, [pc, #72]	; (406d50 <inv_icm20648_convert_quat_rotate_fxp+0x68>)
  406d06:	4798      	blx	r3
    invn_convert_quat_mult_fxp(quat_q30, in4, q_temp1);
  406d08:	f107 0240 	add.w	r2, r7, #64	; 0x40
  406d0c:	f107 0320 	add.w	r3, r7, #32
  406d10:	4619      	mov	r1, r3
  406d12:	68f8      	ldr	r0, [r7, #12]
  406d14:	4b0f      	ldr	r3, [pc, #60]	; (406d54 <inv_icm20648_convert_quat_rotate_fxp+0x6c>)
  406d16:	4798      	blx	r3
    invn_convert_quat_invert_fxp(quat_q30, q_temp2);
  406d18:	f107 0330 	add.w	r3, r7, #48	; 0x30
  406d1c:	4619      	mov	r1, r3
  406d1e:	68f8      	ldr	r0, [r7, #12]
  406d20:	4b0d      	ldr	r3, [pc, #52]	; (406d58 <inv_icm20648_convert_quat_rotate_fxp+0x70>)
  406d22:	4798      	blx	r3
    invn_convert_quat_mult_fxp(q_temp1, q_temp2, out4);
  406d24:	f107 0210 	add.w	r2, r7, #16
  406d28:	f107 0130 	add.w	r1, r7, #48	; 0x30
  406d2c:	f107 0340 	add.w	r3, r7, #64	; 0x40
  406d30:	4618      	mov	r0, r3
  406d32:	4b08      	ldr	r3, [pc, #32]	; (406d54 <inv_icm20648_convert_quat_rotate_fxp+0x6c>)
  406d34:	4798      	blx	r3
    memcpy(out, &out4[1], 3 * sizeof(long));
  406d36:	f107 0310 	add.w	r3, r7, #16
  406d3a:	3304      	adds	r3, #4
  406d3c:	220c      	movs	r2, #12
  406d3e:	4619      	mov	r1, r3
  406d40:	6878      	ldr	r0, [r7, #4]
  406d42:	4b03      	ldr	r3, [pc, #12]	; (406d50 <inv_icm20648_convert_quat_rotate_fxp+0x68>)
  406d44:	4798      	blx	r3
}
  406d46:	bf00      	nop
  406d48:	3750      	adds	r7, #80	; 0x50
  406d4a:	46bd      	mov	sp, r7
  406d4c:	bd80      	pop	{r7, pc}
  406d4e:	bf00      	nop
  406d50:	00414235 	.word	0x00414235
  406d54:	00406969 	.word	0x00406969
  406d58:	00406b05 	.word	0x00406b05

00406d5c <inv_icm20648_set_chip_to_body>:
/** Set the transformation used for chip to body frame
*/
void inv_icm20648_set_chip_to_body(struct inv_icm20648 * s, long *quat)
{
  406d5c:	b580      	push	{r7, lr}
  406d5e:	b082      	sub	sp, #8
  406d60:	af00      	add	r7, sp, #0
  406d62:	6078      	str	r0, [r7, #4]
  406d64:	6039      	str	r1, [r7, #0]
    memcpy(s->s_quat_chip_to_body, quat, sizeof(s->s_quat_chip_to_body));
  406d66:	687b      	ldr	r3, [r7, #4]
  406d68:	33a8      	adds	r3, #168	; 0xa8
  406d6a:	2210      	movs	r2, #16
  406d6c:	6839      	ldr	r1, [r7, #0]
  406d6e:	4618      	mov	r0, r3
  406d70:	4b02      	ldr	r3, [pc, #8]	; (406d7c <inv_icm20648_set_chip_to_body+0x20>)
  406d72:	4798      	blx	r3
}
  406d74:	bf00      	nop
  406d76:	3708      	adds	r7, #8
  406d78:	46bd      	mov	sp, r7
  406d7a:	bd80      	pop	{r7, pc}
  406d7c:	00414235 	.word	0x00414235

00406d80 <inv_icm20648_convert_rotation_vector>:
/** Convert fixed point DMP rotation vector to floating point android notation
* @param[in] quat 3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame
* @param[out] values 4 element quaternion in Android format
*/
void inv_icm20648_convert_rotation_vector(struct inv_icm20648 * s, const long *quat, float *values)
{
  406d80:	b580      	push	{r7, lr}
  406d82:	b08c      	sub	sp, #48	; 0x30
  406d84:	af00      	add	r7, sp, #0
  406d86:	60f8      	str	r0, [r7, #12]
  406d88:	60b9      	str	r1, [r7, #8]
  406d8a:	607a      	str	r2, [r7, #4]
    long quat4[4];
    long quat_body_to_world[4];

    inv_icm20648_convert_compute_scalar_part_fxp(quat, quat4);
  406d8c:	f107 0320 	add.w	r3, r7, #32
  406d90:	4619      	mov	r1, r3
  406d92:	68b8      	ldr	r0, [r7, #8]
  406d94:	4b3e      	ldr	r3, [pc, #248]	; (406e90 <inv_icm20648_convert_rotation_vector+0x110>)
  406d96:	4798      	blx	r3
    inv_icm20648_q_mult_q_qi(quat4, s->s_quat_chip_to_body, quat_body_to_world);
  406d98:	68fb      	ldr	r3, [r7, #12]
  406d9a:	f103 01a8 	add.w	r1, r3, #168	; 0xa8
  406d9e:	f107 0210 	add.w	r2, r7, #16
  406da2:	f107 0320 	add.w	r3, r7, #32
  406da6:	4618      	mov	r0, r3
  406da8:	4b3a      	ldr	r3, [pc, #232]	; (406e94 <inv_icm20648_convert_rotation_vector+0x114>)
  406daa:	4798      	blx	r3
    if (quat_body_to_world[0] >= 0) {
  406dac:	693b      	ldr	r3, [r7, #16]
  406dae:	2b00      	cmp	r3, #0
  406db0:	db33      	blt.n	406e1a <inv_icm20648_convert_rotation_vector+0x9a>
        values[0] = quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
  406db2:	697b      	ldr	r3, [r7, #20]
  406db4:	ee07 3a90 	vmov	s15, r3
  406db8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406dbc:	ed9f 7a36 	vldr	s14, [pc, #216]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406dc0:	ee67 7a87 	vmul.f32	s15, s15, s14
  406dc4:	687b      	ldr	r3, [r7, #4]
  406dc6:	edc3 7a00 	vstr	s15, [r3]
        values[1] = quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
  406dca:	687b      	ldr	r3, [r7, #4]
  406dcc:	3304      	adds	r3, #4
  406dce:	69ba      	ldr	r2, [r7, #24]
  406dd0:	ee07 2a90 	vmov	s15, r2
  406dd4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406dd8:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406ddc:	ee67 7a87 	vmul.f32	s15, s15, s14
  406de0:	edc3 7a00 	vstr	s15, [r3]
        values[2] = quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
  406de4:	687b      	ldr	r3, [r7, #4]
  406de6:	3308      	adds	r3, #8
  406de8:	69fa      	ldr	r2, [r7, #28]
  406dea:	ee07 2a90 	vmov	s15, r2
  406dee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406df2:	ed9f 7a29 	vldr	s14, [pc, #164]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406df6:	ee67 7a87 	vmul.f32	s15, s15, s14
  406dfa:	edc3 7a00 	vstr	s15, [r3]
        values[3] = quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
  406dfe:	687b      	ldr	r3, [r7, #4]
  406e00:	330c      	adds	r3, #12
  406e02:	693a      	ldr	r2, [r7, #16]
  406e04:	ee07 2a90 	vmov	s15, r2
  406e08:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406e0c:	ed9f 7a22 	vldr	s14, [pc, #136]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406e10:	ee67 7a87 	vmul.f32	s15, s15, s14
  406e14:	edc3 7a00 	vstr	s15, [r3]
        values[0] = -quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
        values[1] = -quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
        values[2] = -quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
        values[3] = -quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
    }
}
  406e18:	e036      	b.n	406e88 <inv_icm20648_convert_rotation_vector+0x108>
        values[0] = -quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
  406e1a:	697b      	ldr	r3, [r7, #20]
  406e1c:	425b      	negs	r3, r3
  406e1e:	ee07 3a90 	vmov	s15, r3
  406e22:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406e26:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406e2a:	ee67 7a87 	vmul.f32	s15, s15, s14
  406e2e:	687b      	ldr	r3, [r7, #4]
  406e30:	edc3 7a00 	vstr	s15, [r3]
        values[1] = -quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
  406e34:	687b      	ldr	r3, [r7, #4]
  406e36:	3304      	adds	r3, #4
  406e38:	69ba      	ldr	r2, [r7, #24]
  406e3a:	4252      	negs	r2, r2
  406e3c:	ee07 2a90 	vmov	s15, r2
  406e40:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406e44:	ed9f 7a14 	vldr	s14, [pc, #80]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406e48:	ee67 7a87 	vmul.f32	s15, s15, s14
  406e4c:	edc3 7a00 	vstr	s15, [r3]
        values[2] = -quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
  406e50:	687b      	ldr	r3, [r7, #4]
  406e52:	3308      	adds	r3, #8
  406e54:	69fa      	ldr	r2, [r7, #28]
  406e56:	4252      	negs	r2, r2
  406e58:	ee07 2a90 	vmov	s15, r2
  406e5c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406e60:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406e64:	ee67 7a87 	vmul.f32	s15, s15, s14
  406e68:	edc3 7a00 	vstr	s15, [r3]
        values[3] = -quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
  406e6c:	687b      	ldr	r3, [r7, #4]
  406e6e:	330c      	adds	r3, #12
  406e70:	693a      	ldr	r2, [r7, #16]
  406e72:	4252      	negs	r2, r2
  406e74:	ee07 2a90 	vmov	s15, r2
  406e78:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406e7c:	ed9f 7a06 	vldr	s14, [pc, #24]	; 406e98 <inv_icm20648_convert_rotation_vector+0x118>
  406e80:	ee67 7a87 	vmul.f32	s15, s15, s14
  406e84:	edc3 7a00 	vstr	s15, [r3]
}
  406e88:	bf00      	nop
  406e8a:	3730      	adds	r7, #48	; 0x30
  406e8c:	46bd      	mov	sp, r7
  406e8e:	bd80      	pop	{r7, pc}
  406e90:	0040711d 	.word	0x0040711d
  406e94:	00406b4d 	.word	0x00406b4d
  406e98:	30800000 	.word	0x30800000

00406e9c <inv_rotation_to_quaternion>:
        values[2] = -quat4_world[3] * INV_TWO_POWER_NEG_30;
        values[3] = -quat4_world[0] * INV_TWO_POWER_NEG_30;
    }
}

static void inv_rotation_to_quaternion(float Rcb[9], long Qcb_fp[4]) {	
  406e9c:	b580      	push	{r7, lr}
  406e9e:	b088      	sub	sp, #32
  406ea0:	af00      	add	r7, sp, #0
  406ea2:	6078      	str	r0, [r7, #4]
  406ea4:	6039      	str	r1, [r7, #0]
	float q[4]; 
	inv_icm20648_convert_matrix_to_quat_flt(Rcb, q); 
  406ea6:	f107 030c 	add.w	r3, r7, #12
  406eaa:	4619      	mov	r1, r3
  406eac:	6878      	ldr	r0, [r7, #4]
  406eae:	4b1c      	ldr	r3, [pc, #112]	; (406f20 <inv_rotation_to_quaternion+0x84>)
  406eb0:	4798      	blx	r3
	INVN_CONVERT_FLT_TO_FXP(q, Qcb_fp, 4, 30); 
  406eb2:	2300      	movs	r3, #0
  406eb4:	61fb      	str	r3, [r7, #28]
  406eb6:	e02b      	b.n	406f10 <inv_rotation_to_quaternion+0x74>
  406eb8:	69fb      	ldr	r3, [r7, #28]
  406eba:	009b      	lsls	r3, r3, #2
  406ebc:	683a      	ldr	r2, [r7, #0]
  406ebe:	4413      	add	r3, r2
  406ec0:	69fa      	ldr	r2, [r7, #28]
  406ec2:	0092      	lsls	r2, r2, #2
  406ec4:	f107 0120 	add.w	r1, r7, #32
  406ec8:	440a      	add	r2, r1
  406eca:	3a14      	subs	r2, #20
  406ecc:	edd2 7a00 	vldr	s15, [r2]
  406ed0:	ed9f 7a14 	vldr	s14, [pc, #80]	; 406f24 <inv_rotation_to_quaternion+0x88>
  406ed4:	ee27 7a87 	vmul.f32	s14, s15, s14
  406ed8:	69fa      	ldr	r2, [r7, #28]
  406eda:	0092      	lsls	r2, r2, #2
  406edc:	f107 0120 	add.w	r1, r7, #32
  406ee0:	440a      	add	r2, r1
  406ee2:	3a14      	subs	r2, #20
  406ee4:	edd2 7a00 	vldr	s15, [r2]
  406ee8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  406eec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  406ef0:	db02      	blt.n	406ef8 <inv_rotation_to_quaternion+0x5c>
  406ef2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  406ef6:	e001      	b.n	406efc <inv_rotation_to_quaternion+0x60>
  406ef8:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  406efc:	ee77 7a27 	vadd.f32	s15, s14, s15
  406f00:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  406f04:	ee17 2a90 	vmov	r2, s15
  406f08:	601a      	str	r2, [r3, #0]
  406f0a:	69fb      	ldr	r3, [r7, #28]
  406f0c:	3301      	adds	r3, #1
  406f0e:	61fb      	str	r3, [r7, #28]
  406f10:	69fb      	ldr	r3, [r7, #28]
  406f12:	2b03      	cmp	r3, #3
  406f14:	ddd0      	ble.n	406eb8 <inv_rotation_to_quaternion+0x1c>
}
  406f16:	bf00      	nop
  406f18:	3720      	adds	r7, #32
  406f1a:	46bd      	mov	sp, r7
  406f1c:	bd80      	pop	{r7, pc}
  406f1e:	bf00      	nop
  406f20:	0040748d 	.word	0x0040748d
  406f24:	4e800000 	.word	0x4e800000

00406f28 <inv_icm20648_set_chip_to_body_axis_quaternion>:

void inv_icm20648_set_chip_to_body_axis_quaternion(struct inv_icm20648 * s, signed char *accel_gyro_matrix, float angle)
{
  406f28:	b580      	push	{r7, lr}
  406f2a:	b09a      	sub	sp, #104	; 0x68
  406f2c:	af00      	add	r7, sp, #0
  406f2e:	60f8      	str	r0, [r7, #12]
  406f30:	60b9      	str	r1, [r7, #8]
  406f32:	ed87 0a01 	vstr	s0, [r7, #4]
    int i;
    float rot[9];
    long qcb[4],q_all[4];
    long q_adjust[4];
    for (i=0; i<9; i++) {
  406f36:	2300      	movs	r3, #0
  406f38:	667b      	str	r3, [r7, #100]	; 0x64
  406f3a:	e013      	b.n	406f64 <inv_icm20648_set_chip_to_body_axis_quaternion+0x3c>
        rot[i] = (float)accel_gyro_matrix[i];
  406f3c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406f3e:	68ba      	ldr	r2, [r7, #8]
  406f40:	4413      	add	r3, r2
  406f42:	f993 3000 	ldrsb.w	r3, [r3]
  406f46:	ee07 3a90 	vmov	s15, r3
  406f4a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406f4e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406f50:	009b      	lsls	r3, r3, #2
  406f52:	f107 0268 	add.w	r2, r7, #104	; 0x68
  406f56:	4413      	add	r3, r2
  406f58:	3b28      	subs	r3, #40	; 0x28
  406f5a:	edc3 7a00 	vstr	s15, [r3]
    for (i=0; i<9; i++) {
  406f5e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406f60:	3301      	adds	r3, #1
  406f62:	667b      	str	r3, [r7, #100]	; 0x64
  406f64:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406f66:	2b08      	cmp	r3, #8
  406f68:	dde8      	ble.n	406f3c <inv_icm20648_set_chip_to_body_axis_quaternion+0x14>
    }
    // Convert Chip to Body transformation matrix to quaternion
    // inv_icm20648_convert_matrix_to_quat_fxp(rot, qcb);
	inv_rotation_to_quaternion(rot, qcb);
  406f6a:	f107 0230 	add.w	r2, r7, #48	; 0x30
  406f6e:	f107 0340 	add.w	r3, r7, #64	; 0x40
  406f72:	4611      	mov	r1, r2
  406f74:	4618      	mov	r0, r3
  406f76:	4b30      	ldr	r3, [pc, #192]	; (407038 <inv_icm20648_set_chip_to_body_axis_quaternion+0x110>)
  406f78:	4798      	blx	r3
	
    // The quaterion generated is the inverse, take the inverse again.
    qcb[1] = -qcb[1];
  406f7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  406f7c:	425b      	negs	r3, r3
  406f7e:	637b      	str	r3, [r7, #52]	; 0x34
    qcb[2] = -qcb[2];
  406f80:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  406f82:	425b      	negs	r3, r3
  406f84:	63bb      	str	r3, [r7, #56]	; 0x38
    qcb[3] = -qcb[3];
  406f86:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  406f88:	425b      	negs	r3, r3
  406f8a:	63fb      	str	r3, [r7, #60]	; 0x3c

    // Now rotate by angle, negate angle to rotate other way
    q_adjust[0] = (long)((1L<<30) * cosf(-angle*(float)M_PI/180.f/2.f));
  406f8c:	edd7 7a01 	vldr	s15, [r7, #4]
  406f90:	eef1 7a67 	vneg.f32	s15, s15
  406f94:	ed9f 7a29 	vldr	s14, [pc, #164]	; 40703c <inv_icm20648_set_chip_to_body_axis_quaternion+0x114>
  406f98:	ee27 7a87 	vmul.f32	s14, s15, s14
  406f9c:	eddf 6a28 	vldr	s13, [pc, #160]	; 407040 <inv_icm20648_set_chip_to_body_axis_quaternion+0x118>
  406fa0:	eec7 7a26 	vdiv.f32	s15, s14, s13
  406fa4:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
  406fa8:	eec7 6a87 	vdiv.f32	s13, s15, s14
  406fac:	eeb0 0a66 	vmov.f32	s0, s13
  406fb0:	4b24      	ldr	r3, [pc, #144]	; (407044 <inv_icm20648_set_chip_to_body_axis_quaternion+0x11c>)
  406fb2:	4798      	blx	r3
  406fb4:	eeb0 7a40 	vmov.f32	s14, s0
  406fb8:	eddf 7a23 	vldr	s15, [pc, #140]	; 407048 <inv_icm20648_set_chip_to_body_axis_quaternion+0x120>
  406fbc:	ee67 7a27 	vmul.f32	s15, s14, s15
  406fc0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  406fc4:	ee17 3a90 	vmov	r3, s15
  406fc8:	613b      	str	r3, [r7, #16]
    q_adjust[1] = 0;
  406fca:	2300      	movs	r3, #0
  406fcc:	617b      	str	r3, [r7, #20]
    q_adjust[2] = (long)((1L<<30)*sinf(-angle*(float)M_PI/180.f/2.f));
  406fce:	edd7 7a01 	vldr	s15, [r7, #4]
  406fd2:	eef1 7a67 	vneg.f32	s15, s15
  406fd6:	ed9f 7a19 	vldr	s14, [pc, #100]	; 40703c <inv_icm20648_set_chip_to_body_axis_quaternion+0x114>
  406fda:	ee27 7a87 	vmul.f32	s14, s15, s14
  406fde:	eddf 6a18 	vldr	s13, [pc, #96]	; 407040 <inv_icm20648_set_chip_to_body_axis_quaternion+0x118>
  406fe2:	eec7 7a26 	vdiv.f32	s15, s14, s13
  406fe6:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
  406fea:	eec7 6a87 	vdiv.f32	s13, s15, s14
  406fee:	eeb0 0a66 	vmov.f32	s0, s13
  406ff2:	4b16      	ldr	r3, [pc, #88]	; (40704c <inv_icm20648_set_chip_to_body_axis_quaternion+0x124>)
  406ff4:	4798      	blx	r3
  406ff6:	eeb0 7a40 	vmov.f32	s14, s0
  406ffa:	eddf 7a13 	vldr	s15, [pc, #76]	; 407048 <inv_icm20648_set_chip_to_body_axis_quaternion+0x120>
  406ffe:	ee67 7a27 	vmul.f32	s15, s14, s15
  407002:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  407006:	ee17 3a90 	vmov	r3, s15
  40700a:	61bb      	str	r3, [r7, #24]
    q_adjust[3] = 0;
  40700c:	2300      	movs	r3, #0
  40700e:	61fb      	str	r3, [r7, #28]
    invn_convert_quat_mult_fxp(q_adjust, qcb, q_all);
  407010:	f107 0220 	add.w	r2, r7, #32
  407014:	f107 0130 	add.w	r1, r7, #48	; 0x30
  407018:	f107 0310 	add.w	r3, r7, #16
  40701c:	4618      	mov	r0, r3
  40701e:	4b0c      	ldr	r3, [pc, #48]	; (407050 <inv_icm20648_set_chip_to_body_axis_quaternion+0x128>)
  407020:	4798      	blx	r3
    inv_icm20648_set_chip_to_body(s, q_all);
  407022:	f107 0320 	add.w	r3, r7, #32
  407026:	4619      	mov	r1, r3
  407028:	68f8      	ldr	r0, [r7, #12]
  40702a:	4b0a      	ldr	r3, [pc, #40]	; (407054 <inv_icm20648_set_chip_to_body_axis_quaternion+0x12c>)
  40702c:	4798      	blx	r3
}
  40702e:	bf00      	nop
  407030:	3768      	adds	r7, #104	; 0x68
  407032:	46bd      	mov	sp, r7
  407034:	bd80      	pop	{r7, pc}
  407036:	bf00      	nop
  407038:	00406e9d 	.word	0x00406e9d
  40703c:	40490fdb 	.word	0x40490fdb
  407040:	43340000 	.word	0x43340000
  407044:	0041281d 	.word	0x0041281d
  407048:	4e800000 	.word	0x4e800000
  40704c:	004128ad 	.word	0x004128ad
  407050:	00406969 	.word	0x00406969
  407054:	00406d5d 	.word	0x00406d5d

00407058 <inv_icm20648_convert_dmp3_to_body>:

void inv_icm20648_convert_dmp3_to_body(struct inv_icm20648 * s, const long *vec3, float scale, float *values)
{
  407058:	b580      	push	{r7, lr}
  40705a:	b088      	sub	sp, #32
  40705c:	af00      	add	r7, sp, #0
  40705e:	60f8      	str	r0, [r7, #12]
  407060:	60b9      	str	r1, [r7, #8]
  407062:	ed87 0a01 	vstr	s0, [r7, #4]
  407066:	603a      	str	r2, [r7, #0]
    long out[3];
    inv_icm20648_convert_quat_rotate_fxp(s->s_quat_chip_to_body, vec3, out);
  407068:	68fb      	ldr	r3, [r7, #12]
  40706a:	33a8      	adds	r3, #168	; 0xa8
  40706c:	f107 0214 	add.w	r2, r7, #20
  407070:	68b9      	ldr	r1, [r7, #8]
  407072:	4618      	mov	r0, r3
  407074:	4b15      	ldr	r3, [pc, #84]	; (4070cc <inv_icm20648_convert_dmp3_to_body+0x74>)
  407076:	4798      	blx	r3
    values[0] = out[0] * scale;
  407078:	697b      	ldr	r3, [r7, #20]
  40707a:	ee07 3a90 	vmov	s15, r3
  40707e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  407082:	edd7 7a01 	vldr	s15, [r7, #4]
  407086:	ee67 7a27 	vmul.f32	s15, s14, s15
  40708a:	683b      	ldr	r3, [r7, #0]
  40708c:	edc3 7a00 	vstr	s15, [r3]
    values[1] = out[1] * scale;
  407090:	683b      	ldr	r3, [r7, #0]
  407092:	3304      	adds	r3, #4
  407094:	69ba      	ldr	r2, [r7, #24]
  407096:	ee07 2a90 	vmov	s15, r2
  40709a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40709e:	edd7 7a01 	vldr	s15, [r7, #4]
  4070a2:	ee67 7a27 	vmul.f32	s15, s14, s15
  4070a6:	edc3 7a00 	vstr	s15, [r3]
    values[2] = out[2] * scale;
  4070aa:	683b      	ldr	r3, [r7, #0]
  4070ac:	3308      	adds	r3, #8
  4070ae:	69fa      	ldr	r2, [r7, #28]
  4070b0:	ee07 2a90 	vmov	s15, r2
  4070b4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  4070b8:	edd7 7a01 	vldr	s15, [r7, #4]
  4070bc:	ee67 7a27 	vmul.f32	s15, s14, s15
  4070c0:	edc3 7a00 	vstr	s15, [r3]
}
  4070c4:	bf00      	nop
  4070c6:	3720      	adds	r7, #32
  4070c8:	46bd      	mov	sp, r7
  4070ca:	bd80      	pop	{r7, pc}
  4070cc:	00406ce9 	.word	0x00406ce9

004070d0 <inv_icm20648_convert_mult_q30_fxp>:
    rad_val = deg_val*(float)M_PI / 180.f;
	return rad_val;
}

long inv_icm20648_convert_mult_q30_fxp(long a_q30, long b_q30)
{
  4070d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  4070d2:	b087      	sub	sp, #28
  4070d4:	af00      	add	r7, sp, #0
  4070d6:	6078      	str	r0, [r7, #4]
  4070d8:	6039      	str	r1, [r7, #0]
	long long temp;
	long result;
	temp = (long long)a_q30 * b_q30;
  4070da:	687a      	ldr	r2, [r7, #4]
  4070dc:	4615      	mov	r5, r2
  4070de:	ea4f 76e5 	mov.w	r6, r5, asr #31
  4070e2:	683a      	ldr	r2, [r7, #0]
  4070e4:	4611      	mov	r1, r2
  4070e6:	ea4f 72e1 	mov.w	r2, r1, asr #31
  4070ea:	fb01 fe06 	mul.w	lr, r1, r6
  4070ee:	fb05 f002 	mul.w	r0, r5, r2
  4070f2:	4470      	add	r0, lr
  4070f4:	fba5 1201 	umull	r1, r2, r5, r1
  4070f8:	4410      	add	r0, r2
  4070fa:	4602      	mov	r2, r0
  4070fc:	e9c7 1204 	strd	r1, r2, [r7, #16]
  407100:	e9c7 1204 	strd	r1, r2, [r7, #16]
	result = (long)(temp >> 30);
  407104:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
  407108:	0f8b      	lsrs	r3, r1, #30
  40710a:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
  40710e:	1794      	asrs	r4, r2, #30
  407110:	60fb      	str	r3, [r7, #12]
	return result;
  407112:	68fb      	ldr	r3, [r7, #12]
}
  407114:	4618      	mov	r0, r3
  407116:	371c      	adds	r7, #28
  407118:	46bd      	mov	sp, r7
  40711a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0040711c <inv_icm20648_convert_compute_scalar_part_fxp>:

int inv_icm20648_convert_compute_scalar_part_fxp(const long * inQuat_q30, long* outQuat_q30)
{
  40711c:	b590      	push	{r4, r7, lr}
  40711e:	b085      	sub	sp, #20
  407120:	af00      	add	r7, sp, #0
  407122:	6078      	str	r0, [r7, #4]
  407124:	6039      	str	r1, [r7, #0]
    long scalarPart = 0;
  407126:	2300      	movs	r3, #0
  407128:	60fb      	str	r3, [r7, #12]

    scalarPart = inv_icm20648_convert_fast_sqrt_fxp((1L<<30) - inv_icm20648_convert_mult_q30_fxp(inQuat_q30[0], inQuat_q30[0])
  40712a:	687b      	ldr	r3, [r7, #4]
  40712c:	681a      	ldr	r2, [r3, #0]
  40712e:	687b      	ldr	r3, [r7, #4]
  407130:	681b      	ldr	r3, [r3, #0]
  407132:	4619      	mov	r1, r3
  407134:	4610      	mov	r0, r2
  407136:	4b1c      	ldr	r3, [pc, #112]	; (4071a8 <inv_icm20648_convert_compute_scalar_part_fxp+0x8c>)
  407138:	4798      	blx	r3
  40713a:	4603      	mov	r3, r0
  40713c:	f1c3 4480 	rsb	r4, r3, #1073741824	; 0x40000000
                                        - inv_icm20648_convert_mult_q30_fxp(inQuat_q30[1], inQuat_q30[1])
  407140:	687b      	ldr	r3, [r7, #4]
  407142:	3304      	adds	r3, #4
  407144:	681a      	ldr	r2, [r3, #0]
  407146:	687b      	ldr	r3, [r7, #4]
  407148:	3304      	adds	r3, #4
  40714a:	681b      	ldr	r3, [r3, #0]
  40714c:	4619      	mov	r1, r3
  40714e:	4610      	mov	r0, r2
  407150:	4b15      	ldr	r3, [pc, #84]	; (4071a8 <inv_icm20648_convert_compute_scalar_part_fxp+0x8c>)
  407152:	4798      	blx	r3
  407154:	4603      	mov	r3, r0
  407156:	1ae4      	subs	r4, r4, r3
                                        - inv_icm20648_convert_mult_q30_fxp(inQuat_q30[2], inQuat_q30[2]) );
  407158:	687b      	ldr	r3, [r7, #4]
  40715a:	3308      	adds	r3, #8
  40715c:	681a      	ldr	r2, [r3, #0]
  40715e:	687b      	ldr	r3, [r7, #4]
  407160:	3308      	adds	r3, #8
  407162:	681b      	ldr	r3, [r3, #0]
  407164:	4619      	mov	r1, r3
  407166:	4610      	mov	r0, r2
  407168:	4b0f      	ldr	r3, [pc, #60]	; (4071a8 <inv_icm20648_convert_compute_scalar_part_fxp+0x8c>)
  40716a:	4798      	blx	r3
  40716c:	4603      	mov	r3, r0
    scalarPart = inv_icm20648_convert_fast_sqrt_fxp((1L<<30) - inv_icm20648_convert_mult_q30_fxp(inQuat_q30[0], inQuat_q30[0])
  40716e:	1ae3      	subs	r3, r4, r3
  407170:	4618      	mov	r0, r3
  407172:	4b0e      	ldr	r3, [pc, #56]	; (4071ac <inv_icm20648_convert_compute_scalar_part_fxp+0x90>)
  407174:	4798      	blx	r3
  407176:	60f8      	str	r0, [r7, #12]
    outQuat_q30[0] = scalarPart;
  407178:	683b      	ldr	r3, [r7, #0]
  40717a:	68fa      	ldr	r2, [r7, #12]
  40717c:	601a      	str	r2, [r3, #0]
    outQuat_q30[1] = inQuat_q30[0];
  40717e:	683b      	ldr	r3, [r7, #0]
  407180:	3304      	adds	r3, #4
  407182:	687a      	ldr	r2, [r7, #4]
  407184:	6812      	ldr	r2, [r2, #0]
  407186:	601a      	str	r2, [r3, #0]
    outQuat_q30[2] = inQuat_q30[1];
  407188:	683b      	ldr	r3, [r7, #0]
  40718a:	3308      	adds	r3, #8
  40718c:	687a      	ldr	r2, [r7, #4]
  40718e:	6852      	ldr	r2, [r2, #4]
  407190:	601a      	str	r2, [r3, #0]
    outQuat_q30[3] = inQuat_q30[2];
  407192:	683b      	ldr	r3, [r7, #0]
  407194:	330c      	adds	r3, #12
  407196:	687a      	ldr	r2, [r7, #4]
  407198:	6892      	ldr	r2, [r2, #8]
  40719a:	601a      	str	r2, [r3, #0]

    return 0;
  40719c:	2300      	movs	r3, #0
}
  40719e:	4618      	mov	r0, r3
  4071a0:	3714      	adds	r7, #20
  4071a2:	46bd      	mov	sp, r7
  4071a4:	bd90      	pop	{r4, r7, pc}
  4071a6:	bf00      	nop
  4071a8:	004070d1 	.word	0x004070d1
  4071ac:	004071b1 	.word	0x004071b1

004071b0 <inv_icm20648_convert_fast_sqrt_fxp>:

long inv_icm20648_convert_fast_sqrt_fxp(long x0_q30)
{
  4071b0:	b590      	push	{r4, r7, lr}
  4071b2:	b08b      	sub	sp, #44	; 0x2c
  4071b4:	af00      	add	r7, sp, #0
  4071b6:	6078      	str	r0, [r7, #4]
	long sqrt2, oneoversqrt2, one_pt5;
	long xx, cc;
	int pow2, sq2scale, nr_iters;

	// Return if input is zero. Negative should really error out. 
	if (x0_q30 <= 0L) {
  4071b8:	687b      	ldr	r3, [r7, #4]
  4071ba:	2b00      	cmp	r3, #0
  4071bc:	dc01      	bgt.n	4071c2 <inv_icm20648_convert_fast_sqrt_fxp+0x12>
		return 0L;
  4071be:	2300      	movs	r3, #0
  4071c0:	e080      	b.n	4072c4 <inv_icm20648_convert_fast_sqrt_fxp+0x114>
	}

	sqrt2 =1518500250L;
  4071c2:	4b42      	ldr	r3, [pc, #264]	; (4072cc <inv_icm20648_convert_fast_sqrt_fxp+0x11c>)
  4071c4:	61fb      	str	r3, [r7, #28]
	oneoversqrt2=759250125L;
  4071c6:	4b42      	ldr	r3, [pc, #264]	; (4072d0 <inv_icm20648_convert_fast_sqrt_fxp+0x120>)
  4071c8:	61bb      	str	r3, [r7, #24]
	one_pt5=1610612736L;
  4071ca:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
  4071ce:	617b      	str	r3, [r7, #20]

	nr_iters = inv_icm20648_convert_test_limits_and_scale_fxp(&x0_q30, &pow2);
  4071d0:	f107 0208 	add.w	r2, r7, #8
  4071d4:	1d3b      	adds	r3, r7, #4
  4071d6:	4611      	mov	r1, r2
  4071d8:	4618      	mov	r0, r3
  4071da:	4b3e      	ldr	r3, [pc, #248]	; (4072d4 <inv_icm20648_convert_fast_sqrt_fxp+0x124>)
  4071dc:	4798      	blx	r3
  4071de:	6138      	str	r0, [r7, #16]
	
	sq2scale = 0;
  4071e0:	2300      	movs	r3, #0
  4071e2:	623b      	str	r3, [r7, #32]
	if (pow2 > 0) 
  4071e4:	68bb      	ldr	r3, [r7, #8]
  4071e6:	2b00      	cmp	r3, #0
  4071e8:	dd06      	ble.n	4071f8 <inv_icm20648_convert_fast_sqrt_fxp+0x48>
		sq2scale=pow2%2;  // Find remainder. Is it even or odd?
  4071ea:	68bb      	ldr	r3, [r7, #8]
  4071ec:	2b00      	cmp	r3, #0
  4071ee:	f003 0301 	and.w	r3, r3, #1
  4071f2:	bfb8      	it	lt
  4071f4:	425b      	neglt	r3, r3
  4071f6:	623b      	str	r3, [r7, #32]
	pow2 = pow2-sq2scale; // Now pow2 is even. Note we are adding because result is scaled with sqrt(2)
  4071f8:	68ba      	ldr	r2, [r7, #8]
  4071fa:	6a3b      	ldr	r3, [r7, #32]
  4071fc:	1ad3      	subs	r3, r2, r3
  4071fe:	60bb      	str	r3, [r7, #8]

	// Sqrt 1st NR iteration
	cc = x0_q30 - (1L<<30);
  407200:	687b      	ldr	r3, [r7, #4]
  407202:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
  407206:	60fb      	str	r3, [r7, #12]
	xx = x0_q30 - (inv_icm20648_convert_mult_q30_fxp(x0_q30, cc)>>1);
  407208:	687c      	ldr	r4, [r7, #4]
  40720a:	687b      	ldr	r3, [r7, #4]
  40720c:	68f9      	ldr	r1, [r7, #12]
  40720e:	4618      	mov	r0, r3
  407210:	4b31      	ldr	r3, [pc, #196]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  407212:	4798      	blx	r3
  407214:	4603      	mov	r3, r0
  407216:	105b      	asrs	r3, r3, #1
  407218:	1ae3      	subs	r3, r4, r3
  40721a:	627b      	str	r3, [r7, #36]	; 0x24
 	if ( nr_iters>=2 ) {
  40721c:	693b      	ldr	r3, [r7, #16]
  40721e:	2b01      	cmp	r3, #1
  407220:	dd34      	ble.n	40728c <inv_icm20648_convert_fast_sqrt_fxp+0xdc>
		// Sqrt second NR iteration
		// cc = cc*cc*(cc-3)/4; = cc*cc*(cc/2 - 3/2)/2;
		// cc = ( cc*cc*((cc>>1) - onePt5) ) >> 1
		cc = inv_icm20648_convert_mult_q30_fxp( cc, inv_icm20648_convert_mult_q30_fxp(cc, (cc>>1) - one_pt5) ) >> 1;
  407222:	68fb      	ldr	r3, [r7, #12]
  407224:	105a      	asrs	r2, r3, #1
  407226:	697b      	ldr	r3, [r7, #20]
  407228:	1ad3      	subs	r3, r2, r3
  40722a:	4619      	mov	r1, r3
  40722c:	68f8      	ldr	r0, [r7, #12]
  40722e:	4b2a      	ldr	r3, [pc, #168]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  407230:	4798      	blx	r3
  407232:	4603      	mov	r3, r0
  407234:	4619      	mov	r1, r3
  407236:	68f8      	ldr	r0, [r7, #12]
  407238:	4b27      	ldr	r3, [pc, #156]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  40723a:	4798      	blx	r3
  40723c:	4603      	mov	r3, r0
  40723e:	105b      	asrs	r3, r3, #1
  407240:	60fb      	str	r3, [r7, #12]
		xx = xx - (inv_icm20648_convert_mult_q30_fxp(xx, cc)>>1);
  407242:	68f9      	ldr	r1, [r7, #12]
  407244:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407246:	4b24      	ldr	r3, [pc, #144]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  407248:	4798      	blx	r3
  40724a:	4603      	mov	r3, r0
  40724c:	105b      	asrs	r3, r3, #1
  40724e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407250:	1ad3      	subs	r3, r2, r3
  407252:	627b      	str	r3, [r7, #36]	; 0x24
		if ( nr_iters==3 ) {
  407254:	693b      	ldr	r3, [r7, #16]
  407256:	2b03      	cmp	r3, #3
  407258:	d118      	bne.n	40728c <inv_icm20648_convert_fast_sqrt_fxp+0xdc>
			// Sqrt third NR iteration
			cc = inv_icm20648_convert_mult_q30_fxp( cc, inv_icm20648_convert_mult_q30_fxp(cc, (cc>>1) - one_pt5) ) >> 1;
  40725a:	68fb      	ldr	r3, [r7, #12]
  40725c:	105a      	asrs	r2, r3, #1
  40725e:	697b      	ldr	r3, [r7, #20]
  407260:	1ad3      	subs	r3, r2, r3
  407262:	4619      	mov	r1, r3
  407264:	68f8      	ldr	r0, [r7, #12]
  407266:	4b1c      	ldr	r3, [pc, #112]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  407268:	4798      	blx	r3
  40726a:	4603      	mov	r3, r0
  40726c:	4619      	mov	r1, r3
  40726e:	68f8      	ldr	r0, [r7, #12]
  407270:	4b19      	ldr	r3, [pc, #100]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  407272:	4798      	blx	r3
  407274:	4603      	mov	r3, r0
  407276:	105b      	asrs	r3, r3, #1
  407278:	60fb      	str	r3, [r7, #12]
			xx = xx - (inv_icm20648_convert_mult_q30_fxp(xx, cc)>>1);
  40727a:	68f9      	ldr	r1, [r7, #12]
  40727c:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40727e:	4b16      	ldr	r3, [pc, #88]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  407280:	4798      	blx	r3
  407282:	4603      	mov	r3, r0
  407284:	105b      	asrs	r3, r3, #1
  407286:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407288:	1ad3      	subs	r3, r2, r3
  40728a:	627b      	str	r3, [r7, #36]	; 0x24
		}
	}
	if (sq2scale)
  40728c:	6a3b      	ldr	r3, [r7, #32]
  40728e:	2b00      	cmp	r3, #0
  407290:	d004      	beq.n	40729c <inv_icm20648_convert_fast_sqrt_fxp+0xec>
		xx = inv_icm20648_convert_mult_q30_fxp(xx,oneoversqrt2);
  407292:	69b9      	ldr	r1, [r7, #24]
  407294:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407296:	4b10      	ldr	r3, [pc, #64]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  407298:	4798      	blx	r3
  40729a:	6278      	str	r0, [r7, #36]	; 0x24
	// Scale the number with the half of the power of 2 scaling
	if (pow2>0)
  40729c:	68bb      	ldr	r3, [r7, #8]
  40729e:	2b00      	cmp	r3, #0
  4072a0:	dd06      	ble.n	4072b0 <inv_icm20648_convert_fast_sqrt_fxp+0x100>
		xx = (xx >> (pow2>>1)); 
  4072a2:	68bb      	ldr	r3, [r7, #8]
  4072a4:	105b      	asrs	r3, r3, #1
  4072a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4072a8:	fa42 f303 	asr.w	r3, r2, r3
  4072ac:	627b      	str	r3, [r7, #36]	; 0x24
  4072ae:	e008      	b.n	4072c2 <inv_icm20648_convert_fast_sqrt_fxp+0x112>
	else if (pow2 == -1)
  4072b0:	68bb      	ldr	r3, [r7, #8]
  4072b2:	f1b3 3fff 	cmp.w	r3, #4294967295
  4072b6:	d104      	bne.n	4072c2 <inv_icm20648_convert_fast_sqrt_fxp+0x112>
		xx = inv_icm20648_convert_mult_q30_fxp(xx,sqrt2);
  4072b8:	69f9      	ldr	r1, [r7, #28]
  4072ba:	6a78      	ldr	r0, [r7, #36]	; 0x24
  4072bc:	4b06      	ldr	r3, [pc, #24]	; (4072d8 <inv_icm20648_convert_fast_sqrt_fxp+0x128>)
  4072be:	4798      	blx	r3
  4072c0:	6278      	str	r0, [r7, #36]	; 0x24
	return xx;
  4072c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  4072c4:	4618      	mov	r0, r3
  4072c6:	372c      	adds	r7, #44	; 0x2c
  4072c8:	46bd      	mov	sp, r7
  4072ca:	bd90      	pop	{r4, r7, pc}
  4072cc:	5a82799a 	.word	0x5a82799a
  4072d0:	2d413ccd 	.word	0x2d413ccd
  4072d4:	004072dd 	.word	0x004072dd
  4072d8:	004070d1 	.word	0x004070d1

004072dc <inv_icm20648_convert_test_limits_and_scale_fxp>:

int inv_icm20648_convert_test_limits_and_scale_fxp(long *x0_q30, int *pow)
{
  4072dc:	b580      	push	{r7, lr}
  4072de:	b088      	sub	sp, #32
  4072e0:	af00      	add	r7, sp, #0
  4072e2:	6078      	str	r0, [r7, #4]
  4072e4:	6039      	str	r1, [r7, #0]
    long lowerlimit, upperlimit, oneiterlothr, oneiterhithr, zeroiterlothr, zeroiterhithr;

    // Lower Limit: ll = int32(log(2)*2^30);
    lowerlimit = 744261118L;
  4072e6:	4b33      	ldr	r3, [pc, #204]	; (4073b4 <inv_icm20648_convert_test_limits_and_scale_fxp+0xd8>)
  4072e8:	61fb      	str	r3, [r7, #28]
    //Upper Limit ul = int32(log(4)*2^30);
    upperlimit = 1488522236L;
  4072ea:	4b33      	ldr	r3, [pc, #204]	; (4073b8 <inv_icm20648_convert_test_limits_and_scale_fxp+0xdc>)
  4072ec:	61bb      	str	r3, [r7, #24]
    //  int32(0.9*2^30)
    oneiterlothr = 966367642L;
  4072ee:	4b33      	ldr	r3, [pc, #204]	; (4073bc <inv_icm20648_convert_test_limits_and_scale_fxp+0xe0>)
  4072f0:	617b      	str	r3, [r7, #20]
    // int32(1.1*2^30)
    oneiterhithr = 1181116006L;
  4072f2:	4b33      	ldr	r3, [pc, #204]	; (4073c0 <inv_icm20648_convert_test_limits_and_scale_fxp+0xe4>)
  4072f4:	613b      	str	r3, [r7, #16]
    // int32(0.99*2^30)
    zeroiterlothr=1063004406L;
  4072f6:	4b33      	ldr	r3, [pc, #204]	; (4073c4 <inv_icm20648_convert_test_limits_and_scale_fxp+0xe8>)
  4072f8:	60fb      	str	r3, [r7, #12]
    //int32(1.01*2^30)
    zeroiterhithr=1084479242L;
  4072fa:	4b33      	ldr	r3, [pc, #204]	; (4073c8 <inv_icm20648_convert_test_limits_and_scale_fxp+0xec>)
  4072fc:	60bb      	str	r3, [r7, #8]

    // Scale number such that Newton Raphson iteration works best:
    // Find the power of two scaling that leaves the number in the optimal range,
    // ll <= number <= ul. Note odd powers have special scaling further below
	if (*x0_q30 > upperlimit) {
  4072fe:	687b      	ldr	r3, [r7, #4]
  407300:	681a      	ldr	r2, [r3, #0]
  407302:	69bb      	ldr	r3, [r7, #24]
  407304:	429a      	cmp	r2, r3
  407306:	dd09      	ble.n	40731c <inv_icm20648_convert_test_limits_and_scale_fxp+0x40>
		// Halving the number will push it in the optimal range since largest value is 2
		*x0_q30 = *x0_q30>>1;
  407308:	687b      	ldr	r3, [r7, #4]
  40730a:	681b      	ldr	r3, [r3, #0]
  40730c:	105a      	asrs	r2, r3, #1
  40730e:	687b      	ldr	r3, [r7, #4]
  407310:	601a      	str	r2, [r3, #0]
		*pow=-1;
  407312:	683b      	ldr	r3, [r7, #0]
  407314:	f04f 32ff 	mov.w	r2, #4294967295
  407318:	601a      	str	r2, [r3, #0]
  40731a:	e02e      	b.n	40737a <inv_icm20648_convert_test_limits_and_scale_fxp+0x9e>
	} else if (*x0_q30 < lowerlimit) {
  40731c:	687b      	ldr	r3, [r7, #4]
  40731e:	681a      	ldr	r2, [r3, #0]
  407320:	69fb      	ldr	r3, [r7, #28]
  407322:	429a      	cmp	r2, r3
  407324:	da26      	bge.n	407374 <inv_icm20648_convert_test_limits_and_scale_fxp+0x98>
		// Find position of highest bit, counting from left, and scale number 
		*pow=inv_icm20648_convert_get_highest_bit_position((uint32_t*)x0_q30);
  407326:	6878      	ldr	r0, [r7, #4]
  407328:	4b28      	ldr	r3, [pc, #160]	; (4073cc <inv_icm20648_convert_test_limits_and_scale_fxp+0xf0>)
  40732a:	4798      	blx	r3
  40732c:	4603      	mov	r3, r0
  40732e:	461a      	mov	r2, r3
  407330:	683b      	ldr	r3, [r7, #0]
  407332:	601a      	str	r2, [r3, #0]
		if (*x0_q30 >= upperlimit) {
  407334:	687b      	ldr	r3, [r7, #4]
  407336:	681a      	ldr	r2, [r3, #0]
  407338:	69bb      	ldr	r3, [r7, #24]
  40733a:	429a      	cmp	r2, r3
  40733c:	db0a      	blt.n	407354 <inv_icm20648_convert_test_limits_and_scale_fxp+0x78>
			// Halving the number will push it in the optimal range
			*x0_q30 = *x0_q30>>1;
  40733e:	687b      	ldr	r3, [r7, #4]
  407340:	681b      	ldr	r3, [r3, #0]
  407342:	105a      	asrs	r2, r3, #1
  407344:	687b      	ldr	r3, [r7, #4]
  407346:	601a      	str	r2, [r3, #0]
			*pow=*pow-1;
  407348:	683b      	ldr	r3, [r7, #0]
  40734a:	681b      	ldr	r3, [r3, #0]
  40734c:	1e5a      	subs	r2, r3, #1
  40734e:	683b      	ldr	r3, [r7, #0]
  407350:	601a      	str	r2, [r3, #0]
  407352:	e012      	b.n	40737a <inv_icm20648_convert_test_limits_and_scale_fxp+0x9e>
		}
		else if (*x0_q30 < lowerlimit) {
  407354:	687b      	ldr	r3, [r7, #4]
  407356:	681a      	ldr	r2, [r3, #0]
  407358:	69fb      	ldr	r3, [r7, #28]
  40735a:	429a      	cmp	r2, r3
  40735c:	da0d      	bge.n	40737a <inv_icm20648_convert_test_limits_and_scale_fxp+0x9e>
			// Doubling the number will push it in the optimal range
			*x0_q30 = *x0_q30<<1;
  40735e:	687b      	ldr	r3, [r7, #4]
  407360:	681b      	ldr	r3, [r3, #0]
  407362:	005a      	lsls	r2, r3, #1
  407364:	687b      	ldr	r3, [r7, #4]
  407366:	601a      	str	r2, [r3, #0]
			*pow=*pow+1;
  407368:	683b      	ldr	r3, [r7, #0]
  40736a:	681b      	ldr	r3, [r3, #0]
  40736c:	1c5a      	adds	r2, r3, #1
  40736e:	683b      	ldr	r3, [r7, #0]
  407370:	601a      	str	r2, [r3, #0]
  407372:	e002      	b.n	40737a <inv_icm20648_convert_test_limits_and_scale_fxp+0x9e>
		}
	} else {
		*pow = 0;
  407374:	683b      	ldr	r3, [r7, #0]
  407376:	2200      	movs	r2, #0
  407378:	601a      	str	r2, [r3, #0]
	}
    
    if ( *x0_q30<oneiterlothr || *x0_q30>oneiterhithr )
  40737a:	687b      	ldr	r3, [r7, #4]
  40737c:	681a      	ldr	r2, [r3, #0]
  40737e:	697b      	ldr	r3, [r7, #20]
  407380:	429a      	cmp	r2, r3
  407382:	db04      	blt.n	40738e <inv_icm20648_convert_test_limits_and_scale_fxp+0xb2>
  407384:	687b      	ldr	r3, [r7, #4]
  407386:	681a      	ldr	r2, [r3, #0]
  407388:	693b      	ldr	r3, [r7, #16]
  40738a:	429a      	cmp	r2, r3
  40738c:	dd01      	ble.n	407392 <inv_icm20648_convert_test_limits_and_scale_fxp+0xb6>
        return 3; // 3 NR iterations
  40738e:	2303      	movs	r3, #3
  407390:	e00c      	b.n	4073ac <inv_icm20648_convert_test_limits_and_scale_fxp+0xd0>
    if ( *x0_q30<zeroiterlothr || *x0_q30>zeroiterhithr )
  407392:	687b      	ldr	r3, [r7, #4]
  407394:	681a      	ldr	r2, [r3, #0]
  407396:	68fb      	ldr	r3, [r7, #12]
  407398:	429a      	cmp	r2, r3
  40739a:	db04      	blt.n	4073a6 <inv_icm20648_convert_test_limits_and_scale_fxp+0xca>
  40739c:	687b      	ldr	r3, [r7, #4]
  40739e:	681a      	ldr	r2, [r3, #0]
  4073a0:	68bb      	ldr	r3, [r7, #8]
  4073a2:	429a      	cmp	r2, r3
  4073a4:	dd01      	ble.n	4073aa <inv_icm20648_convert_test_limits_and_scale_fxp+0xce>
        return 2; // 2 NR iteration
  4073a6:	2302      	movs	r3, #2
  4073a8:	e000      	b.n	4073ac <inv_icm20648_convert_test_limits_and_scale_fxp+0xd0>

    return 1; // 1 NR iteration
  4073aa:	2301      	movs	r3, #1
}
  4073ac:	4618      	mov	r0, r3
  4073ae:	3720      	adds	r7, #32
  4073b0:	46bd      	mov	sp, r7
  4073b2:	bd80      	pop	{r7, pc}
  4073b4:	2c5c85fe 	.word	0x2c5c85fe
  4073b8:	58b90bfc 	.word	0x58b90bfc
  4073bc:	3999999a 	.word	0x3999999a
  4073c0:	46666666 	.word	0x46666666
  4073c4:	3f5c28f6 	.word	0x3f5c28f6
  4073c8:	40a3d70a 	.word	0x40a3d70a
  4073cc:	004073d1 	.word	0x004073d1

004073d0 <inv_icm20648_convert_get_highest_bit_position>:
* @return highest bit position.
* \note This function performs the log2 of an interger as well. 
* \ingroup binary
**/
int16_t inv_icm20648_convert_get_highest_bit_position(uint32_t *value)
{
  4073d0:	b480      	push	{r7}
  4073d2:	b085      	sub	sp, #20
  4073d4:	af00      	add	r7, sp, #0
  4073d6:	6078      	str	r0, [r7, #4]
    int16_t position;
    position = 0;
  4073d8:	2300      	movs	r3, #0
  4073da:	81fb      	strh	r3, [r7, #14]
    if (*value == 0) return 0;
  4073dc:	687b      	ldr	r3, [r7, #4]
  4073de:	681b      	ldr	r3, [r3, #0]
  4073e0:	2b00      	cmp	r3, #0
  4073e2:	d101      	bne.n	4073e8 <inv_icm20648_convert_get_highest_bit_position+0x18>
  4073e4:	2300      	movs	r3, #0
  4073e6:	e04a      	b.n	40747e <inv_icm20648_convert_get_highest_bit_position+0xae>

    if ((*value & 0xFFFF0000) == 0) {
  4073e8:	687b      	ldr	r3, [r7, #4]
  4073ea:	681b      	ldr	r3, [r3, #0]
  4073ec:	0c1b      	lsrs	r3, r3, #16
  4073ee:	041b      	lsls	r3, r3, #16
  4073f0:	2b00      	cmp	r3, #0
  4073f2:	d108      	bne.n	407406 <inv_icm20648_convert_get_highest_bit_position+0x36>
        position += 16;
  4073f4:	89fb      	ldrh	r3, [r7, #14]
  4073f6:	3310      	adds	r3, #16
  4073f8:	b29b      	uxth	r3, r3
  4073fa:	81fb      	strh	r3, [r7, #14]
        *value=*value<<16;
  4073fc:	687b      	ldr	r3, [r7, #4]
  4073fe:	681b      	ldr	r3, [r3, #0]
  407400:	041a      	lsls	r2, r3, #16
  407402:	687b      	ldr	r3, [r7, #4]
  407404:	601a      	str	r2, [r3, #0]
    }
    if ((*value & 0xFF000000) == 0) {
  407406:	687b      	ldr	r3, [r7, #4]
  407408:	681b      	ldr	r3, [r3, #0]
  40740a:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  40740e:	2b00      	cmp	r3, #0
  407410:	d108      	bne.n	407424 <inv_icm20648_convert_get_highest_bit_position+0x54>
        position += 8;
  407412:	89fb      	ldrh	r3, [r7, #14]
  407414:	3308      	adds	r3, #8
  407416:	b29b      	uxth	r3, r3
  407418:	81fb      	strh	r3, [r7, #14]
        *value=*value<<8;
  40741a:	687b      	ldr	r3, [r7, #4]
  40741c:	681b      	ldr	r3, [r3, #0]
  40741e:	021a      	lsls	r2, r3, #8
  407420:	687b      	ldr	r3, [r7, #4]
  407422:	601a      	str	r2, [r3, #0]
    }
    if ((*value & 0xF0000000) == 0) {
  407424:	687b      	ldr	r3, [r7, #4]
  407426:	681b      	ldr	r3, [r3, #0]
  407428:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
  40742c:	2b00      	cmp	r3, #0
  40742e:	d108      	bne.n	407442 <inv_icm20648_convert_get_highest_bit_position+0x72>
        position += 4;
  407430:	89fb      	ldrh	r3, [r7, #14]
  407432:	3304      	adds	r3, #4
  407434:	b29b      	uxth	r3, r3
  407436:	81fb      	strh	r3, [r7, #14]
        *value=*value<<4;
  407438:	687b      	ldr	r3, [r7, #4]
  40743a:	681b      	ldr	r3, [r3, #0]
  40743c:	011a      	lsls	r2, r3, #4
  40743e:	687b      	ldr	r3, [r7, #4]
  407440:	601a      	str	r2, [r3, #0]
    }
    if ((*value & 0xC0000000) == 0) {
  407442:	687b      	ldr	r3, [r7, #4]
  407444:	681b      	ldr	r3, [r3, #0]
  407446:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
  40744a:	2b00      	cmp	r3, #0
  40744c:	d108      	bne.n	407460 <inv_icm20648_convert_get_highest_bit_position+0x90>
        position += 2;
  40744e:	89fb      	ldrh	r3, [r7, #14]
  407450:	3302      	adds	r3, #2
  407452:	b29b      	uxth	r3, r3
  407454:	81fb      	strh	r3, [r7, #14]
        *value=*value<<2;
  407456:	687b      	ldr	r3, [r7, #4]
  407458:	681b      	ldr	r3, [r3, #0]
  40745a:	009a      	lsls	r2, r3, #2
  40745c:	687b      	ldr	r3, [r7, #4]
  40745e:	601a      	str	r2, [r3, #0]
    }

    // If we got too far into sign bit, shift back. Note we are using an
    // unsigned long here, so right shift is going to shift all the bits.
    if ((*value & 0x80000000)) { 
  407460:	687b      	ldr	r3, [r7, #4]
  407462:	681b      	ldr	r3, [r3, #0]
  407464:	2b00      	cmp	r3, #0
  407466:	da08      	bge.n	40747a <inv_icm20648_convert_get_highest_bit_position+0xaa>
        position -= 1;
  407468:	89fb      	ldrh	r3, [r7, #14]
  40746a:	3b01      	subs	r3, #1
  40746c:	b29b      	uxth	r3, r3
  40746e:	81fb      	strh	r3, [r7, #14]
        *value=*value>>1;
  407470:	687b      	ldr	r3, [r7, #4]
  407472:	681b      	ldr	r3, [r3, #0]
  407474:	085a      	lsrs	r2, r3, #1
  407476:	687b      	ldr	r3, [r7, #4]
  407478:	601a      	str	r2, [r3, #0]
    }
    return position;
  40747a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
  40747e:	4618      	mov	r0, r3
  407480:	3714      	adds	r7, #20
  407482:	46bd      	mov	sp, r7
  407484:	f85d 7b04 	ldr.w	r7, [sp], #4
  407488:	4770      	bx	lr
	...

0040748c <inv_icm20648_convert_matrix_to_quat_flt>:
        y=-y;
    return y;
}

void inv_icm20648_convert_matrix_to_quat_flt(float *R, float *q)
{
  40748c:	b590      	push	{r4, r7, lr}
  40748e:	b08d      	sub	sp, #52	; 0x34
  407490:	af00      	add	r7, sp, #0
  407492:	6078      	str	r0, [r7, #4]
  407494:	6039      	str	r1, [r7, #0]
	float r11,r12,r13, r21,r22,r23, r31,r32,r33;

	r11 = R[0]; //assume matrix is stored row wise first, that is rot[1] is row 1, col 2
  407496:	687b      	ldr	r3, [r7, #4]
  407498:	681b      	ldr	r3, [r3, #0]
  40749a:	62fb      	str	r3, [r7, #44]	; 0x2c
	r12 = R[1];
  40749c:	687b      	ldr	r3, [r7, #4]
  40749e:	685b      	ldr	r3, [r3, #4]
  4074a0:	62bb      	str	r3, [r7, #40]	; 0x28
	r13 = R[2];
  4074a2:	687b      	ldr	r3, [r7, #4]
  4074a4:	689b      	ldr	r3, [r3, #8]
  4074a6:	627b      	str	r3, [r7, #36]	; 0x24

	r21 = R[3];
  4074a8:	687b      	ldr	r3, [r7, #4]
  4074aa:	68db      	ldr	r3, [r3, #12]
  4074ac:	623b      	str	r3, [r7, #32]
	r22 = R[4];
  4074ae:	687b      	ldr	r3, [r7, #4]
  4074b0:	691b      	ldr	r3, [r3, #16]
  4074b2:	61fb      	str	r3, [r7, #28]
	r23 = R[5];
  4074b4:	687b      	ldr	r3, [r7, #4]
  4074b6:	695b      	ldr	r3, [r3, #20]
  4074b8:	61bb      	str	r3, [r7, #24]

	r31 = R[6];
  4074ba:	687b      	ldr	r3, [r7, #4]
  4074bc:	699b      	ldr	r3, [r3, #24]
  4074be:	617b      	str	r3, [r7, #20]
	r32 = R[7];
  4074c0:	687b      	ldr	r3, [r7, #4]
  4074c2:	69db      	ldr	r3, [r3, #28]
  4074c4:	613b      	str	r3, [r7, #16]
	r33 = R[8];
  4074c6:	687b      	ldr	r3, [r7, #4]
  4074c8:	6a1b      	ldr	r3, [r3, #32]
  4074ca:	60fb      	str	r3, [r7, #12]

	q[0] = (1.f + r11 + r22 + r33) / 4.f;
  4074cc:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  4074d0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  4074d4:	ee37 7a87 	vadd.f32	s14, s15, s14
  4074d8:	edd7 7a07 	vldr	s15, [r7, #28]
  4074dc:	ee37 7a27 	vadd.f32	s14, s14, s15
  4074e0:	edd7 7a03 	vldr	s15, [r7, #12]
  4074e4:	ee37 7a27 	vadd.f32	s14, s14, s15
  4074e8:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  4074ec:	eec7 7a26 	vdiv.f32	s15, s14, s13
  4074f0:	683b      	ldr	r3, [r7, #0]
  4074f2:	edc3 7a00 	vstr	s15, [r3]
	q[1] = (1.f + r11 - r22 - r33) / 4.f;
  4074f6:	683b      	ldr	r3, [r7, #0]
  4074f8:	3304      	adds	r3, #4
  4074fa:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  4074fe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  407502:	ee37 7a87 	vadd.f32	s14, s15, s14
  407506:	edd7 7a07 	vldr	s15, [r7, #28]
  40750a:	ee37 7a67 	vsub.f32	s14, s14, s15
  40750e:	edd7 7a03 	vldr	s15, [r7, #12]
  407512:	ee37 7a67 	vsub.f32	s14, s14, s15
  407516:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  40751a:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40751e:	edc3 7a00 	vstr	s15, [r3]
	q[2] = (1.f - r11 + r22 - r33) / 4.f;
  407522:	683b      	ldr	r3, [r7, #0]
  407524:	3308      	adds	r3, #8
  407526:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  40752a:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  40752e:	ee37 7a67 	vsub.f32	s14, s14, s15
  407532:	edd7 7a07 	vldr	s15, [r7, #28]
  407536:	ee37 7a27 	vadd.f32	s14, s14, s15
  40753a:	edd7 7a03 	vldr	s15, [r7, #12]
  40753e:	ee37 7a67 	vsub.f32	s14, s14, s15
  407542:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  407546:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40754a:	edc3 7a00 	vstr	s15, [r3]
	q[3] = (1.f - r11 - r22 + r33) / 4.f;
  40754e:	683b      	ldr	r3, [r7, #0]
  407550:	330c      	adds	r3, #12
  407552:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  407556:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  40755a:	ee37 7a67 	vsub.f32	s14, s14, s15
  40755e:	edd7 7a07 	vldr	s15, [r7, #28]
  407562:	ee37 7a67 	vsub.f32	s14, s14, s15
  407566:	edd7 7a03 	vldr	s15, [r7, #12]
  40756a:	ee37 7a27 	vadd.f32	s14, s14, s15
  40756e:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  407572:	eec7 7a26 	vdiv.f32	s15, s14, s13
  407576:	edc3 7a00 	vstr	s15, [r3]

	if(q[0] < 0.0f) q[0] = 0.0f;
  40757a:	683b      	ldr	r3, [r7, #0]
  40757c:	edd3 7a00 	vldr	s15, [r3]
  407580:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  407584:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407588:	d503      	bpl.n	407592 <inv_icm20648_convert_matrix_to_quat_flt+0x106>
  40758a:	683b      	ldr	r3, [r7, #0]
  40758c:	f04f 0200 	mov.w	r2, #0
  407590:	601a      	str	r2, [r3, #0]
	if(q[1] < 0.0f) q[1] = 0.0f;
  407592:	683b      	ldr	r3, [r7, #0]
  407594:	3304      	adds	r3, #4
  407596:	edd3 7a00 	vldr	s15, [r3]
  40759a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40759e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4075a2:	d504      	bpl.n	4075ae <inv_icm20648_convert_matrix_to_quat_flt+0x122>
  4075a4:	683b      	ldr	r3, [r7, #0]
  4075a6:	3304      	adds	r3, #4
  4075a8:	f04f 0200 	mov.w	r2, #0
  4075ac:	601a      	str	r2, [r3, #0]
	if(q[2] < 0.0f) q[2] = 0.0f;
  4075ae:	683b      	ldr	r3, [r7, #0]
  4075b0:	3308      	adds	r3, #8
  4075b2:	edd3 7a00 	vldr	s15, [r3]
  4075b6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4075ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4075be:	d504      	bpl.n	4075ca <inv_icm20648_convert_matrix_to_quat_flt+0x13e>
  4075c0:	683b      	ldr	r3, [r7, #0]
  4075c2:	3308      	adds	r3, #8
  4075c4:	f04f 0200 	mov.w	r2, #0
  4075c8:	601a      	str	r2, [r3, #0]
	if(q[3] < 0.0f) q[3] = 0.0f;
  4075ca:	683b      	ldr	r3, [r7, #0]
  4075cc:	330c      	adds	r3, #12
  4075ce:	edd3 7a00 	vldr	s15, [r3]
  4075d2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4075d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4075da:	d504      	bpl.n	4075e6 <inv_icm20648_convert_matrix_to_quat_flt+0x15a>
  4075dc:	683b      	ldr	r3, [r7, #0]
  4075de:	330c      	adds	r3, #12
  4075e0:	f04f 0200 	mov.w	r2, #0
  4075e4:	601a      	str	r2, [r3, #0]
	q[0] = sqrtf(q[0]);
  4075e6:	683b      	ldr	r3, [r7, #0]
  4075e8:	edd3 7a00 	vldr	s15, [r3]
  4075ec:	eeb0 0a67 	vmov.f32	s0, s15
  4075f0:	4bbe      	ldr	r3, [pc, #760]	; (4078ec <inv_icm20648_convert_matrix_to_quat_flt+0x460>)
  4075f2:	4798      	blx	r3
  4075f4:	eef0 7a40 	vmov.f32	s15, s0
  4075f8:	683b      	ldr	r3, [r7, #0]
  4075fa:	edc3 7a00 	vstr	s15, [r3]
	q[1] = sqrtf(q[1]);
  4075fe:	683b      	ldr	r3, [r7, #0]
  407600:	1d1c      	adds	r4, r3, #4
  407602:	683b      	ldr	r3, [r7, #0]
  407604:	3304      	adds	r3, #4
  407606:	edd3 7a00 	vldr	s15, [r3]
  40760a:	eeb0 0a67 	vmov.f32	s0, s15
  40760e:	4bb7      	ldr	r3, [pc, #732]	; (4078ec <inv_icm20648_convert_matrix_to_quat_flt+0x460>)
  407610:	4798      	blx	r3
  407612:	eef0 7a40 	vmov.f32	s15, s0
  407616:	edc4 7a00 	vstr	s15, [r4]
	q[2] = sqrtf(q[2]);
  40761a:	683b      	ldr	r3, [r7, #0]
  40761c:	f103 0408 	add.w	r4, r3, #8
  407620:	683b      	ldr	r3, [r7, #0]
  407622:	3308      	adds	r3, #8
  407624:	edd3 7a00 	vldr	s15, [r3]
  407628:	eeb0 0a67 	vmov.f32	s0, s15
  40762c:	4baf      	ldr	r3, [pc, #700]	; (4078ec <inv_icm20648_convert_matrix_to_quat_flt+0x460>)
  40762e:	4798      	blx	r3
  407630:	eef0 7a40 	vmov.f32	s15, s0
  407634:	edc4 7a00 	vstr	s15, [r4]
	q[3] = sqrtf(q[3]);
  407638:	683b      	ldr	r3, [r7, #0]
  40763a:	f103 040c 	add.w	r4, r3, #12
  40763e:	683b      	ldr	r3, [r7, #0]
  407640:	330c      	adds	r3, #12
  407642:	edd3 7a00 	vldr	s15, [r3]
  407646:	eeb0 0a67 	vmov.f32	s0, s15
  40764a:	4ba8      	ldr	r3, [pc, #672]	; (4078ec <inv_icm20648_convert_matrix_to_quat_flt+0x460>)
  40764c:	4798      	blx	r3
  40764e:	eef0 7a40 	vmov.f32	s15, s0
  407652:	edc4 7a00 	vstr	s15, [r4]
	q[1] =(q[1] < 0.0f) ? q[1] = 0.0f : sqrtf(q[1]);
	q[2] =(q[2] < 0.0f) ? q[2] = 0.0f : sqrtf(q[2]);
	q[3] =(q[3] < 0.0f) ? q[3] = 0.0f : sqrtf(q[3]);
	*/
	
	if(q[0] >= q[1] && q[0] >= q[2] && q[0] >= q[3]) //q[0] is max
  407656:	683b      	ldr	r3, [r7, #0]
  407658:	ed93 7a00 	vldr	s14, [r3]
  40765c:	683b      	ldr	r3, [r7, #0]
  40765e:	3304      	adds	r3, #4
  407660:	edd3 7a00 	vldr	s15, [r3]
  407664:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407668:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40766c:	db51      	blt.n	407712 <inv_icm20648_convert_matrix_to_quat_flt+0x286>
  40766e:	683b      	ldr	r3, [r7, #0]
  407670:	ed93 7a00 	vldr	s14, [r3]
  407674:	683b      	ldr	r3, [r7, #0]
  407676:	3308      	adds	r3, #8
  407678:	edd3 7a00 	vldr	s15, [r3]
  40767c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407680:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407684:	db45      	blt.n	407712 <inv_icm20648_convert_matrix_to_quat_flt+0x286>
  407686:	683b      	ldr	r3, [r7, #0]
  407688:	ed93 7a00 	vldr	s14, [r3]
  40768c:	683b      	ldr	r3, [r7, #0]
  40768e:	330c      	adds	r3, #12
  407690:	edd3 7a00 	vldr	s15, [r3]
  407694:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407698:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40769c:	db39      	blt.n	407712 <inv_icm20648_convert_matrix_to_quat_flt+0x286>
	{
		 q[1] = (r23 - r32)/(4.f*q[0]);
  40769e:	683b      	ldr	r3, [r7, #0]
  4076a0:	3304      	adds	r3, #4
  4076a2:	ed97 7a06 	vldr	s14, [r7, #24]
  4076a6:	edd7 7a04 	vldr	s15, [r7, #16]
  4076aa:	ee77 6a67 	vsub.f32	s13, s14, s15
  4076ae:	683a      	ldr	r2, [r7, #0]
  4076b0:	edd2 7a00 	vldr	s15, [r2]
  4076b4:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4076b8:	ee27 7a87 	vmul.f32	s14, s15, s14
  4076bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4076c0:	edc3 7a00 	vstr	s15, [r3]
		 q[2] = (r31 - r13)/(4.f*q[0]);
  4076c4:	683b      	ldr	r3, [r7, #0]
  4076c6:	3308      	adds	r3, #8
  4076c8:	ed97 7a05 	vldr	s14, [r7, #20]
  4076cc:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  4076d0:	ee77 6a67 	vsub.f32	s13, s14, s15
  4076d4:	683a      	ldr	r2, [r7, #0]
  4076d6:	edd2 7a00 	vldr	s15, [r2]
  4076da:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4076de:	ee27 7a87 	vmul.f32	s14, s15, s14
  4076e2:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4076e6:	edc3 7a00 	vstr	s15, [r3]
		 q[3] = (r12 - r21)/(4.f*q[0]);
  4076ea:	683b      	ldr	r3, [r7, #0]
  4076ec:	330c      	adds	r3, #12
  4076ee:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  4076f2:	edd7 7a08 	vldr	s15, [r7, #32]
  4076f6:	ee77 6a67 	vsub.f32	s13, s14, s15
  4076fa:	683a      	ldr	r2, [r7, #0]
  4076fc:	edd2 7a00 	vldr	s15, [r2]
  407700:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407704:	ee27 7a87 	vmul.f32	s14, s15, s14
  407708:	eec6 7a87 	vdiv.f32	s15, s13, s14
  40770c:	edc3 7a00 	vstr	s15, [r3]
  407710:	e12a      	b.n	407968 <inv_icm20648_convert_matrix_to_quat_flt+0x4dc>
	}
	else if(q[1] >= q[0] && q[1] >= q[2] && q[1] >= q[3]) //q[1] is max
  407712:	683b      	ldr	r3, [r7, #0]
  407714:	3304      	adds	r3, #4
  407716:	ed93 7a00 	vldr	s14, [r3]
  40771a:	683b      	ldr	r3, [r7, #0]
  40771c:	edd3 7a00 	vldr	s15, [r3]
  407720:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407724:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407728:	db55      	blt.n	4077d6 <inv_icm20648_convert_matrix_to_quat_flt+0x34a>
  40772a:	683b      	ldr	r3, [r7, #0]
  40772c:	3304      	adds	r3, #4
  40772e:	ed93 7a00 	vldr	s14, [r3]
  407732:	683b      	ldr	r3, [r7, #0]
  407734:	3308      	adds	r3, #8
  407736:	edd3 7a00 	vldr	s15, [r3]
  40773a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  40773e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407742:	db48      	blt.n	4077d6 <inv_icm20648_convert_matrix_to_quat_flt+0x34a>
  407744:	683b      	ldr	r3, [r7, #0]
  407746:	3304      	adds	r3, #4
  407748:	ed93 7a00 	vldr	s14, [r3]
  40774c:	683b      	ldr	r3, [r7, #0]
  40774e:	330c      	adds	r3, #12
  407750:	edd3 7a00 	vldr	s15, [r3]
  407754:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407758:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40775c:	db3b      	blt.n	4077d6 <inv_icm20648_convert_matrix_to_quat_flt+0x34a>
	{
		 q[0] = (r23 - r32)/(4.f*q[1]);
  40775e:	ed97 7a06 	vldr	s14, [r7, #24]
  407762:	edd7 7a04 	vldr	s15, [r7, #16]
  407766:	ee77 6a67 	vsub.f32	s13, s14, s15
  40776a:	683b      	ldr	r3, [r7, #0]
  40776c:	3304      	adds	r3, #4
  40776e:	edd3 7a00 	vldr	s15, [r3]
  407772:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407776:	ee27 7a87 	vmul.f32	s14, s15, s14
  40777a:	eec6 7a87 	vdiv.f32	s15, s13, s14
  40777e:	683b      	ldr	r3, [r7, #0]
  407780:	edc3 7a00 	vstr	s15, [r3]
		 q[2] = (r12 + r21)/(4.f*q[1]);
  407784:	683b      	ldr	r3, [r7, #0]
  407786:	3308      	adds	r3, #8
  407788:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  40778c:	edd7 7a08 	vldr	s15, [r7, #32]
  407790:	ee77 6a27 	vadd.f32	s13, s14, s15
  407794:	683a      	ldr	r2, [r7, #0]
  407796:	3204      	adds	r2, #4
  407798:	edd2 7a00 	vldr	s15, [r2]
  40779c:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4077a0:	ee27 7a87 	vmul.f32	s14, s15, s14
  4077a4:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4077a8:	edc3 7a00 	vstr	s15, [r3]
		 q[3] = (r31 + r13)/(4.f*q[1]);
  4077ac:	683b      	ldr	r3, [r7, #0]
  4077ae:	330c      	adds	r3, #12
  4077b0:	ed97 7a05 	vldr	s14, [r7, #20]
  4077b4:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  4077b8:	ee77 6a27 	vadd.f32	s13, s14, s15
  4077bc:	683a      	ldr	r2, [r7, #0]
  4077be:	3204      	adds	r2, #4
  4077c0:	edd2 7a00 	vldr	s15, [r2]
  4077c4:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4077c8:	ee27 7a87 	vmul.f32	s14, s15, s14
  4077cc:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4077d0:	edc3 7a00 	vstr	s15, [r3]
  4077d4:	e0c8      	b.n	407968 <inv_icm20648_convert_matrix_to_quat_flt+0x4dc>
	}
	else if(q[2] >= q[0] && q[2] >= q[1] && q[2] >= q[3]) //q[2] is max
  4077d6:	683b      	ldr	r3, [r7, #0]
  4077d8:	3308      	adds	r3, #8
  4077da:	ed93 7a00 	vldr	s14, [r3]
  4077de:	683b      	ldr	r3, [r7, #0]
  4077e0:	edd3 7a00 	vldr	s15, [r3]
  4077e4:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4077e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4077ec:	db55      	blt.n	40789a <inv_icm20648_convert_matrix_to_quat_flt+0x40e>
  4077ee:	683b      	ldr	r3, [r7, #0]
  4077f0:	3308      	adds	r3, #8
  4077f2:	ed93 7a00 	vldr	s14, [r3]
  4077f6:	683b      	ldr	r3, [r7, #0]
  4077f8:	3304      	adds	r3, #4
  4077fa:	edd3 7a00 	vldr	s15, [r3]
  4077fe:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407802:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407806:	db48      	blt.n	40789a <inv_icm20648_convert_matrix_to_quat_flt+0x40e>
  407808:	683b      	ldr	r3, [r7, #0]
  40780a:	3308      	adds	r3, #8
  40780c:	ed93 7a00 	vldr	s14, [r3]
  407810:	683b      	ldr	r3, [r7, #0]
  407812:	330c      	adds	r3, #12
  407814:	edd3 7a00 	vldr	s15, [r3]
  407818:	eeb4 7ae7 	vcmpe.f32	s14, s15
  40781c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407820:	db3b      	blt.n	40789a <inv_icm20648_convert_matrix_to_quat_flt+0x40e>
	{
		 q[0] = (r31 - r13)/(4.f*q[2]);
  407822:	ed97 7a05 	vldr	s14, [r7, #20]
  407826:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  40782a:	ee77 6a67 	vsub.f32	s13, s14, s15
  40782e:	683b      	ldr	r3, [r7, #0]
  407830:	3308      	adds	r3, #8
  407832:	edd3 7a00 	vldr	s15, [r3]
  407836:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  40783a:	ee27 7a87 	vmul.f32	s14, s15, s14
  40783e:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407842:	683b      	ldr	r3, [r7, #0]
  407844:	edc3 7a00 	vstr	s15, [r3]
		 q[1] = (r12 + r21)/(4.f*q[2]);
  407848:	683b      	ldr	r3, [r7, #0]
  40784a:	3304      	adds	r3, #4
  40784c:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  407850:	edd7 7a08 	vldr	s15, [r7, #32]
  407854:	ee77 6a27 	vadd.f32	s13, s14, s15
  407858:	683a      	ldr	r2, [r7, #0]
  40785a:	3208      	adds	r2, #8
  40785c:	edd2 7a00 	vldr	s15, [r2]
  407860:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407864:	ee27 7a87 	vmul.f32	s14, s15, s14
  407868:	eec6 7a87 	vdiv.f32	s15, s13, s14
  40786c:	edc3 7a00 	vstr	s15, [r3]
		 q[3] = (r23 + r32)/(4.f*q[2]);
  407870:	683b      	ldr	r3, [r7, #0]
  407872:	330c      	adds	r3, #12
  407874:	ed97 7a06 	vldr	s14, [r7, #24]
  407878:	edd7 7a04 	vldr	s15, [r7, #16]
  40787c:	ee77 6a27 	vadd.f32	s13, s14, s15
  407880:	683a      	ldr	r2, [r7, #0]
  407882:	3208      	adds	r2, #8
  407884:	edd2 7a00 	vldr	s15, [r2]
  407888:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  40788c:	ee27 7a87 	vmul.f32	s14, s15, s14
  407890:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407894:	edc3 7a00 	vstr	s15, [r3]
  407898:	e066      	b.n	407968 <inv_icm20648_convert_matrix_to_quat_flt+0x4dc>
	}
	else if(q[3] >= q[0] && q[3] >= q[1] && q[3] >= q[2]) //q[3] is max
  40789a:	683b      	ldr	r3, [r7, #0]
  40789c:	330c      	adds	r3, #12
  40789e:	ed93 7a00 	vldr	s14, [r3]
  4078a2:	683b      	ldr	r3, [r7, #0]
  4078a4:	edd3 7a00 	vldr	s15, [r3]
  4078a8:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4078ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4078b0:	da00      	bge.n	4078b4 <inv_icm20648_convert_matrix_to_quat_flt+0x428>
	{
		 q[0] = (r12 - r21)/(4.f*q[3]);
		 q[1] = (r31 + r13)/(4.f*q[3]);
		 q[2] = (r23 + r32)/(4.f*q[3]);
	}
}
  4078b2:	e059      	b.n	407968 <inv_icm20648_convert_matrix_to_quat_flt+0x4dc>
	else if(q[3] >= q[0] && q[3] >= q[1] && q[3] >= q[2]) //q[3] is max
  4078b4:	683b      	ldr	r3, [r7, #0]
  4078b6:	330c      	adds	r3, #12
  4078b8:	ed93 7a00 	vldr	s14, [r3]
  4078bc:	683b      	ldr	r3, [r7, #0]
  4078be:	3304      	adds	r3, #4
  4078c0:	edd3 7a00 	vldr	s15, [r3]
  4078c4:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4078c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4078cc:	da00      	bge.n	4078d0 <inv_icm20648_convert_matrix_to_quat_flt+0x444>
}
  4078ce:	e04b      	b.n	407968 <inv_icm20648_convert_matrix_to_quat_flt+0x4dc>
	else if(q[3] >= q[0] && q[3] >= q[1] && q[3] >= q[2]) //q[3] is max
  4078d0:	683b      	ldr	r3, [r7, #0]
  4078d2:	330c      	adds	r3, #12
  4078d4:	ed93 7a00 	vldr	s14, [r3]
  4078d8:	683b      	ldr	r3, [r7, #0]
  4078da:	3308      	adds	r3, #8
  4078dc:	edd3 7a00 	vldr	s15, [r3]
  4078e0:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4078e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4078e8:	da02      	bge.n	4078f0 <inv_icm20648_convert_matrix_to_quat_flt+0x464>
}
  4078ea:	e03d      	b.n	407968 <inv_icm20648_convert_matrix_to_quat_flt+0x4dc>
  4078ec:	00412941 	.word	0x00412941
		 q[0] = (r12 - r21)/(4.f*q[3]);
  4078f0:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  4078f4:	edd7 7a08 	vldr	s15, [r7, #32]
  4078f8:	ee77 6a67 	vsub.f32	s13, s14, s15
  4078fc:	683b      	ldr	r3, [r7, #0]
  4078fe:	330c      	adds	r3, #12
  407900:	edd3 7a00 	vldr	s15, [r3]
  407904:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407908:	ee27 7a87 	vmul.f32	s14, s15, s14
  40790c:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407910:	683b      	ldr	r3, [r7, #0]
  407912:	edc3 7a00 	vstr	s15, [r3]
		 q[1] = (r31 + r13)/(4.f*q[3]);
  407916:	683b      	ldr	r3, [r7, #0]
  407918:	3304      	adds	r3, #4
  40791a:	ed97 7a05 	vldr	s14, [r7, #20]
  40791e:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  407922:	ee77 6a27 	vadd.f32	s13, s14, s15
  407926:	683a      	ldr	r2, [r7, #0]
  407928:	320c      	adds	r2, #12
  40792a:	edd2 7a00 	vldr	s15, [r2]
  40792e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407932:	ee27 7a87 	vmul.f32	s14, s15, s14
  407936:	eec6 7a87 	vdiv.f32	s15, s13, s14
  40793a:	edc3 7a00 	vstr	s15, [r3]
		 q[2] = (r23 + r32)/(4.f*q[3]);
  40793e:	683b      	ldr	r3, [r7, #0]
  407940:	3308      	adds	r3, #8
  407942:	ed97 7a06 	vldr	s14, [r7, #24]
  407946:	edd7 7a04 	vldr	s15, [r7, #16]
  40794a:	ee77 6a27 	vadd.f32	s13, s14, s15
  40794e:	683a      	ldr	r2, [r7, #0]
  407950:	320c      	adds	r2, #12
  407952:	edd2 7a00 	vldr	s15, [r2]
  407956:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  40795a:	ee27 7a87 	vmul.f32	s14, s15, s14
  40795e:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407962:	edc3 7a00 	vstr	s15, [r3]
}
  407966:	e7ff      	b.n	407968 <inv_icm20648_convert_matrix_to_quat_flt+0x4dc>
  407968:	bf00      	nop
  40796a:	3734      	adds	r7, #52	; 0x34
  40796c:	46bd      	mov	sp, r7
  40796e:	bd90      	pop	{r4, r7, pc}

00407970 <inv_icm20648_convert_mult_qfix_fxp>:

long inv_icm20648_convert_mult_qfix_fxp(long a, long b, unsigned char qfix)
{
  407970:	b5f0      	push	{r4, r5, r6, r7, lr}
  407972:	b089      	sub	sp, #36	; 0x24
  407974:	af00      	add	r7, sp, #0
  407976:	60f8      	str	r0, [r7, #12]
  407978:	60b9      	str	r1, [r7, #8]
  40797a:	71fa      	strb	r2, [r7, #7]
    long long temp;
    long result;
    temp = (long long)a * b;
  40797c:	68fa      	ldr	r2, [r7, #12]
  40797e:	4615      	mov	r5, r2
  407980:	ea4f 76e5 	mov.w	r6, r5, asr #31
  407984:	68ba      	ldr	r2, [r7, #8]
  407986:	4611      	mov	r1, r2
  407988:	ea4f 72e1 	mov.w	r2, r1, asr #31
  40798c:	fb01 fe06 	mul.w	lr, r1, r6
  407990:	fb05 f002 	mul.w	r0, r5, r2
  407994:	4470      	add	r0, lr
  407996:	fba5 1201 	umull	r1, r2, r5, r1
  40799a:	4410      	add	r0, r2
  40799c:	4602      	mov	r2, r0
  40799e:	e9c7 1206 	strd	r1, r2, [r7, #24]
  4079a2:	e9c7 1206 	strd	r1, r2, [r7, #24]
    result = (long)(temp >> qfix);
  4079a6:	79f8      	ldrb	r0, [r7, #7]
  4079a8:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
  4079ac:	f1c0 0620 	rsb	r6, r0, #32
  4079b0:	f1b0 0520 	subs.w	r5, r0, #32
  4079b4:	fa21 f300 	lsr.w	r3, r1, r0
  4079b8:	fa02 f606 	lsl.w	r6, r2, r6
  4079bc:	ea43 0306 	orr.w	r3, r3, r6
  4079c0:	d402      	bmi.n	4079c8 <inv_icm20648_convert_mult_qfix_fxp+0x58>
  4079c2:	fa42 f505 	asr.w	r5, r2, r5
  4079c6:	432b      	orrs	r3, r5
  4079c8:	fa42 f400 	asr.w	r4, r2, r0
  4079cc:	617b      	str	r3, [r7, #20]
    return result;
  4079ce:	697b      	ldr	r3, [r7, #20]
}
  4079d0:	4618      	mov	r0, r3
  4079d2:	3724      	adds	r7, #36	; 0x24
  4079d4:	46bd      	mov	sp, r7
  4079d6:	bdf0      	pop	{r4, r5, r6, r7, pc}

004079d8 <invn_convert_mult_q29_fxp>:

static long invn_convert_mult_q29_fxp(long a_q29, long b_q29)
{
  4079d8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4079da:	b087      	sub	sp, #28
  4079dc:	af00      	add	r7, sp, #0
  4079de:	6078      	str	r0, [r7, #4]
  4079e0:	6039      	str	r1, [r7, #0]
	long long temp;
	long result;
	temp = (long long)a_q29 * b_q29;
  4079e2:	687a      	ldr	r2, [r7, #4]
  4079e4:	4615      	mov	r5, r2
  4079e6:	ea4f 76e5 	mov.w	r6, r5, asr #31
  4079ea:	683a      	ldr	r2, [r7, #0]
  4079ec:	4611      	mov	r1, r2
  4079ee:	ea4f 72e1 	mov.w	r2, r1, asr #31
  4079f2:	fb01 fe06 	mul.w	lr, r1, r6
  4079f6:	fb05 f002 	mul.w	r0, r5, r2
  4079fa:	4470      	add	r0, lr
  4079fc:	fba5 1201 	umull	r1, r2, r5, r1
  407a00:	4410      	add	r0, r2
  407a02:	4602      	mov	r2, r0
  407a04:	e9c7 1204 	strd	r1, r2, [r7, #16]
  407a08:	e9c7 1204 	strd	r1, r2, [r7, #16]
	result = (long)(temp >> 29);
  407a0c:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
  407a10:	0f4b      	lsrs	r3, r1, #29
  407a12:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
  407a16:	1754      	asrs	r4, r2, #29
  407a18:	60fb      	str	r3, [r7, #12]
	return result;
  407a1a:	68fb      	ldr	r3, [r7, #12]

}
  407a1c:	4618      	mov	r0, r3
  407a1e:	371c      	adds	r7, #28
  407a20:	46bd      	mov	sp, r7
  407a22:	bdf0      	pop	{r4, r5, r6, r7, pc}

00407a24 <inv_icm20648_convert_quat_to_col_major_matrix_fxp>:

void inv_icm20648_convert_quat_to_col_major_matrix_fxp(const long *quat_q30, long *rot_q30)
{
  407a24:	b5b0      	push	{r4, r5, r7, lr}
  407a26:	b082      	sub	sp, #8
  407a28:	af00      	add	r7, sp, #0
  407a2a:	6078      	str	r0, [r7, #4]
  407a2c:	6039      	str	r1, [r7, #0]
	//Use q29 in order to skip a multiplication by 2
    rot_q30[0] =
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[1]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
  407a2e:	687b      	ldr	r3, [r7, #4]
  407a30:	3304      	adds	r3, #4
  407a32:	681a      	ldr	r2, [r3, #0]
  407a34:	687b      	ldr	r3, [r7, #4]
  407a36:	3304      	adds	r3, #4
  407a38:	681b      	ldr	r3, [r3, #0]
  407a3a:	4619      	mov	r1, r3
  407a3c:	4610      	mov	r0, r2
  407a3e:	4b73      	ldr	r3, [pc, #460]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407a40:	4798      	blx	r3
  407a42:	4604      	mov	r4, r0
  407a44:	687b      	ldr	r3, [r7, #4]
  407a46:	681a      	ldr	r2, [r3, #0]
  407a48:	687b      	ldr	r3, [r7, #4]
  407a4a:	681b      	ldr	r3, [r3, #0]
  407a4c:	4619      	mov	r1, r3
  407a4e:	4610      	mov	r0, r2
  407a50:	4b6e      	ldr	r3, [pc, #440]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407a52:	4798      	blx	r3
  407a54:	4603      	mov	r3, r0
  407a56:	4423      	add	r3, r4
  407a58:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
    rot_q30[0] =
  407a5c:	683b      	ldr	r3, [r7, #0]
  407a5e:	601a      	str	r2, [r3, #0]
    rot_q30[1] =
  407a60:	683b      	ldr	r3, [r7, #0]
  407a62:	1d1c      	adds	r4, r3, #4
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[2]) - invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[0]);
  407a64:	687b      	ldr	r3, [r7, #4]
  407a66:	3304      	adds	r3, #4
  407a68:	681a      	ldr	r2, [r3, #0]
  407a6a:	687b      	ldr	r3, [r7, #4]
  407a6c:	3308      	adds	r3, #8
  407a6e:	681b      	ldr	r3, [r3, #0]
  407a70:	4619      	mov	r1, r3
  407a72:	4610      	mov	r0, r2
  407a74:	4b65      	ldr	r3, [pc, #404]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407a76:	4798      	blx	r3
  407a78:	4605      	mov	r5, r0
  407a7a:	687b      	ldr	r3, [r7, #4]
  407a7c:	330c      	adds	r3, #12
  407a7e:	681a      	ldr	r2, [r3, #0]
  407a80:	687b      	ldr	r3, [r7, #4]
  407a82:	681b      	ldr	r3, [r3, #0]
  407a84:	4619      	mov	r1, r3
  407a86:	4610      	mov	r0, r2
  407a88:	4b60      	ldr	r3, [pc, #384]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407a8a:	4798      	blx	r3
  407a8c:	4603      	mov	r3, r0
  407a8e:	1aeb      	subs	r3, r5, r3
    rot_q30[1] =
  407a90:	6023      	str	r3, [r4, #0]
    rot_q30[2] =
  407a92:	683b      	ldr	r3, [r7, #0]
  407a94:	f103 0408 	add.w	r4, r3, #8
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[0]);
  407a98:	687b      	ldr	r3, [r7, #4]
  407a9a:	3304      	adds	r3, #4
  407a9c:	681a      	ldr	r2, [r3, #0]
  407a9e:	687b      	ldr	r3, [r7, #4]
  407aa0:	330c      	adds	r3, #12
  407aa2:	681b      	ldr	r3, [r3, #0]
  407aa4:	4619      	mov	r1, r3
  407aa6:	4610      	mov	r0, r2
  407aa8:	4b58      	ldr	r3, [pc, #352]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407aaa:	4798      	blx	r3
  407aac:	4605      	mov	r5, r0
  407aae:	687b      	ldr	r3, [r7, #4]
  407ab0:	3308      	adds	r3, #8
  407ab2:	681a      	ldr	r2, [r3, #0]
  407ab4:	687b      	ldr	r3, [r7, #4]
  407ab6:	681b      	ldr	r3, [r3, #0]
  407ab8:	4619      	mov	r1, r3
  407aba:	4610      	mov	r0, r2
  407abc:	4b53      	ldr	r3, [pc, #332]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407abe:	4798      	blx	r3
  407ac0:	4603      	mov	r3, r0
  407ac2:	442b      	add	r3, r5
    rot_q30[2] =
  407ac4:	6023      	str	r3, [r4, #0]
    rot_q30[3] =
  407ac6:	683b      	ldr	r3, [r7, #0]
  407ac8:	f103 040c 	add.w	r4, r3, #12
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[2]) + invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[0]);
  407acc:	687b      	ldr	r3, [r7, #4]
  407ace:	3304      	adds	r3, #4
  407ad0:	681a      	ldr	r2, [r3, #0]
  407ad2:	687b      	ldr	r3, [r7, #4]
  407ad4:	3308      	adds	r3, #8
  407ad6:	681b      	ldr	r3, [r3, #0]
  407ad8:	4619      	mov	r1, r3
  407ada:	4610      	mov	r0, r2
  407adc:	4b4b      	ldr	r3, [pc, #300]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407ade:	4798      	blx	r3
  407ae0:	4605      	mov	r5, r0
  407ae2:	687b      	ldr	r3, [r7, #4]
  407ae4:	330c      	adds	r3, #12
  407ae6:	681a      	ldr	r2, [r3, #0]
  407ae8:	687b      	ldr	r3, [r7, #4]
  407aea:	681b      	ldr	r3, [r3, #0]
  407aec:	4619      	mov	r1, r3
  407aee:	4610      	mov	r0, r2
  407af0:	4b46      	ldr	r3, [pc, #280]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407af2:	4798      	blx	r3
  407af4:	4603      	mov	r3, r0
  407af6:	442b      	add	r3, r5
    rot_q30[3] =
  407af8:	6023      	str	r3, [r4, #0]
    rot_q30[4] =
  407afa:	683b      	ldr	r3, [r7, #0]
  407afc:	f103 0410 	add.w	r4, r3, #16
        invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[2]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
  407b00:	687b      	ldr	r3, [r7, #4]
  407b02:	3308      	adds	r3, #8
  407b04:	681a      	ldr	r2, [r3, #0]
  407b06:	687b      	ldr	r3, [r7, #4]
  407b08:	3308      	adds	r3, #8
  407b0a:	681b      	ldr	r3, [r3, #0]
  407b0c:	4619      	mov	r1, r3
  407b0e:	4610      	mov	r0, r2
  407b10:	4b3e      	ldr	r3, [pc, #248]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407b12:	4798      	blx	r3
  407b14:	4605      	mov	r5, r0
  407b16:	687b      	ldr	r3, [r7, #4]
  407b18:	681a      	ldr	r2, [r3, #0]
  407b1a:	687b      	ldr	r3, [r7, #4]
  407b1c:	681b      	ldr	r3, [r3, #0]
  407b1e:	4619      	mov	r1, r3
  407b20:	4610      	mov	r0, r2
  407b22:	4b3a      	ldr	r3, [pc, #232]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407b24:	4798      	blx	r3
  407b26:	4603      	mov	r3, r0
  407b28:	442b      	add	r3, r5
  407b2a:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
    rot_q30[4] =
  407b2e:	6023      	str	r3, [r4, #0]
    rot_q30[5] =
  407b30:	683b      	ldr	r3, [r7, #0]
  407b32:	f103 0414 	add.w	r4, r3, #20
        invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[3]) - invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[0]);
  407b36:	687b      	ldr	r3, [r7, #4]
  407b38:	3308      	adds	r3, #8
  407b3a:	681a      	ldr	r2, [r3, #0]
  407b3c:	687b      	ldr	r3, [r7, #4]
  407b3e:	330c      	adds	r3, #12
  407b40:	681b      	ldr	r3, [r3, #0]
  407b42:	4619      	mov	r1, r3
  407b44:	4610      	mov	r0, r2
  407b46:	4b31      	ldr	r3, [pc, #196]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407b48:	4798      	blx	r3
  407b4a:	4605      	mov	r5, r0
  407b4c:	687b      	ldr	r3, [r7, #4]
  407b4e:	3304      	adds	r3, #4
  407b50:	681a      	ldr	r2, [r3, #0]
  407b52:	687b      	ldr	r3, [r7, #4]
  407b54:	681b      	ldr	r3, [r3, #0]
  407b56:	4619      	mov	r1, r3
  407b58:	4610      	mov	r0, r2
  407b5a:	4b2c      	ldr	r3, [pc, #176]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407b5c:	4798      	blx	r3
  407b5e:	4603      	mov	r3, r0
  407b60:	1aeb      	subs	r3, r5, r3
    rot_q30[5] =
  407b62:	6023      	str	r3, [r4, #0]
    rot_q30[6] =
  407b64:	683b      	ldr	r3, [r7, #0]
  407b66:	f103 0418 	add.w	r4, r3, #24
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[3]) - invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[0]);
  407b6a:	687b      	ldr	r3, [r7, #4]
  407b6c:	3304      	adds	r3, #4
  407b6e:	681a      	ldr	r2, [r3, #0]
  407b70:	687b      	ldr	r3, [r7, #4]
  407b72:	330c      	adds	r3, #12
  407b74:	681b      	ldr	r3, [r3, #0]
  407b76:	4619      	mov	r1, r3
  407b78:	4610      	mov	r0, r2
  407b7a:	4b24      	ldr	r3, [pc, #144]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407b7c:	4798      	blx	r3
  407b7e:	4605      	mov	r5, r0
  407b80:	687b      	ldr	r3, [r7, #4]
  407b82:	3308      	adds	r3, #8
  407b84:	681a      	ldr	r2, [r3, #0]
  407b86:	687b      	ldr	r3, [r7, #4]
  407b88:	681b      	ldr	r3, [r3, #0]
  407b8a:	4619      	mov	r1, r3
  407b8c:	4610      	mov	r0, r2
  407b8e:	4b1f      	ldr	r3, [pc, #124]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407b90:	4798      	blx	r3
  407b92:	4603      	mov	r3, r0
  407b94:	1aeb      	subs	r3, r5, r3
    rot_q30[6] =
  407b96:	6023      	str	r3, [r4, #0]
    rot_q30[7] =
  407b98:	683b      	ldr	r3, [r7, #0]
  407b9a:	f103 041c 	add.w	r4, r3, #28
        invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[0]);
  407b9e:	687b      	ldr	r3, [r7, #4]
  407ba0:	3308      	adds	r3, #8
  407ba2:	681a      	ldr	r2, [r3, #0]
  407ba4:	687b      	ldr	r3, [r7, #4]
  407ba6:	330c      	adds	r3, #12
  407ba8:	681b      	ldr	r3, [r3, #0]
  407baa:	4619      	mov	r1, r3
  407bac:	4610      	mov	r0, r2
  407bae:	4b17      	ldr	r3, [pc, #92]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407bb0:	4798      	blx	r3
  407bb2:	4605      	mov	r5, r0
  407bb4:	687b      	ldr	r3, [r7, #4]
  407bb6:	3304      	adds	r3, #4
  407bb8:	681a      	ldr	r2, [r3, #0]
  407bba:	687b      	ldr	r3, [r7, #4]
  407bbc:	681b      	ldr	r3, [r3, #0]
  407bbe:	4619      	mov	r1, r3
  407bc0:	4610      	mov	r0, r2
  407bc2:	4b12      	ldr	r3, [pc, #72]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407bc4:	4798      	blx	r3
  407bc6:	4603      	mov	r3, r0
  407bc8:	442b      	add	r3, r5
    rot_q30[7] =
  407bca:	6023      	str	r3, [r4, #0]
    rot_q30[8] =
  407bcc:	683b      	ldr	r3, [r7, #0]
  407bce:	f103 0420 	add.w	r4, r3, #32
        invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
  407bd2:	687b      	ldr	r3, [r7, #4]
  407bd4:	330c      	adds	r3, #12
  407bd6:	681a      	ldr	r2, [r3, #0]
  407bd8:	687b      	ldr	r3, [r7, #4]
  407bda:	330c      	adds	r3, #12
  407bdc:	681b      	ldr	r3, [r3, #0]
  407bde:	4619      	mov	r1, r3
  407be0:	4610      	mov	r0, r2
  407be2:	4b0a      	ldr	r3, [pc, #40]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407be4:	4798      	blx	r3
  407be6:	4605      	mov	r5, r0
  407be8:	687b      	ldr	r3, [r7, #4]
  407bea:	681a      	ldr	r2, [r3, #0]
  407bec:	687b      	ldr	r3, [r7, #4]
  407bee:	681b      	ldr	r3, [r3, #0]
  407bf0:	4619      	mov	r1, r3
  407bf2:	4610      	mov	r0, r2
  407bf4:	4b05      	ldr	r3, [pc, #20]	; (407c0c <inv_icm20648_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407bf6:	4798      	blx	r3
  407bf8:	4603      	mov	r3, r0
  407bfa:	442b      	add	r3, r5
  407bfc:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
    rot_q30[8] =
  407c00:	6023      	str	r3, [r4, #0]
}
  407c02:	bf00      	nop
  407c04:	3708      	adds	r7, #8
  407c06:	46bd      	mov	sp, r7
  407c08:	bdb0      	pop	{r4, r5, r7, pc}
  407c0a:	bf00      	nop
  407c0c:	004079d9 	.word	0x004079d9

00407c10 <invn_convert_mult_q15_fxp>:

static long invn_convert_mult_q15_fxp(long a_q15, long b_q15)
{
  407c10:	b5f0      	push	{r4, r5, r6, r7, lr}
  407c12:	b085      	sub	sp, #20
  407c14:	af00      	add	r7, sp, #0
  407c16:	6078      	str	r0, [r7, #4]
  407c18:	6039      	str	r1, [r7, #0]
	long out = (long)(((long long)a_q15 * (long long)b_q15) >> 15);
  407c1a:	687b      	ldr	r3, [r7, #4]
  407c1c:	4619      	mov	r1, r3
  407c1e:	ea4f 72e1 	mov.w	r2, r1, asr #31
  407c22:	683b      	ldr	r3, [r7, #0]
  407c24:	ea4f 74e3 	mov.w	r4, r3, asr #31
  407c28:	fb03 fe02 	mul.w	lr, r3, r2
  407c2c:	fb01 f004 	mul.w	r0, r1, r4
  407c30:	4470      	add	r0, lr
  407c32:	fba1 3403 	umull	r3, r4, r1, r3
  407c36:	1902      	adds	r2, r0, r4
  407c38:	4614      	mov	r4, r2
  407c3a:	0bdd      	lsrs	r5, r3, #15
  407c3c:	ea45 4544 	orr.w	r5, r5, r4, lsl #17
  407c40:	13e6      	asrs	r6, r4, #15
  407c42:	462b      	mov	r3, r5
  407c44:	60fb      	str	r3, [r7, #12]
	return out;
  407c46:	68fb      	ldr	r3, [r7, #12]
}
  407c48:	4618      	mov	r0, r3
  407c4a:	3714      	adds	r7, #20
  407c4c:	46bd      	mov	sp, r7
  407c4e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00407c50 <invn_convert_inv_sqrt_q15_fxp>:

static long invn_convert_inv_sqrt_q15_fxp(long x_q15)
{
  407c50:	b580      	push	{r7, lr}
  407c52:	b08a      	sub	sp, #40	; 0x28
  407c54:	af00      	add	r7, sp, #0
  407c56:	6078      	str	r0, [r7, #4]
    long oneoversqrt2 = 23170L; // int32(2^15*1/sqrt(2))
  407c58:	f645 2382 	movw	r3, #23170	; 0x5a82
  407c5c:	61bb      	str	r3, [r7, #24]
    long oneandhalf = 49152L; // int32(1.5*2^15);
  407c5e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
  407c62:	617b      	str	r3, [r7, #20]
    long upperlimit = 45426; // int32(log(4)*2^15);
  407c64:	f24b 1372 	movw	r3, #45426	; 0xb172
  407c68:	613b      	str	r3, [r7, #16]
    long lowerlimit = 22713; // int32(log(2)*2^15); 
  407c6a:	f645 03b9 	movw	r3, #22713	; 0x58b9
  407c6e:	60fb      	str	r3, [r7, #12]
    long xx, x0_2, invsqrtx;
    int pow2;

    if (x_q15 <= 0)
  407c70:	687b      	ldr	r3, [r7, #4]
  407c72:	2b00      	cmp	r3, #0
  407c74:	dc01      	bgt.n	407c7a <invn_convert_inv_sqrt_q15_fxp+0x2a>
        return 0L;
  407c76:	2300      	movs	r3, #0
  407c78:	e078      	b.n	407d6c <invn_convert_inv_sqrt_q15_fxp+0x11c>

    pow2 = 0;
  407c7a:	2300      	movs	r3, #0
  407c7c:	61fb      	str	r3, [r7, #28]
    xx = x_q15;
  407c7e:	687b      	ldr	r3, [r7, #4]
  407c80:	627b      	str	r3, [r7, #36]	; 0x24
    if (xx > upperlimit) {
  407c82:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407c84:	693b      	ldr	r3, [r7, #16]
  407c86:	429a      	cmp	r2, r3
  407c88:	dd0c      	ble.n	407ca4 <invn_convert_inv_sqrt_q15_fxp+0x54>
downscale:
        if (xx > upperlimit) {
  407c8a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407c8c:	693b      	ldr	r3, [r7, #16]
  407c8e:	429a      	cmp	r2, r3
  407c90:	dd17      	ble.n	407cc2 <invn_convert_inv_sqrt_q15_fxp+0x72>
            xx = xx/2;
  407c92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407c94:	0fda      	lsrs	r2, r3, #31
  407c96:	4413      	add	r3, r2
  407c98:	105b      	asrs	r3, r3, #1
  407c9a:	627b      	str	r3, [r7, #36]	; 0x24
            pow2 = pow2 - 1;
  407c9c:	69fb      	ldr	r3, [r7, #28]
  407c9e:	3b01      	subs	r3, #1
  407ca0:	61fb      	str	r3, [r7, #28]
            goto downscale;
  407ca2:	e7f2      	b.n	407c8a <invn_convert_inv_sqrt_q15_fxp+0x3a>
        }
        goto newton_raphson;
    }

    if (xx < lowerlimit) {
  407ca4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407ca6:	68fb      	ldr	r3, [r7, #12]
  407ca8:	429a      	cmp	r2, r3
  407caa:	da0d      	bge.n	407cc8 <invn_convert_inv_sqrt_q15_fxp+0x78>
upscale:
        if (xx < lowerlimit) {
  407cac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407cae:	68fb      	ldr	r3, [r7, #12]
  407cb0:	429a      	cmp	r2, r3
  407cb2:	da08      	bge.n	407cc6 <invn_convert_inv_sqrt_q15_fxp+0x76>
            xx = xx*2;
  407cb4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407cb6:	005b      	lsls	r3, r3, #1
  407cb8:	627b      	str	r3, [r7, #36]	; 0x24
            pow2 = pow2 + 1;
  407cba:	69fb      	ldr	r3, [r7, #28]
  407cbc:	3301      	adds	r3, #1
  407cbe:	61fb      	str	r3, [r7, #28]
            goto upscale;
  407cc0:	e7f4      	b.n	407cac <invn_convert_inv_sqrt_q15_fxp+0x5c>
        goto newton_raphson;
  407cc2:	bf00      	nop
  407cc4:	e000      	b.n	407cc8 <invn_convert_inv_sqrt_q15_fxp+0x78>
        }
        goto newton_raphson;
  407cc6:	bf00      	nop
    }

newton_raphson:
    // 3 NR iterations. In some cases second and/or third iteration may not be needed, however
    // for code simplicity always iterate three times. Fourth iteration is below bit precision.
    x0_2 = xx >>1;
  407cc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407cca:	105b      	asrs	r3, r3, #1
  407ccc:	60bb      	str	r3, [r7, #8]
    xx = oneandhalf - x0_2;
  407cce:	697a      	ldr	r2, [r7, #20]
  407cd0:	68bb      	ldr	r3, [r7, #8]
  407cd2:	1ad3      	subs	r3, r2, r3
  407cd4:	627b      	str	r3, [r7, #36]	; 0x24
    xx = invn_convert_mult_q15_fxp( xx, ( oneandhalf - invn_convert_mult_q15_fxp(x0_2, invn_convert_mult_q15_fxp(xx,xx) ) ) );
  407cd6:	6a79      	ldr	r1, [r7, #36]	; 0x24
  407cd8:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407cda:	4b26      	ldr	r3, [pc, #152]	; (407d74 <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407cdc:	4798      	blx	r3
  407cde:	4603      	mov	r3, r0
  407ce0:	4619      	mov	r1, r3
  407ce2:	68b8      	ldr	r0, [r7, #8]
  407ce4:	4b23      	ldr	r3, [pc, #140]	; (407d74 <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407ce6:	4798      	blx	r3
  407ce8:	4602      	mov	r2, r0
  407cea:	697b      	ldr	r3, [r7, #20]
  407cec:	1a9b      	subs	r3, r3, r2
  407cee:	4619      	mov	r1, r3
  407cf0:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407cf2:	4b20      	ldr	r3, [pc, #128]	; (407d74 <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407cf4:	4798      	blx	r3
  407cf6:	6278      	str	r0, [r7, #36]	; 0x24
    xx = invn_convert_mult_q15_fxp( xx, ( oneandhalf - invn_convert_mult_q15_fxp(x0_2, invn_convert_mult_q15_fxp(xx,xx) ) ) );
  407cf8:	6a79      	ldr	r1, [r7, #36]	; 0x24
  407cfa:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407cfc:	4b1d      	ldr	r3, [pc, #116]	; (407d74 <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407cfe:	4798      	blx	r3
  407d00:	4603      	mov	r3, r0
  407d02:	4619      	mov	r1, r3
  407d04:	68b8      	ldr	r0, [r7, #8]
  407d06:	4b1b      	ldr	r3, [pc, #108]	; (407d74 <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407d08:	4798      	blx	r3
  407d0a:	4602      	mov	r2, r0
  407d0c:	697b      	ldr	r3, [r7, #20]
  407d0e:	1a9b      	subs	r3, r3, r2
  407d10:	4619      	mov	r1, r3
  407d12:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407d14:	4b17      	ldr	r3, [pc, #92]	; (407d74 <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407d16:	4798      	blx	r3
  407d18:	6278      	str	r0, [r7, #36]	; 0x24

    if (pow2 & 1) { // This checks if the number is even or odd.
  407d1a:	69fb      	ldr	r3, [r7, #28]
  407d1c:	f003 0301 	and.w	r3, r3, #1
  407d20:	2b00      	cmp	r3, #0
  407d22:	d009      	beq.n	407d38 <invn_convert_inv_sqrt_q15_fxp+0xe8>
        pow2 = (pow2>>1) + 1; // Account for sqrt(2) in denominator
  407d24:	69fb      	ldr	r3, [r7, #28]
  407d26:	105b      	asrs	r3, r3, #1
  407d28:	3301      	adds	r3, #1
  407d2a:	61fb      	str	r3, [r7, #28]
        invsqrtx = (invn_convert_mult_q15_fxp(xx,oneoversqrt2));
  407d2c:	69b9      	ldr	r1, [r7, #24]
  407d2e:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407d30:	4b10      	ldr	r3, [pc, #64]	; (407d74 <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407d32:	4798      	blx	r3
  407d34:	6238      	str	r0, [r7, #32]
  407d36:	e004      	b.n	407d42 <invn_convert_inv_sqrt_q15_fxp+0xf2>
    }
    else {
        pow2 = pow2>>1;
  407d38:	69fb      	ldr	r3, [r7, #28]
  407d3a:	105b      	asrs	r3, r3, #1
  407d3c:	61fb      	str	r3, [r7, #28]
        invsqrtx =  xx;
  407d3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407d40:	623b      	str	r3, [r7, #32]
    }

    if (pow2 < 0)
  407d42:	69fb      	ldr	r3, [r7, #28]
  407d44:	2b00      	cmp	r3, #0
  407d46:	da08      	bge.n	407d5a <invn_convert_inv_sqrt_q15_fxp+0x10a>
        invsqrtx = invsqrtx>>ABS(pow2);
  407d48:	69fb      	ldr	r3, [r7, #28]
  407d4a:	2b00      	cmp	r3, #0
  407d4c:	bfb8      	it	lt
  407d4e:	425b      	neglt	r3, r3
  407d50:	6a3a      	ldr	r2, [r7, #32]
  407d52:	fa42 f303 	asr.w	r3, r2, r3
  407d56:	623b      	str	r3, [r7, #32]
  407d58:	e007      	b.n	407d6a <invn_convert_inv_sqrt_q15_fxp+0x11a>
    else if (pow2>0)
  407d5a:	69fb      	ldr	r3, [r7, #28]
  407d5c:	2b00      	cmp	r3, #0
  407d5e:	dd04      	ble.n	407d6a <invn_convert_inv_sqrt_q15_fxp+0x11a>
        invsqrtx = invsqrtx <<pow2;
  407d60:	6a3a      	ldr	r2, [r7, #32]
  407d62:	69fb      	ldr	r3, [r7, #28]
  407d64:	fa02 f303 	lsl.w	r3, r2, r3
  407d68:	623b      	str	r3, [r7, #32]

    return invsqrtx;
  407d6a:	6a3b      	ldr	r3, [r7, #32]
}
  407d6c:	4618      	mov	r0, r3
  407d6e:	3728      	adds	r7, #40	; 0x28
  407d70:	46bd      	mov	sp, r7
  407d72:	bd80      	pop	{r7, pc}
  407d74:	00407c11 	.word	0x00407c11

00407d78 <invn_convert_inverse_q15_fxp>:

static long invn_convert_inverse_q15_fxp(long x_q15)
{
  407d78:	b580      	push	{r7, lr}
  407d7a:	b084      	sub	sp, #16
  407d7c:	af00      	add	r7, sp, #0
  407d7e:	6078      	str	r0, [r7, #4]
    long y;
    int negx;

	if (x_q15 == 0) {
  407d80:	687b      	ldr	r3, [r7, #4]
  407d82:	2b00      	cmp	r3, #0
  407d84:	d103      	bne.n	407d8e <invn_convert_inverse_q15_fxp+0x16>
		y = 0L;
  407d86:	2300      	movs	r3, #0
  407d88:	60fb      	str	r3, [r7, #12]
		return y;
  407d8a:	68fb      	ldr	r3, [r7, #12]
  407d8c:	e028      	b.n	407de0 <invn_convert_inverse_q15_fxp+0x68>
	}

    negx=0;
  407d8e:	2300      	movs	r3, #0
  407d90:	60bb      	str	r3, [r7, #8]
    if (x_q15 < 0 ) {
  407d92:	687b      	ldr	r3, [r7, #4]
  407d94:	2b00      	cmp	r3, #0
  407d96:	da04      	bge.n	407da2 <invn_convert_inverse_q15_fxp+0x2a>
        x_q15 = -x_q15;
  407d98:	687b      	ldr	r3, [r7, #4]
  407d9a:	425b      	negs	r3, r3
  407d9c:	607b      	str	r3, [r7, #4]
        negx = 1;
  407d9e:	2301      	movs	r3, #1
  407da0:	60bb      	str	r3, [r7, #8]
    }

	if(x_q15 >= 1073741824L) { // 2^15 in Q15; underflow number
  407da2:	687b      	ldr	r3, [r7, #4]
  407da4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  407da8:	db0a      	blt.n	407dc0 <invn_convert_inverse_q15_fxp+0x48>
        if (negx)
  407daa:	68bb      	ldr	r3, [r7, #8]
  407dac:	2b00      	cmp	r3, #0
  407dae:	d003      	beq.n	407db8 <invn_convert_inverse_q15_fxp+0x40>
            y=-1L;
  407db0:	f04f 33ff 	mov.w	r3, #4294967295
  407db4:	60fb      	str	r3, [r7, #12]
  407db6:	e001      	b.n	407dbc <invn_convert_inverse_q15_fxp+0x44>
        else
            y = 1L;
  407db8:	2301      	movs	r3, #1
  407dba:	60fb      	str	r3, [r7, #12]
		return y;
  407dbc:	68fb      	ldr	r3, [r7, #12]
  407dbe:	e00f      	b.n	407de0 <invn_convert_inverse_q15_fxp+0x68>
	}

    y = invn_convert_inv_sqrt_q15_fxp(x_q15); // sqrt(y)
  407dc0:	6878      	ldr	r0, [r7, #4]
  407dc2:	4b09      	ldr	r3, [pc, #36]	; (407de8 <invn_convert_inverse_q15_fxp+0x70>)
  407dc4:	4798      	blx	r3
  407dc6:	60f8      	str	r0, [r7, #12]
    y = invn_convert_mult_q15_fxp(y, y);
  407dc8:	68f9      	ldr	r1, [r7, #12]
  407dca:	68f8      	ldr	r0, [r7, #12]
  407dcc:	4b07      	ldr	r3, [pc, #28]	; (407dec <invn_convert_inverse_q15_fxp+0x74>)
  407dce:	4798      	blx	r3
  407dd0:	60f8      	str	r0, [r7, #12]

    if (negx)
  407dd2:	68bb      	ldr	r3, [r7, #8]
  407dd4:	2b00      	cmp	r3, #0
  407dd6:	d002      	beq.n	407dde <invn_convert_inverse_q15_fxp+0x66>
        y=-y;
  407dd8:	68fb      	ldr	r3, [r7, #12]
  407dda:	425b      	negs	r3, r3
  407ddc:	60fb      	str	r3, [r7, #12]
    return y;
  407dde:	68fb      	ldr	r3, [r7, #12]
}
  407de0:	4618      	mov	r0, r3
  407de2:	3710      	adds	r7, #16
  407de4:	46bd      	mov	sp, r7
  407de6:	bd80      	pop	{r7, pc}
  407de8:	00407c51 	.word	0x00407c51
  407dec:	00407c11 	.word	0x00407c11

00407df0 <inv_icm20648_math_atan2_q15_fxp>:

long inv_icm20648_math_atan2_q15_fxp(long y_q15, long x_q15)
{
  407df0:	b580      	push	{r7, lr}
  407df2:	b08a      	sub	sp, #40	; 0x28
  407df4:	af00      	add	r7, sp, #0
  407df6:	6078      	str	r0, [r7, #4]
  407df8:	6039      	str	r1, [r7, #0]
    long absy, absx, maxABS, tmp, tmp2, tmp3, Z, angle;
    static long constA7[4] = {32740, -10503,  4751, -1254}; // int32(2^15*[0.999133448222780 -0.320533292381664 0.144982490144465,-0.038254464970299]); %7th order
    static long PI15 = 102944; // int32(2^15*pi): pi in Q15

    absx=ABS(x_q15);
  407dfa:	683b      	ldr	r3, [r7, #0]
  407dfc:	2b00      	cmp	r3, #0
  407dfe:	bfb8      	it	lt
  407e00:	425b      	neglt	r3, r3
  407e02:	623b      	str	r3, [r7, #32]
    absy=ABS(y_q15);
  407e04:	687b      	ldr	r3, [r7, #4]
  407e06:	2b00      	cmp	r3, #0
  407e08:	bfb8      	it	lt
  407e0a:	425b      	neglt	r3, r3
  407e0c:	627b      	str	r3, [r7, #36]	; 0x24

    maxABS=MAX(absx, absy);
  407e0e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407e10:	6a3b      	ldr	r3, [r7, #32]
  407e12:	4293      	cmp	r3, r2
  407e14:	bfb8      	it	lt
  407e16:	4613      	movlt	r3, r2
  407e18:	61fb      	str	r3, [r7, #28]
    // SCALE arguments down to protect from roundoff loss due to 1/x operation.
    //% Threshold for scaling found by numericaly simulating arguments
    //% to yield optimal (minimal) error of less than 0.01 deg through
    //% entire range (for Chebycheff order 7).
//    while ( maxABS >> 13) {  --> Or it can be done this way if DMP code is more efficient
    while ( maxABS > 8192L) {
  407e1a:	e00e      	b.n	407e3a <inv_icm20648_math_atan2_q15_fxp+0x4a>
            maxABS=maxABS/2;
  407e1c:	69fb      	ldr	r3, [r7, #28]
  407e1e:	0fda      	lsrs	r2, r3, #31
  407e20:	4413      	add	r3, r2
  407e22:	105b      	asrs	r3, r3, #1
  407e24:	61fb      	str	r3, [r7, #28]
            absx=absx/2;
  407e26:	6a3b      	ldr	r3, [r7, #32]
  407e28:	0fda      	lsrs	r2, r3, #31
  407e2a:	4413      	add	r3, r2
  407e2c:	105b      	asrs	r3, r3, #1
  407e2e:	623b      	str	r3, [r7, #32]
            absy=absy/2;
  407e30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407e32:	0fda      	lsrs	r2, r3, #31
  407e34:	4413      	add	r3, r2
  407e36:	105b      	asrs	r3, r3, #1
  407e38:	627b      	str	r3, [r7, #36]	; 0x24
    while ( maxABS > 8192L) {
  407e3a:	69fb      	ldr	r3, [r7, #28]
  407e3c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  407e40:	dcec      	bgt.n	407e1c <inv_icm20648_math_atan2_q15_fxp+0x2c>
    }

    {
        if (absx >= absy) // (0, pi/4]: tmp = abs(y)/abs(x);
  407e42:	6a3a      	ldr	r2, [r7, #32]
  407e44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407e46:	429a      	cmp	r2, r3
  407e48:	db09      	blt.n	407e5e <inv_icm20648_math_atan2_q15_fxp+0x6e>
            tmp = invn_convert_mult_q15_fxp(absy, invn_convert_inverse_q15_fxp(absx));
  407e4a:	6a38      	ldr	r0, [r7, #32]
  407e4c:	4b32      	ldr	r3, [pc, #200]	; (407f18 <inv_icm20648_math_atan2_q15_fxp+0x128>)
  407e4e:	4798      	blx	r3
  407e50:	4603      	mov	r3, r0
  407e52:	4619      	mov	r1, r3
  407e54:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407e56:	4b31      	ldr	r3, [pc, #196]	; (407f1c <inv_icm20648_math_atan2_q15_fxp+0x12c>)
  407e58:	4798      	blx	r3
  407e5a:	61b8      	str	r0, [r7, #24]
  407e5c:	e008      	b.n	407e70 <inv_icm20648_math_atan2_q15_fxp+0x80>
        else             // (pi/4, pi/2): tmp = abs(x)/abs(y);
            tmp = invn_convert_mult_q15_fxp(absx, invn_convert_inverse_q15_fxp(absy));
  407e5e:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407e60:	4b2d      	ldr	r3, [pc, #180]	; (407f18 <inv_icm20648_math_atan2_q15_fxp+0x128>)
  407e62:	4798      	blx	r3
  407e64:	4603      	mov	r3, r0
  407e66:	4619      	mov	r1, r3
  407e68:	6a38      	ldr	r0, [r7, #32]
  407e6a:	4b2c      	ldr	r3, [pc, #176]	; (407f1c <inv_icm20648_math_atan2_q15_fxp+0x12c>)
  407e6c:	4798      	blx	r3
  407e6e:	61b8      	str	r0, [r7, #24]

        tmp2=invn_convert_mult_q15_fxp(tmp, tmp);
  407e70:	69b9      	ldr	r1, [r7, #24]
  407e72:	69b8      	ldr	r0, [r7, #24]
  407e74:	4b29      	ldr	r3, [pc, #164]	; (407f1c <inv_icm20648_math_atan2_q15_fxp+0x12c>)
  407e76:	4798      	blx	r3
  407e78:	6138      	str	r0, [r7, #16]
         // Alternatively:
        tmp3 = invn_convert_mult_q15_fxp(constA7[3], tmp2);
  407e7a:	4b29      	ldr	r3, [pc, #164]	; (407f20 <inv_icm20648_math_atan2_q15_fxp+0x130>)
  407e7c:	68db      	ldr	r3, [r3, #12]
  407e7e:	6939      	ldr	r1, [r7, #16]
  407e80:	4618      	mov	r0, r3
  407e82:	4b26      	ldr	r3, [pc, #152]	; (407f1c <inv_icm20648_math_atan2_q15_fxp+0x12c>)
  407e84:	4798      	blx	r3
  407e86:	60f8      	str	r0, [r7, #12]
        tmp3 = invn_convert_mult_q15_fxp(constA7[2] + tmp3, tmp2);
  407e88:	4b25      	ldr	r3, [pc, #148]	; (407f20 <inv_icm20648_math_atan2_q15_fxp+0x130>)
  407e8a:	689a      	ldr	r2, [r3, #8]
  407e8c:	68fb      	ldr	r3, [r7, #12]
  407e8e:	4413      	add	r3, r2
  407e90:	6939      	ldr	r1, [r7, #16]
  407e92:	4618      	mov	r0, r3
  407e94:	4b21      	ldr	r3, [pc, #132]	; (407f1c <inv_icm20648_math_atan2_q15_fxp+0x12c>)
  407e96:	4798      	blx	r3
  407e98:	60f8      	str	r0, [r7, #12]
        tmp3 = invn_convert_mult_q15_fxp(constA7[1] + tmp3, tmp2);
  407e9a:	4b21      	ldr	r3, [pc, #132]	; (407f20 <inv_icm20648_math_atan2_q15_fxp+0x130>)
  407e9c:	685a      	ldr	r2, [r3, #4]
  407e9e:	68fb      	ldr	r3, [r7, #12]
  407ea0:	4413      	add	r3, r2
  407ea2:	6939      	ldr	r1, [r7, #16]
  407ea4:	4618      	mov	r0, r3
  407ea6:	4b1d      	ldr	r3, [pc, #116]	; (407f1c <inv_icm20648_math_atan2_q15_fxp+0x12c>)
  407ea8:	4798      	blx	r3
  407eaa:	60f8      	str	r0, [r7, #12]
        Z    = invn_convert_mult_q15_fxp(constA7[0] + tmp3, tmp);
  407eac:	4b1c      	ldr	r3, [pc, #112]	; (407f20 <inv_icm20648_math_atan2_q15_fxp+0x130>)
  407eae:	681a      	ldr	r2, [r3, #0]
  407eb0:	68fb      	ldr	r3, [r7, #12]
  407eb2:	4413      	add	r3, r2
  407eb4:	69b9      	ldr	r1, [r7, #24]
  407eb6:	4618      	mov	r0, r3
  407eb8:	4b18      	ldr	r3, [pc, #96]	; (407f1c <inv_icm20648_math_atan2_q15_fxp+0x12c>)
  407eba:	4798      	blx	r3
  407ebc:	6178      	str	r0, [r7, #20]

        if (absx < absy)
  407ebe:	6a3a      	ldr	r2, [r7, #32]
  407ec0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407ec2:	429a      	cmp	r2, r3
  407ec4:	da08      	bge.n	407ed8 <inv_icm20648_math_atan2_q15_fxp+0xe8>
            Z = PI15/2 - Z;
  407ec6:	4b17      	ldr	r3, [pc, #92]	; (407f24 <inv_icm20648_math_atan2_q15_fxp+0x134>)
  407ec8:	681b      	ldr	r3, [r3, #0]
  407eca:	0fda      	lsrs	r2, r3, #31
  407ecc:	4413      	add	r3, r2
  407ece:	105b      	asrs	r3, r3, #1
  407ed0:	461a      	mov	r2, r3
  407ed2:	697b      	ldr	r3, [r7, #20]
  407ed4:	1ad3      	subs	r3, r2, r3
  407ed6:	617b      	str	r3, [r7, #20]

        if (x_q15 < 0) { // second and third quadrant
  407ed8:	683b      	ldr	r3, [r7, #0]
  407eda:	2b00      	cmp	r3, #0
  407edc:	da0e      	bge.n	407efc <inv_icm20648_math_atan2_q15_fxp+0x10c>
            if (y_q15 < 0)
  407ede:	687b      	ldr	r3, [r7, #4]
  407ee0:	2b00      	cmp	r3, #0
  407ee2:	da05      	bge.n	407ef0 <inv_icm20648_math_atan2_q15_fxp+0x100>
                Z = -PI15 + Z;
  407ee4:	4b0f      	ldr	r3, [pc, #60]	; (407f24 <inv_icm20648_math_atan2_q15_fxp+0x134>)
  407ee6:	681b      	ldr	r3, [r3, #0]
  407ee8:	697a      	ldr	r2, [r7, #20]
  407eea:	1ad3      	subs	r3, r2, r3
  407eec:	617b      	str	r3, [r7, #20]
  407eee:	e00b      	b.n	407f08 <inv_icm20648_math_atan2_q15_fxp+0x118>
            else
                Z = PI15 - Z;
  407ef0:	4b0c      	ldr	r3, [pc, #48]	; (407f24 <inv_icm20648_math_atan2_q15_fxp+0x134>)
  407ef2:	681a      	ldr	r2, [r3, #0]
  407ef4:	697b      	ldr	r3, [r7, #20]
  407ef6:	1ad3      	subs	r3, r2, r3
  407ef8:	617b      	str	r3, [r7, #20]
  407efa:	e005      	b.n	407f08 <inv_icm20648_math_atan2_q15_fxp+0x118>
        }
        else { // fourth quadrant
            if (y_q15 < 0)
  407efc:	687b      	ldr	r3, [r7, #4]
  407efe:	2b00      	cmp	r3, #0
  407f00:	da02      	bge.n	407f08 <inv_icm20648_math_atan2_q15_fxp+0x118>
                Z = -Z;
  407f02:	697b      	ldr	r3, [r7, #20]
  407f04:	425b      	negs	r3, r3
  407f06:	617b      	str	r3, [r7, #20]
        }
        angle = Z; // Note the result is angle in radians, expressed in Q15.
  407f08:	697b      	ldr	r3, [r7, #20]
  407f0a:	60bb      	str	r3, [r7, #8]
    }
    return angle;
  407f0c:	68bb      	ldr	r3, [r7, #8]
}
  407f0e:	4618      	mov	r0, r3
  407f10:	3728      	adds	r7, #40	; 0x28
  407f12:	46bd      	mov	sp, r7
  407f14:	bd80      	pop	{r7, pc}
  407f16:	bf00      	nop
  407f18:	00407d79 	.word	0x00407d79
  407f1c:	00407c11 	.word	0x00407c11
  407f20:	20000120 	.word	0x20000120
  407f24:	20000130 	.word	0x20000130

00407f28 <inv_icm20648_convert_int16_to_big8>:

uint8_t *inv_icm20648_convert_int16_to_big8(int16_t x, uint8_t *big8)
{
  407f28:	b480      	push	{r7}
  407f2a:	b083      	sub	sp, #12
  407f2c:	af00      	add	r7, sp, #0
  407f2e:	4603      	mov	r3, r0
  407f30:	6039      	str	r1, [r7, #0]
  407f32:	80fb      	strh	r3, [r7, #6]
    big8[0] = (uint8_t)((x >> 8) & 0xff);
  407f34:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
  407f38:	121b      	asrs	r3, r3, #8
  407f3a:	b21b      	sxth	r3, r3
  407f3c:	b2da      	uxtb	r2, r3
  407f3e:	683b      	ldr	r3, [r7, #0]
  407f40:	701a      	strb	r2, [r3, #0]
    big8[1] = (uint8_t)(x & 0xff);
  407f42:	683b      	ldr	r3, [r7, #0]
  407f44:	3301      	adds	r3, #1
  407f46:	88fa      	ldrh	r2, [r7, #6]
  407f48:	b2d2      	uxtb	r2, r2
  407f4a:	701a      	strb	r2, [r3, #0]
    return big8;
  407f4c:	683b      	ldr	r3, [r7, #0]
}
  407f4e:	4618      	mov	r0, r3
  407f50:	370c      	adds	r7, #12
  407f52:	46bd      	mov	sp, r7
  407f54:	f85d 7b04 	ldr.w	r7, [sp], #4
  407f58:	4770      	bx	lr

00407f5a <inv_icm20648_convert_int32_to_big8>:

uint8_t *inv_icm20648_convert_int32_to_big8(int32_t x, uint8_t *big8)
{
  407f5a:	b480      	push	{r7}
  407f5c:	b083      	sub	sp, #12
  407f5e:	af00      	add	r7, sp, #0
  407f60:	6078      	str	r0, [r7, #4]
  407f62:	6039      	str	r1, [r7, #0]
    big8[0] = (uint8_t)((x >> 24) & 0xff);
  407f64:	687b      	ldr	r3, [r7, #4]
  407f66:	161b      	asrs	r3, r3, #24
  407f68:	b2da      	uxtb	r2, r3
  407f6a:	683b      	ldr	r3, [r7, #0]
  407f6c:	701a      	strb	r2, [r3, #0]
    big8[1] = (uint8_t)((x >> 16) & 0xff);
  407f6e:	683b      	ldr	r3, [r7, #0]
  407f70:	3301      	adds	r3, #1
  407f72:	687a      	ldr	r2, [r7, #4]
  407f74:	1412      	asrs	r2, r2, #16
  407f76:	b2d2      	uxtb	r2, r2
  407f78:	701a      	strb	r2, [r3, #0]
    big8[2] = (uint8_t)((x >> 8) & 0xff);
  407f7a:	683b      	ldr	r3, [r7, #0]
  407f7c:	3302      	adds	r3, #2
  407f7e:	687a      	ldr	r2, [r7, #4]
  407f80:	1212      	asrs	r2, r2, #8
  407f82:	b2d2      	uxtb	r2, r2
  407f84:	701a      	strb	r2, [r3, #0]
    big8[3] = (uint8_t)(x & 0xff);
  407f86:	683b      	ldr	r3, [r7, #0]
  407f88:	3303      	adds	r3, #3
  407f8a:	687a      	ldr	r2, [r7, #4]
  407f8c:	b2d2      	uxtb	r2, r2
  407f8e:	701a      	strb	r2, [r3, #0]
    return big8;
  407f90:	683b      	ldr	r3, [r7, #0]
}
  407f92:	4618      	mov	r0, r3
  407f94:	370c      	adds	r7, #12
  407f96:	46bd      	mov	sp, r7
  407f98:	f85d 7b04 	ldr.w	r7, [sp], #4
  407f9c:	4770      	bx	lr

00407f9e <inv_icm20648_convert_big8_to_int32>:

int32_t inv_icm20648_convert_big8_to_int32(const uint8_t *big8)
{
  407f9e:	b480      	push	{r7}
  407fa0:	b085      	sub	sp, #20
  407fa2:	af00      	add	r7, sp, #0
  407fa4:	6078      	str	r0, [r7, #4]
    int32_t x;
    x = ((int32_t)big8[0] << 24) | ((int32_t)big8[1] << 16) | ((int32_t)big8[2] << 8)
  407fa6:	687b      	ldr	r3, [r7, #4]
  407fa8:	781b      	ldrb	r3, [r3, #0]
  407faa:	061a      	lsls	r2, r3, #24
  407fac:	687b      	ldr	r3, [r7, #4]
  407fae:	3301      	adds	r3, #1
  407fb0:	781b      	ldrb	r3, [r3, #0]
  407fb2:	041b      	lsls	r3, r3, #16
  407fb4:	431a      	orrs	r2, r3
  407fb6:	687b      	ldr	r3, [r7, #4]
  407fb8:	3302      	adds	r3, #2
  407fba:	781b      	ldrb	r3, [r3, #0]
  407fbc:	021b      	lsls	r3, r3, #8
  407fbe:	4313      	orrs	r3, r2
        | ((int32_t)big8[3]);
  407fc0:	687a      	ldr	r2, [r7, #4]
  407fc2:	3203      	adds	r2, #3
  407fc4:	7812      	ldrb	r2, [r2, #0]
    x = ((int32_t)big8[0] << 24) | ((int32_t)big8[1] << 16) | ((int32_t)big8[2] << 8)
  407fc6:	4313      	orrs	r3, r2
  407fc8:	60fb      	str	r3, [r7, #12]
    return x;
  407fca:	68fb      	ldr	r3, [r7, #12]
}
  407fcc:	4618      	mov	r0, r3
  407fce:	3714      	adds	r7, #20
  407fd0:	46bd      	mov	sp, r7
  407fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
  407fd6:	4770      	bx	lr

00407fd8 <inv_icm20648_load_firmware>:

/** Loads the dmp firmware for the icm20648 part.
* @param[in] dmp_image_sram Load DMP3 image from SRAM.
*/
int inv_icm20648_load_firmware(struct inv_icm20648 * s, const unsigned char *dmp3_image, unsigned int dmp3_image_size)
{
  407fd8:	b590      	push	{r4, r7, lr}
  407fda:	b085      	sub	sp, #20
  407fdc:	af00      	add	r7, sp, #0
  407fde:	60f8      	str	r0, [r7, #12]
  407fe0:	60b9      	str	r1, [r7, #8]
  407fe2:	607a      	str	r2, [r7, #4]
	return inv_icm20648_firmware_load(s, dmp3_image, dmp3_image_size, DMP_LOAD_START);
  407fe4:	687b      	ldr	r3, [r7, #4]
  407fe6:	b29a      	uxth	r2, r3
  407fe8:	2390      	movs	r3, #144	; 0x90
  407fea:	68b9      	ldr	r1, [r7, #8]
  407fec:	68f8      	ldr	r0, [r7, #12]
  407fee:	4c03      	ldr	r4, [pc, #12]	; (407ffc <inv_icm20648_load_firmware+0x24>)
  407ff0:	47a0      	blx	r4
  407ff2:	4603      	mov	r3, r0
}
  407ff4:	4618      	mov	r0, r3
  407ff6:	3714      	adds	r7, #20
  407ff8:	46bd      	mov	sp, r7
  407ffa:	bd90      	pop	{r4, r7, pc}
  407ffc:	00408c45 	.word	0x00408c45

00408000 <inv_icm20648_get_dmp_start_address>:

/** Loads the dmp firmware for the icm20648 part.
* @param[out] dmp_cnfg The config item
*/
void inv_icm20648_get_dmp_start_address(struct inv_icm20648 * s, unsigned short *dmp_cnfg)
{
  408000:	b480      	push	{r7}
  408002:	b083      	sub	sp, #12
  408004:	af00      	add	r7, sp, #0
  408006:	6078      	str	r0, [r7, #4]
  408008:	6039      	str	r1, [r7, #0]

	(void)s;

	*dmp_cnfg = DMP_START_ADDRESS;
  40800a:	683b      	ldr	r3, [r7, #0]
  40800c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  408010:	801a      	strh	r2, [r3, #0]
}
  408012:	bf00      	nop
  408014:	370c      	adds	r7, #12
  408016:	46bd      	mov	sp, r7
  408018:	f85d 7b04 	ldr.w	r7, [sp], #4
  40801c:	4770      	bx	lr
	...

00408020 <dmp_icm20648_set_data_output_control1>:
*	PED_STEPDET_SET		0x0010 - timestamp when each step is detected
*	HEADER2_SET			0x0008 - enable/disable data output in data output control register 2
*	PED_STEPIND_SET		0x0007 - number of steps detected will be attached to the 3 least significant bits of header
*/
int dmp_icm20648_set_data_output_control1(struct inv_icm20648 * s, int output_mask)
{
  408020:	b590      	push	{r4, r7, lr}
  408022:	b085      	sub	sp, #20
  408024:	af00      	add	r7, sp, #0
  408026:	6078      	str	r0, [r7, #4]
  408028:	6039      	str	r1, [r7, #0]

	int result;
	unsigned char data_output_control_reg1[2];

	data_output_control_reg1[0] = (unsigned char)(output_mask >> 8);
  40802a:	683b      	ldr	r3, [r7, #0]
  40802c:	121b      	asrs	r3, r3, #8
  40802e:	b2db      	uxtb	r3, r3
  408030:	723b      	strb	r3, [r7, #8]
	data_output_control_reg1[1] = (unsigned char)(output_mask & 0xff);
  408032:	683b      	ldr	r3, [r7, #0]
  408034:	b2db      	uxtb	r3, r3
  408036:	727b      	strb	r3, [r7, #9]

	result = inv_icm20648_write_mems(s, DATA_OUT_CTL1, 2, data_output_control_reg1);
  408038:	f107 0308 	add.w	r3, r7, #8
  40803c:	2202      	movs	r2, #2
  40803e:	2140      	movs	r1, #64	; 0x40
  408040:	6878      	ldr	r0, [r7, #4]
  408042:	4c04      	ldr	r4, [pc, #16]	; (408054 <dmp_icm20648_set_data_output_control1+0x34>)
  408044:	47a0      	blx	r4
  408046:	60f8      	str	r0, [r7, #12]

	return result;
  408048:	68fb      	ldr	r3, [r7, #12]
}
  40804a:	4618      	mov	r0, r3
  40804c:	3714      	adds	r7, #20
  40804e:	46bd      	mov	sp, r7
  408050:	bd90      	pop	{r4, r7, pc}
  408052:	bf00      	nop
  408054:	0040cdfd 	.word	0x0040cdfd

00408058 <dmp_icm20648_set_data_output_control2>:
*	GYRO_ACCURACY_SET	0x2000 - gyro accuracy when changes, HEADER2_SET also needs to be set in data output control regsiter 1
*	CPASS_ACCURACY_SET	0x1000 - compass accuracy when changes, HEADER2_SET also needs to be set in data output control regsiter 1
*	BATCH_MODE_EN		0x0100 - enable batching
*/
int dmp_icm20648_set_data_output_control2(struct inv_icm20648 * s, int output_mask)
{
  408058:	b590      	push	{r4, r7, lr}
  40805a:	b085      	sub	sp, #20
  40805c:	af00      	add	r7, sp, #0
  40805e:	6078      	str	r0, [r7, #4]
  408060:	6039      	str	r1, [r7, #0]
	int result;
	static unsigned char data_output_control_reg2[2]={0};

	data_output_control_reg2[0] = (unsigned char)(output_mask >> 8);
  408062:	683b      	ldr	r3, [r7, #0]
  408064:	121b      	asrs	r3, r3, #8
  408066:	b2da      	uxtb	r2, r3
  408068:	4b08      	ldr	r3, [pc, #32]	; (40808c <dmp_icm20648_set_data_output_control2+0x34>)
  40806a:	701a      	strb	r2, [r3, #0]
	data_output_control_reg2[1] = (unsigned char)(output_mask & 0xff);
  40806c:	683b      	ldr	r3, [r7, #0]
  40806e:	b2da      	uxtb	r2, r3
  408070:	4b06      	ldr	r3, [pc, #24]	; (40808c <dmp_icm20648_set_data_output_control2+0x34>)
  408072:	705a      	strb	r2, [r3, #1]

	result = inv_icm20648_write_mems(s, DATA_OUT_CTL2, 2, data_output_control_reg2);
  408074:	4b05      	ldr	r3, [pc, #20]	; (40808c <dmp_icm20648_set_data_output_control2+0x34>)
  408076:	2202      	movs	r2, #2
  408078:	2142      	movs	r1, #66	; 0x42
  40807a:	6878      	ldr	r0, [r7, #4]
  40807c:	4c04      	ldr	r4, [pc, #16]	; (408090 <dmp_icm20648_set_data_output_control2+0x38>)
  40807e:	47a0      	blx	r4
  408080:	60f8      	str	r0, [r7, #12]

	return result;
  408082:	68fb      	ldr	r3, [r7, #12]
}
  408084:	4618      	mov	r0, r3
  408086:	3714      	adds	r7, #20
  408088:	46bd      	mov	sp, r7
  40808a:	bd90      	pop	{r4, r7, pc}
  40808c:	20001428 	.word	0x20001428
  408090:	0040cdfd 	.word	0x0040cdfd

00408094 <dmp_icm20648_reset_control_registers>:
/**
* Clears all output control registers:
*	data output control register 1, data output control register 2, data interrupt control register, motion event control regsiter, data ready status register
*/
int dmp_icm20648_reset_control_registers(struct inv_icm20648 * s)
{
  408094:	b590      	push	{r4, r7, lr}
  408096:	b085      	sub	sp, #20
  408098:	af00      	add	r7, sp, #0
  40809a:	6078      	str	r0, [r7, #4]
	int result;
	unsigned char data[4]={0};
  40809c:	2300      	movs	r3, #0
  40809e:	60bb      	str	r3, [r7, #8]

	//reset data output control registers
	result = inv_icm20648_write_mems(s, DATA_OUT_CTL1, 2, &data[0]);
  4080a0:	f107 0308 	add.w	r3, r7, #8
  4080a4:	2202      	movs	r2, #2
  4080a6:	2140      	movs	r1, #64	; 0x40
  4080a8:	6878      	ldr	r0, [r7, #4]
  4080aa:	4c1c      	ldr	r4, [pc, #112]	; (40811c <dmp_icm20648_reset_control_registers+0x88>)
  4080ac:	47a0      	blx	r4
  4080ae:	60f8      	str	r0, [r7, #12]
	result += inv_icm20648_write_mems(s, DATA_OUT_CTL2, 2, &data[0]);
  4080b0:	f107 0308 	add.w	r3, r7, #8
  4080b4:	2202      	movs	r2, #2
  4080b6:	2142      	movs	r1, #66	; 0x42
  4080b8:	6878      	ldr	r0, [r7, #4]
  4080ba:	4c18      	ldr	r4, [pc, #96]	; (40811c <dmp_icm20648_reset_control_registers+0x88>)
  4080bc:	47a0      	blx	r4
  4080be:	4602      	mov	r2, r0
  4080c0:	68fb      	ldr	r3, [r7, #12]
  4080c2:	4413      	add	r3, r2
  4080c4:	60fb      	str	r3, [r7, #12]

	//reset data interrupt control register
	result += inv_icm20648_write_mems(s, DATA_INTR_CTL, 2, &data[0]);
  4080c6:	f107 0308 	add.w	r3, r7, #8
  4080ca:	2202      	movs	r2, #2
  4080cc:	214c      	movs	r1, #76	; 0x4c
  4080ce:	6878      	ldr	r0, [r7, #4]
  4080d0:	4c12      	ldr	r4, [pc, #72]	; (40811c <dmp_icm20648_reset_control_registers+0x88>)
  4080d2:	47a0      	blx	r4
  4080d4:	4602      	mov	r2, r0
  4080d6:	68fb      	ldr	r3, [r7, #12]
  4080d8:	4413      	add	r3, r2
  4080da:	60fb      	str	r3, [r7, #12]

	//reset motion event control register
	result += inv_icm20648_write_mems(s, MOTION_EVENT_CTL, 2, &data[0]);
  4080dc:	f107 0308 	add.w	r3, r7, #8
  4080e0:	2202      	movs	r2, #2
  4080e2:	214e      	movs	r1, #78	; 0x4e
  4080e4:	6878      	ldr	r0, [r7, #4]
  4080e6:	4c0d      	ldr	r4, [pc, #52]	; (40811c <dmp_icm20648_reset_control_registers+0x88>)
  4080e8:	47a0      	blx	r4
  4080ea:	4602      	mov	r2, r0
  4080ec:	68fb      	ldr	r3, [r7, #12]
  4080ee:	4413      	add	r3, r2
  4080f0:	60fb      	str	r3, [r7, #12]

	//reset data ready status register
	result += inv_icm20648_write_mems(s, DATA_RDY_STATUS, 2, &data[0]);
  4080f2:	f107 0308 	add.w	r3, r7, #8
  4080f6:	2202      	movs	r2, #2
  4080f8:	218a      	movs	r1, #138	; 0x8a
  4080fa:	6878      	ldr	r0, [r7, #4]
  4080fc:	4c07      	ldr	r4, [pc, #28]	; (40811c <dmp_icm20648_reset_control_registers+0x88>)
  4080fe:	47a0      	blx	r4
  408100:	4602      	mov	r2, r0
  408102:	68fb      	ldr	r3, [r7, #12]
  408104:	4413      	add	r3, r2
  408106:	60fb      	str	r3, [r7, #12]
	//result += inv_icm20648_write_mems(s, DATA_RDY_STATUS, 2, inv_icm20648_convert_int16_to_big8(3, data)); //fixme

	if (result) 
  408108:	68fb      	ldr	r3, [r7, #12]
  40810a:	2b00      	cmp	r3, #0
  40810c:	d001      	beq.n	408112 <dmp_icm20648_reset_control_registers+0x7e>
		return result;
  40810e:	68fb      	ldr	r3, [r7, #12]
  408110:	e000      	b.n	408114 <dmp_icm20648_reset_control_registers+0x80>

	return 0;
  408112:	2300      	movs	r3, #0
}
  408114:	4618      	mov	r0, r3
  408116:	3714      	adds	r7, #20
  408118:	46bd      	mov	sp, r7
  40811a:	bd90      	pop	{r4, r7, pc}
  40811c:	0040cdfd 	.word	0x0040cdfd

00408120 <dmp_icm20648_set_data_interrupt_control>:
*	PED_STEPDET_SET		0x0010 - timestamp when each step is detected
*	HEADER2_SET			0x0008 - data output defined in data output control register 2
*	PED_STEPIND_SET		0x0007 - number of steps detected will be attached to the 3 least significant bits of header
*/
int dmp_icm20648_set_data_interrupt_control(struct inv_icm20648 * s, uint32_t interrupt_ctl)
{
  408120:	b590      	push	{r4, r7, lr}
  408122:	b085      	sub	sp, #20
  408124:	af00      	add	r7, sp, #0
  408126:	6078      	str	r0, [r7, #4]
  408128:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[2]={0};
  40812a:	2300      	movs	r3, #0
  40812c:	813b      	strh	r3, [r7, #8]

	result = inv_icm20648_write_mems(s, DATA_INTR_CTL, 2, inv_icm20648_convert_int16_to_big8(interrupt_ctl, big8));
  40812e:	683b      	ldr	r3, [r7, #0]
  408130:	b21b      	sxth	r3, r3
  408132:	f107 0208 	add.w	r2, r7, #8
  408136:	4611      	mov	r1, r2
  408138:	4618      	mov	r0, r3
  40813a:	4b09      	ldr	r3, [pc, #36]	; (408160 <dmp_icm20648_set_data_interrupt_control+0x40>)
  40813c:	4798      	blx	r3
  40813e:	4603      	mov	r3, r0
  408140:	2202      	movs	r2, #2
  408142:	214c      	movs	r1, #76	; 0x4c
  408144:	6878      	ldr	r0, [r7, #4]
  408146:	4c07      	ldr	r4, [pc, #28]	; (408164 <dmp_icm20648_set_data_interrupt_control+0x44>)
  408148:	47a0      	blx	r4
  40814a:	60f8      	str	r0, [r7, #12]

	if (result) 
  40814c:	68fb      	ldr	r3, [r7, #12]
  40814e:	2b00      	cmp	r3, #0
  408150:	d001      	beq.n	408156 <dmp_icm20648_set_data_interrupt_control+0x36>
		return result;
  408152:	68fb      	ldr	r3, [r7, #12]
  408154:	e000      	b.n	408158 <dmp_icm20648_set_data_interrupt_control+0x38>

	return 0;
  408156:	2300      	movs	r3, #0
}
  408158:	4618      	mov	r0, r3
  40815a:	3714      	adds	r7, #20
  40815c:	46bd      	mov	sp, r7
  40815e:	bd90      	pop	{r4, r7, pc}
  408160:	00407f29 	.word	0x00407f29
  408164:	0040cdfd 	.word	0x0040cdfd

00408168 <dmp_icm20648_set_FIFO_watermark>:
/**
* Sets FIFO watermark. DMP will send FIFO interrupt if FIFO count > FIFO watermark
* @param[in] fifo_wm	FIFO watermark set to 80% of actual FIFO size by default
*/
int dmp_icm20648_set_FIFO_watermark(struct inv_icm20648 * s, unsigned short fifo_wm)
{
  408168:	b590      	push	{r4, r7, lr}
  40816a:	b085      	sub	sp, #20
  40816c:	af00      	add	r7, sp, #0
  40816e:	6078      	str	r0, [r7, #4]
  408170:	460b      	mov	r3, r1
  408172:	807b      	strh	r3, [r7, #2]
	int result;
	unsigned char big8[2]={0};
  408174:	2300      	movs	r3, #0
  408176:	813b      	strh	r3, [r7, #8]

	result = inv_icm20648_write_mems(s, FIFO_WATERMARK, 2, inv_icm20648_convert_int16_to_big8(fifo_wm,big8));
  408178:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  40817c:	f107 0208 	add.w	r2, r7, #8
  408180:	4611      	mov	r1, r2
  408182:	4618      	mov	r0, r3
  408184:	4b09      	ldr	r3, [pc, #36]	; (4081ac <dmp_icm20648_set_FIFO_watermark+0x44>)
  408186:	4798      	blx	r3
  408188:	4603      	mov	r3, r0
  40818a:	2202      	movs	r2, #2
  40818c:	f44f 71ff 	mov.w	r1, #510	; 0x1fe
  408190:	6878      	ldr	r0, [r7, #4]
  408192:	4c07      	ldr	r4, [pc, #28]	; (4081b0 <dmp_icm20648_set_FIFO_watermark+0x48>)
  408194:	47a0      	blx	r4
  408196:	60f8      	str	r0, [r7, #12]

	if (result)
  408198:	68fb      	ldr	r3, [r7, #12]
  40819a:	2b00      	cmp	r3, #0
  40819c:	d001      	beq.n	4081a2 <dmp_icm20648_set_FIFO_watermark+0x3a>
		return result;
  40819e:	68fb      	ldr	r3, [r7, #12]
  4081a0:	e000      	b.n	4081a4 <dmp_icm20648_set_FIFO_watermark+0x3c>

	return 0;
  4081a2:	2300      	movs	r3, #0
}
  4081a4:	4618      	mov	r0, r3
  4081a6:	3714      	adds	r7, #20
  4081a8:	46bd      	mov	sp, r7
  4081aa:	bd90      	pop	{r4, r7, pc}
  4081ac:	00407f29 	.word	0x00407f29
  4081b0:	0040cdfd 	.word	0x0040cdfd

004081b4 <dmp_icm20648_set_data_rdy_status>:
*	gyro samples available		0x1
*	accel samples available		0x2
*	secondary samples available	0x8
*/
int dmp_icm20648_set_data_rdy_status(struct inv_icm20648 * s, unsigned short data_rdy)
{
  4081b4:	b590      	push	{r4, r7, lr}
  4081b6:	b085      	sub	sp, #20
  4081b8:	af00      	add	r7, sp, #0
  4081ba:	6078      	str	r0, [r7, #4]
  4081bc:	460b      	mov	r3, r1
  4081be:	807b      	strh	r3, [r7, #2]
	int result;
	unsigned char big8[2]={0};
  4081c0:	2300      	movs	r3, #0
  4081c2:	813b      	strh	r3, [r7, #8]

	result = inv_icm20648_write_mems(s, DATA_RDY_STATUS, 2, inv_icm20648_convert_int16_to_big8(data_rdy, big8));
  4081c4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  4081c8:	f107 0208 	add.w	r2, r7, #8
  4081cc:	4611      	mov	r1, r2
  4081ce:	4618      	mov	r0, r3
  4081d0:	4b09      	ldr	r3, [pc, #36]	; (4081f8 <dmp_icm20648_set_data_rdy_status+0x44>)
  4081d2:	4798      	blx	r3
  4081d4:	4603      	mov	r3, r0
  4081d6:	2202      	movs	r2, #2
  4081d8:	218a      	movs	r1, #138	; 0x8a
  4081da:	6878      	ldr	r0, [r7, #4]
  4081dc:	4c07      	ldr	r4, [pc, #28]	; (4081fc <dmp_icm20648_set_data_rdy_status+0x48>)
  4081de:	47a0      	blx	r4
  4081e0:	60f8      	str	r0, [r7, #12]

	if (result) 
  4081e2:	68fb      	ldr	r3, [r7, #12]
  4081e4:	2b00      	cmp	r3, #0
  4081e6:	d001      	beq.n	4081ec <dmp_icm20648_set_data_rdy_status+0x38>
		return result;
  4081e8:	68fb      	ldr	r3, [r7, #12]
  4081ea:	e000      	b.n	4081ee <dmp_icm20648_set_data_rdy_status+0x3a>

	return 0;
  4081ec:	2300      	movs	r3, #0
}
  4081ee:	4618      	mov	r0, r3
  4081f0:	3714      	adds	r7, #20
  4081f2:	46bd      	mov	sp, r7
  4081f4:	bd90      	pop	{r4, r7, pc}
  4081f6:	bf00      	nop
  4081f8:	00407f29 	.word	0x00407f29
  4081fc:	0040cdfd 	.word	0x0040cdfd

00408200 <dmp_icm20648_set_motion_event_control>:
*	GEOMAG_EN			0x0008 - Geomag algorithm execution
*	BTS_LTS_EN          0x0004 - bring & look to see
*	BAC_ACCEL_ONLY_EN   0x0002 - run BAC as accel only
*/
int dmp_icm20648_set_motion_event_control(struct inv_icm20648 * s, unsigned short output_mask)
{
  408200:	b590      	push	{r4, r7, lr}
  408202:	b085      	sub	sp, #20
  408204:	af00      	add	r7, sp, #0
  408206:	6078      	str	r0, [r7, #4]
  408208:	460b      	mov	r3, r1
  40820a:	807b      	strh	r3, [r7, #2]
	int result;
	unsigned char motion_event_control_reg[2];

	motion_event_control_reg[0] = (unsigned char)(output_mask >> 8);
  40820c:	887b      	ldrh	r3, [r7, #2]
  40820e:	0a1b      	lsrs	r3, r3, #8
  408210:	b29b      	uxth	r3, r3
  408212:	b2db      	uxtb	r3, r3
  408214:	723b      	strb	r3, [r7, #8]
	motion_event_control_reg[1] = (unsigned char)(output_mask & 0xff);
  408216:	887b      	ldrh	r3, [r7, #2]
  408218:	b2db      	uxtb	r3, r3
  40821a:	727b      	strb	r3, [r7, #9]

	result = inv_icm20648_write_mems(s, MOTION_EVENT_CTL, 2, motion_event_control_reg);
  40821c:	f107 0308 	add.w	r3, r7, #8
  408220:	2202      	movs	r2, #2
  408222:	214e      	movs	r1, #78	; 0x4e
  408224:	6878      	ldr	r0, [r7, #4]
  408226:	4c04      	ldr	r4, [pc, #16]	; (408238 <dmp_icm20648_set_motion_event_control+0x38>)
  408228:	47a0      	blx	r4
  40822a:	60f8      	str	r0, [r7, #12]

	return result;
  40822c:	68fb      	ldr	r3, [r7, #12]
}
  40822e:	4618      	mov	r0, r3
  408230:	3714      	adds	r7, #20
  408232:	46bd      	mov	sp, r7
  408234:	bd90      	pop	{r4, r7, pc}
  408236:	bf00      	nop
  408238:	0040cdfd 	.word	0x0040cdfd

0040823c <dmp_icm20648_set_sensor_rate>:
*		INV_SENSOR_INVALID,
*	};					
* @param[in] divider	desired ODR = base engine rate/(divider + 1)
*/
int dmp_icm20648_set_sensor_rate(struct inv_icm20648 * s, int invSensor, short divider)
{
  40823c:	b590      	push	{r4, r7, lr}
  40823e:	b089      	sub	sp, #36	; 0x24
  408240:	af00      	add	r7, sp, #0
  408242:	60f8      	str	r0, [r7, #12]
  408244:	60b9      	str	r1, [r7, #8]
  408246:	4613      	mov	r3, r2
  408248:	80fb      	strh	r3, [r7, #6]
	int result;
	unsigned char big8[2]={0};
  40824a:	2300      	movs	r3, #0
  40824c:	82bb      	strh	r3, [r7, #20]
	int odr_addr = 0;
  40824e:	2300      	movs	r3, #0
  408250:	61fb      	str	r3, [r7, #28]

	switch (invSensor) {
  408252:	68bb      	ldr	r3, [r7, #8]
  408254:	2b0c      	cmp	r3, #12
  408256:	d83e      	bhi.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
  408258:	a201      	add	r2, pc, #4	; (adr r2, 408260 <dmp_icm20648_set_sensor_rate+0x24>)
  40825a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40825e:	bf00      	nop
  408260:	00408295 	.word	0x00408295
  408264:	0040829b 	.word	0x0040829b
  408268:	004082d7 	.word	0x004082d7
  40826c:	004082a1 	.word	0x004082a1
  408270:	004082a7 	.word	0x004082a7
  408274:	004082ad 	.word	0x004082ad
  408278:	004082b3 	.word	0x004082b3
  40827c:	004082b9 	.word	0x004082b9
  408280:	004082bf 	.word	0x004082bf
  408284:	004082c5 	.word	0x004082c5
  408288:	004082cb 	.word	0x004082cb
  40828c:	004082d1 	.word	0x004082d1
  408290:	004082d7 	.word	0x004082d7
	case INV_SENSOR_ACCEL:
		odr_addr = ODR_ACCEL;
  408294:	23be      	movs	r3, #190	; 0xbe
  408296:	61fb      	str	r3, [r7, #28]
		break;
  408298:	e01d      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_GYRO:
		odr_addr = ODR_GYRO;
  40829a:	23ba      	movs	r3, #186	; 0xba
  40829c:	61fb      	str	r3, [r7, #28]
		break;
  40829e:	e01a      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_COMPASS:
		odr_addr = ODR_CPASS;
  4082a0:	23b6      	movs	r3, #182	; 0xb6
  4082a2:	61fb      	str	r3, [r7, #28]
		break;
  4082a4:	e017      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_ALS:
		odr_addr = ODR_ALS;
  4082a6:	23b2      	movs	r3, #178	; 0xb2
  4082a8:	61fb      	str	r3, [r7, #28]
		break;
  4082aa:	e014      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_SIXQ:
		odr_addr = ODR_QUAT6;
  4082ac:	23ac      	movs	r3, #172	; 0xac
  4082ae:	61fb      	str	r3, [r7, #28]
		break;
  4082b0:	e011      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_NINEQ:
		odr_addr = ODR_QUAT9;
  4082b2:	23a8      	movs	r3, #168	; 0xa8
  4082b4:	61fb      	str	r3, [r7, #28]
		break;
  4082b6:	e00e      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_GEOMAG:
		odr_addr = ODR_GEOMAG;
  4082b8:	23a0      	movs	r3, #160	; 0xa0
  4082ba:	61fb      	str	r3, [r7, #28]
		break;
  4082bc:	e00b      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_PEDQ:
		odr_addr = ODR_PQUAT6;
  4082be:	23a4      	movs	r3, #164	; 0xa4
  4082c0:	61fb      	str	r3, [r7, #28]
		break;
  4082c2:	e008      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_PRESSURE:
		odr_addr = ODR_PRESSURE;
  4082c4:	23bc      	movs	r3, #188	; 0xbc
  4082c6:	61fb      	str	r3, [r7, #28]
		break;
  4082c8:	e005      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_CALIB_GYRO:
		odr_addr = ODR_GYRO_CALIBR;
  4082ca:	23b8      	movs	r3, #184	; 0xb8
  4082cc:	61fb      	str	r3, [r7, #28]
		break;
  4082ce:	e002      	b.n	4082d6 <dmp_icm20648_set_sensor_rate+0x9a>
	case INV_SENSOR_CALIB_COMPASS:
		odr_addr = ODR_CPASS_CALIBR;
  4082d0:	23b4      	movs	r3, #180	; 0xb4
  4082d2:	61fb      	str	r3, [r7, #28]
		break;
  4082d4:	bf00      	nop
	case INV_SENSOR_STEP_COUNTER:
		//odr_addr = PED_RATE + 2; //PED_RATE is a 4-byte address but only writing 2 bytes here
		break;
	}	

	result = inv_icm20648_write_mems(s, odr_addr, 2, inv_icm20648_convert_int16_to_big8(divider, big8));
  4082d6:	69fb      	ldr	r3, [r7, #28]
  4082d8:	b29c      	uxth	r4, r3
  4082da:	f107 0214 	add.w	r2, r7, #20
  4082de:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
  4082e2:	4611      	mov	r1, r2
  4082e4:	4618      	mov	r0, r3
  4082e6:	4b09      	ldr	r3, [pc, #36]	; (40830c <dmp_icm20648_set_sensor_rate+0xd0>)
  4082e8:	4798      	blx	r3
  4082ea:	4603      	mov	r3, r0
  4082ec:	2202      	movs	r2, #2
  4082ee:	4621      	mov	r1, r4
  4082f0:	68f8      	ldr	r0, [r7, #12]
  4082f2:	4c07      	ldr	r4, [pc, #28]	; (408310 <dmp_icm20648_set_sensor_rate+0xd4>)
  4082f4:	47a0      	blx	r4
  4082f6:	61b8      	str	r0, [r7, #24]

	if (result)
  4082f8:	69bb      	ldr	r3, [r7, #24]
  4082fa:	2b00      	cmp	r3, #0
  4082fc:	d001      	beq.n	408302 <dmp_icm20648_set_sensor_rate+0xc6>
		return result;
  4082fe:	69bb      	ldr	r3, [r7, #24]
  408300:	e000      	b.n	408304 <dmp_icm20648_set_sensor_rate+0xc8>

	return 0;
  408302:	2300      	movs	r3, #0
}
  408304:	4618      	mov	r0, r3
  408306:	3724      	adds	r7, #36	; 0x24
  408308:	46bd      	mov	sp, r7
  40830a:	bd90      	pop	{r4, r7, pc}
  40830c:	00407f29 	.word	0x00407f29
  408310:	0040cdfd 	.word	0x0040cdfd

00408314 <dmp_icm20648_get_bias_cmp>:
*	[0] compass_x
*	[1] compass_y
*	[2] compass_z
*/
int dmp_icm20648_get_bias_cmp(struct inv_icm20648 * s, int *bias)
{
  408314:	b590      	push	{r4, r7, lr}
  408316:	b085      	sub	sp, #20
  408318:	af00      	add	r7, sp, #0
  40831a:	6078      	str	r0, [r7, #4]
  40831c:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  40831e:	2300      	movs	r3, #0
  408320:	60bb      	str	r3, [r7, #8]

	result = inv_icm20648_read_mems(s, CPASS_BIAS_X, 4, big8);
  408322:	f107 0308 	add.w	r3, r7, #8
  408326:	2204      	movs	r2, #4
  408328:	f240 71e4 	movw	r1, #2020	; 0x7e4
  40832c:	6878      	ldr	r0, [r7, #4]
  40832e:	4c20      	ldr	r4, [pc, #128]	; (4083b0 <dmp_icm20648_get_bias_cmp+0x9c>)
  408330:	47a0      	blx	r4
  408332:	60f8      	str	r0, [r7, #12]
	bias[0] = inv_icm20648_convert_big8_to_int32(big8);
  408334:	f107 0308 	add.w	r3, r7, #8
  408338:	4618      	mov	r0, r3
  40833a:	4b1e      	ldr	r3, [pc, #120]	; (4083b4 <dmp_icm20648_get_bias_cmp+0xa0>)
  40833c:	4798      	blx	r3
  40833e:	4602      	mov	r2, r0
  408340:	683b      	ldr	r3, [r7, #0]
  408342:	601a      	str	r2, [r3, #0]
	result += inv_icm20648_read_mems(s, CPASS_BIAS_Y, 4, big8);
  408344:	f107 0308 	add.w	r3, r7, #8
  408348:	2204      	movs	r2, #4
  40834a:	f44f 61fd 	mov.w	r1, #2024	; 0x7e8
  40834e:	6878      	ldr	r0, [r7, #4]
  408350:	4c17      	ldr	r4, [pc, #92]	; (4083b0 <dmp_icm20648_get_bias_cmp+0x9c>)
  408352:	47a0      	blx	r4
  408354:	4602      	mov	r2, r0
  408356:	68fb      	ldr	r3, [r7, #12]
  408358:	4413      	add	r3, r2
  40835a:	60fb      	str	r3, [r7, #12]
	bias[1] = inv_icm20648_convert_big8_to_int32(big8);
  40835c:	683b      	ldr	r3, [r7, #0]
  40835e:	1d1c      	adds	r4, r3, #4
  408360:	f107 0308 	add.w	r3, r7, #8
  408364:	4618      	mov	r0, r3
  408366:	4b13      	ldr	r3, [pc, #76]	; (4083b4 <dmp_icm20648_get_bias_cmp+0xa0>)
  408368:	4798      	blx	r3
  40836a:	4603      	mov	r3, r0
  40836c:	6023      	str	r3, [r4, #0]
	result += inv_icm20648_read_mems(s, CPASS_BIAS_Z, 4, big8);
  40836e:	f107 0308 	add.w	r3, r7, #8
  408372:	2204      	movs	r2, #4
  408374:	f240 71ec 	movw	r1, #2028	; 0x7ec
  408378:	6878      	ldr	r0, [r7, #4]
  40837a:	4c0d      	ldr	r4, [pc, #52]	; (4083b0 <dmp_icm20648_get_bias_cmp+0x9c>)
  40837c:	47a0      	blx	r4
  40837e:	4602      	mov	r2, r0
  408380:	68fb      	ldr	r3, [r7, #12]
  408382:	4413      	add	r3, r2
  408384:	60fb      	str	r3, [r7, #12]
	bias[2] = inv_icm20648_convert_big8_to_int32(big8);
  408386:	683b      	ldr	r3, [r7, #0]
  408388:	f103 0408 	add.w	r4, r3, #8
  40838c:	f107 0308 	add.w	r3, r7, #8
  408390:	4618      	mov	r0, r3
  408392:	4b08      	ldr	r3, [pc, #32]	; (4083b4 <dmp_icm20648_get_bias_cmp+0xa0>)
  408394:	4798      	blx	r3
  408396:	4603      	mov	r3, r0
  408398:	6023      	str	r3, [r4, #0]

	if (result)
  40839a:	68fb      	ldr	r3, [r7, #12]
  40839c:	2b00      	cmp	r3, #0
  40839e:	d001      	beq.n	4083a4 <dmp_icm20648_get_bias_cmp+0x90>
		return result;
  4083a0:	68fb      	ldr	r3, [r7, #12]
  4083a2:	e000      	b.n	4083a6 <dmp_icm20648_get_bias_cmp+0x92>

	return 0; 
  4083a4:	2300      	movs	r3, #0
}
  4083a6:	4618      	mov	r0, r3
  4083a8:	3714      	adds	r7, #20
  4083aa:	46bd      	mov	sp, r7
  4083ac:	bd90      	pop	{r4, r7, pc}
  4083ae:	bf00      	nop
  4083b0:	0040cc1d 	.word	0x0040cc1d
  4083b4:	00407f9f 	.word	0x00407f9f

004083b8 <dmp_icm20648_set_gyro_sf>:
/**
* Sets the gyro_sf used by quaternions on the DMP.
* @param[in] gyro_sf	see inv_icm20648_set_gyro_sf() for value to set based on gyro rate and gyro fullscale range
*/
int dmp_icm20648_set_gyro_sf(struct inv_icm20648 * s, long gyro_sf)
{
  4083b8:	b590      	push	{r4, r7, lr}
  4083ba:	b085      	sub	sp, #20
  4083bc:	af00      	add	r7, sp, #0
  4083be:	6078      	str	r0, [r7, #4]
  4083c0:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4];

	result = inv_icm20648_write_mems(s, GYRO_SF, 4, inv_icm20648_convert_int32_to_big8(gyro_sf, big8));
  4083c2:	f107 0308 	add.w	r3, r7, #8
  4083c6:	4619      	mov	r1, r3
  4083c8:	6838      	ldr	r0, [r7, #0]
  4083ca:	4b07      	ldr	r3, [pc, #28]	; (4083e8 <dmp_icm20648_set_gyro_sf+0x30>)
  4083cc:	4798      	blx	r3
  4083ce:	4603      	mov	r3, r0
  4083d0:	2204      	movs	r2, #4
  4083d2:	f44f 7198 	mov.w	r1, #304	; 0x130
  4083d6:	6878      	ldr	r0, [r7, #4]
  4083d8:	4c04      	ldr	r4, [pc, #16]	; (4083ec <dmp_icm20648_set_gyro_sf+0x34>)
  4083da:	47a0      	blx	r4
  4083dc:	60f8      	str	r0, [r7, #12]

	return result;
  4083de:	68fb      	ldr	r3, [r7, #12]
}
  4083e0:	4618      	mov	r0, r3
  4083e2:	3714      	adds	r7, #20
  4083e4:	46bd      	mov	sp, r7
  4083e6:	bd90      	pop	{r4, r7, pc}
  4083e8:	00407f5b 	.word	0x00407f5b
  4083ec:	0040cdfd 	.word	0x0040cdfd

004083f0 <dmp_icm20648_set_accel_feedback_gain>:
/**
* Sets the accel gain used by accel quaternion on the DMP.
* @param[in] accel_gain		value changes with accel engine rate
*/
int dmp_icm20648_set_accel_feedback_gain(struct inv_icm20648 * s, int accel_gain)
{
  4083f0:	b590      	push	{r4, r7, lr}
  4083f2:	b085      	sub	sp, #20
  4083f4:	af00      	add	r7, sp, #0
  4083f6:	6078      	str	r0, [r7, #4]
  4083f8:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  4083fa:	2300      	movs	r3, #0
  4083fc:	60bb      	str	r3, [r7, #8]

	result = inv_icm20648_write_mems(s, ACCEL_ONLY_GAIN, 4, inv_icm20648_convert_int32_to_big8(accel_gain, big8));
  4083fe:	f107 0308 	add.w	r3, r7, #8
  408402:	4619      	mov	r1, r3
  408404:	6838      	ldr	r0, [r7, #0]
  408406:	4b0a      	ldr	r3, [pc, #40]	; (408430 <dmp_icm20648_set_accel_feedback_gain+0x40>)
  408408:	4798      	blx	r3
  40840a:	4603      	mov	r3, r0
  40840c:	2204      	movs	r2, #4
  40840e:	f44f 7186 	mov.w	r1, #268	; 0x10c
  408412:	6878      	ldr	r0, [r7, #4]
  408414:	4c07      	ldr	r4, [pc, #28]	; (408434 <dmp_icm20648_set_accel_feedback_gain+0x44>)
  408416:	47a0      	blx	r4
  408418:	60f8      	str	r0, [r7, #12]

	if (result)
  40841a:	68fb      	ldr	r3, [r7, #12]
  40841c:	2b00      	cmp	r3, #0
  40841e:	d001      	beq.n	408424 <dmp_icm20648_set_accel_feedback_gain+0x34>
		return result;
  408420:	68fb      	ldr	r3, [r7, #12]
  408422:	e000      	b.n	408426 <dmp_icm20648_set_accel_feedback_gain+0x36>

	return 0;
  408424:	2300      	movs	r3, #0
}
  408426:	4618      	mov	r0, r3
  408428:	3714      	adds	r7, #20
  40842a:	46bd      	mov	sp, r7
  40842c:	bd90      	pop	{r4, r7, pc}
  40842e:	bf00      	nop
  408430:	00407f5b 	.word	0x00407f5b
  408434:	0040cdfd 	.word	0x0040cdfd

00408438 <dmp_icm20648_set_accel_cal_params>:
*	[0] = ACCEL_CAL_ALPHA_VAR
*	[1] = ACCEL_CAL_A_VAR
*   [2] = ACCEL_CAL_DIV - divider from hardware accel engine rate such that acce cal runs at accel_engine_rate/(divider+1)
*/
int dmp_icm20648_set_accel_cal_params(struct inv_icm20648 * s, int *accel_cal)
{
  408438:	b590      	push	{r4, r7, lr}
  40843a:	b085      	sub	sp, #20
  40843c:	af00      	add	r7, sp, #0
  40843e:	6078      	str	r0, [r7, #4]
  408440:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  408442:	2300      	movs	r3, #0
  408444:	60bb      	str	r3, [r7, #8]

	result  = inv_icm20648_write_mems(s, ACCEL_ALPHA_VAR, 4, inv_icm20648_convert_int32_to_big8(accel_cal[ACCEL_CAL_ALPHA_VAR], big8));
  408446:	683b      	ldr	r3, [r7, #0]
  408448:	681b      	ldr	r3, [r3, #0]
  40844a:	f107 0208 	add.w	r2, r7, #8
  40844e:	4611      	mov	r1, r2
  408450:	4618      	mov	r0, r3
  408452:	4b1e      	ldr	r3, [pc, #120]	; (4084cc <dmp_icm20648_set_accel_cal_params+0x94>)
  408454:	4798      	blx	r3
  408456:	4603      	mov	r3, r0
  408458:	2204      	movs	r2, #4
  40845a:	f44f 61b6 	mov.w	r1, #1456	; 0x5b0
  40845e:	6878      	ldr	r0, [r7, #4]
  408460:	4c1b      	ldr	r4, [pc, #108]	; (4084d0 <dmp_icm20648_set_accel_cal_params+0x98>)
  408462:	47a0      	blx	r4
  408464:	60f8      	str	r0, [r7, #12]
	result |= inv_icm20648_write_mems(s, ACCEL_A_VAR, 4, inv_icm20648_convert_int32_to_big8(accel_cal[ACCEL_CAL_A_VAR], big8));
  408466:	683b      	ldr	r3, [r7, #0]
  408468:	3304      	adds	r3, #4
  40846a:	681b      	ldr	r3, [r3, #0]
  40846c:	f107 0208 	add.w	r2, r7, #8
  408470:	4611      	mov	r1, r2
  408472:	4618      	mov	r0, r3
  408474:	4b15      	ldr	r3, [pc, #84]	; (4084cc <dmp_icm20648_set_accel_cal_params+0x94>)
  408476:	4798      	blx	r3
  408478:	4603      	mov	r3, r0
  40847a:	2204      	movs	r2, #4
  40847c:	f44f 61b8 	mov.w	r1, #1472	; 0x5c0
  408480:	6878      	ldr	r0, [r7, #4]
  408482:	4c13      	ldr	r4, [pc, #76]	; (4084d0 <dmp_icm20648_set_accel_cal_params+0x98>)
  408484:	47a0      	blx	r4
  408486:	4602      	mov	r2, r0
  408488:	68fb      	ldr	r3, [r7, #12]
  40848a:	4313      	orrs	r3, r2
  40848c:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20648_write_mems(s, ACCEL_CAL_RATE, 2, inv_icm20648_convert_int16_to_big8(accel_cal[ACCEL_CAL_DIV], big8));
  40848e:	683b      	ldr	r3, [r7, #0]
  408490:	3308      	adds	r3, #8
  408492:	681b      	ldr	r3, [r3, #0]
  408494:	b21b      	sxth	r3, r3
  408496:	f107 0208 	add.w	r2, r7, #8
  40849a:	4611      	mov	r1, r2
  40849c:	4618      	mov	r0, r3
  40849e:	4b0d      	ldr	r3, [pc, #52]	; (4084d4 <dmp_icm20648_set_accel_cal_params+0x9c>)
  4084a0:	4798      	blx	r3
  4084a2:	4603      	mov	r3, r0
  4084a4:	2202      	movs	r2, #2
  4084a6:	f240 51e4 	movw	r1, #1508	; 0x5e4
  4084aa:	6878      	ldr	r0, [r7, #4]
  4084ac:	4c08      	ldr	r4, [pc, #32]	; (4084d0 <dmp_icm20648_set_accel_cal_params+0x98>)
  4084ae:	47a0      	blx	r4
  4084b0:	4602      	mov	r2, r0
  4084b2:	68fb      	ldr	r3, [r7, #12]
  4084b4:	4313      	orrs	r3, r2
  4084b6:	60fb      	str	r3, [r7, #12]

	if (result)
  4084b8:	68fb      	ldr	r3, [r7, #12]
  4084ba:	2b00      	cmp	r3, #0
  4084bc:	d001      	beq.n	4084c2 <dmp_icm20648_set_accel_cal_params+0x8a>
		return result;
  4084be:	68fb      	ldr	r3, [r7, #12]
  4084c0:	e000      	b.n	4084c4 <dmp_icm20648_set_accel_cal_params+0x8c>

	return 0;
  4084c2:	2300      	movs	r3, #0
}
  4084c4:	4618      	mov	r0, r3
  4084c6:	3714      	adds	r7, #20
  4084c8:	46bd      	mov	sp, r7
  4084ca:	bd90      	pop	{r4, r7, pc}
  4084cc:	00407f5b 	.word	0x00407f5b
  4084d0:	0040cdfd 	.word	0x0040cdfd
  4084d4:	00407f29 	.word	0x00407f29

004084d8 <dmp_icm20648_set_compass_matrix>:
/**
* Sets compass orientation matrix to DMP.
* @param[in] compass_mtx
*/
int dmp_icm20648_set_compass_matrix(struct inv_icm20648 * s, int *compass_mtx)
{
  4084d8:	b590      	push	{r4, r7, lr}
  4084da:	b085      	sub	sp, #20
  4084dc:	af00      	add	r7, sp, #0
  4084de:	6078      	str	r0, [r7, #4]
  4084e0:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  4084e2:	2300      	movs	r3, #0
  4084e4:	60bb      	str	r3, [r7, #8]

	result = inv_icm20648_write_mems(s, CPASS_MTX_00, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[0], big8));
  4084e6:	683b      	ldr	r3, [r7, #0]
  4084e8:	681b      	ldr	r3, [r3, #0]
  4084ea:	f107 0208 	add.w	r2, r7, #8
  4084ee:	4611      	mov	r1, r2
  4084f0:	4618      	mov	r0, r3
  4084f2:	4b5a      	ldr	r3, [pc, #360]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  4084f4:	4798      	blx	r3
  4084f6:	4603      	mov	r3, r0
  4084f8:	2204      	movs	r2, #4
  4084fa:	f44f 71b8 	mov.w	r1, #368	; 0x170
  4084fe:	6878      	ldr	r0, [r7, #4]
  408500:	4c57      	ldr	r4, [pc, #348]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  408502:	47a0      	blx	r4
  408504:	60f8      	str	r0, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_01, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[1], big8));
  408506:	683b      	ldr	r3, [r7, #0]
  408508:	3304      	adds	r3, #4
  40850a:	681b      	ldr	r3, [r3, #0]
  40850c:	f107 0208 	add.w	r2, r7, #8
  408510:	4611      	mov	r1, r2
  408512:	4618      	mov	r0, r3
  408514:	4b51      	ldr	r3, [pc, #324]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  408516:	4798      	blx	r3
  408518:	4603      	mov	r3, r0
  40851a:	2204      	movs	r2, #4
  40851c:	f44f 71ba 	mov.w	r1, #372	; 0x174
  408520:	6878      	ldr	r0, [r7, #4]
  408522:	4c4f      	ldr	r4, [pc, #316]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  408524:	47a0      	blx	r4
  408526:	4602      	mov	r2, r0
  408528:	68fb      	ldr	r3, [r7, #12]
  40852a:	4413      	add	r3, r2
  40852c:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_02, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[2], big8));
  40852e:	683b      	ldr	r3, [r7, #0]
  408530:	3308      	adds	r3, #8
  408532:	681b      	ldr	r3, [r3, #0]
  408534:	f107 0208 	add.w	r2, r7, #8
  408538:	4611      	mov	r1, r2
  40853a:	4618      	mov	r0, r3
  40853c:	4b47      	ldr	r3, [pc, #284]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  40853e:	4798      	blx	r3
  408540:	4603      	mov	r3, r0
  408542:	2204      	movs	r2, #4
  408544:	f44f 71bc 	mov.w	r1, #376	; 0x178
  408548:	6878      	ldr	r0, [r7, #4]
  40854a:	4c45      	ldr	r4, [pc, #276]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  40854c:	47a0      	blx	r4
  40854e:	4602      	mov	r2, r0
  408550:	68fb      	ldr	r3, [r7, #12]
  408552:	4413      	add	r3, r2
  408554:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_10, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[3], big8));
  408556:	683b      	ldr	r3, [r7, #0]
  408558:	330c      	adds	r3, #12
  40855a:	681b      	ldr	r3, [r3, #0]
  40855c:	f107 0208 	add.w	r2, r7, #8
  408560:	4611      	mov	r1, r2
  408562:	4618      	mov	r0, r3
  408564:	4b3d      	ldr	r3, [pc, #244]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  408566:	4798      	blx	r3
  408568:	4603      	mov	r3, r0
  40856a:	2204      	movs	r2, #4
  40856c:	f44f 71be 	mov.w	r1, #380	; 0x17c
  408570:	6878      	ldr	r0, [r7, #4]
  408572:	4c3b      	ldr	r4, [pc, #236]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  408574:	47a0      	blx	r4
  408576:	4602      	mov	r2, r0
  408578:	68fb      	ldr	r3, [r7, #12]
  40857a:	4413      	add	r3, r2
  40857c:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_11, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[4], big8));
  40857e:	683b      	ldr	r3, [r7, #0]
  408580:	3310      	adds	r3, #16
  408582:	681b      	ldr	r3, [r3, #0]
  408584:	f107 0208 	add.w	r2, r7, #8
  408588:	4611      	mov	r1, r2
  40858a:	4618      	mov	r0, r3
  40858c:	4b33      	ldr	r3, [pc, #204]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  40858e:	4798      	blx	r3
  408590:	4603      	mov	r3, r0
  408592:	2204      	movs	r2, #4
  408594:	f44f 71c0 	mov.w	r1, #384	; 0x180
  408598:	6878      	ldr	r0, [r7, #4]
  40859a:	4c31      	ldr	r4, [pc, #196]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  40859c:	47a0      	blx	r4
  40859e:	4602      	mov	r2, r0
  4085a0:	68fb      	ldr	r3, [r7, #12]
  4085a2:	4413      	add	r3, r2
  4085a4:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_12, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[5], big8));
  4085a6:	683b      	ldr	r3, [r7, #0]
  4085a8:	3314      	adds	r3, #20
  4085aa:	681b      	ldr	r3, [r3, #0]
  4085ac:	f107 0208 	add.w	r2, r7, #8
  4085b0:	4611      	mov	r1, r2
  4085b2:	4618      	mov	r0, r3
  4085b4:	4b29      	ldr	r3, [pc, #164]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  4085b6:	4798      	blx	r3
  4085b8:	4603      	mov	r3, r0
  4085ba:	2204      	movs	r2, #4
  4085bc:	f44f 71c2 	mov.w	r1, #388	; 0x184
  4085c0:	6878      	ldr	r0, [r7, #4]
  4085c2:	4c27      	ldr	r4, [pc, #156]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  4085c4:	47a0      	blx	r4
  4085c6:	4602      	mov	r2, r0
  4085c8:	68fb      	ldr	r3, [r7, #12]
  4085ca:	4413      	add	r3, r2
  4085cc:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_20, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[6], big8));
  4085ce:	683b      	ldr	r3, [r7, #0]
  4085d0:	3318      	adds	r3, #24
  4085d2:	681b      	ldr	r3, [r3, #0]
  4085d4:	f107 0208 	add.w	r2, r7, #8
  4085d8:	4611      	mov	r1, r2
  4085da:	4618      	mov	r0, r3
  4085dc:	4b1f      	ldr	r3, [pc, #124]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  4085de:	4798      	blx	r3
  4085e0:	4603      	mov	r3, r0
  4085e2:	2204      	movs	r2, #4
  4085e4:	f44f 71c4 	mov.w	r1, #392	; 0x188
  4085e8:	6878      	ldr	r0, [r7, #4]
  4085ea:	4c1d      	ldr	r4, [pc, #116]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  4085ec:	47a0      	blx	r4
  4085ee:	4602      	mov	r2, r0
  4085f0:	68fb      	ldr	r3, [r7, #12]
  4085f2:	4413      	add	r3, r2
  4085f4:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_21, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[7], big8));
  4085f6:	683b      	ldr	r3, [r7, #0]
  4085f8:	331c      	adds	r3, #28
  4085fa:	681b      	ldr	r3, [r3, #0]
  4085fc:	f107 0208 	add.w	r2, r7, #8
  408600:	4611      	mov	r1, r2
  408602:	4618      	mov	r0, r3
  408604:	4b15      	ldr	r3, [pc, #84]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  408606:	4798      	blx	r3
  408608:	4603      	mov	r3, r0
  40860a:	2204      	movs	r2, #4
  40860c:	f44f 71c6 	mov.w	r1, #396	; 0x18c
  408610:	6878      	ldr	r0, [r7, #4]
  408612:	4c13      	ldr	r4, [pc, #76]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  408614:	47a0      	blx	r4
  408616:	4602      	mov	r2, r0
  408618:	68fb      	ldr	r3, [r7, #12]
  40861a:	4413      	add	r3, r2
  40861c:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, CPASS_MTX_22, 4, inv_icm20648_convert_int32_to_big8(compass_mtx[8], big8));
  40861e:	683b      	ldr	r3, [r7, #0]
  408620:	3320      	adds	r3, #32
  408622:	681b      	ldr	r3, [r3, #0]
  408624:	f107 0208 	add.w	r2, r7, #8
  408628:	4611      	mov	r1, r2
  40862a:	4618      	mov	r0, r3
  40862c:	4b0b      	ldr	r3, [pc, #44]	; (40865c <dmp_icm20648_set_compass_matrix+0x184>)
  40862e:	4798      	blx	r3
  408630:	4603      	mov	r3, r0
  408632:	2204      	movs	r2, #4
  408634:	f44f 71c8 	mov.w	r1, #400	; 0x190
  408638:	6878      	ldr	r0, [r7, #4]
  40863a:	4c09      	ldr	r4, [pc, #36]	; (408660 <dmp_icm20648_set_compass_matrix+0x188>)
  40863c:	47a0      	blx	r4
  40863e:	4602      	mov	r2, r0
  408640:	68fb      	ldr	r3, [r7, #12]
  408642:	4413      	add	r3, r2
  408644:	60fb      	str	r3, [r7, #12]

	if (result)
  408646:	68fb      	ldr	r3, [r7, #12]
  408648:	2b00      	cmp	r3, #0
  40864a:	d001      	beq.n	408650 <dmp_icm20648_set_compass_matrix+0x178>
		return result;
  40864c:	68fb      	ldr	r3, [r7, #12]
  40864e:	e000      	b.n	408652 <dmp_icm20648_set_compass_matrix+0x17a>

	return 0;
  408650:	2300      	movs	r3, #0
}
  408652:	4618      	mov	r0, r3
  408654:	3714      	adds	r7, #20
  408656:	46bd      	mov	sp, r7
  408658:	bd90      	pop	{r4, r7, pc}
  40865a:	bf00      	nop
  40865c:	00407f5b 	.word	0x00407f5b
  408660:	0040cdfd 	.word	0x0040cdfd

00408664 <dmp_icm20648_get_pedometer_num_of_steps>:
* Gets pedometer step count.
* @param[in] steps
* @param[out] steps
*/
int dmp_icm20648_get_pedometer_num_of_steps(struct inv_icm20648 * s, unsigned long *steps)
{
  408664:	b590      	push	{r4, r7, lr}
  408666:	b085      	sub	sp, #20
  408668:	af00      	add	r7, sp, #0
  40866a:	6078      	str	r0, [r7, #4]
  40866c:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  40866e:	2300      	movs	r3, #0
  408670:	60bb      	str	r3, [r7, #8]
	(void)s;
	result = inv_icm20648_read_mems(s, PEDSTD_STEPCTR, 4, big8);
  408672:	f107 0308 	add.w	r3, r7, #8
  408676:	2204      	movs	r2, #4
  408678:	f44f 7158 	mov.w	r1, #864	; 0x360
  40867c:	6878      	ldr	r0, [r7, #4]
  40867e:	4c0d      	ldr	r4, [pc, #52]	; (4086b4 <dmp_icm20648_get_pedometer_num_of_steps+0x50>)
  408680:	47a0      	blx	r4
  408682:	60f8      	str	r0, [r7, #12]
	if (result) 
  408684:	68fb      	ldr	r3, [r7, #12]
  408686:	2b00      	cmp	r3, #0
  408688:	d001      	beq.n	40868e <dmp_icm20648_get_pedometer_num_of_steps+0x2a>
		return result;
  40868a:	68fb      	ldr	r3, [r7, #12]
  40868c:	e00d      	b.n	4086aa <dmp_icm20648_get_pedometer_num_of_steps+0x46>
	*steps = (big8[0]*(1L<<24)) + (big8[1]*(1L<<16)) + (big8[2]*256) + big8[3];
  40868e:	7a3b      	ldrb	r3, [r7, #8]
  408690:	021b      	lsls	r3, r3, #8
  408692:	7a7a      	ldrb	r2, [r7, #9]
  408694:	4413      	add	r3, r2
  408696:	021b      	lsls	r3, r3, #8
  408698:	7aba      	ldrb	r2, [r7, #10]
  40869a:	4413      	add	r3, r2
  40869c:	021b      	lsls	r3, r3, #8
  40869e:	7afa      	ldrb	r2, [r7, #11]
  4086a0:	4413      	add	r3, r2
  4086a2:	461a      	mov	r2, r3
  4086a4:	683b      	ldr	r3, [r7, #0]
  4086a6:	601a      	str	r2, [r3, #0]

	return 0;
  4086a8:	2300      	movs	r3, #0
}
  4086aa:	4618      	mov	r0, r3
  4086ac:	3714      	adds	r7, #20
  4086ae:	46bd      	mov	sp, r7
  4086b0:	bd90      	pop	{r4, r7, pc}
  4086b2:	bf00      	nop
  4086b4:	0040cc1d 	.word	0x0040cc1d

004086b8 <dmp_icm20648_set_gyro_fsr>:
DMP takes raw gyro data and left shifts by 16 bits, so (<<16) becomes 2000dps=2^31, to make 4000dps=2^30, >>2 bits.
In Q-30 math, >> 2 equals multiply by 2^28 = 268435456.
*/

int dmp_icm20648_set_gyro_fsr(struct inv_icm20648 * s, short gyro_fsr)
{
  4086b8:	b590      	push	{r4, r7, lr}
  4086ba:	b087      	sub	sp, #28
  4086bc:	af00      	add	r7, sp, #0
  4086be:	6078      	str	r0, [r7, #4]
  4086c0:	460b      	mov	r3, r1
  4086c2:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4];
	int result;
	long scale;

	switch (gyro_fsr) {
  4086c4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  4086c8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  4086cc:	d016      	beq.n	4086fc <dmp_icm20648_set_gyro_fsr+0x44>
  4086ce:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  4086d2:	dc05      	bgt.n	4086e0 <dmp_icm20648_set_gyro_fsr+0x28>
  4086d4:	2bfa      	cmp	r3, #250	; 0xfa
  4086d6:	d019      	beq.n	40870c <dmp_icm20648_set_gyro_fsr+0x54>
  4086d8:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  4086dc:	d012      	beq.n	408704 <dmp_icm20648_set_gyro_fsr+0x4c>
  4086de:	e019      	b.n	408714 <dmp_icm20648_set_gyro_fsr+0x5c>
  4086e0:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  4086e4:	d006      	beq.n	4086f4 <dmp_icm20648_set_gyro_fsr+0x3c>
  4086e6:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
  4086ea:	d113      	bne.n	408714 <dmp_icm20648_set_gyro_fsr+0x5c>
	case 4000:
		scale =  536870912L;  // 2^29
  4086ec:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  4086f0:	617b      	str	r3, [r7, #20]
		break;
  4086f2:	e012      	b.n	40871a <dmp_icm20648_set_gyro_fsr+0x62>
	case 2000:
		scale =  268435456L;  // 2^28
  4086f4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  4086f8:	617b      	str	r3, [r7, #20]
		break;
  4086fa:	e00e      	b.n	40871a <dmp_icm20648_set_gyro_fsr+0x62>
	case 1000:
		scale = 134217728L;  // 2^27
  4086fc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  408700:	617b      	str	r3, [r7, #20]
		break;
  408702:	e00a      	b.n	40871a <dmp_icm20648_set_gyro_fsr+0x62>
	case 500:
		scale = 67108864L;  // 2^26
  408704:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  408708:	617b      	str	r3, [r7, #20]
		break;
  40870a:	e006      	b.n	40871a <dmp_icm20648_set_gyro_fsr+0x62>
	case 250:
		scale = 33554432L;  // 2^25
  40870c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  408710:	617b      	str	r3, [r7, #20]
		break;
  408712:	e002      	b.n	40871a <dmp_icm20648_set_gyro_fsr+0x62>
	default:
		return -1;
  408714:	f04f 33ff 	mov.w	r3, #4294967295
  408718:	e013      	b.n	408742 <dmp_icm20648_set_gyro_fsr+0x8a>
	}

	result = inv_icm20648_write_mems(s, GYRO_FULLSCALE, 4, inv_icm20648_convert_int32_to_big8(scale,reg));
  40871a:	f107 030c 	add.w	r3, r7, #12
  40871e:	4619      	mov	r1, r3
  408720:	6978      	ldr	r0, [r7, #20]
  408722:	4b0a      	ldr	r3, [pc, #40]	; (40874c <dmp_icm20648_set_gyro_fsr+0x94>)
  408724:	4798      	blx	r3
  408726:	4603      	mov	r3, r0
  408728:	2204      	movs	r2, #4
  40872a:	f240 418c 	movw	r1, #1164	; 0x48c
  40872e:	6878      	ldr	r0, [r7, #4]
  408730:	4c07      	ldr	r4, [pc, #28]	; (408750 <dmp_icm20648_set_gyro_fsr+0x98>)
  408732:	47a0      	blx	r4
  408734:	6138      	str	r0, [r7, #16]

	if (result) {
  408736:	693b      	ldr	r3, [r7, #16]
  408738:	2b00      	cmp	r3, #0
  40873a:	d001      	beq.n	408740 <dmp_icm20648_set_gyro_fsr+0x88>
		return result;
  40873c:	693b      	ldr	r3, [r7, #16]
  40873e:	e000      	b.n	408742 <dmp_icm20648_set_gyro_fsr+0x8a>
	} else {
		return 0;
  408740:	2300      	movs	r3, #0
	}
}
  408742:	4618      	mov	r0, r3
  408744:	371c      	adds	r7, #28
  408746:	46bd      	mov	sp, r7
  408748:	bd90      	pop	{r4, r7, pc}
  40874a:	bf00      	nop
  40874c:	00407f5b 	.word	0x00407f5b
  408750:	0040cdfd 	.word	0x0040cdfd

00408754 <dmp_icm20648_set_accel_fsr>:
For 8g parts, 8g = 2^15 -> 1g = 2^12.
DMP takes raw accel data and left shifts by 16 bits, so 1g=2^12 (<<16) becomes 1g=2^28, to make 1g=2^25, >>3bits.
In Q-30 math, >> 3 equals multiply by 2^27 = 134217728.
*/
int dmp_icm20648_set_accel_fsr(struct inv_icm20648 * s, short accel_fsr)
{
  408754:	b590      	push	{r4, r7, lr}
  408756:	b087      	sub	sp, #28
  408758:	af00      	add	r7, sp, #0
  40875a:	6078      	str	r0, [r7, #4]
  40875c:	460b      	mov	r3, r1
  40875e:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4];
	int result;
	long scale;

	switch (accel_fsr) {
  408760:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  408764:	3b02      	subs	r3, #2
  408766:	2b1e      	cmp	r3, #30
  408768:	d854      	bhi.n	408814 <dmp_icm20648_set_accel_fsr+0xc0>
  40876a:	a201      	add	r2, pc, #4	; (adr r2, 408770 <dmp_icm20648_set_accel_fsr+0x1c>)
  40876c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  408770:	004087ed 	.word	0x004087ed
  408774:	00408815 	.word	0x00408815
  408778:	004087f5 	.word	0x004087f5
  40877c:	00408815 	.word	0x00408815
  408780:	00408815 	.word	0x00408815
  408784:	00408815 	.word	0x00408815
  408788:	004087fd 	.word	0x004087fd
  40878c:	00408815 	.word	0x00408815
  408790:	00408815 	.word	0x00408815
  408794:	00408815 	.word	0x00408815
  408798:	00408815 	.word	0x00408815
  40879c:	00408815 	.word	0x00408815
  4087a0:	00408815 	.word	0x00408815
  4087a4:	00408815 	.word	0x00408815
  4087a8:	00408805 	.word	0x00408805
  4087ac:	00408815 	.word	0x00408815
  4087b0:	00408815 	.word	0x00408815
  4087b4:	00408815 	.word	0x00408815
  4087b8:	00408815 	.word	0x00408815
  4087bc:	00408815 	.word	0x00408815
  4087c0:	00408815 	.word	0x00408815
  4087c4:	00408815 	.word	0x00408815
  4087c8:	00408815 	.word	0x00408815
  4087cc:	00408815 	.word	0x00408815
  4087d0:	00408815 	.word	0x00408815
  4087d4:	00408815 	.word	0x00408815
  4087d8:	00408815 	.word	0x00408815
  4087dc:	00408815 	.word	0x00408815
  4087e0:	00408815 	.word	0x00408815
  4087e4:	00408815 	.word	0x00408815
  4087e8:	0040880d 	.word	0x0040880d
	case 2:
		scale =  33554432L;  // 2^25
  4087ec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  4087f0:	617b      	str	r3, [r7, #20]
		break;
  4087f2:	e012      	b.n	40881a <dmp_icm20648_set_accel_fsr+0xc6>
	case 4:
		scale =  67108864L;  // 2^26
  4087f4:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  4087f8:	617b      	str	r3, [r7, #20]
		break;
  4087fa:	e00e      	b.n	40881a <dmp_icm20648_set_accel_fsr+0xc6>
	case 8:
		scale = 134217728L;  // 2^27
  4087fc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  408800:	617b      	str	r3, [r7, #20]
		break;
  408802:	e00a      	b.n	40881a <dmp_icm20648_set_accel_fsr+0xc6>
	case 16:
		scale = 268435456L;  // 2^28
  408804:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  408808:	617b      	str	r3, [r7, #20]
		break;
  40880a:	e006      	b.n	40881a <dmp_icm20648_set_accel_fsr+0xc6>
	case 32:
		scale = 536870912L;  // 2^29
  40880c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  408810:	617b      	str	r3, [r7, #20]
		break;
  408812:	e002      	b.n	40881a <dmp_icm20648_set_accel_fsr+0xc6>
	default:
		return -1;
  408814:	f04f 33ff 	mov.w	r3, #4294967295
  408818:	e013      	b.n	408842 <dmp_icm20648_set_accel_fsr+0xee>
	}

	result = inv_icm20648_write_mems(s, ACC_SCALE, 4, inv_icm20648_convert_int32_to_big8(scale,reg));
  40881a:	f107 030c 	add.w	r3, r7, #12
  40881e:	4619      	mov	r1, r3
  408820:	6978      	ldr	r0, [r7, #20]
  408822:	4b0a      	ldr	r3, [pc, #40]	; (40884c <dmp_icm20648_set_accel_fsr+0xf8>)
  408824:	4798      	blx	r3
  408826:	4603      	mov	r3, r0
  408828:	2204      	movs	r2, #4
  40882a:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
  40882e:	6878      	ldr	r0, [r7, #4]
  408830:	4c07      	ldr	r4, [pc, #28]	; (408850 <dmp_icm20648_set_accel_fsr+0xfc>)
  408832:	47a0      	blx	r4
  408834:	6138      	str	r0, [r7, #16]

	if (result) {
  408836:	693b      	ldr	r3, [r7, #16]
  408838:	2b00      	cmp	r3, #0
  40883a:	d001      	beq.n	408840 <dmp_icm20648_set_accel_fsr+0xec>
		return result;
  40883c:	693b      	ldr	r3, [r7, #16]
  40883e:	e000      	b.n	408842 <dmp_icm20648_set_accel_fsr+0xee>
	} else {
		return 0;
  408840:	2300      	movs	r3, #0
	}
}
  408842:	4618      	mov	r0, r3
  408844:	371c      	adds	r7, #28
  408846:	46bd      	mov	sp, r7
  408848:	bd90      	pop	{r4, r7, pc}
  40884a:	bf00      	nop
  40884c:	00407f5b 	.word	0x00407f5b
  408850:	0040cdfd 	.word	0x0040cdfd

00408854 <dmp_icm20648_set_accel_scale2>:
* It is a reverse scaling of the scale factor written to ACC_SCALE.
* @param[in] fsr for accel parts
2: 2g. 4: 4g. 8: 8g. 16: 16g. 32: 32g.
*/
int dmp_icm20648_set_accel_scale2(struct inv_icm20648 * s, short accel_fsr)
{
  408854:	b590      	push	{r4, r7, lr}
  408856:	b087      	sub	sp, #28
  408858:	af00      	add	r7, sp, #0
  40885a:	6078      	str	r0, [r7, #4]
  40885c:	460b      	mov	r3, r1
  40885e:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4];
	int result;
	long scale;

	switch (accel_fsr) {
  408860:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  408864:	3b02      	subs	r3, #2
  408866:	2b1e      	cmp	r3, #30
  408868:	d854      	bhi.n	408914 <dmp_icm20648_set_accel_scale2+0xc0>
  40886a:	a201      	add	r2, pc, #4	; (adr r2, 408870 <dmp_icm20648_set_accel_scale2+0x1c>)
  40886c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  408870:	004088ed 	.word	0x004088ed
  408874:	00408915 	.word	0x00408915
  408878:	004088f5 	.word	0x004088f5
  40887c:	00408915 	.word	0x00408915
  408880:	00408915 	.word	0x00408915
  408884:	00408915 	.word	0x00408915
  408888:	004088fd 	.word	0x004088fd
  40888c:	00408915 	.word	0x00408915
  408890:	00408915 	.word	0x00408915
  408894:	00408915 	.word	0x00408915
  408898:	00408915 	.word	0x00408915
  40889c:	00408915 	.word	0x00408915
  4088a0:	00408915 	.word	0x00408915
  4088a4:	00408915 	.word	0x00408915
  4088a8:	00408905 	.word	0x00408905
  4088ac:	00408915 	.word	0x00408915
  4088b0:	00408915 	.word	0x00408915
  4088b4:	00408915 	.word	0x00408915
  4088b8:	00408915 	.word	0x00408915
  4088bc:	00408915 	.word	0x00408915
  4088c0:	00408915 	.word	0x00408915
  4088c4:	00408915 	.word	0x00408915
  4088c8:	00408915 	.word	0x00408915
  4088cc:	00408915 	.word	0x00408915
  4088d0:	00408915 	.word	0x00408915
  4088d4:	00408915 	.word	0x00408915
  4088d8:	00408915 	.word	0x00408915
  4088dc:	00408915 	.word	0x00408915
  4088e0:	00408915 	.word	0x00408915
  4088e4:	00408915 	.word	0x00408915
  4088e8:	0040890d 	.word	0x0040890d
	case 2:
		scale = 524288L;  // 2^19
  4088ec:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  4088f0:	617b      	str	r3, [r7, #20]
		break;
  4088f2:	e012      	b.n	40891a <dmp_icm20648_set_accel_scale2+0xc6>
	case 4:
		scale = 262144L;  // 2^18
  4088f4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  4088f8:	617b      	str	r3, [r7, #20]
		break;
  4088fa:	e00e      	b.n	40891a <dmp_icm20648_set_accel_scale2+0xc6>
	case 8:
		scale = 131072L;  // 2^17
  4088fc:	f44f 3300 	mov.w	r3, #131072	; 0x20000
  408900:	617b      	str	r3, [r7, #20]
		break;
  408902:	e00a      	b.n	40891a <dmp_icm20648_set_accel_scale2+0xc6>
	case 16:
		scale = 65536L;  // 2^16
  408904:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  408908:	617b      	str	r3, [r7, #20]
		break;
  40890a:	e006      	b.n	40891a <dmp_icm20648_set_accel_scale2+0xc6>
	case 32:
		scale = 32768L;  // 2^15
  40890c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  408910:	617b      	str	r3, [r7, #20]
		break;
  408912:	e002      	b.n	40891a <dmp_icm20648_set_accel_scale2+0xc6>
	default:
		return -1;
  408914:	f04f 33ff 	mov.w	r3, #4294967295
  408918:	e013      	b.n	408942 <dmp_icm20648_set_accel_scale2+0xee>
	}

	result = inv_icm20648_write_mems(s, ACC_SCALE2, 4, inv_icm20648_convert_int32_to_big8(scale,reg));
  40891a:	f107 030c 	add.w	r3, r7, #12
  40891e:	4619      	mov	r1, r3
  408920:	6978      	ldr	r0, [r7, #20]
  408922:	4b0a      	ldr	r3, [pc, #40]	; (40894c <dmp_icm20648_set_accel_scale2+0xf8>)
  408924:	4798      	blx	r3
  408926:	4603      	mov	r3, r0
  408928:	2204      	movs	r2, #4
  40892a:	f240 41f4 	movw	r1, #1268	; 0x4f4
  40892e:	6878      	ldr	r0, [r7, #4]
  408930:	4c07      	ldr	r4, [pc, #28]	; (408950 <dmp_icm20648_set_accel_scale2+0xfc>)
  408932:	47a0      	blx	r4
  408934:	6138      	str	r0, [r7, #16]

	if (result) {
  408936:	693b      	ldr	r3, [r7, #16]
  408938:	2b00      	cmp	r3, #0
  40893a:	d001      	beq.n	408940 <dmp_icm20648_set_accel_scale2+0xec>
		return result;
  40893c:	693b      	ldr	r3, [r7, #16]
  40893e:	e000      	b.n	408942 <dmp_icm20648_set_accel_scale2+0xee>
	} else {
		return 0;
  408940:	2300      	movs	r3, #0
	}
}
  408942:	4618      	mov	r0, r3
  408944:	371c      	adds	r7, #28
  408946:	46bd      	mov	sp, r7
  408948:	bd90      	pop	{r4, r7, pc}
  40894a:	bf00      	nop
  40894c:	00407f5b 	.word	0x00407f5b
  408950:	0040cdfd 	.word	0x0040cdfd

00408954 <dmp_icm20648_set_bac_rate>:
/**
* BAC only works in 56 Hz. Set divider to make sure accel ODR into BAC is 56Hz.
* @param[in] bac_odr. the values are 56 , 112 , 225 450 or 900 Hz
*/
int dmp_icm20648_set_bac_rate(struct inv_icm20648 * s, short bac_odr)
{
  408954:	b590      	push	{r4, r7, lr}
  408956:	b087      	sub	sp, #28
  408958:	af00      	add	r7, sp, #0
  40895a:	6078      	str	r0, [r7, #4]
  40895c:	460b      	mov	r3, r1
  40895e:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4]={0,0,0,0};
  408960:	2300      	movs	r3, #0
  408962:	60fb      	str	r3, [r7, #12]
	int result;
	short odr;

	switch (bac_odr) {
  408964:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  408968:	2be1      	cmp	r3, #225	; 0xe1
  40896a:	d013      	beq.n	408994 <dmp_icm20648_set_bac_rate+0x40>
  40896c:	2be1      	cmp	r3, #225	; 0xe1
  40896e:	dc04      	bgt.n	40897a <dmp_icm20648_set_bac_rate+0x26>
  408970:	2b38      	cmp	r3, #56	; 0x38
  408972:	d009      	beq.n	408988 <dmp_icm20648_set_bac_rate+0x34>
  408974:	2b70      	cmp	r3, #112	; 0x70
  408976:	d00a      	beq.n	40898e <dmp_icm20648_set_bac_rate+0x3a>
  408978:	e015      	b.n	4089a6 <dmp_icm20648_set_bac_rate+0x52>
  40897a:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
  40897e:	d00c      	beq.n	40899a <dmp_icm20648_set_bac_rate+0x46>
  408980:	f5b3 7f61 	cmp.w	r3, #900	; 0x384
  408984:	d00c      	beq.n	4089a0 <dmp_icm20648_set_bac_rate+0x4c>
  408986:	e00e      	b.n	4089a6 <dmp_icm20648_set_bac_rate+0x52>
	case DMP_ALGO_FREQ_56:
		odr = 0;
  408988:	2300      	movs	r3, #0
  40898a:	82fb      	strh	r3, [r7, #22]
		break;
  40898c:	e00e      	b.n	4089ac <dmp_icm20648_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_112:
		odr = 1;
  40898e:	2301      	movs	r3, #1
  408990:	82fb      	strh	r3, [r7, #22]
		break;
  408992:	e00b      	b.n	4089ac <dmp_icm20648_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_225:
		odr = 3;
  408994:	2303      	movs	r3, #3
  408996:	82fb      	strh	r3, [r7, #22]
		break;
  408998:	e008      	b.n	4089ac <dmp_icm20648_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_450:
		odr = 7;
  40899a:	2307      	movs	r3, #7
  40899c:	82fb      	strh	r3, [r7, #22]
		break;
  40899e:	e005      	b.n	4089ac <dmp_icm20648_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_900:
		odr = 15;
  4089a0:	230f      	movs	r3, #15
  4089a2:	82fb      	strh	r3, [r7, #22]
		break;
  4089a4:	e002      	b.n	4089ac <dmp_icm20648_set_bac_rate+0x58>
	default:
		return -1;
  4089a6:	f04f 33ff 	mov.w	r3, #4294967295
  4089aa:	e015      	b.n	4089d8 <dmp_icm20648_set_bac_rate+0x84>
	}

	result = inv_icm20648_write_mems(s, BAC_RATE, 2, inv_icm20648_convert_int16_to_big8(odr,reg));
  4089ac:	f107 020c 	add.w	r2, r7, #12
  4089b0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  4089b4:	4611      	mov	r1, r2
  4089b6:	4618      	mov	r0, r3
  4089b8:	4b09      	ldr	r3, [pc, #36]	; (4089e0 <dmp_icm20648_set_bac_rate+0x8c>)
  4089ba:	4798      	blx	r3
  4089bc:	4603      	mov	r3, r0
  4089be:	2202      	movs	r2, #2
  4089c0:	f240 310a 	movw	r1, #778	; 0x30a
  4089c4:	6878      	ldr	r0, [r7, #4]
  4089c6:	4c07      	ldr	r4, [pc, #28]	; (4089e4 <dmp_icm20648_set_bac_rate+0x90>)
  4089c8:	47a0      	blx	r4
  4089ca:	6138      	str	r0, [r7, #16]
	if (result) {
  4089cc:	693b      	ldr	r3, [r7, #16]
  4089ce:	2b00      	cmp	r3, #0
  4089d0:	d001      	beq.n	4089d6 <dmp_icm20648_set_bac_rate+0x82>
		return result;
  4089d2:	693b      	ldr	r3, [r7, #16]
  4089d4:	e000      	b.n	4089d8 <dmp_icm20648_set_bac_rate+0x84>
	} else {
		return 0;
  4089d6:	2300      	movs	r3, #0
	}
}
  4089d8:	4618      	mov	r0, r3
  4089da:	371c      	adds	r7, #28
  4089dc:	46bd      	mov	sp, r7
  4089de:	bd90      	pop	{r4, r7, pc}
  4089e0:	00407f29 	.word	0x00407f29
  4089e4:	0040cdfd 	.word	0x0040cdfd

004089e8 <dmp_icm20648_set_b2s_rate>:
/**
* B2S only works in 56 Hz. Set divider to make sure accel ODR into B2S is 56Hz.
* @param[in] bac_odr. the values are 56 , 112 , 225 450 or 900 Hz
*/
int dmp_icm20648_set_b2s_rate(struct inv_icm20648 * s, short accel_odr)
{
  4089e8:	b590      	push	{r4, r7, lr}
  4089ea:	b087      	sub	sp, #28
  4089ec:	af00      	add	r7, sp, #0
  4089ee:	6078      	str	r0, [r7, #4]
  4089f0:	460b      	mov	r3, r1
  4089f2:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4]={0,0,0,0};
  4089f4:	2300      	movs	r3, #0
  4089f6:	60fb      	str	r3, [r7, #12]
	int result;
	short odr;

	switch (accel_odr) {
  4089f8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  4089fc:	2be1      	cmp	r3, #225	; 0xe1
  4089fe:	d013      	beq.n	408a28 <dmp_icm20648_set_b2s_rate+0x40>
  408a00:	2be1      	cmp	r3, #225	; 0xe1
  408a02:	dc04      	bgt.n	408a0e <dmp_icm20648_set_b2s_rate+0x26>
  408a04:	2b38      	cmp	r3, #56	; 0x38
  408a06:	d009      	beq.n	408a1c <dmp_icm20648_set_b2s_rate+0x34>
  408a08:	2b70      	cmp	r3, #112	; 0x70
  408a0a:	d00a      	beq.n	408a22 <dmp_icm20648_set_b2s_rate+0x3a>
  408a0c:	e015      	b.n	408a3a <dmp_icm20648_set_b2s_rate+0x52>
  408a0e:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
  408a12:	d00c      	beq.n	408a2e <dmp_icm20648_set_b2s_rate+0x46>
  408a14:	f5b3 7f61 	cmp.w	r3, #900	; 0x384
  408a18:	d00c      	beq.n	408a34 <dmp_icm20648_set_b2s_rate+0x4c>
  408a1a:	e00e      	b.n	408a3a <dmp_icm20648_set_b2s_rate+0x52>
	case DMP_ALGO_FREQ_56:
		odr = 0;
  408a1c:	2300      	movs	r3, #0
  408a1e:	82fb      	strh	r3, [r7, #22]
		break;
  408a20:	e00e      	b.n	408a40 <dmp_icm20648_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_112:
		odr = 1;
  408a22:	2301      	movs	r3, #1
  408a24:	82fb      	strh	r3, [r7, #22]
		break;
  408a26:	e00b      	b.n	408a40 <dmp_icm20648_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_225:
		odr = 3;
  408a28:	2303      	movs	r3, #3
  408a2a:	82fb      	strh	r3, [r7, #22]
		break;
  408a2c:	e008      	b.n	408a40 <dmp_icm20648_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_450:
		odr = 7;
  408a2e:	2307      	movs	r3, #7
  408a30:	82fb      	strh	r3, [r7, #22]
		break;
  408a32:	e005      	b.n	408a40 <dmp_icm20648_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_900:
		odr = 15;
  408a34:	230f      	movs	r3, #15
  408a36:	82fb      	strh	r3, [r7, #22]
		break;
  408a38:	e002      	b.n	408a40 <dmp_icm20648_set_b2s_rate+0x58>
	default:
		return -1;
  408a3a:	f04f 33ff 	mov.w	r3, #4294967295
  408a3e:	e015      	b.n	408a6c <dmp_icm20648_set_b2s_rate+0x84>
	}

	result = inv_icm20648_write_mems(s, B2S_RATE, 2, inv_icm20648_convert_int16_to_big8(odr,reg));
  408a40:	f107 020c 	add.w	r2, r7, #12
  408a44:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  408a48:	4611      	mov	r1, r2
  408a4a:	4618      	mov	r0, r3
  408a4c:	4b09      	ldr	r3, [pc, #36]	; (408a74 <dmp_icm20648_set_b2s_rate+0x8c>)
  408a4e:	4798      	blx	r3
  408a50:	4603      	mov	r3, r0
  408a52:	2202      	movs	r2, #2
  408a54:	f44f 7142 	mov.w	r1, #776	; 0x308
  408a58:	6878      	ldr	r0, [r7, #4]
  408a5a:	4c07      	ldr	r4, [pc, #28]	; (408a78 <dmp_icm20648_set_b2s_rate+0x90>)
  408a5c:	47a0      	blx	r4
  408a5e:	6138      	str	r0, [r7, #16]
	if (result) {
  408a60:	693b      	ldr	r3, [r7, #16]
  408a62:	2b00      	cmp	r3, #0
  408a64:	d001      	beq.n	408a6a <dmp_icm20648_set_b2s_rate+0x82>
		return result;
  408a66:	693b      	ldr	r3, [r7, #16]
  408a68:	e000      	b.n	408a6c <dmp_icm20648_set_b2s_rate+0x84>
	} else {
		return 0;
  408a6a:	2300      	movs	r3, #0
	}
}
  408a6c:	4618      	mov	r0, r3
  408a6e:	371c      	adds	r7, #28
  408a70:	46bd      	mov	sp, r7
  408a72:	bd90      	pop	{r4, r7, pc}
  408a74:	00407f29 	.word	0x00407f29
  408a78:	0040cdfd 	.word	0x0040cdfd

00408a7c <dmp_icm20648_set_B2S_matrix>:
/**
* Sets B2S accel orientation matrix to DMP.
* @param[in] b2s_mtx. Unit: 1 = 2^30.
*/
int dmp_icm20648_set_B2S_matrix(struct inv_icm20648 * s, int *b2s_mtx)
{
  408a7c:	b590      	push	{r4, r7, lr}
  408a7e:	b085      	sub	sp, #20
  408a80:	af00      	add	r7, sp, #0
  408a82:	6078      	str	r0, [r7, #4]
  408a84:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  408a86:	2300      	movs	r3, #0
  408a88:	60bb      	str	r3, [r7, #8]

	result  = inv_icm20648_write_mems(s, B2S_MTX_00, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[0], big8));
  408a8a:	683b      	ldr	r3, [r7, #0]
  408a8c:	681b      	ldr	r3, [r3, #0]
  408a8e:	f107 0208 	add.w	r2, r7, #8
  408a92:	4611      	mov	r1, r2
  408a94:	4618      	mov	r0, r3
  408a96:	4b5a      	ldr	r3, [pc, #360]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408a98:	4798      	blx	r3
  408a9a:	4603      	mov	r3, r0
  408a9c:	2204      	movs	r2, #4
  408a9e:	f44f 6150 	mov.w	r1, #3328	; 0xd00
  408aa2:	6878      	ldr	r0, [r7, #4]
  408aa4:	4c57      	ldr	r4, [pc, #348]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408aa6:	47a0      	blx	r4
  408aa8:	60f8      	str	r0, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_01, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[1], big8));
  408aaa:	683b      	ldr	r3, [r7, #0]
  408aac:	3304      	adds	r3, #4
  408aae:	681b      	ldr	r3, [r3, #0]
  408ab0:	f107 0208 	add.w	r2, r7, #8
  408ab4:	4611      	mov	r1, r2
  408ab6:	4618      	mov	r0, r3
  408ab8:	4b51      	ldr	r3, [pc, #324]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408aba:	4798      	blx	r3
  408abc:	4603      	mov	r3, r0
  408abe:	2204      	movs	r2, #4
  408ac0:	f640 5104 	movw	r1, #3332	; 0xd04
  408ac4:	6878      	ldr	r0, [r7, #4]
  408ac6:	4c4f      	ldr	r4, [pc, #316]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408ac8:	47a0      	blx	r4
  408aca:	4602      	mov	r2, r0
  408acc:	68fb      	ldr	r3, [r7, #12]
  408ace:	4413      	add	r3, r2
  408ad0:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_02, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[2], big8));
  408ad2:	683b      	ldr	r3, [r7, #0]
  408ad4:	3308      	adds	r3, #8
  408ad6:	681b      	ldr	r3, [r3, #0]
  408ad8:	f107 0208 	add.w	r2, r7, #8
  408adc:	4611      	mov	r1, r2
  408ade:	4618      	mov	r0, r3
  408ae0:	4b47      	ldr	r3, [pc, #284]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408ae2:	4798      	blx	r3
  408ae4:	4603      	mov	r3, r0
  408ae6:	2204      	movs	r2, #4
  408ae8:	f640 5108 	movw	r1, #3336	; 0xd08
  408aec:	6878      	ldr	r0, [r7, #4]
  408aee:	4c45      	ldr	r4, [pc, #276]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408af0:	47a0      	blx	r4
  408af2:	4602      	mov	r2, r0
  408af4:	68fb      	ldr	r3, [r7, #12]
  408af6:	4413      	add	r3, r2
  408af8:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_10, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[3], big8));
  408afa:	683b      	ldr	r3, [r7, #0]
  408afc:	330c      	adds	r3, #12
  408afe:	681b      	ldr	r3, [r3, #0]
  408b00:	f107 0208 	add.w	r2, r7, #8
  408b04:	4611      	mov	r1, r2
  408b06:	4618      	mov	r0, r3
  408b08:	4b3d      	ldr	r3, [pc, #244]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408b0a:	4798      	blx	r3
  408b0c:	4603      	mov	r3, r0
  408b0e:	2204      	movs	r2, #4
  408b10:	f640 510c 	movw	r1, #3340	; 0xd0c
  408b14:	6878      	ldr	r0, [r7, #4]
  408b16:	4c3b      	ldr	r4, [pc, #236]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408b18:	47a0      	blx	r4
  408b1a:	4602      	mov	r2, r0
  408b1c:	68fb      	ldr	r3, [r7, #12]
  408b1e:	4413      	add	r3, r2
  408b20:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_11, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[4], big8));
  408b22:	683b      	ldr	r3, [r7, #0]
  408b24:	3310      	adds	r3, #16
  408b26:	681b      	ldr	r3, [r3, #0]
  408b28:	f107 0208 	add.w	r2, r7, #8
  408b2c:	4611      	mov	r1, r2
  408b2e:	4618      	mov	r0, r3
  408b30:	4b33      	ldr	r3, [pc, #204]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408b32:	4798      	blx	r3
  408b34:	4603      	mov	r3, r0
  408b36:	2204      	movs	r2, #4
  408b38:	f44f 6151 	mov.w	r1, #3344	; 0xd10
  408b3c:	6878      	ldr	r0, [r7, #4]
  408b3e:	4c31      	ldr	r4, [pc, #196]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408b40:	47a0      	blx	r4
  408b42:	4602      	mov	r2, r0
  408b44:	68fb      	ldr	r3, [r7, #12]
  408b46:	4413      	add	r3, r2
  408b48:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_12, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[5], big8));
  408b4a:	683b      	ldr	r3, [r7, #0]
  408b4c:	3314      	adds	r3, #20
  408b4e:	681b      	ldr	r3, [r3, #0]
  408b50:	f107 0208 	add.w	r2, r7, #8
  408b54:	4611      	mov	r1, r2
  408b56:	4618      	mov	r0, r3
  408b58:	4b29      	ldr	r3, [pc, #164]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408b5a:	4798      	blx	r3
  408b5c:	4603      	mov	r3, r0
  408b5e:	2204      	movs	r2, #4
  408b60:	f640 5114 	movw	r1, #3348	; 0xd14
  408b64:	6878      	ldr	r0, [r7, #4]
  408b66:	4c27      	ldr	r4, [pc, #156]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408b68:	47a0      	blx	r4
  408b6a:	4602      	mov	r2, r0
  408b6c:	68fb      	ldr	r3, [r7, #12]
  408b6e:	4413      	add	r3, r2
  408b70:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_20, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[6], big8));
  408b72:	683b      	ldr	r3, [r7, #0]
  408b74:	3318      	adds	r3, #24
  408b76:	681b      	ldr	r3, [r3, #0]
  408b78:	f107 0208 	add.w	r2, r7, #8
  408b7c:	4611      	mov	r1, r2
  408b7e:	4618      	mov	r0, r3
  408b80:	4b1f      	ldr	r3, [pc, #124]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408b82:	4798      	blx	r3
  408b84:	4603      	mov	r3, r0
  408b86:	2204      	movs	r2, #4
  408b88:	f640 5118 	movw	r1, #3352	; 0xd18
  408b8c:	6878      	ldr	r0, [r7, #4]
  408b8e:	4c1d      	ldr	r4, [pc, #116]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408b90:	47a0      	blx	r4
  408b92:	4602      	mov	r2, r0
  408b94:	68fb      	ldr	r3, [r7, #12]
  408b96:	4413      	add	r3, r2
  408b98:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_21, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[7], big8));
  408b9a:	683b      	ldr	r3, [r7, #0]
  408b9c:	331c      	adds	r3, #28
  408b9e:	681b      	ldr	r3, [r3, #0]
  408ba0:	f107 0208 	add.w	r2, r7, #8
  408ba4:	4611      	mov	r1, r2
  408ba6:	4618      	mov	r0, r3
  408ba8:	4b15      	ldr	r3, [pc, #84]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408baa:	4798      	blx	r3
  408bac:	4603      	mov	r3, r0
  408bae:	2204      	movs	r2, #4
  408bb0:	f640 511c 	movw	r1, #3356	; 0xd1c
  408bb4:	6878      	ldr	r0, [r7, #4]
  408bb6:	4c13      	ldr	r4, [pc, #76]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408bb8:	47a0      	blx	r4
  408bba:	4602      	mov	r2, r0
  408bbc:	68fb      	ldr	r3, [r7, #12]
  408bbe:	4413      	add	r3, r2
  408bc0:	60fb      	str	r3, [r7, #12]
	result += inv_icm20648_write_mems(s, B2S_MTX_22, 4, inv_icm20648_convert_int32_to_big8(b2s_mtx[8], big8));
  408bc2:	683b      	ldr	r3, [r7, #0]
  408bc4:	3320      	adds	r3, #32
  408bc6:	681b      	ldr	r3, [r3, #0]
  408bc8:	f107 0208 	add.w	r2, r7, #8
  408bcc:	4611      	mov	r1, r2
  408bce:	4618      	mov	r0, r3
  408bd0:	4b0b      	ldr	r3, [pc, #44]	; (408c00 <dmp_icm20648_set_B2S_matrix+0x184>)
  408bd2:	4798      	blx	r3
  408bd4:	4603      	mov	r3, r0
  408bd6:	2204      	movs	r2, #4
  408bd8:	f44f 6152 	mov.w	r1, #3360	; 0xd20
  408bdc:	6878      	ldr	r0, [r7, #4]
  408bde:	4c09      	ldr	r4, [pc, #36]	; (408c04 <dmp_icm20648_set_B2S_matrix+0x188>)
  408be0:	47a0      	blx	r4
  408be2:	4602      	mov	r2, r0
  408be4:	68fb      	ldr	r3, [r7, #12]
  408be6:	4413      	add	r3, r2
  408be8:	60fb      	str	r3, [r7, #12]

	if (result)
  408bea:	68fb      	ldr	r3, [r7, #12]
  408bec:	2b00      	cmp	r3, #0
  408bee:	d001      	beq.n	408bf4 <dmp_icm20648_set_B2S_matrix+0x178>
		return result;
  408bf0:	68fb      	ldr	r3, [r7, #12]
  408bf2:	e000      	b.n	408bf6 <dmp_icm20648_set_B2S_matrix+0x17a>

	return 0;
  408bf4:	2300      	movs	r3, #0
}
  408bf6:	4618      	mov	r0, r3
  408bf8:	3714      	adds	r7, #20
  408bfa:	46bd      	mov	sp, r7
  408bfc:	bd90      	pop	{r4, r7, pc}
  408bfe:	bf00      	nop
  408c00:	00407f5b 	.word	0x00407f5b
  408c04:	0040cdfd 	.word	0x0040cdfd

00408c08 <dmp_icm20648_set_ped_y_ratio>:
/**
* Set BAC ped y ration
* @param[in] ped_y_ratio: value will influence pedometer result
*/
int dmp_icm20648_set_ped_y_ratio(struct inv_icm20648 * s, long ped_y_ratio)
{
  408c08:	b590      	push	{r4, r7, lr}
  408c0a:	b085      	sub	sp, #20
  408c0c:	af00      	add	r7, sp, #0
  408c0e:	6078      	str	r0, [r7, #4]
  408c10:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0, 0, 0, 0};
  408c12:	2300      	movs	r3, #0
  408c14:	60bb      	str	r3, [r7, #8]

	result = inv_icm20648_write_mems(s, PED_Y_RATIO, 4, inv_icm20648_convert_int32_to_big8(ped_y_ratio, big8));
  408c16:	f107 0308 	add.w	r3, r7, #8
  408c1a:	4619      	mov	r1, r3
  408c1c:	6838      	ldr	r0, [r7, #0]
  408c1e:	4b07      	ldr	r3, [pc, #28]	; (408c3c <dmp_icm20648_set_ped_y_ratio+0x34>)
  408c20:	4798      	blx	r3
  408c22:	4603      	mov	r3, r0
  408c24:	2204      	movs	r2, #4
  408c26:	f44f 7188 	mov.w	r1, #272	; 0x110
  408c2a:	6878      	ldr	r0, [r7, #4]
  408c2c:	4c04      	ldr	r4, [pc, #16]	; (408c40 <dmp_icm20648_set_ped_y_ratio+0x38>)
  408c2e:	47a0      	blx	r4
  408c30:	60f8      	str	r0, [r7, #12]

	return result;
  408c32:	68fb      	ldr	r3, [r7, #12]
}
  408c34:	4618      	mov	r0, r3
  408c36:	3714      	adds	r7, #20
  408c38:	46bd      	mov	sp, r7
  408c3a:	bd90      	pop	{r4, r7, pc}
  408c3c:	00407f5b 	.word	0x00407f5b
  408c40:	0040cdfd 	.word	0x0040cdfd

00408c44 <inv_icm20648_firmware_load>:
#include "Icm20648LoadFirmware.h"
#include "Icm20648Defs.h"
#include "Icm20648DataBaseDriver.h"

int inv_icm20648_firmware_load(struct inv_icm20648 * s, const unsigned char *data_start, unsigned short size_start, unsigned short load_addr)
{ 
  408c44:	b590      	push	{r4, r7, lr}
  408c46:	b08f      	sub	sp, #60	; 0x3c
  408c48:	af00      	add	r7, sp, #0
  408c4a:	60f8      	str	r0, [r7, #12]
  408c4c:	60b9      	str	r1, [r7, #8]
  408c4e:	4611      	mov	r1, r2
  408c50:	461a      	mov	r2, r3
  408c52:	460b      	mov	r3, r1
  408c54:	80fb      	strh	r3, [r7, #6]
  408c56:	4613      	mov	r3, r2
  408c58:	80bb      	strh	r3, [r7, #4]
    int result;
    unsigned short memaddr;
    const unsigned char *data;
    unsigned short size;
    unsigned char data_cmp[INV_MAX_SERIAL_READ];
    int flag = 0;
  408c5a:	2300      	movs	r3, #0
  408c5c:	627b      	str	r3, [r7, #36]	; 0x24

	if(s->base_state.firmware_loaded)
  408c5e:	68fb      	ldr	r3, [r7, #12]
  408c60:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  408c64:	f003 0302 	and.w	r3, r3, #2
  408c68:	b2db      	uxtb	r3, r3
  408c6a:	2b00      	cmp	r3, #0
  408c6c:	d001      	beq.n	408c72 <inv_icm20648_firmware_load+0x2e>
		return 0;
  408c6e:	2300      	movs	r3, #0
  408c70:	e081      	b.n	408d76 <inv_icm20648_firmware_load+0x132>
		
    // Write DMP memory
    data = data_start;
  408c72:	68bb      	ldr	r3, [r7, #8]
  408c74:	62fb      	str	r3, [r7, #44]	; 0x2c
    size = size_start;
  408c76:	88fb      	ldrh	r3, [r7, #6]
  408c78:	857b      	strh	r3, [r7, #42]	; 0x2a
    memaddr = load_addr;
  408c7a:	88bb      	ldrh	r3, [r7, #4]
  408c7c:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  408c7e:	e02e      	b.n	408cde <inv_icm20648_firmware_load+0x9a>
        write_size = min(size, INV_MAX_SERIAL_WRITE);
  408c80:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408c82:	2b0f      	cmp	r3, #15
  408c84:	d801      	bhi.n	408c8a <inv_icm20648_firmware_load+0x46>
  408c86:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408c88:	e000      	b.n	408c8c <inv_icm20648_firmware_load+0x48>
  408c8a:	2310      	movs	r3, #16
  408c8c:	637b      	str	r3, [r7, #52]	; 0x34
        if ((memaddr & 0xff) + write_size > 0x100) {
  408c8e:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408c90:	b2da      	uxtb	r2, r3
  408c92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408c94:	4413      	add	r3, r2
  408c96:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  408c9a:	dd06      	ble.n	408caa <inv_icm20648_firmware_load+0x66>
            // Moved across a bank
            write_size = (memaddr & 0xff) + write_size - 0x100;
  408c9c:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408c9e:	b2da      	uxtb	r2, r3
  408ca0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408ca2:	4413      	add	r3, r2
  408ca4:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
  408ca8:	637b      	str	r3, [r7, #52]	; 0x34
        }
        result = inv_icm20648_write_mems(s, memaddr, write_size, (unsigned char *)data);
  408caa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  408cac:	8e79      	ldrh	r1, [r7, #50]	; 0x32
  408cae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408cb0:	68f8      	ldr	r0, [r7, #12]
  408cb2:	4c33      	ldr	r4, [pc, #204]	; (408d80 <inv_icm20648_firmware_load+0x13c>)
  408cb4:	47a0      	blx	r4
  408cb6:	6238      	str	r0, [r7, #32]
        if (result)  
  408cb8:	6a3b      	ldr	r3, [r7, #32]
  408cba:	2b00      	cmp	r3, #0
  408cbc:	d001      	beq.n	408cc2 <inv_icm20648_firmware_load+0x7e>
            return result;
  408cbe:	6a3b      	ldr	r3, [r7, #32]
  408cc0:	e059      	b.n	408d76 <inv_icm20648_firmware_load+0x132>
        data += write_size;
  408cc2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408cc4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  408cc6:	4413      	add	r3, r2
  408cc8:	62fb      	str	r3, [r7, #44]	; 0x2c
        size -= write_size;
  408cca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408ccc:	b29b      	uxth	r3, r3
  408cce:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  408cd0:	1ad3      	subs	r3, r2, r3
  408cd2:	857b      	strh	r3, [r7, #42]	; 0x2a
        memaddr += write_size;
  408cd4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408cd6:	b29a      	uxth	r2, r3
  408cd8:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408cda:	4413      	add	r3, r2
  408cdc:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  408cde:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408ce0:	2b00      	cmp	r3, #0
  408ce2:	d1cd      	bne.n	408c80 <inv_icm20648_firmware_load+0x3c>
    }

    // Verify DMP memory

    data = data_start;
  408ce4:	68bb      	ldr	r3, [r7, #8]
  408ce6:	62fb      	str	r3, [r7, #44]	; 0x2c
    size = size_start;
  408ce8:	88fb      	ldrh	r3, [r7, #6]
  408cea:	857b      	strh	r3, [r7, #42]	; 0x2a
    memaddr = load_addr;
  408cec:	88bb      	ldrh	r3, [r7, #4]
  408cee:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  408cf0:	e03d      	b.n	408d6e <inv_icm20648_firmware_load+0x12a>
        write_size = min(size, INV_MAX_SERIAL_READ);
  408cf2:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408cf4:	2b0f      	cmp	r3, #15
  408cf6:	d801      	bhi.n	408cfc <inv_icm20648_firmware_load+0xb8>
  408cf8:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408cfa:	e000      	b.n	408cfe <inv_icm20648_firmware_load+0xba>
  408cfc:	2310      	movs	r3, #16
  408cfe:	637b      	str	r3, [r7, #52]	; 0x34
        if ((memaddr & 0xff) + write_size > 0x100) {
  408d00:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408d02:	b2da      	uxtb	r2, r3
  408d04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408d06:	4413      	add	r3, r2
  408d08:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  408d0c:	dd06      	ble.n	408d1c <inv_icm20648_firmware_load+0xd8>
            // Moved across a bank
            write_size = (memaddr & 0xff) + write_size - 0x100;
  408d0e:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408d10:	b2da      	uxtb	r2, r3
  408d12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408d14:	4413      	add	r3, r2
  408d16:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
  408d1a:	637b      	str	r3, [r7, #52]	; 0x34
        }
        result = inv_icm20648_read_mems(s, memaddr, write_size, data_cmp);
  408d1c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  408d1e:	f107 0310 	add.w	r3, r7, #16
  408d22:	8e79      	ldrh	r1, [r7, #50]	; 0x32
  408d24:	68f8      	ldr	r0, [r7, #12]
  408d26:	4c17      	ldr	r4, [pc, #92]	; (408d84 <inv_icm20648_firmware_load+0x140>)
  408d28:	47a0      	blx	r4
  408d2a:	6238      	str	r0, [r7, #32]
        if (result)
  408d2c:	6a3b      	ldr	r3, [r7, #32]
  408d2e:	2b00      	cmp	r3, #0
  408d30:	d002      	beq.n	408d38 <inv_icm20648_firmware_load+0xf4>
            flag++; // Error, DMP not written correctly
  408d32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  408d34:	3301      	adds	r3, #1
  408d36:	627b      	str	r3, [r7, #36]	; 0x24
        if (memcmp(data_cmp, data, write_size))
  408d38:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  408d3a:	f107 0310 	add.w	r3, r7, #16
  408d3e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  408d40:	4618      	mov	r0, r3
  408d42:	4b11      	ldr	r3, [pc, #68]	; (408d88 <inv_icm20648_firmware_load+0x144>)
  408d44:	4798      	blx	r3
  408d46:	4603      	mov	r3, r0
  408d48:	2b00      	cmp	r3, #0
  408d4a:	d002      	beq.n	408d52 <inv_icm20648_firmware_load+0x10e>
            return -1;
  408d4c:	f04f 33ff 	mov.w	r3, #4294967295
  408d50:	e011      	b.n	408d76 <inv_icm20648_firmware_load+0x132>
        data += write_size;
  408d52:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408d54:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  408d56:	4413      	add	r3, r2
  408d58:	62fb      	str	r3, [r7, #44]	; 0x2c
        size -= write_size;
  408d5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408d5c:	b29b      	uxth	r3, r3
  408d5e:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  408d60:	1ad3      	subs	r3, r2, r3
  408d62:	857b      	strh	r3, [r7, #42]	; 0x2a
        memaddr += write_size;
  408d64:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408d66:	b29a      	uxth	r2, r3
  408d68:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408d6a:	4413      	add	r3, r2
  408d6c:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  408d6e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408d70:	2b00      	cmp	r3, #0
  408d72:	d1be      	bne.n	408cf2 <inv_icm20648_firmware_load+0xae>
#if defined(WIN32)   
    //if(!flag)
      // inv_log("DMP Firmware was updated successfully..\r\n");
#endif

    return 0;
  408d74:	2300      	movs	r3, #0
}
  408d76:	4618      	mov	r0, r3
  408d78:	373c      	adds	r7, #60	; 0x3c
  408d7a:	46bd      	mov	sp, r7
  408d7c:	bd90      	pop	{r4, r7, pc}
  408d7e:	bf00      	nop
  408d80:	0040cdfd 	.word	0x0040cdfd
  408d84:	0040cc1d 	.word	0x0040cc1d
  408d88:	004141d5 	.word	0x004141d5

00408d8c <inv_icm20648_mpu_set_FIFO_RST_Diamond>:

static void inv_decode_3_16bit_elements(short *out_data, const unsigned char *in_data);
static void inv_decode_3_32bit_elements(long *out_data, const unsigned char *in_data);

int inv_icm20648_mpu_set_FIFO_RST_Diamond(struct inv_icm20648 * s, unsigned char value)
{
  408d8c:	b590      	push	{r4, r7, lr}
  408d8e:	b085      	sub	sp, #20
  408d90:	af00      	add	r7, sp, #0
  408d92:	6078      	str	r0, [r7, #4]
  408d94:	460b      	mov	r3, r1
  408d96:	70fb      	strb	r3, [r7, #3]
	int result = 0;
  408d98:	2300      	movs	r3, #0
  408d9a:	60fb      	str	r3, [r7, #12]
	unsigned char reg;

	result |= inv_icm20648_read_mems_reg(s, REG_FIFO_RST, 1, &reg);
  408d9c:	f107 030b 	add.w	r3, r7, #11
  408da0:	2201      	movs	r2, #1
  408da2:	2168      	movs	r1, #104	; 0x68
  408da4:	6878      	ldr	r0, [r7, #4]
  408da6:	4c10      	ldr	r4, [pc, #64]	; (408de8 <inv_icm20648_mpu_set_FIFO_RST_Diamond+0x5c>)
  408da8:	47a0      	blx	r4
  408daa:	4602      	mov	r2, r0
  408dac:	68fb      	ldr	r3, [r7, #12]
  408dae:	4313      	orrs	r3, r2
  408db0:	60fb      	str	r3, [r7, #12]

	reg &= 0xe0;
  408db2:	7afb      	ldrb	r3, [r7, #11]
  408db4:	f023 031f 	bic.w	r3, r3, #31
  408db8:	b2db      	uxtb	r3, r3
  408dba:	72fb      	strb	r3, [r7, #11]
	reg |= value;
  408dbc:	7afa      	ldrb	r2, [r7, #11]
  408dbe:	78fb      	ldrb	r3, [r7, #3]
  408dc0:	4313      	orrs	r3, r2
  408dc2:	b2db      	uxtb	r3, r3
  408dc4:	72fb      	strb	r3, [r7, #11]
	result |= inv_icm20648_write_mems_reg(s, REG_FIFO_RST, 1, &reg);
  408dc6:	f107 030b 	add.w	r3, r7, #11
  408dca:	2201      	movs	r2, #1
  408dcc:	2168      	movs	r1, #104	; 0x68
  408dce:	6878      	ldr	r0, [r7, #4]
  408dd0:	4c06      	ldr	r4, [pc, #24]	; (408dec <inv_icm20648_mpu_set_FIFO_RST_Diamond+0x60>)
  408dd2:	47a0      	blx	r4
  408dd4:	4602      	mov	r2, r0
  408dd6:	68fb      	ldr	r3, [r7, #12]
  408dd8:	4313      	orrs	r3, r2
  408dda:	60fb      	str	r3, [r7, #12]

	return result;
  408ddc:	68fb      	ldr	r3, [r7, #12]
}
  408dde:	4618      	mov	r0, r3
  408de0:	3714      	adds	r7, #20
  408de2:	46bd      	mov	sp, r7
  408de4:	bd90      	pop	{r4, r7, pc}
  408de6:	bf00      	nop
  408de8:	0040caa1 	.word	0x0040caa1
  408dec:	0040c8cd 	.word	0x0040c8cd

00408df0 <inv_icm20648_identify_interrupt>:

int inv_icm20648_identify_interrupt(struct inv_icm20648 * s, short *int_read)
{
  408df0:	b590      	push	{r4, r7, lr}
  408df2:	b085      	sub	sp, #20
  408df4:	af00      	add	r7, sp, #0
  408df6:	6078      	str	r0, [r7, #4]
  408df8:	6039      	str	r1, [r7, #0]
	unsigned char int_status;
    int result=0 ;
  408dfa:	2300      	movs	r3, #0
  408dfc:	60fb      	str	r3, [r7, #12]

    if(int_read)
  408dfe:	683b      	ldr	r3, [r7, #0]
  408e00:	2b00      	cmp	r3, #0
  408e02:	d002      	beq.n	408e0a <inv_icm20648_identify_interrupt+0x1a>
        *int_read = 0;
  408e04:	683b      	ldr	r3, [r7, #0]
  408e06:	2200      	movs	r2, #0
  408e08:	801a      	strh	r2, [r3, #0]

    result = inv_icm20648_read_mems_reg(s, REG_INT_STATUS, 1, &int_status);
  408e0a:	f107 030b 	add.w	r3, r7, #11
  408e0e:	2201      	movs	r2, #1
  408e10:	2119      	movs	r1, #25
  408e12:	6878      	ldr	r0, [r7, #4]
  408e14:	4c11      	ldr	r4, [pc, #68]	; (408e5c <inv_icm20648_identify_interrupt+0x6c>)
  408e16:	47a0      	blx	r4
  408e18:	60f8      	str	r0, [r7, #12]
    if(int_read)
  408e1a:	683b      	ldr	r3, [r7, #0]
  408e1c:	2b00      	cmp	r3, #0
  408e1e:	d003      	beq.n	408e28 <inv_icm20648_identify_interrupt+0x38>
        *int_read = int_status;
  408e20:	7afb      	ldrb	r3, [r7, #11]
  408e22:	b21a      	sxth	r2, r3
  408e24:	683b      	ldr	r3, [r7, #0]
  408e26:	801a      	strh	r2, [r3, #0]

    result = inv_icm20648_read_mems_reg(s, REG_DMP_INT_STATUS, 1, &int_status); // DMP_INT_STATUS
  408e28:	f107 030b 	add.w	r3, r7, #11
  408e2c:	2201      	movs	r2, #1
  408e2e:	2118      	movs	r1, #24
  408e30:	6878      	ldr	r0, [r7, #4]
  408e32:	4c0a      	ldr	r4, [pc, #40]	; (408e5c <inv_icm20648_identify_interrupt+0x6c>)
  408e34:	47a0      	blx	r4
  408e36:	60f8      	str	r0, [r7, #12]
	if(int_read)
  408e38:	683b      	ldr	r3, [r7, #0]
  408e3a:	2b00      	cmp	r3, #0
  408e3c:	d009      	beq.n	408e52 <inv_icm20648_identify_interrupt+0x62>
		*int_read |= (int_status << 8);
  408e3e:	683b      	ldr	r3, [r7, #0]
  408e40:	f9b3 2000 	ldrsh.w	r2, [r3]
  408e44:	7afb      	ldrb	r3, [r7, #11]
  408e46:	021b      	lsls	r3, r3, #8
  408e48:	b21b      	sxth	r3, r3
  408e4a:	4313      	orrs	r3, r2
  408e4c:	b21a      	sxth	r2, r3
  408e4e:	683b      	ldr	r3, [r7, #0]
  408e50:	801a      	strh	r2, [r3, #0]
     * We do not need to handle FIFO overflow here.
     * When we read FIFO_SIZE we can determine if FIFO overflow has occured.
     */
    //result = inv_icm20648_read_mems_reg(s, 0x1B, 1, &int_status);

	return result;
  408e52:	68fb      	ldr	r3, [r7, #12]
}
  408e54:	4618      	mov	r0, r3
  408e56:	3714      	adds	r7, #20
  408e58:	46bd      	mov	sp, r7
  408e5a:	bd90      	pop	{r4, r7, pc}
  408e5c:	0040caa1 	.word	0x0040caa1

00408e60 <dmp_get_fifo_length>:
* @param[out] len amount of data currently stored in the fifo.
*
* @return MPU_SUCCESS or non-zero error code.
**/
static int dmp_get_fifo_length(struct inv_icm20648 * s, uint_fast16_t * len )
{
  408e60:	b590      	push	{r4, r7, lr}
  408e62:	b085      	sub	sp, #20
  408e64:	af00      	add	r7, sp, #0
  408e66:	6078      	str	r0, [r7, #4]
  408e68:	6039      	str	r1, [r7, #0]
	unsigned char fifoBuf[2];
	int result = 0;
  408e6a:	2300      	movs	r3, #0
  408e6c:	60fb      	str	r3, [r7, #12]

	if (NULL == len)
  408e6e:	683b      	ldr	r3, [r7, #0]
  408e70:	2b00      	cmp	r3, #0
  408e72:	d102      	bne.n	408e7a <dmp_get_fifo_length+0x1a>
		return -1;
  408e74:	f04f 33ff 	mov.w	r3, #4294967295
  408e78:	e020      	b.n	408ebc <dmp_get_fifo_length+0x5c>

	/*---- read the 2 'count' registers and
	burst read the data from the FIFO ----*/
	result = inv_icm20648_read_mems_reg(s, REG_FIFO_COUNT_H, 2, fifoBuf);
  408e7a:	f107 0308 	add.w	r3, r7, #8
  408e7e:	2202      	movs	r2, #2
  408e80:	2170      	movs	r1, #112	; 0x70
  408e82:	6878      	ldr	r0, [r7, #4]
  408e84:	4c0f      	ldr	r4, [pc, #60]	; (408ec4 <dmp_get_fifo_length+0x64>)
  408e86:	47a0      	blx	r4
  408e88:	60f8      	str	r0, [r7, #12]
	if (result)
  408e8a:	68fb      	ldr	r3, [r7, #12]
  408e8c:	2b00      	cmp	r3, #0
  408e8e:	d009      	beq.n	408ea4 <dmp_get_fifo_length+0x44>
	{
		s->fifo_info.fifoError = -1;
  408e90:	687b      	ldr	r3, [r7, #4]
  408e92:	f04f 32ff 	mov.w	r2, #4294967295
  408e96:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		*len = 0;
  408e9a:	683b      	ldr	r3, [r7, #0]
  408e9c:	2200      	movs	r2, #0
  408e9e:	601a      	str	r2, [r3, #0]
		return result;
  408ea0:	68fb      	ldr	r3, [r7, #12]
  408ea2:	e00b      	b.n	408ebc <dmp_get_fifo_length+0x5c>
	}

	*len = (uint_fast16_t) (fifoBuf[0] << 8);
  408ea4:	7a3b      	ldrb	r3, [r7, #8]
  408ea6:	021b      	lsls	r3, r3, #8
  408ea8:	461a      	mov	r2, r3
  408eaa:	683b      	ldr	r3, [r7, #0]
  408eac:	601a      	str	r2, [r3, #0]
	*len += (uint_fast16_t) (fifoBuf[1]);
  408eae:	683b      	ldr	r3, [r7, #0]
  408eb0:	681b      	ldr	r3, [r3, #0]
  408eb2:	7a7a      	ldrb	r2, [r7, #9]
  408eb4:	441a      	add	r2, r3
  408eb6:	683b      	ldr	r3, [r7, #0]
  408eb8:	601a      	str	r2, [r3, #0]

	return result;
  408eba:	68fb      	ldr	r3, [r7, #12]
}
  408ebc:	4618      	mov	r0, r3
  408ebe:	3714      	adds	r7, #20
  408ec0:	46bd      	mov	sp, r7
  408ec2:	bd90      	pop	{r4, r7, pc}
  408ec4:	0040caa1 	.word	0x0040caa1

00408ec8 <dmp_reset_fifo>:
*  @note   Halt the DMP writing into the FIFO for the time
*          needed to reset the FIFO.
*  @return MPU_SUCCESS if successful, a non-zero error code otherwise.
*/
static int dmp_reset_fifo(struct inv_icm20648 * s)
{
  408ec8:	b580      	push	{r7, lr}
  408eca:	b086      	sub	sp, #24
  408ecc:	af00      	add	r7, sp, #0
  408ece:	6078      	str	r0, [r7, #4]
    uint_fast16_t len = HARDWARE_FIFO_SIZE;
  408ed0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  408ed4:	60fb      	str	r3, [r7, #12]
	unsigned char tries = 0;
  408ed6:	2300      	movs	r3, #0
  408ed8:	75fb      	strb	r3, [r7, #23]
	int result = 0;
  408eda:	2300      	movs	r3, #0
  408edc:	613b      	str	r3, [r7, #16]

	while (len != 0 && tries < 6)
  408ede:	e03e      	b.n	408f5e <dmp_reset_fifo+0x96>
	{
		s->base_state.user_ctrl &= (~BIT_FIFO_EN);
  408ee0:	687b      	ldr	r3, [r7, #4]
  408ee2:	7f1b      	ldrb	r3, [r3, #28]
  408ee4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  408ee8:	b2da      	uxtb	r2, r3
  408eea:	687b      	ldr	r3, [r7, #4]
  408eec:	771a      	strb	r2, [r3, #28]
		s->base_state.user_ctrl &= (~BIT_DMP_EN);
  408eee:	687b      	ldr	r3, [r7, #4]
  408ef0:	7f1b      	ldrb	r3, [r3, #28]
  408ef2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  408ef6:	b2da      	uxtb	r2, r3
  408ef8:	687b      	ldr	r3, [r7, #4]
  408efa:	771a      	strb	r2, [r3, #28]
		result |= inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  408efc:	687b      	ldr	r3, [r7, #4]
  408efe:	7f1b      	ldrb	r3, [r3, #28]
  408f00:	461a      	mov	r2, r3
  408f02:	2103      	movs	r1, #3
  408f04:	6878      	ldr	r0, [r7, #4]
  408f06:	4b28      	ldr	r3, [pc, #160]	; (408fa8 <dmp_reset_fifo+0xe0>)
  408f08:	4798      	blx	r3
  408f0a:	4602      	mov	r2, r0
  408f0c:	693b      	ldr	r3, [r7, #16]
  408f0e:	4313      	orrs	r3, r2
  408f10:	613b      	str	r3, [r7, #16]
		result |= inv_icm20648_mpu_set_FIFO_RST_Diamond(s, 0x1f);
  408f12:	211f      	movs	r1, #31
  408f14:	6878      	ldr	r0, [r7, #4]
  408f16:	4b25      	ldr	r3, [pc, #148]	; (408fac <dmp_reset_fifo+0xe4>)
  408f18:	4798      	blx	r3
  408f1a:	4602      	mov	r2, r0
  408f1c:	693b      	ldr	r3, [r7, #16]
  408f1e:	4313      	orrs	r3, r2
  408f20:	613b      	str	r3, [r7, #16]
		result |= inv_icm20648_mpu_set_FIFO_RST_Diamond(s, 0x1e);
  408f22:	211e      	movs	r1, #30
  408f24:	6878      	ldr	r0, [r7, #4]
  408f26:	4b21      	ldr	r3, [pc, #132]	; (408fac <dmp_reset_fifo+0xe4>)
  408f28:	4798      	blx	r3
  408f2a:	4602      	mov	r2, r0
  408f2c:	693b      	ldr	r3, [r7, #16]
  408f2e:	4313      	orrs	r3, r2
  408f30:	613b      	str	r3, [r7, #16]

		// Reset overflow flag
		s->fifo_info.fifo_overflow = 0;
  408f32:	687b      	ldr	r3, [r7, #4]
  408f34:	2200      	movs	r2, #0
  408f36:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c

		result |= dmp_get_fifo_length(s, &len);
  408f3a:	f107 030c 	add.w	r3, r7, #12
  408f3e:	4619      	mov	r1, r3
  408f40:	6878      	ldr	r0, [r7, #4]
  408f42:	4b1b      	ldr	r3, [pc, #108]	; (408fb0 <dmp_reset_fifo+0xe8>)
  408f44:	4798      	blx	r3
  408f46:	4602      	mov	r2, r0
  408f48:	693b      	ldr	r3, [r7, #16]
  408f4a:	4313      	orrs	r3, r2
  408f4c:	613b      	str	r3, [r7, #16]
		if (result)
  408f4e:	693b      	ldr	r3, [r7, #16]
  408f50:	2b00      	cmp	r3, #0
  408f52:	d001      	beq.n	408f58 <dmp_reset_fifo+0x90>
			return result;
  408f54:	693b      	ldr	r3, [r7, #16]
  408f56:	e022      	b.n	408f9e <dmp_reset_fifo+0xd6>

		tries++;
  408f58:	7dfb      	ldrb	r3, [r7, #23]
  408f5a:	3301      	adds	r3, #1
  408f5c:	75fb      	strb	r3, [r7, #23]
	while (len != 0 && tries < 6)
  408f5e:	68fb      	ldr	r3, [r7, #12]
  408f60:	2b00      	cmp	r3, #0
  408f62:	d002      	beq.n	408f6a <dmp_reset_fifo+0xa2>
  408f64:	7dfb      	ldrb	r3, [r7, #23]
  408f66:	2b05      	cmp	r3, #5
  408f68:	d9ba      	bls.n	408ee0 <dmp_reset_fifo+0x18>
	}

	s->base_state.user_ctrl |= BIT_FIFO_EN;
  408f6a:	687b      	ldr	r3, [r7, #4]
  408f6c:	7f1b      	ldrb	r3, [r3, #28]
  408f6e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  408f72:	b2da      	uxtb	r2, r3
  408f74:	687b      	ldr	r3, [r7, #4]
  408f76:	771a      	strb	r2, [r3, #28]
	s->base_state.user_ctrl |= BIT_DMP_EN;
  408f78:	687b      	ldr	r3, [r7, #4]
  408f7a:	7f1b      	ldrb	r3, [r3, #28]
  408f7c:	f063 037f 	orn	r3, r3, #127	; 0x7f
  408f80:	b2da      	uxtb	r2, r3
  408f82:	687b      	ldr	r3, [r7, #4]
  408f84:	771a      	strb	r2, [r3, #28]
	result |= inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  408f86:	687b      	ldr	r3, [r7, #4]
  408f88:	7f1b      	ldrb	r3, [r3, #28]
  408f8a:	461a      	mov	r2, r3
  408f8c:	2103      	movs	r1, #3
  408f8e:	6878      	ldr	r0, [r7, #4]
  408f90:	4b05      	ldr	r3, [pc, #20]	; (408fa8 <dmp_reset_fifo+0xe0>)
  408f92:	4798      	blx	r3
  408f94:	4602      	mov	r2, r0
  408f96:	693b      	ldr	r3, [r7, #16]
  408f98:	4313      	orrs	r3, r2
  408f9a:	613b      	str	r3, [r7, #16]

	return result;
  408f9c:	693b      	ldr	r3, [r7, #16]
}
  408f9e:	4618      	mov	r0, r3
  408fa0:	3718      	adds	r7, #24
  408fa2:	46bd      	mov	sp, r7
  408fa4:	bd80      	pop	{r7, pc}
  408fa6:	bf00      	nop
  408fa8:	0040c9d5 	.word	0x0040c9d5
  408fac:	00408d8d 	.word	0x00408d8d
  408fb0:	00408e61 	.word	0x00408e61

00408fb4 <dmp_read_fifo>:
*  @param[in] len   Amount of data to read out of the fifo
*
*  @return MPU_SUCCESS or non-zero error code
**/
static int dmp_read_fifo(struct inv_icm20648 * s, unsigned char *data, uint_fast16_t len)
{
  408fb4:	b590      	push	{r4, r7, lr}
  408fb6:	b089      	sub	sp, #36	; 0x24
  408fb8:	af00      	add	r7, sp, #0
  408fba:	60f8      	str	r0, [r7, #12]
  408fbc:	60b9      	str	r1, [r7, #8]
  408fbe:	607a      	str	r2, [r7, #4]
	int result;
    uint_fast16_t bytesRead = 0;
  408fc0:	2300      	movs	r3, #0
  408fc2:	61bb      	str	r3, [r7, #24]

    while (bytesRead<len)
  408fc4:	e021      	b.n	40900a <dmp_read_fifo+0x56>
    {
        unsigned short thisLen = min(INV_MAX_SERIAL_READ, len-bytesRead);
  408fc6:	687a      	ldr	r2, [r7, #4]
  408fc8:	69bb      	ldr	r3, [r7, #24]
  408fca:	1ad3      	subs	r3, r2, r3
  408fcc:	2b10      	cmp	r3, #16
  408fce:	bf28      	it	cs
  408fd0:	2310      	movcs	r3, #16
  408fd2:	82fb      	strh	r3, [r7, #22]

        result = inv_icm20648_read_mems_reg(s, REG_FIFO_R_W, thisLen, &data[bytesRead]);
  408fd4:	8af9      	ldrh	r1, [r7, #22]
  408fd6:	68ba      	ldr	r2, [r7, #8]
  408fd8:	69bb      	ldr	r3, [r7, #24]
  408fda:	4413      	add	r3, r2
  408fdc:	460a      	mov	r2, r1
  408fde:	2172      	movs	r1, #114	; 0x72
  408fe0:	68f8      	ldr	r0, [r7, #12]
  408fe2:	4c0e      	ldr	r4, [pc, #56]	; (40901c <dmp_read_fifo+0x68>)
  408fe4:	47a0      	blx	r4
  408fe6:	61f8      	str	r0, [r7, #28]
        if (result)
  408fe8:	69fb      	ldr	r3, [r7, #28]
  408fea:	2b00      	cmp	r3, #0
  408fec:	d009      	beq.n	409002 <dmp_read_fifo+0x4e>
		{
			dmp_reset_fifo(s);
  408fee:	68f8      	ldr	r0, [r7, #12]
  408ff0:	4b0b      	ldr	r3, [pc, #44]	; (409020 <dmp_read_fifo+0x6c>)
  408ff2:	4798      	blx	r3
			s->fifo_info.fifoError = -1;
  408ff4:	68fb      	ldr	r3, [r7, #12]
  408ff6:	f04f 32ff 	mov.w	r2, #4294967295
  408ffa:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			return result;
  408ffe:	69fb      	ldr	r3, [r7, #28]
  409000:	e008      	b.n	409014 <dmp_read_fifo+0x60>
		}

        bytesRead += thisLen;
  409002:	8afb      	ldrh	r3, [r7, #22]
  409004:	69ba      	ldr	r2, [r7, #24]
  409006:	4413      	add	r3, r2
  409008:	61bb      	str	r3, [r7, #24]
    while (bytesRead<len)
  40900a:	69ba      	ldr	r2, [r7, #24]
  40900c:	687b      	ldr	r3, [r7, #4]
  40900e:	429a      	cmp	r2, r3
  409010:	d3d9      	bcc.n	408fc6 <dmp_read_fifo+0x12>
    }

	return result;
  409012:	69fb      	ldr	r3, [r7, #28]
}
  409014:	4618      	mov	r0, r3
  409016:	3724      	adds	r7, #36	; 0x24
  409018:	46bd      	mov	sp, r7
  40901a:	bd90      	pop	{r4, r7, pc}
  40901c:	0040caa1 	.word	0x0040caa1
  409020:	00408ec9 	.word	0x00408ec9

00409024 <dmp_get_fifo_all>:
*  @param  buffer Reads up to length into the buffer.
*
*  @return number of bytes of read.
**/
static uint_fast16_t dmp_get_fifo_all(struct inv_icm20648 * s, uint_fast16_t length, unsigned char *buffer, int *reset)
{
  409024:	b580      	push	{r7, lr}
  409026:	b086      	sub	sp, #24
  409028:	af00      	add	r7, sp, #0
  40902a:	60f8      	str	r0, [r7, #12]
  40902c:	60b9      	str	r1, [r7, #8]
  40902e:	607a      	str	r2, [r7, #4]
  409030:	603b      	str	r3, [r7, #0]
	int result;
	uint_fast16_t in_fifo;

	if(reset)
  409032:	683b      	ldr	r3, [r7, #0]
  409034:	2b00      	cmp	r3, #0
  409036:	d002      	beq.n	40903e <dmp_get_fifo_all+0x1a>
		*reset = 0;
  409038:	683b      	ldr	r3, [r7, #0]
  40903a:	2200      	movs	r2, #0
  40903c:	601a      	str	r2, [r3, #0]

	result = dmp_get_fifo_length(s, &in_fifo);
  40903e:	f107 0310 	add.w	r3, r7, #16
  409042:	4619      	mov	r1, r3
  409044:	68f8      	ldr	r0, [r7, #12]
  409046:	4b20      	ldr	r3, [pc, #128]	; (4090c8 <dmp_get_fifo_all+0xa4>)
  409048:	4798      	blx	r3
  40904a:	6178      	str	r0, [r7, #20]
	if (result) {
  40904c:	697b      	ldr	r3, [r7, #20]
  40904e:	2b00      	cmp	r3, #0
  409050:	d005      	beq.n	40905e <dmp_get_fifo_all+0x3a>
		s->fifo_info.fifoError = result;
  409052:	68fb      	ldr	r3, [r7, #12]
  409054:	697a      	ldr	r2, [r7, #20]
  409056:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		return 0;
  40905a:	2300      	movs	r3, #0
  40905c:	e02f      	b.n	4090be <dmp_get_fifo_all+0x9a>
	}

	// Nothing to read
	if (in_fifo == 0){
  40905e:	693b      	ldr	r3, [r7, #16]
  409060:	2b00      	cmp	r3, #0
  409062:	d107      	bne.n	409074 <dmp_get_fifo_all+0x50>
		if(reset)
  409064:	683b      	ldr	r3, [r7, #0]
  409066:	2b00      	cmp	r3, #0
  409068:	d002      	beq.n	409070 <dmp_get_fifo_all+0x4c>
			*reset = 1;
  40906a:	683b      	ldr	r3, [r7, #0]
  40906c:	2201      	movs	r2, #1
  40906e:	601a      	str	r2, [r3, #0]
		return 0;
  409070:	2300      	movs	r3, #0
  409072:	e024      	b.n	4090be <dmp_get_fifo_all+0x9a>
	}

	/* Check if buffer is able to be filled in with in_fifo bytes */
	if (in_fifo > length) {
  409074:	693a      	ldr	r2, [r7, #16]
  409076:	68bb      	ldr	r3, [r7, #8]
  409078:	429a      	cmp	r2, r3
  40907a:	d90f      	bls.n	40909c <dmp_get_fifo_all+0x78>
		dmp_reset_fifo(s);
  40907c:	68f8      	ldr	r0, [r7, #12]
  40907e:	4b13      	ldr	r3, [pc, #76]	; (4090cc <dmp_get_fifo_all+0xa8>)
  409080:	4798      	blx	r3
		s->fifo_info.fifoError = -1;
  409082:	68fb      	ldr	r3, [r7, #12]
  409084:	f04f 32ff 	mov.w	r2, #4294967295
  409088:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		if(reset)
  40908c:	683b      	ldr	r3, [r7, #0]
  40908e:	2b00      	cmp	r3, #0
  409090:	d002      	beq.n	409098 <dmp_get_fifo_all+0x74>
			*reset = 1;
  409092:	683b      	ldr	r3, [r7, #0]
  409094:	2201      	movs	r2, #1
  409096:	601a      	str	r2, [r3, #0]
		return 0;
  409098:	2300      	movs	r3, #0
  40909a:	e010      	b.n	4090be <dmp_get_fifo_all+0x9a>
	}

	result = dmp_read_fifo(s, buffer, in_fifo);
  40909c:	693b      	ldr	r3, [r7, #16]
  40909e:	461a      	mov	r2, r3
  4090a0:	6879      	ldr	r1, [r7, #4]
  4090a2:	68f8      	ldr	r0, [r7, #12]
  4090a4:	4b0a      	ldr	r3, [pc, #40]	; (4090d0 <dmp_get_fifo_all+0xac>)
  4090a6:	4798      	blx	r3
  4090a8:	6178      	str	r0, [r7, #20]
	if (result) {
  4090aa:	697b      	ldr	r3, [r7, #20]
  4090ac:	2b00      	cmp	r3, #0
  4090ae:	d005      	beq.n	4090bc <dmp_get_fifo_all+0x98>
		s->fifo_info.fifoError = result;
  4090b0:	68fb      	ldr	r3, [r7, #12]
  4090b2:	697a      	ldr	r2, [r7, #20]
  4090b4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		return 0;
  4090b8:	2300      	movs	r3, #0
  4090ba:	e000      	b.n	4090be <dmp_get_fifo_all+0x9a>
	}
	return in_fifo;
  4090bc:	693b      	ldr	r3, [r7, #16]
}
  4090be:	4618      	mov	r0, r3
  4090c0:	3718      	adds	r7, #24
  4090c2:	46bd      	mov	sp, r7
  4090c4:	bd80      	pop	{r7, pc}
  4090c6:	bf00      	nop
  4090c8:	00408e61 	.word	0x00408e61
  4090cc:	00408ec9 	.word	0x00408ec9
  4090d0:	00408fb5 	.word	0x00408fb5

004090d4 <get_packet_size_and_samplecnt>:

/** Determines the packet size by decoding the header. Both header and header2 are set. header2 is set to zero
*   if it doesn't exist. sample_cnt_array is filled in if not null with number of samples expected for each sensor
*/
static uint_fast16_t get_packet_size_and_samplecnt(unsigned char *data, unsigned short *header, unsigned short *header2, unsigned short * sample_cnt_array)
{
  4090d4:	b480      	push	{r7}
  4090d6:	b087      	sub	sp, #28
  4090d8:	af00      	add	r7, sp, #0
  4090da:	60f8      	str	r0, [r7, #12]
  4090dc:	60b9      	str	r1, [r7, #8]
  4090de:	607a      	str	r2, [r7, #4]
  4090e0:	603b      	str	r3, [r7, #0]
	int sz = HEADER_SZ; // 2 for header
  4090e2:	2302      	movs	r3, #2
  4090e4:	617b      	str	r3, [r7, #20]

	*header = (((unsigned short)data[0])<<8) | data[1];
  4090e6:	68fb      	ldr	r3, [r7, #12]
  4090e8:	781b      	ldrb	r3, [r3, #0]
  4090ea:	021b      	lsls	r3, r3, #8
  4090ec:	b21a      	sxth	r2, r3
  4090ee:	68fb      	ldr	r3, [r7, #12]
  4090f0:	3301      	adds	r3, #1
  4090f2:	781b      	ldrb	r3, [r3, #0]
  4090f4:	b21b      	sxth	r3, r3
  4090f6:	4313      	orrs	r3, r2
  4090f8:	b21b      	sxth	r3, r3
  4090fa:	b29a      	uxth	r2, r3
  4090fc:	68bb      	ldr	r3, [r7, #8]
  4090fe:	801a      	strh	r2, [r3, #0]

	if (*header & ACCEL_SET) {
  409100:	68bb      	ldr	r3, [r7, #8]
  409102:	881b      	ldrh	r3, [r3, #0]
  409104:	b21b      	sxth	r3, r3
  409106:	2b00      	cmp	r3, #0
  409108:	da14      	bge.n	409134 <get_packet_size_and_samplecnt+0x60>
		sz += ACCEL_DATA_SZ;
  40910a:	697b      	ldr	r3, [r7, #20]
  40910c:	3306      	adds	r3, #6
  40910e:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  409110:	683b      	ldr	r3, [r7, #0]
  409112:	2b00      	cmp	r3, #0
  409114:	d005      	beq.n	409122 <get_packet_size_and_samplecnt+0x4e>
			sample_cnt_array[ANDROID_SENSOR_ACCELEROMETER]++;
  409116:	683b      	ldr	r3, [r7, #0]
  409118:	3302      	adds	r3, #2
  40911a:	881a      	ldrh	r2, [r3, #0]
  40911c:	3201      	adds	r2, #1
  40911e:	b292      	uxth	r2, r2
  409120:	801a      	strh	r2, [r3, #0]
		if (sample_cnt_array)
  409122:	683b      	ldr	r3, [r7, #0]
  409124:	2b00      	cmp	r3, #0
  409126:	d005      	beq.n	409134 <get_packet_size_and_samplecnt+0x60>
			sample_cnt_array[ANDROID_SENSOR_RAW_ACCELEROMETER]++;
  409128:	683b      	ldr	r3, [r7, #0]
  40912a:	3354      	adds	r3, #84	; 0x54
  40912c:	881a      	ldrh	r2, [r3, #0]
  40912e:	3201      	adds	r2, #1
  409130:	b292      	uxth	r2, r2
  409132:	801a      	strh	r2, [r3, #0]
	}

	if (*header & GYRO_SET) {
  409134:	68bb      	ldr	r3, [r7, #8]
  409136:	881b      	ldrh	r3, [r3, #0]
  409138:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  40913c:	2b00      	cmp	r3, #0
  40913e:	d020      	beq.n	409182 <get_packet_size_and_samplecnt+0xae>
		sz += GYRO_DATA_SZ;
  409140:	697b      	ldr	r3, [r7, #20]
  409142:	3306      	adds	r3, #6
  409144:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  409146:	683b      	ldr	r3, [r7, #0]
  409148:	2b00      	cmp	r3, #0
  40914a:	d005      	beq.n	409158 <get_packet_size_and_samplecnt+0x84>
			sample_cnt_array[ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED]++;
  40914c:	683b      	ldr	r3, [r7, #0]
  40914e:	3320      	adds	r3, #32
  409150:	881a      	ldrh	r2, [r3, #0]
  409152:	3201      	adds	r2, #1
  409154:	b292      	uxth	r2, r2
  409156:	801a      	strh	r2, [r3, #0]
		sz += GYRO_BIAS_DATA_SZ;
  409158:	697b      	ldr	r3, [r7, #20]
  40915a:	3306      	adds	r3, #6
  40915c:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  40915e:	683b      	ldr	r3, [r7, #0]
  409160:	2b00      	cmp	r3, #0
  409162:	d005      	beq.n	409170 <get_packet_size_and_samplecnt+0x9c>
			sample_cnt_array[ANDROID_SENSOR_GYROSCOPE]++;
  409164:	683b      	ldr	r3, [r7, #0]
  409166:	3308      	adds	r3, #8
  409168:	881a      	ldrh	r2, [r3, #0]
  40916a:	3201      	adds	r2, #1
  40916c:	b292      	uxth	r2, r2
  40916e:	801a      	strh	r2, [r3, #0]
		if (sample_cnt_array)
  409170:	683b      	ldr	r3, [r7, #0]
  409172:	2b00      	cmp	r3, #0
  409174:	d005      	beq.n	409182 <get_packet_size_and_samplecnt+0xae>
			sample_cnt_array[ANDROID_SENSOR_RAW_GYROSCOPE]++;
  409176:	683b      	ldr	r3, [r7, #0]
  409178:	3356      	adds	r3, #86	; 0x56
  40917a:	881a      	ldrh	r2, [r3, #0]
  40917c:	3201      	adds	r2, #1
  40917e:	b292      	uxth	r2, r2
  409180:	801a      	strh	r2, [r3, #0]
	}

	if (*header & CPASS_SET) {
  409182:	68bb      	ldr	r3, [r7, #8]
  409184:	881b      	ldrh	r3, [r3, #0]
  409186:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40918a:	2b00      	cmp	r3, #0
  40918c:	d00b      	beq.n	4091a6 <get_packet_size_and_samplecnt+0xd2>
		sz += CPASS_DATA_SZ;
  40918e:	697b      	ldr	r3, [r7, #20]
  409190:	3306      	adds	r3, #6
  409192:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  409194:	683b      	ldr	r3, [r7, #0]
  409196:	2b00      	cmp	r3, #0
  409198:	d005      	beq.n	4091a6 <get_packet_size_and_samplecnt+0xd2>
			sample_cnt_array[ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED]++;
  40919a:	683b      	ldr	r3, [r7, #0]
  40919c:	331c      	adds	r3, #28
  40919e:	881a      	ldrh	r2, [r3, #0]
  4091a0:	3201      	adds	r2, #1
  4091a2:	b292      	uxth	r2, r2
  4091a4:	801a      	strh	r2, [r3, #0]
	}

	if (*header & ALS_SET) {
  4091a6:	68bb      	ldr	r3, [r7, #8]
  4091a8:	881b      	ldrh	r3, [r3, #0]
  4091aa:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  4091ae:	2b00      	cmp	r3, #0
  4091b0:	d00b      	beq.n	4091ca <get_packet_size_and_samplecnt+0xf6>
		sz += ALS_DATA_SZ;
  4091b2:	697b      	ldr	r3, [r7, #20]
  4091b4:	3308      	adds	r3, #8
  4091b6:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  4091b8:	683b      	ldr	r3, [r7, #0]
  4091ba:	2b00      	cmp	r3, #0
  4091bc:	d005      	beq.n	4091ca <get_packet_size_and_samplecnt+0xf6>
			sample_cnt_array[ANDROID_SENSOR_LIGHT]++;
  4091be:	683b      	ldr	r3, [r7, #0]
  4091c0:	330a      	adds	r3, #10
  4091c2:	881a      	ldrh	r2, [r3, #0]
  4091c4:	3201      	adds	r2, #1
  4091c6:	b292      	uxth	r2, r2
  4091c8:	801a      	strh	r2, [r3, #0]
	}

	if (*header & QUAT6_SET) {
  4091ca:	68bb      	ldr	r3, [r7, #8]
  4091cc:	881b      	ldrh	r3, [r3, #0]
  4091ce:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  4091d2:	2b00      	cmp	r3, #0
  4091d4:	d00b      	beq.n	4091ee <get_packet_size_and_samplecnt+0x11a>
		sz += QUAT6_DATA_SZ;
  4091d6:	697b      	ldr	r3, [r7, #20]
  4091d8:	330c      	adds	r3, #12
  4091da:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  4091dc:	683b      	ldr	r3, [r7, #0]
  4091de:	2b00      	cmp	r3, #0
  4091e0:	d005      	beq.n	4091ee <get_packet_size_and_samplecnt+0x11a>
			sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR]++;
  4091e2:	683b      	ldr	r3, [r7, #0]
  4091e4:	331e      	adds	r3, #30
  4091e6:	881a      	ldrh	r2, [r3, #0]
  4091e8:	3201      	adds	r2, #1
  4091ea:	b292      	uxth	r2, r2
  4091ec:	801a      	strh	r2, [r3, #0]
	}

	if (*header & QUAT9_SET) {
  4091ee:	68bb      	ldr	r3, [r7, #8]
  4091f0:	881b      	ldrh	r3, [r3, #0]
  4091f2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  4091f6:	2b00      	cmp	r3, #0
  4091f8:	d00b      	beq.n	409212 <get_packet_size_and_samplecnt+0x13e>
		sz += QUAT9_DATA_SZ;
  4091fa:	697b      	ldr	r3, [r7, #20]
  4091fc:	330e      	adds	r3, #14
  4091fe:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  409200:	683b      	ldr	r3, [r7, #0]
  409202:	2b00      	cmp	r3, #0
  409204:	d005      	beq.n	409212 <get_packet_size_and_samplecnt+0x13e>
			sample_cnt_array[ANDROID_SENSOR_ROTATION_VECTOR]++;
  409206:	683b      	ldr	r3, [r7, #0]
  409208:	3316      	adds	r3, #22
  40920a:	881a      	ldrh	r2, [r3, #0]
  40920c:	3201      	adds	r2, #1
  40920e:	b292      	uxth	r2, r2
  409210:	801a      	strh	r2, [r3, #0]
	}

	if (*header & PQUAT6_SET)
  409212:	68bb      	ldr	r3, [r7, #8]
  409214:	881b      	ldrh	r3, [r3, #0]
  409216:	f403 7300 	and.w	r3, r3, #512	; 0x200
  40921a:	2b00      	cmp	r3, #0
  40921c:	d002      	beq.n	409224 <get_packet_size_and_samplecnt+0x150>
		sz += PQUAT6_DATA_SZ;
  40921e:	697b      	ldr	r3, [r7, #20]
  409220:	3306      	adds	r3, #6
  409222:	617b      	str	r3, [r7, #20]

	if (*header & GEOMAG_SET) {
  409224:	68bb      	ldr	r3, [r7, #8]
  409226:	881b      	ldrh	r3, [r3, #0]
  409228:	f403 7380 	and.w	r3, r3, #256	; 0x100
  40922c:	2b00      	cmp	r3, #0
  40922e:	d00b      	beq.n	409248 <get_packet_size_and_samplecnt+0x174>
		sz += GEOMAG_DATA_SZ;
  409230:	697b      	ldr	r3, [r7, #20]
  409232:	330e      	adds	r3, #14
  409234:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  409236:	683b      	ldr	r3, [r7, #0]
  409238:	2b00      	cmp	r3, #0
  40923a:	d005      	beq.n	409248 <get_packet_size_and_samplecnt+0x174>
			sample_cnt_array[ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR]++;
  40923c:	683b      	ldr	r3, [r7, #0]
  40923e:	3328      	adds	r3, #40	; 0x28
  409240:	881a      	ldrh	r2, [r3, #0]
  409242:	3201      	adds	r2, #1
  409244:	b292      	uxth	r2, r2
  409246:	801a      	strh	r2, [r3, #0]
	}

	if (*header & CPASS_CALIBR_SET) {
  409248:	68bb      	ldr	r3, [r7, #8]
  40924a:	881b      	ldrh	r3, [r3, #0]
  40924c:	f003 0320 	and.w	r3, r3, #32
  409250:	2b00      	cmp	r3, #0
  409252:	d00b      	beq.n	40926c <get_packet_size_and_samplecnt+0x198>
		sz += CPASS_CALIBR_DATA_SZ;
  409254:	697b      	ldr	r3, [r7, #20]
  409256:	330c      	adds	r3, #12
  409258:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  40925a:	683b      	ldr	r3, [r7, #0]
  40925c:	2b00      	cmp	r3, #0
  40925e:	d005      	beq.n	40926c <get_packet_size_and_samplecnt+0x198>
			sample_cnt_array[ANDROID_SENSOR_GEOMAGNETIC_FIELD]++;
  409260:	683b      	ldr	r3, [r7, #0]
  409262:	3304      	adds	r3, #4
  409264:	881a      	ldrh	r2, [r3, #0]
  409266:	3201      	adds	r2, #1
  409268:	b292      	uxth	r2, r2
  40926a:	801a      	strh	r2, [r3, #0]
	}

	if (*header & PED_STEPDET_SET) {
  40926c:	68bb      	ldr	r3, [r7, #8]
  40926e:	881b      	ldrh	r3, [r3, #0]
  409270:	f003 0310 	and.w	r3, r3, #16
  409274:	2b00      	cmp	r3, #0
  409276:	d00b      	beq.n	409290 <get_packet_size_and_samplecnt+0x1bc>
		sz += PED_STEPDET_TIMESTAMP_SZ;
  409278:	697b      	ldr	r3, [r7, #20]
  40927a:	3304      	adds	r3, #4
  40927c:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  40927e:	683b      	ldr	r3, [r7, #0]
  409280:	2b00      	cmp	r3, #0
  409282:	d005      	beq.n	409290 <get_packet_size_and_samplecnt+0x1bc>
			sample_cnt_array[ANDROID_SENSOR_STEP_DETECTOR]++;
  409284:	683b      	ldr	r3, [r7, #0]
  409286:	3324      	adds	r3, #36	; 0x24
  409288:	881a      	ldrh	r2, [r3, #0]
  40928a:	3201      	adds	r2, #1
  40928c:	b292      	uxth	r2, r2
  40928e:	801a      	strh	r2, [r3, #0]
	}

	if (*header & HEADER2_SET) {
  409290:	68bb      	ldr	r3, [r7, #8]
  409292:	881b      	ldrh	r3, [r3, #0]
  409294:	f003 0308 	and.w	r3, r3, #8
  409298:	2b00      	cmp	r3, #0
  40929a:	d011      	beq.n	4092c0 <get_packet_size_and_samplecnt+0x1ec>
		*header2 = (((unsigned short)data[2])<<8) | data[3];
  40929c:	68fb      	ldr	r3, [r7, #12]
  40929e:	3302      	adds	r3, #2
  4092a0:	781b      	ldrb	r3, [r3, #0]
  4092a2:	021b      	lsls	r3, r3, #8
  4092a4:	b21a      	sxth	r2, r3
  4092a6:	68fb      	ldr	r3, [r7, #12]
  4092a8:	3303      	adds	r3, #3
  4092aa:	781b      	ldrb	r3, [r3, #0]
  4092ac:	b21b      	sxth	r3, r3
  4092ae:	4313      	orrs	r3, r2
  4092b0:	b21b      	sxth	r3, r3
  4092b2:	b29a      	uxth	r2, r3
  4092b4:	687b      	ldr	r3, [r7, #4]
  4092b6:	801a      	strh	r2, [r3, #0]
		sz += HEADER2_SZ;
  4092b8:	697b      	ldr	r3, [r7, #20]
  4092ba:	3302      	adds	r3, #2
  4092bc:	617b      	str	r3, [r7, #20]
  4092be:	e002      	b.n	4092c6 <get_packet_size_and_samplecnt+0x1f2>
	} else {
		*header2 = 0;
  4092c0:	687b      	ldr	r3, [r7, #4]
  4092c2:	2200      	movs	r2, #0
  4092c4:	801a      	strh	r2, [r3, #0]
	}

	if (*header2 & ACCEL_ACCURACY_SET) {
  4092c6:	687b      	ldr	r3, [r7, #4]
  4092c8:	881b      	ldrh	r3, [r3, #0]
  4092ca:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  4092ce:	2b00      	cmp	r3, #0
  4092d0:	d002      	beq.n	4092d8 <get_packet_size_and_samplecnt+0x204>
		sz += ACCEL_ACCURACY_SZ;
  4092d2:	697b      	ldr	r3, [r7, #20]
  4092d4:	3302      	adds	r3, #2
  4092d6:	617b      	str	r3, [r7, #20]
	}
	if (*header2 & GYRO_ACCURACY_SET) {
  4092d8:	687b      	ldr	r3, [r7, #4]
  4092da:	881b      	ldrh	r3, [r3, #0]
  4092dc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  4092e0:	2b00      	cmp	r3, #0
  4092e2:	d002      	beq.n	4092ea <get_packet_size_and_samplecnt+0x216>
		sz += GYRO_ACCURACY_SZ;
  4092e4:	697b      	ldr	r3, [r7, #20]
  4092e6:	3302      	adds	r3, #2
  4092e8:	617b      	str	r3, [r7, #20]
	}
	if (*header2 & CPASS_ACCURACY_SET) {
  4092ea:	687b      	ldr	r3, [r7, #4]
  4092ec:	881b      	ldrh	r3, [r3, #0]
  4092ee:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  4092f2:	2b00      	cmp	r3, #0
  4092f4:	d002      	beq.n	4092fc <get_packet_size_and_samplecnt+0x228>
		sz += CPASS_ACCURACY_SZ;
  4092f6:	697b      	ldr	r3, [r7, #20]
  4092f8:	3302      	adds	r3, #2
  4092fa:	617b      	str	r3, [r7, #20]
	}
	if (*header2 & FLIP_PICKUP_SET) {
  4092fc:	687b      	ldr	r3, [r7, #4]
  4092fe:	881b      	ldrh	r3, [r3, #0]
  409300:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  409304:	2b00      	cmp	r3, #0
  409306:	d00b      	beq.n	409320 <get_packet_size_and_samplecnt+0x24c>
		sz += FLIP_PICKUP_SZ;
  409308:	697b      	ldr	r3, [r7, #20]
  40930a:	3302      	adds	r3, #2
  40930c:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  40930e:	683b      	ldr	r3, [r7, #0]
  409310:	2b00      	cmp	r3, #0
  409312:	d005      	beq.n	409320 <get_packet_size_and_samplecnt+0x24c>
			sample_cnt_array[ANDROID_SENSOR_FLIP_PICKUP]++;
  409314:	683b      	ldr	r3, [r7, #0]
  409316:	335c      	adds	r3, #92	; 0x5c
  409318:	881a      	ldrh	r2, [r3, #0]
  40931a:	3201      	adds	r2, #1
  40931c:	b292      	uxth	r2, r2
  40931e:	801a      	strh	r2, [r3, #0]
	}
	if (*header2 & ACT_RECOG_SET) {
  409320:	687b      	ldr	r3, [r7, #4]
  409322:	881b      	ldrh	r3, [r3, #0]
  409324:	f003 0380 	and.w	r3, r3, #128	; 0x80
  409328:	2b00      	cmp	r3, #0
  40932a:	d00b      	beq.n	409344 <get_packet_size_and_samplecnt+0x270>
		sz += ACT_RECOG_SZ;
  40932c:	697b      	ldr	r3, [r7, #20]
  40932e:	3306      	adds	r3, #6
  409330:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  409332:	683b      	ldr	r3, [r7, #0]
  409334:	2b00      	cmp	r3, #0
  409336:	d005      	beq.n	409344 <get_packet_size_and_samplecnt+0x270>
			sample_cnt_array[ANDROID_SENSOR_ACTIVITY_CLASSIFICATON]++;
  409338:	683b      	ldr	r3, [r7, #0]
  40933a:	335e      	adds	r3, #94	; 0x5e
  40933c:	881a      	ldrh	r2, [r3, #0]
  40933e:	3201      	adds	r2, #1
  409340:	b292      	uxth	r2, r2
  409342:	801a      	strh	r2, [r3, #0]
	}
	sz += ODR_CNT_GYRO_SZ;
  409344:	697b      	ldr	r3, [r7, #20]
  409346:	3302      	adds	r3, #2
  409348:	617b      	str	r3, [r7, #20]

	return sz;
  40934a:	697b      	ldr	r3, [r7, #20]
}
  40934c:	4618      	mov	r0, r3
  40934e:	371c      	adds	r7, #28
  409350:	46bd      	mov	sp, r7
  409352:	f85d 7b04 	ldr.w	r7, [sp], #4
  409356:	4770      	bx	lr

00409358 <check_fifo_decoded_headers>:

static int check_fifo_decoded_headers(unsigned short header, unsigned short header2)
{
  409358:	b480      	push	{r7}
  40935a:	b085      	sub	sp, #20
  40935c:	af00      	add	r7, sp, #0
  40935e:	4603      	mov	r3, r0
  409360:	460a      	mov	r2, r1
  409362:	80fb      	strh	r3, [r7, #6]
  409364:	4613      	mov	r3, r2
  409366:	80bb      	strh	r3, [r7, #4]
	unsigned short header_bit_mask = 0;
  409368:	2300      	movs	r3, #0
  40936a:	81fb      	strh	r3, [r7, #14]
	unsigned short header2_bit_mask = 0;
  40936c:	2300      	movs	r3, #0
  40936e:	81bb      	strh	r3, [r7, #12]

	// at least 1 bit must be set
	if (header == 0)
  409370:	88fb      	ldrh	r3, [r7, #6]
  409372:	2b00      	cmp	r3, #0
  409374:	d102      	bne.n	40937c <check_fifo_decoded_headers+0x24>
		return -1;
  409376:	f04f 33ff 	mov.w	r3, #4294967295
  40937a:	e063      	b.n	409444 <check_fifo_decoded_headers+0xec>

	header_bit_mask |= ACCEL_SET;
  40937c:	89fb      	ldrh	r3, [r7, #14]
  40937e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  409382:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  409386:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= GYRO_SET;
  409388:	89fb      	ldrh	r3, [r7, #14]
  40938a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  40938e:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= CPASS_SET;
  409390:	89fb      	ldrh	r3, [r7, #14]
  409392:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  409396:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= ALS_SET;
  409398:	89fb      	ldrh	r3, [r7, #14]
  40939a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  40939e:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= QUAT6_SET;
  4093a0:	89fb      	ldrh	r3, [r7, #14]
  4093a2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  4093a6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= QUAT9_SET;
  4093a8:	89fb      	ldrh	r3, [r7, #14]
  4093aa:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  4093ae:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= PQUAT6_SET;
  4093b0:	89fb      	ldrh	r3, [r7, #14]
  4093b2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  4093b6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= GEOMAG_SET;
  4093b8:	89fb      	ldrh	r3, [r7, #14]
  4093ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4093be:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= GYRO_CALIBR_SET;
  4093c0:	89fb      	ldrh	r3, [r7, #14]
  4093c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4093c6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= CPASS_CALIBR_SET;
  4093c8:	89fb      	ldrh	r3, [r7, #14]
  4093ca:	f043 0320 	orr.w	r3, r3, #32
  4093ce:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= PED_STEPDET_SET;
  4093d0:	89fb      	ldrh	r3, [r7, #14]
  4093d2:	f043 0310 	orr.w	r3, r3, #16
  4093d6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= HEADER2_SET;
  4093d8:	89fb      	ldrh	r3, [r7, #14]
  4093da:	f043 0308 	orr.w	r3, r3, #8
  4093de:	81fb      	strh	r3, [r7, #14]

	if (header & ~header_bit_mask)
  4093e0:	88fa      	ldrh	r2, [r7, #6]
  4093e2:	89fb      	ldrh	r3, [r7, #14]
  4093e4:	43db      	mvns	r3, r3
  4093e6:	4013      	ands	r3, r2
  4093e8:	2b00      	cmp	r3, #0
  4093ea:	d002      	beq.n	4093f2 <check_fifo_decoded_headers+0x9a>
		return -1;
  4093ec:	f04f 33ff 	mov.w	r3, #4294967295
  4093f0:	e028      	b.n	409444 <check_fifo_decoded_headers+0xec>

	// at least 1 bit must be set if header 2 is set
	if (header & HEADER2_SET) {
  4093f2:	88fb      	ldrh	r3, [r7, #6]
  4093f4:	f003 0308 	and.w	r3, r3, #8
  4093f8:	2b00      	cmp	r3, #0
  4093fa:	d022      	beq.n	409442 <check_fifo_decoded_headers+0xea>
		header2_bit_mask |= ACCEL_ACCURACY_SET;
  4093fc:	89bb      	ldrh	r3, [r7, #12]
  4093fe:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  409402:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= GYRO_ACCURACY_SET;
  409404:	89bb      	ldrh	r3, [r7, #12]
  409406:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  40940a:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= CPASS_ACCURACY_SET;
  40940c:	89bb      	ldrh	r3, [r7, #12]
  40940e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  409412:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= FLIP_PICKUP_SET;
  409414:	89bb      	ldrh	r3, [r7, #12]
  409416:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  40941a:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= ACT_RECOG_SET;
  40941c:	89bb      	ldrh	r3, [r7, #12]
  40941e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  409422:	81bb      	strh	r3, [r7, #12]
		if (header2 == 0)
  409424:	88bb      	ldrh	r3, [r7, #4]
  409426:	2b00      	cmp	r3, #0
  409428:	d102      	bne.n	409430 <check_fifo_decoded_headers+0xd8>
			return -1;
  40942a:	f04f 33ff 	mov.w	r3, #4294967295
  40942e:	e009      	b.n	409444 <check_fifo_decoded_headers+0xec>
		if (header2 & ~header2_bit_mask)
  409430:	88ba      	ldrh	r2, [r7, #4]
  409432:	89bb      	ldrh	r3, [r7, #12]
  409434:	43db      	mvns	r3, r3
  409436:	4013      	ands	r3, r2
  409438:	2b00      	cmp	r3, #0
  40943a:	d002      	beq.n	409442 <check_fifo_decoded_headers+0xea>
			return -1;
  40943c:	f04f 33ff 	mov.w	r3, #4294967295
  409440:	e000      	b.n	409444 <check_fifo_decoded_headers+0xec>
	}

    return 0;
  409442:	2300      	movs	r3, #0
}
  409444:	4618      	mov	r0, r3
  409446:	3714      	adds	r7, #20
  409448:	46bd      	mov	sp, r7
  40944a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40944e:	4770      	bx	lr

00409450 <extract_sample_cnt>:

/** Determine number of samples present in SW FIFO fifo_data containing fifo_size bytes to be analyzed. Total number
* of samples filled in total_sample_cnt, number of samples per sensor filled in sample_cnt_array array
*/
static int extract_sample_cnt(struct inv_icm20648 * s, int fifo_size, unsigned short * total_sample_cnt, unsigned short * sample_cnt_array)
{
  409450:	b590      	push	{r4, r7, lr}
  409452:	b089      	sub	sp, #36	; 0x24
  409454:	af00      	add	r7, sp, #0
  409456:	60f8      	str	r0, [r7, #12]
  409458:	60b9      	str	r1, [r7, #8]
  40945a:	607a      	str	r2, [r7, #4]
  40945c:	603b      	str	r3, [r7, #0]
	// Next SW FIFO index to be parsed
	int fifo_idx = 0;
  40945e:	2300      	movs	r3, #0
  409460:	61fb      	str	r3, [r7, #28]

	while (fifo_idx < fifo_size) {
  409462:	e02a      	b.n	4094ba <extract_sample_cnt+0x6a>
		unsigned short header;
		unsigned short header2;
		int need_sz = get_packet_size_and_samplecnt(&fifo_data[fifo_idx], &header, &header2, sample_cnt_array);
  409464:	69fb      	ldr	r3, [r7, #28]
  409466:	4a2c      	ldr	r2, [pc, #176]	; (409518 <extract_sample_cnt+0xc8>)
  409468:	1898      	adds	r0, r3, r2
  40946a:	f107 0214 	add.w	r2, r7, #20
  40946e:	f107 0116 	add.w	r1, r7, #22
  409472:	683b      	ldr	r3, [r7, #0]
  409474:	4c29      	ldr	r4, [pc, #164]	; (40951c <extract_sample_cnt+0xcc>)
  409476:	47a0      	blx	r4
  409478:	4603      	mov	r3, r0
  40947a:	61bb      	str	r3, [r7, #24]

		// Guarantee there is a full packet before continuing to decode the FIFO packet
		if (fifo_size-fifo_idx < need_sz)
  40947c:	68ba      	ldr	r2, [r7, #8]
  40947e:	69fb      	ldr	r3, [r7, #28]
  409480:	1ad2      	subs	r2, r2, r3
  409482:	69bb      	ldr	r3, [r7, #24]
  409484:	429a      	cmp	r2, r3
  409486:	db1d      	blt.n	4094c4 <extract_sample_cnt+0x74>
			goto endSuccess;

		// Decode any error
		if (check_fifo_decoded_headers(header, header2)) {
  409488:	8afb      	ldrh	r3, [r7, #22]
  40948a:	8aba      	ldrh	r2, [r7, #20]
  40948c:	4611      	mov	r1, r2
  40948e:	4618      	mov	r0, r3
  409490:	4b23      	ldr	r3, [pc, #140]	; (409520 <extract_sample_cnt+0xd0>)
  409492:	4798      	blx	r3
  409494:	4603      	mov	r3, r0
  409496:	2b00      	cmp	r3, #0
  409498:	d005      	beq.n	4094a6 <extract_sample_cnt+0x56>
			// in that case, stop processing, we might have overflowed so following bytes are non sense
			dmp_reset_fifo(s);
  40949a:	68f8      	ldr	r0, [r7, #12]
  40949c:	4b21      	ldr	r3, [pc, #132]	; (409524 <extract_sample_cnt+0xd4>)
  40949e:	4798      	blx	r3
			return -1;
  4094a0:	f04f 33ff 	mov.w	r3, #4294967295
  4094a4:	e034      	b.n	409510 <extract_sample_cnt+0xc0>
		}

		fifo_idx += need_sz;
  4094a6:	69fa      	ldr	r2, [r7, #28]
  4094a8:	69bb      	ldr	r3, [r7, #24]
  4094aa:	4413      	add	r3, r2
  4094ac:	61fb      	str	r3, [r7, #28]

		// One sample found, increment total sample counter
		(*total_sample_cnt)++;
  4094ae:	687b      	ldr	r3, [r7, #4]
  4094b0:	881b      	ldrh	r3, [r3, #0]
  4094b2:	3301      	adds	r3, #1
  4094b4:	b29a      	uxth	r2, r3
  4094b6:	687b      	ldr	r3, [r7, #4]
  4094b8:	801a      	strh	r2, [r3, #0]
	while (fifo_idx < fifo_size) {
  4094ba:	69fa      	ldr	r2, [r7, #28]
  4094bc:	68bb      	ldr	r3, [r7, #8]
  4094be:	429a      	cmp	r2, r3
  4094c0:	dbd0      	blt.n	409464 <extract_sample_cnt+0x14>
  4094c2:	e000      	b.n	4094c6 <extract_sample_cnt+0x76>
			goto endSuccess;
  4094c4:	bf00      	nop
	}

endSuccess:
	// Augmented sensors are not part of DMP FIFO, they are computed by DMP driver based on GRV or RV presence in DMP FIFO
	// So their sample counts must rely on GRV and RV sample counts
	if (sample_cnt_array) {
  4094c6:	683b      	ldr	r3, [r7, #0]
  4094c8:	2b00      	cmp	r3, #0
  4094ca:	d020      	beq.n	40950e <extract_sample_cnt+0xbe>
		sample_cnt_array[ANDROID_SENSOR_GRAVITY] += sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR];
  4094cc:	683b      	ldr	r3, [r7, #0]
  4094ce:	3312      	adds	r3, #18
  4094d0:	683a      	ldr	r2, [r7, #0]
  4094d2:	3212      	adds	r2, #18
  4094d4:	8811      	ldrh	r1, [r2, #0]
  4094d6:	683a      	ldr	r2, [r7, #0]
  4094d8:	321e      	adds	r2, #30
  4094da:	8812      	ldrh	r2, [r2, #0]
  4094dc:	440a      	add	r2, r1
  4094de:	b292      	uxth	r2, r2
  4094e0:	801a      	strh	r2, [r3, #0]
		sample_cnt_array[ANDROID_SENSOR_LINEAR_ACCELERATION] += sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR];
  4094e2:	683b      	ldr	r3, [r7, #0]
  4094e4:	3314      	adds	r3, #20
  4094e6:	683a      	ldr	r2, [r7, #0]
  4094e8:	3214      	adds	r2, #20
  4094ea:	8811      	ldrh	r1, [r2, #0]
  4094ec:	683a      	ldr	r2, [r7, #0]
  4094ee:	321e      	adds	r2, #30
  4094f0:	8812      	ldrh	r2, [r2, #0]
  4094f2:	440a      	add	r2, r1
  4094f4:	b292      	uxth	r2, r2
  4094f6:	801a      	strh	r2, [r3, #0]
		sample_cnt_array[ANDROID_SENSOR_ORIENTATION] += sample_cnt_array[ANDROID_SENSOR_ROTATION_VECTOR];
  4094f8:	683b      	ldr	r3, [r7, #0]
  4094fa:	3306      	adds	r3, #6
  4094fc:	683a      	ldr	r2, [r7, #0]
  4094fe:	3206      	adds	r2, #6
  409500:	8811      	ldrh	r1, [r2, #0]
  409502:	683a      	ldr	r2, [r7, #0]
  409504:	3216      	adds	r2, #22
  409506:	8812      	ldrh	r2, [r2, #0]
  409508:	440a      	add	r2, r1
  40950a:	b292      	uxth	r2, r2
  40950c:	801a      	strh	r2, [r3, #0]
	}

	return 0;
  40950e:	2300      	movs	r3, #0
}
  409510:	4618      	mov	r0, r3
  409512:	3724      	adds	r7, #36	; 0x24
  409514:	46bd      	mov	sp, r7
  409516:	bd90      	pop	{r4, r7, pc}
  409518:	2000142c 	.word	0x2000142c
  40951c:	004090d5 	.word	0x004090d5
  409520:	00409359 	.word	0x00409359
  409524:	00408ec9 	.word	0x00408ec9

00409528 <inv_icm20648_fifo_swmirror>:

int inv_icm20648_fifo_swmirror(struct inv_icm20648 * s, int *fifo_sw_size, unsigned short * total_sample_cnt, unsigned short * sample_cnt_array)
{
  409528:	b590      	push	{r4, r7, lr}
  40952a:	b087      	sub	sp, #28
  40952c:	af00      	add	r7, sp, #0
  40952e:	60f8      	str	r0, [r7, #12]
  409530:	60b9      	str	r1, [r7, #8]
  409532:	607a      	str	r2, [r7, #4]
  409534:	603b      	str	r3, [r7, #0]
	int reset=0;
  409536:	2300      	movs	r3, #0
  409538:	617b      	str	r3, [r7, #20]

	*total_sample_cnt = 0;
  40953a:	687b      	ldr	r3, [r7, #4]
  40953c:	2200      	movs	r2, #0
  40953e:	801a      	strh	r2, [r3, #0]

	// Mirror HW FIFO into local SW FIFO, taking into account remaining *fifo_sw_size bytes still present in SW FIFO
	if (*fifo_sw_size < HARDWARE_FIFO_SIZE ) {
  409540:	68bb      	ldr	r3, [r7, #8]
  409542:	681b      	ldr	r3, [r3, #0]
  409544:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  409548:	da17      	bge.n	40957a <inv_icm20648_fifo_swmirror+0x52>
		*fifo_sw_size += dmp_get_fifo_all(s, (HARDWARE_FIFO_SIZE - *fifo_sw_size),&fifo_data[*fifo_sw_size],&reset);
  40954a:	68bb      	ldr	r3, [r7, #8]
  40954c:	681b      	ldr	r3, [r3, #0]
  40954e:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
  409552:	4619      	mov	r1, r3
  409554:	68bb      	ldr	r3, [r7, #8]
  409556:	681b      	ldr	r3, [r3, #0]
  409558:	4a14      	ldr	r2, [pc, #80]	; (4095ac <inv_icm20648_fifo_swmirror+0x84>)
  40955a:	441a      	add	r2, r3
  40955c:	f107 0314 	add.w	r3, r7, #20
  409560:	68f8      	ldr	r0, [r7, #12]
  409562:	4c13      	ldr	r4, [pc, #76]	; (4095b0 <inv_icm20648_fifo_swmirror+0x88>)
  409564:	47a0      	blx	r4
  409566:	4602      	mov	r2, r0
  409568:	68bb      	ldr	r3, [r7, #8]
  40956a:	681b      	ldr	r3, [r3, #0]
  40956c:	4413      	add	r3, r2
  40956e:	461a      	mov	r2, r3
  409570:	68bb      	ldr	r3, [r7, #8]
  409572:	601a      	str	r2, [r3, #0]

		if (reset)
  409574:	697b      	ldr	r3, [r7, #20]
  409576:	2b00      	cmp	r3, #0
  409578:	d10b      	bne.n	409592 <inv_icm20648_fifo_swmirror+0x6a>
			goto error;
	}

	// SW FIFO is mirror, we can now parse it to extract total number of samples and number of samples per sensor
	if (extract_sample_cnt(s, *fifo_sw_size, total_sample_cnt, sample_cnt_array))
  40957a:	68bb      	ldr	r3, [r7, #8]
  40957c:	6819      	ldr	r1, [r3, #0]
  40957e:	683b      	ldr	r3, [r7, #0]
  409580:	687a      	ldr	r2, [r7, #4]
  409582:	68f8      	ldr	r0, [r7, #12]
  409584:	4c0b      	ldr	r4, [pc, #44]	; (4095b4 <inv_icm20648_fifo_swmirror+0x8c>)
  409586:	47a0      	blx	r4
  409588:	4603      	mov	r3, r0
  40958a:	2b00      	cmp	r3, #0
  40958c:	d103      	bne.n	409596 <inv_icm20648_fifo_swmirror+0x6e>
			goto error;

	return MPU_SUCCESS;
  40958e:	2300      	movs	r3, #0
  409590:	e007      	b.n	4095a2 <inv_icm20648_fifo_swmirror+0x7a>
			goto error;
  409592:	bf00      	nop
  409594:	e000      	b.n	409598 <inv_icm20648_fifo_swmirror+0x70>
			goto error;
  409596:	bf00      	nop

error:
	*fifo_sw_size = 0;
  409598:	68bb      	ldr	r3, [r7, #8]
  40959a:	2200      	movs	r2, #0
  40959c:	601a      	str	r2, [r3, #0]
	return -1;
  40959e:	f04f 33ff 	mov.w	r3, #4294967295

}
  4095a2:	4618      	mov	r0, r3
  4095a4:	371c      	adds	r7, #28
  4095a6:	46bd      	mov	sp, r7
  4095a8:	bd90      	pop	{r4, r7, pc}
  4095aa:	bf00      	nop
  4095ac:	2000142c 	.word	0x2000142c
  4095b0:	00409025 	.word	0x00409025
  4095b4:	00409451 	.word	0x00409451

004095b8 <inv_icm20648_fifo_pop>:

int inv_icm20648_fifo_pop(struct inv_icm20648 * s, unsigned short *user_header, unsigned short *user_header2, int *fifo_sw_size)
{
  4095b8:	b590      	push	{r4, r7, lr}
  4095ba:	b087      	sub	sp, #28
  4095bc:	af00      	add	r7, sp, #0
  4095be:	60f8      	str	r0, [r7, #12]
  4095c0:	60b9      	str	r1, [r7, #8]
  4095c2:	607a      	str	r2, [r7, #4]
  4095c4:	603b      	str	r3, [r7, #0]
	int need_sz=0; // size in bytes of packet to be analyzed from FIFO
  4095c6:	2300      	movs	r3, #0
  4095c8:	613b      	str	r3, [r7, #16]
	unsigned char *fifo_ptr = fifo_data; // pointer to next byte in SW FIFO to be parsed
  4095ca:	4b28      	ldr	r3, [pc, #160]	; (40966c <inv_icm20648_fifo_pop+0xb4>)
  4095cc:	617b      	str	r3, [r7, #20]

	if (*fifo_sw_size > 3) {
  4095ce:	683b      	ldr	r3, [r7, #0]
  4095d0:	681b      	ldr	r3, [r3, #0]
  4095d2:	2b03      	cmp	r3, #3
  4095d4:	dd44      	ble.n	409660 <inv_icm20648_fifo_pop+0xa8>
		// extract headers and number of bytes requested by next sample present in FIFO
		need_sz = get_packet_size_and_samplecnt(fifo_data, &fd.header, &fd.header2, 0);
  4095d6:	2300      	movs	r3, #0
  4095d8:	4a25      	ldr	r2, [pc, #148]	; (409670 <inv_icm20648_fifo_pop+0xb8>)
  4095da:	4926      	ldr	r1, [pc, #152]	; (409674 <inv_icm20648_fifo_pop+0xbc>)
  4095dc:	4823      	ldr	r0, [pc, #140]	; (40966c <inv_icm20648_fifo_pop+0xb4>)
  4095de:	4c26      	ldr	r4, [pc, #152]	; (409678 <inv_icm20648_fifo_pop+0xc0>)
  4095e0:	47a0      	blx	r4
  4095e2:	4603      	mov	r3, r0
  4095e4:	613b      	str	r3, [r7, #16]

		// Guarantee there is a full packet before continuing to decode the FIFO packet
		if (*fifo_sw_size < need_sz) {
  4095e6:	683b      	ldr	r3, [r7, #0]
  4095e8:	681a      	ldr	r2, [r3, #0]
  4095ea:	693b      	ldr	r3, [r7, #16]
  4095ec:	429a      	cmp	r2, r3
  4095ee:	da03      	bge.n	4095f8 <inv_icm20648_fifo_pop+0x40>
		    return s->fifo_info.fifoError;
  4095f0:	68fb      	ldr	r3, [r7, #12]
  4095f2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  4095f6:	e034      	b.n	409662 <inv_icm20648_fifo_pop+0xaa>
		}

		fifo_ptr += HEADER_SZ;
  4095f8:	697b      	ldr	r3, [r7, #20]
  4095fa:	3302      	adds	r3, #2
  4095fc:	617b      	str	r3, [r7, #20]
		if (fd.header & HEADER2_SET)
  4095fe:	4b1f      	ldr	r3, [pc, #124]	; (40967c <inv_icm20648_fifo_pop+0xc4>)
  409600:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409604:	f003 0308 	and.w	r3, r3, #8
  409608:	2b00      	cmp	r3, #0
  40960a:	d002      	beq.n	409612 <inv_icm20648_fifo_pop+0x5a>
			fifo_ptr += HEADER2_SZ;
  40960c:	697b      	ldr	r3, [r7, #20]
  40960e:	3302      	adds	r3, #2
  409610:	617b      	str	r3, [r7, #20]

		// extract payload data from SW FIFO
		fifo_ptr += inv_icm20648_inv_decode_one_ivory_fifo_packet(s, &fd, fifo_ptr);
  409612:	697a      	ldr	r2, [r7, #20]
  409614:	4919      	ldr	r1, [pc, #100]	; (40967c <inv_icm20648_fifo_pop+0xc4>)
  409616:	68f8      	ldr	r0, [r7, #12]
  409618:	4b19      	ldr	r3, [pc, #100]	; (409680 <inv_icm20648_fifo_pop+0xc8>)
  40961a:	4798      	blx	r3
  40961c:	4603      	mov	r3, r0
  40961e:	461a      	mov	r2, r3
  409620:	697b      	ldr	r3, [r7, #20]
  409622:	4413      	add	r3, r2
  409624:	617b      	str	r3, [r7, #20]

		// remove first need_sz bytes from SW FIFO
		*fifo_sw_size -= need_sz;
  409626:	683b      	ldr	r3, [r7, #0]
  409628:	681a      	ldr	r2, [r3, #0]
  40962a:	693b      	ldr	r3, [r7, #16]
  40962c:	1ad2      	subs	r2, r2, r3
  40962e:	683b      	ldr	r3, [r7, #0]
  409630:	601a      	str	r2, [r3, #0]
		if(*fifo_sw_size)
  409632:	683b      	ldr	r3, [r7, #0]
  409634:	681b      	ldr	r3, [r3, #0]
  409636:	2b00      	cmp	r3, #0
  409638:	d008      	beq.n	40964c <inv_icm20648_fifo_pop+0x94>
			memmove(fifo_data, &fifo_data[need_sz], *fifo_sw_size);// Data left in FIFO
  40963a:	693b      	ldr	r3, [r7, #16]
  40963c:	4a0b      	ldr	r2, [pc, #44]	; (40966c <inv_icm20648_fifo_pop+0xb4>)
  40963e:	1899      	adds	r1, r3, r2
  409640:	683b      	ldr	r3, [r7, #0]
  409642:	681b      	ldr	r3, [r3, #0]
  409644:	461a      	mov	r2, r3
  409646:	4809      	ldr	r0, [pc, #36]	; (40966c <inv_icm20648_fifo_pop+0xb4>)
  409648:	4b0e      	ldr	r3, [pc, #56]	; (409684 <inv_icm20648_fifo_pop+0xcc>)
  40964a:	4798      	blx	r3

		*user_header = fd.header;
  40964c:	4b0b      	ldr	r3, [pc, #44]	; (40967c <inv_icm20648_fifo_pop+0xc4>)
  40964e:	f8b3 209a 	ldrh.w	r2, [r3, #154]	; 0x9a
  409652:	68bb      	ldr	r3, [r7, #8]
  409654:	801a      	strh	r2, [r3, #0]
		*user_header2 = fd.header2;
  409656:	4b09      	ldr	r3, [pc, #36]	; (40967c <inv_icm20648_fifo_pop+0xc4>)
  409658:	f8b3 209c 	ldrh.w	r2, [r3, #156]	; 0x9c
  40965c:	687b      	ldr	r3, [r7, #4]
  40965e:	801a      	strh	r2, [r3, #0]
	}

	return MPU_SUCCESS;
  409660:	2300      	movs	r3, #0
}
  409662:	4618      	mov	r0, r3
  409664:	371c      	adds	r7, #28
  409666:	46bd      	mov	sp, r7
  409668:	bd90      	pop	{r4, r7, pc}
  40966a:	bf00      	nop
  40966c:	2000142c 	.word	0x2000142c
  409670:	20001f78 	.word	0x20001f78
  409674:	20001f76 	.word	0x20001f76
  409678:	004090d5 	.word	0x004090d5
  40967c:	20001edc 	.word	0x20001edc
  409680:	00409781 	.word	0x00409781
  409684:	00414369 	.word	0x00414369

00409688 <inv_decode_3_32bit_elements>:

    return result;
}

static void inv_decode_3_32bit_elements(long *out_data, const unsigned char *in_data)
{
  409688:	b480      	push	{r7}
  40968a:	b083      	sub	sp, #12
  40968c:	af00      	add	r7, sp, #0
  40968e:	6078      	str	r0, [r7, #4]
  409690:	6039      	str	r1, [r7, #0]
    out_data[0] = ((long)(0xff & in_data[0]) << 24) | ((long)(0xff & in_data[1]) << 16) | ((long)(0xff & in_data[2]) << 8) | (0xff & in_data[3]);
  409692:	683b      	ldr	r3, [r7, #0]
  409694:	781b      	ldrb	r3, [r3, #0]
  409696:	061a      	lsls	r2, r3, #24
  409698:	683b      	ldr	r3, [r7, #0]
  40969a:	3301      	adds	r3, #1
  40969c:	781b      	ldrb	r3, [r3, #0]
  40969e:	041b      	lsls	r3, r3, #16
  4096a0:	431a      	orrs	r2, r3
  4096a2:	683b      	ldr	r3, [r7, #0]
  4096a4:	3302      	adds	r3, #2
  4096a6:	781b      	ldrb	r3, [r3, #0]
  4096a8:	021b      	lsls	r3, r3, #8
  4096aa:	4313      	orrs	r3, r2
  4096ac:	683a      	ldr	r2, [r7, #0]
  4096ae:	3203      	adds	r2, #3
  4096b0:	7812      	ldrb	r2, [r2, #0]
  4096b2:	431a      	orrs	r2, r3
  4096b4:	687b      	ldr	r3, [r7, #4]
  4096b6:	601a      	str	r2, [r3, #0]
    out_data[1] = ((long)(0xff & in_data[4]) << 24) | ((long)(0xff & in_data[5]) << 16) | ((long)(0xff & in_data[6]) << 8) | (0xff & in_data[7]);
  4096b8:	687b      	ldr	r3, [r7, #4]
  4096ba:	3304      	adds	r3, #4
  4096bc:	683a      	ldr	r2, [r7, #0]
  4096be:	3204      	adds	r2, #4
  4096c0:	7812      	ldrb	r2, [r2, #0]
  4096c2:	0611      	lsls	r1, r2, #24
  4096c4:	683a      	ldr	r2, [r7, #0]
  4096c6:	3205      	adds	r2, #5
  4096c8:	7812      	ldrb	r2, [r2, #0]
  4096ca:	0412      	lsls	r2, r2, #16
  4096cc:	4311      	orrs	r1, r2
  4096ce:	683a      	ldr	r2, [r7, #0]
  4096d0:	3206      	adds	r2, #6
  4096d2:	7812      	ldrb	r2, [r2, #0]
  4096d4:	0212      	lsls	r2, r2, #8
  4096d6:	430a      	orrs	r2, r1
  4096d8:	6839      	ldr	r1, [r7, #0]
  4096da:	3107      	adds	r1, #7
  4096dc:	7809      	ldrb	r1, [r1, #0]
  4096de:	430a      	orrs	r2, r1
  4096e0:	601a      	str	r2, [r3, #0]
    out_data[2] = ((long)(0xff & in_data[8]) << 24) | ((long)(0xff & in_data[9]) << 16) | ((long)(0xff & in_data[10]) << 8) | (0xff & in_data[11]);
  4096e2:	687b      	ldr	r3, [r7, #4]
  4096e4:	3308      	adds	r3, #8
  4096e6:	683a      	ldr	r2, [r7, #0]
  4096e8:	3208      	adds	r2, #8
  4096ea:	7812      	ldrb	r2, [r2, #0]
  4096ec:	0611      	lsls	r1, r2, #24
  4096ee:	683a      	ldr	r2, [r7, #0]
  4096f0:	3209      	adds	r2, #9
  4096f2:	7812      	ldrb	r2, [r2, #0]
  4096f4:	0412      	lsls	r2, r2, #16
  4096f6:	4311      	orrs	r1, r2
  4096f8:	683a      	ldr	r2, [r7, #0]
  4096fa:	320a      	adds	r2, #10
  4096fc:	7812      	ldrb	r2, [r2, #0]
  4096fe:	0212      	lsls	r2, r2, #8
  409700:	430a      	orrs	r2, r1
  409702:	6839      	ldr	r1, [r7, #0]
  409704:	310b      	adds	r1, #11
  409706:	7809      	ldrb	r1, [r1, #0]
  409708:	430a      	orrs	r2, r1
  40970a:	601a      	str	r2, [r3, #0]
}
  40970c:	bf00      	nop
  40970e:	370c      	adds	r7, #12
  409710:	46bd      	mov	sp, r7
  409712:	f85d 7b04 	ldr.w	r7, [sp], #4
  409716:	4770      	bx	lr

00409718 <inv_decode_3_16bit_elements>:
static void inv_decode_3_16bit_elements(short *out_data, const unsigned char *in_data)
{
  409718:	b480      	push	{r7}
  40971a:	b083      	sub	sp, #12
  40971c:	af00      	add	r7, sp, #0
  40971e:	6078      	str	r0, [r7, #4]
  409720:	6039      	str	r1, [r7, #0]
    out_data[0] = ((short)(0xff & in_data[0]) << 8) | (0xff & in_data[1]);
  409722:	683b      	ldr	r3, [r7, #0]
  409724:	781b      	ldrb	r3, [r3, #0]
  409726:	021b      	lsls	r3, r3, #8
  409728:	b21a      	sxth	r2, r3
  40972a:	683b      	ldr	r3, [r7, #0]
  40972c:	3301      	adds	r3, #1
  40972e:	781b      	ldrb	r3, [r3, #0]
  409730:	b21b      	sxth	r3, r3
  409732:	4313      	orrs	r3, r2
  409734:	b21a      	sxth	r2, r3
  409736:	687b      	ldr	r3, [r7, #4]
  409738:	801a      	strh	r2, [r3, #0]
    out_data[1] = ((short)(0xff & in_data[2]) << 8) | (0xff & in_data[3]);
  40973a:	687b      	ldr	r3, [r7, #4]
  40973c:	3302      	adds	r3, #2
  40973e:	683a      	ldr	r2, [r7, #0]
  409740:	3202      	adds	r2, #2
  409742:	7812      	ldrb	r2, [r2, #0]
  409744:	0212      	lsls	r2, r2, #8
  409746:	b211      	sxth	r1, r2
  409748:	683a      	ldr	r2, [r7, #0]
  40974a:	3203      	adds	r2, #3
  40974c:	7812      	ldrb	r2, [r2, #0]
  40974e:	b212      	sxth	r2, r2
  409750:	430a      	orrs	r2, r1
  409752:	b212      	sxth	r2, r2
  409754:	801a      	strh	r2, [r3, #0]
    out_data[2] = ((short)(0xff & in_data[4]) << 8) | (0xff & in_data[5]);
  409756:	687b      	ldr	r3, [r7, #4]
  409758:	3304      	adds	r3, #4
  40975a:	683a      	ldr	r2, [r7, #0]
  40975c:	3204      	adds	r2, #4
  40975e:	7812      	ldrb	r2, [r2, #0]
  409760:	0212      	lsls	r2, r2, #8
  409762:	b211      	sxth	r1, r2
  409764:	683a      	ldr	r2, [r7, #0]
  409766:	3205      	adds	r2, #5
  409768:	7812      	ldrb	r2, [r2, #0]
  40976a:	b212      	sxth	r2, r2
  40976c:	430a      	orrs	r2, r1
  40976e:	b212      	sxth	r2, r2
  409770:	801a      	strh	r2, [r3, #0]
}
  409772:	bf00      	nop
  409774:	370c      	adds	r7, #12
  409776:	46bd      	mov	sp, r7
  409778:	f85d 7b04 	ldr.w	r7, [sp], #4
  40977c:	4770      	bx	lr
	...

00409780 <inv_icm20648_inv_decode_one_ivory_fifo_packet>:
* @param[in] fd Structure to be filled out with data. Assumes header and header2 are already set inside.
* @param[in] fifo_ptr FIFO data, points to just after any header information
* @return Returns the number of bytes consumed in FIFO data.
*/
int inv_icm20648_inv_decode_one_ivory_fifo_packet(struct inv_icm20648 * s, struct inv_fifo_decoded_t *fd, const unsigned char *fifo_ptr)
{
  409780:	b580      	push	{r7, lr}
  409782:	b086      	sub	sp, #24
  409784:	af00      	add	r7, sp, #0
  409786:	60f8      	str	r0, [r7, #12]
  409788:	60b9      	str	r1, [r7, #8]
  40978a:	607a      	str	r2, [r7, #4]
    const unsigned char *fifo_ptr_start = fifo_ptr;
  40978c:	687b      	ldr	r3, [r7, #4]
  40978e:	617b      	str	r3, [r7, #20]
	short odr_cntr;
    if (fd->header & ACCEL_SET) {
  409790:	68bb      	ldr	r3, [r7, #8]
  409792:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409796:	b21b      	sxth	r3, r3
  409798:	2b00      	cmp	r3, #0
  40979a:	da1a      	bge.n	4097d2 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x52>
        // do not cast data here, do that when you use it
        inv_decode_3_16bit_elements(fd->accel_s, fifo_ptr);
  40979c:	68bb      	ldr	r3, [r7, #8]
  40979e:	332c      	adds	r3, #44	; 0x2c
  4097a0:	6879      	ldr	r1, [r7, #4]
  4097a2:	4618      	mov	r0, r3
  4097a4:	4b9c      	ldr	r3, [pc, #624]	; (409a18 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x298>)
  4097a6:	4798      	blx	r3
        fd->accel[0] = fd->accel_s[0] << 15;
  4097a8:	68bb      	ldr	r3, [r7, #8]
  4097aa:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
  4097ae:	03da      	lsls	r2, r3, #15
  4097b0:	68bb      	ldr	r3, [r7, #8]
  4097b2:	635a      	str	r2, [r3, #52]	; 0x34
        fd->accel[1] = fd->accel_s[1] << 15;
  4097b4:	68bb      	ldr	r3, [r7, #8]
  4097b6:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
  4097ba:	03da      	lsls	r2, r3, #15
  4097bc:	68bb      	ldr	r3, [r7, #8]
  4097be:	639a      	str	r2, [r3, #56]	; 0x38
        fd->accel[2] = fd->accel_s[2] << 15;
  4097c0:	68bb      	ldr	r3, [r7, #8]
  4097c2:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
  4097c6:	03da      	lsls	r2, r3, #15
  4097c8:	68bb      	ldr	r3, [r7, #8]
  4097ca:	63da      	str	r2, [r3, #60]	; 0x3c
        fifo_ptr += ACCEL_DATA_SZ;
  4097cc:	687b      	ldr	r3, [r7, #4]
  4097ce:	3306      	adds	r3, #6
  4097d0:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & GYRO_SET) {
  4097d2:	68bb      	ldr	r3, [r7, #8]
  4097d4:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  4097d8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  4097dc:	2b00      	cmp	r3, #0
  4097de:	d011      	beq.n	409804 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x84>
        inv_decode_3_16bit_elements(fd->gyro, fifo_ptr);
  4097e0:	68bb      	ldr	r3, [r7, #8]
  4097e2:	3340      	adds	r3, #64	; 0x40
  4097e4:	6879      	ldr	r1, [r7, #4]
  4097e6:	4618      	mov	r0, r3
  4097e8:	4b8b      	ldr	r3, [pc, #556]	; (409a18 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x298>)
  4097ea:	4798      	blx	r3
        fifo_ptr += GYRO_DATA_SZ;
  4097ec:	687b      	ldr	r3, [r7, #4]
  4097ee:	3306      	adds	r3, #6
  4097f0:	607b      	str	r3, [r7, #4]
        inv_decode_3_16bit_elements(fd->gyro_bias, fifo_ptr);
  4097f2:	68bb      	ldr	r3, [r7, #8]
  4097f4:	3346      	adds	r3, #70	; 0x46
  4097f6:	6879      	ldr	r1, [r7, #4]
  4097f8:	4618      	mov	r0, r3
  4097fa:	4b87      	ldr	r3, [pc, #540]	; (409a18 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x298>)
  4097fc:	4798      	blx	r3
        fifo_ptr += GYRO_BIAS_DATA_SZ;
  4097fe:	687b      	ldr	r3, [r7, #4]
  409800:	3306      	adds	r3, #6
  409802:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & CPASS_SET) {
  409804:	68bb      	ldr	r3, [r7, #8]
  409806:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  40980a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40980e:	2b00      	cmp	r3, #0
  409810:	d018      	beq.n	409844 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0xc4>
        inv_decode_3_16bit_elements(fd->cpass_raw_data, fifo_ptr);
  409812:	68bb      	ldr	r3, [r7, #8]
  409814:	3374      	adds	r3, #116	; 0x74
  409816:	6879      	ldr	r1, [r7, #4]
  409818:	4618      	mov	r0, r3
  40981a:	4b7f      	ldr	r3, [pc, #508]	; (409a18 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x298>)
  40981c:	4798      	blx	r3
        inv_icm20648_apply_raw_compass_matrix(s, fd->cpass_raw_data, fd->compass);
  40981e:	68bb      	ldr	r3, [r7, #8]
  409820:	f103 0174 	add.w	r1, r3, #116	; 0x74
  409824:	68bb      	ldr	r3, [r7, #8]
  409826:	3358      	adds	r3, #88	; 0x58
  409828:	461a      	mov	r2, r3
  40982a:	68f8      	ldr	r0, [r7, #12]
  40982c:	4b7b      	ldr	r3, [pc, #492]	; (409a1c <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x29c>)
  40982e:	4798      	blx	r3
        memcpy( fd->cpass_calibr_6chars, fifo_ptr, 6*sizeof(unsigned char));
  409830:	68bb      	ldr	r3, [r7, #8]
  409832:	3394      	adds	r3, #148	; 0x94
  409834:	2206      	movs	r2, #6
  409836:	6879      	ldr	r1, [r7, #4]
  409838:	4618      	mov	r0, r3
  40983a:	4b79      	ldr	r3, [pc, #484]	; (409a20 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a0>)
  40983c:	4798      	blx	r3
        fifo_ptr += CPASS_DATA_SZ;
  40983e:	687b      	ldr	r3, [r7, #4]
  409840:	3306      	adds	r3, #6
  409842:	607b      	str	r3, [r7, #4]
    }

    if(fd->header & ALS_SET) {
  409844:	68bb      	ldr	r3, [r7, #8]
  409846:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  40984a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  40984e:	2b00      	cmp	r3, #0
  409850:	d002      	beq.n	409858 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0xd8>
        fifo_ptr += ALS_DATA_SZ;
  409852:	687b      	ldr	r3, [r7, #4]
  409854:	3308      	adds	r3, #8
  409856:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & QUAT6_SET) {
  409858:	68bb      	ldr	r3, [r7, #8]
  40985a:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  40985e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  409862:	2b00      	cmp	r3, #0
  409864:	d007      	beq.n	409876 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0xf6>
        inv_decode_3_32bit_elements(fd->dmp_3e_6quat, fifo_ptr);
  409866:	68bb      	ldr	r3, [r7, #8]
  409868:	6879      	ldr	r1, [r7, #4]
  40986a:	4618      	mov	r0, r3
  40986c:	4b6d      	ldr	r3, [pc, #436]	; (409a24 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a4>)
  40986e:	4798      	blx	r3
        fifo_ptr += QUAT6_DATA_SZ;
  409870:	687b      	ldr	r3, [r7, #4]
  409872:	330c      	adds	r3, #12
  409874:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & QUAT9_SET) {
  409876:	68bb      	ldr	r3, [r7, #8]
  409878:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  40987c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  409880:	2b00      	cmp	r3, #0
  409882:	d013      	beq.n	4098ac <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x12c>
        inv_decode_3_32bit_elements(fd->dmp_3e_9quat, fifo_ptr);
  409884:	68bb      	ldr	r3, [r7, #8]
  409886:	330c      	adds	r3, #12
  409888:	6879      	ldr	r1, [r7, #4]
  40988a:	4618      	mov	r0, r3
  40988c:	4b65      	ldr	r3, [pc, #404]	; (409a24 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a4>)
  40988e:	4798      	blx	r3
        fd->dmp_rv_accuracyQ29 = ((0xff & fifo_ptr[12]) << 24) | ((0xff & fifo_ptr[13]) << 16);
  409890:	687b      	ldr	r3, [r7, #4]
  409892:	330c      	adds	r3, #12
  409894:	781b      	ldrb	r3, [r3, #0]
  409896:	061a      	lsls	r2, r3, #24
  409898:	687b      	ldr	r3, [r7, #4]
  40989a:	330d      	adds	r3, #13
  40989c:	781b      	ldrb	r3, [r3, #0]
  40989e:	041b      	lsls	r3, r3, #16
  4098a0:	431a      	orrs	r2, r3
  4098a2:	68bb      	ldr	r3, [r7, #8]
  4098a4:	619a      	str	r2, [r3, #24]
        fifo_ptr += QUAT9_DATA_SZ;
  4098a6:	687b      	ldr	r3, [r7, #4]
  4098a8:	330e      	adds	r3, #14
  4098aa:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & PED_STEPDET_SET) {
  4098ac:	68bb      	ldr	r3, [r7, #8]
  4098ae:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  4098b2:	f003 0310 	and.w	r3, r3, #16
  4098b6:	2b00      	cmp	r3, #0
  4098b8:	d015      	beq.n	4098e6 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x166>
        fd->ped_step_det_ts = ((0xff & fifo_ptr[0]) << 24) | ((0xff & fifo_ptr[1]) << 16) | ((0xff & fifo_ptr[2]) << 8) | (0xff & fifo_ptr[3]);
  4098ba:	687b      	ldr	r3, [r7, #4]
  4098bc:	781b      	ldrb	r3, [r3, #0]
  4098be:	061a      	lsls	r2, r3, #24
  4098c0:	687b      	ldr	r3, [r7, #4]
  4098c2:	3301      	adds	r3, #1
  4098c4:	781b      	ldrb	r3, [r3, #0]
  4098c6:	041b      	lsls	r3, r3, #16
  4098c8:	431a      	orrs	r2, r3
  4098ca:	687b      	ldr	r3, [r7, #4]
  4098cc:	3302      	adds	r3, #2
  4098ce:	781b      	ldrb	r3, [r3, #0]
  4098d0:	021b      	lsls	r3, r3, #8
  4098d2:	4313      	orrs	r3, r2
  4098d4:	687a      	ldr	r2, [r7, #4]
  4098d6:	3203      	adds	r2, #3
  4098d8:	7812      	ldrb	r2, [r2, #0]
  4098da:	431a      	orrs	r2, r3
  4098dc:	68bb      	ldr	r3, [r7, #8]
  4098de:	671a      	str	r2, [r3, #112]	; 0x70
        fifo_ptr += PED_STEPDET_TIMESTAMP_SZ;
  4098e0:	687b      	ldr	r3, [r7, #4]
  4098e2:	3304      	adds	r3, #4
  4098e4:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & GEOMAG_SET) {
  4098e6:	68bb      	ldr	r3, [r7, #8]
  4098e8:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  4098ec:	f403 7380 	and.w	r3, r3, #256	; 0x100
  4098f0:	2b00      	cmp	r3, #0
  4098f2:	d013      	beq.n	40991c <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x19c>
        inv_decode_3_32bit_elements(fd->dmp_3e_geomagquat, fifo_ptr);
  4098f4:	68bb      	ldr	r3, [r7, #8]
  4098f6:	331c      	adds	r3, #28
  4098f8:	6879      	ldr	r1, [r7, #4]
  4098fa:	4618      	mov	r0, r3
  4098fc:	4b49      	ldr	r3, [pc, #292]	; (409a24 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a4>)
  4098fe:	4798      	blx	r3
        fd->dmp_geomag_accuracyQ29 = ((0xff & fifo_ptr[12]) << 24) | ((0xff & fifo_ptr[13]) << 16);
  409900:	687b      	ldr	r3, [r7, #4]
  409902:	330c      	adds	r3, #12
  409904:	781b      	ldrb	r3, [r3, #0]
  409906:	061a      	lsls	r2, r3, #24
  409908:	687b      	ldr	r3, [r7, #4]
  40990a:	330d      	adds	r3, #13
  40990c:	781b      	ldrb	r3, [r3, #0]
  40990e:	041b      	lsls	r3, r3, #16
  409910:	431a      	orrs	r2, r3
  409912:	68bb      	ldr	r3, [r7, #8]
  409914:	629a      	str	r2, [r3, #40]	; 0x28
        fifo_ptr += GEOMAG_DATA_SZ;
  409916:	687b      	ldr	r3, [r7, #4]
  409918:	330e      	adds	r3, #14
  40991a:	607b      	str	r3, [r7, #4]
    }

    if(fd->header & PRESSURE_SET) {
  40991c:	68bb      	ldr	r3, [r7, #8]
  40991e:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409922:	f003 0380 	and.w	r3, r3, #128	; 0x80
  409926:	2b00      	cmp	r3, #0
  409928:	d002      	beq.n	409930 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x1b0>
        fifo_ptr += PRESSURE_DATA_SZ;
  40992a:	687b      	ldr	r3, [r7, #4]
  40992c:	3306      	adds	r3, #6
  40992e:	607b      	str	r3, [r7, #4]
    }
    if (fd->header & CPASS_CALIBR_SET) {
  409930:	68bb      	ldr	r3, [r7, #8]
  409932:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409936:	f003 0320 	and.w	r3, r3, #32
  40993a:	2b00      	cmp	r3, #0
  40993c:	d00f      	beq.n	40995e <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x1de>
        inv_decode_3_32bit_elements(fd->cpass_calibr, fifo_ptr);
  40993e:	68bb      	ldr	r3, [r7, #8]
  409940:	3364      	adds	r3, #100	; 0x64
  409942:	6879      	ldr	r1, [r7, #4]
  409944:	4618      	mov	r0, r3
  409946:	4b37      	ldr	r3, [pc, #220]	; (409a24 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a4>)
  409948:	4798      	blx	r3
        memcpy( fd->cpass_calibr_12chars, fifo_ptr, 12*sizeof(unsigned char));
  40994a:	68bb      	ldr	r3, [r7, #8]
  40994c:	3388      	adds	r3, #136	; 0x88
  40994e:	220c      	movs	r2, #12
  409950:	6879      	ldr	r1, [r7, #4]
  409952:	4618      	mov	r0, r3
  409954:	4b32      	ldr	r3, [pc, #200]	; (409a20 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a0>)
  409956:	4798      	blx	r3
        fifo_ptr += CPASS_CALIBR_DATA_SZ;
  409958:	687b      	ldr	r3, [r7, #4]
  40995a:	330c      	adds	r3, #12
  40995c:	607b      	str	r3, [r7, #4]
    }

    if (fd->header2 & ACCEL_ACCURACY_SET) {
  40995e:	68bb      	ldr	r3, [r7, #8]
  409960:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  409964:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  409968:	2b00      	cmp	r3, #0
  40996a:	d00f      	beq.n	40998c <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x20c>
        fd->accel_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  40996c:	687b      	ldr	r3, [r7, #4]
  40996e:	781b      	ldrb	r3, [r3, #0]
  409970:	021b      	lsls	r3, r3, #8
  409972:	b21a      	sxth	r2, r3
  409974:	687b      	ldr	r3, [r7, #4]
  409976:	3301      	adds	r3, #1
  409978:	781b      	ldrb	r3, [r3, #0]
  40997a:	b21b      	sxth	r3, r3
  40997c:	4313      	orrs	r3, r2
  40997e:	b21a      	sxth	r2, r3
  409980:	68bb      	ldr	r3, [r7, #8]
  409982:	f8a3 207a 	strh.w	r2, [r3, #122]	; 0x7a
        fifo_ptr += ACCEL_ACCURACY_SZ;
  409986:	687b      	ldr	r3, [r7, #4]
  409988:	3302      	adds	r3, #2
  40998a:	607b      	str	r3, [r7, #4]
    }

    if (fd->header2 & GYRO_ACCURACY_SET) {
  40998c:	68bb      	ldr	r3, [r7, #8]
  40998e:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  409992:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  409996:	2b00      	cmp	r3, #0
  409998:	d00f      	beq.n	4099ba <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x23a>
        fd->gyro_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  40999a:	687b      	ldr	r3, [r7, #4]
  40999c:	781b      	ldrb	r3, [r3, #0]
  40999e:	021b      	lsls	r3, r3, #8
  4099a0:	b21a      	sxth	r2, r3
  4099a2:	687b      	ldr	r3, [r7, #4]
  4099a4:	3301      	adds	r3, #1
  4099a6:	781b      	ldrb	r3, [r3, #0]
  4099a8:	b21b      	sxth	r3, r3
  4099aa:	4313      	orrs	r3, r2
  4099ac:	b21a      	sxth	r2, r3
  4099ae:	68bb      	ldr	r3, [r7, #8]
  4099b0:	f8a3 207c 	strh.w	r2, [r3, #124]	; 0x7c
        fifo_ptr += GYRO_ACCURACY_SZ;
  4099b4:	687b      	ldr	r3, [r7, #4]
  4099b6:	3302      	adds	r3, #2
  4099b8:	607b      	str	r3, [r7, #4]
    }

    if (fd->header2 & CPASS_ACCURACY_SET) {
  4099ba:	68bb      	ldr	r3, [r7, #8]
  4099bc:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  4099c0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  4099c4:	2b00      	cmp	r3, #0
  4099c6:	d00f      	beq.n	4099e8 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x268>
        fd->cpass_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  4099c8:	687b      	ldr	r3, [r7, #4]
  4099ca:	781b      	ldrb	r3, [r3, #0]
  4099cc:	021b      	lsls	r3, r3, #8
  4099ce:	b21a      	sxth	r2, r3
  4099d0:	687b      	ldr	r3, [r7, #4]
  4099d2:	3301      	adds	r3, #1
  4099d4:	781b      	ldrb	r3, [r3, #0]
  4099d6:	b21b      	sxth	r3, r3
  4099d8:	4313      	orrs	r3, r2
  4099da:	b21a      	sxth	r2, r3
  4099dc:	68bb      	ldr	r3, [r7, #8]
  4099de:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
        fifo_ptr += CPASS_ACCURACY_SZ;
  4099e2:	687b      	ldr	r3, [r7, #4]
  4099e4:	3302      	adds	r3, #2
  4099e6:	607b      	str	r3, [r7, #4]
    }

	if (fd->header2 & FLIP_PICKUP_SET) {
  4099e8:	68bb      	ldr	r3, [r7, #8]
  4099ea:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  4099ee:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  4099f2:	2b00      	cmp	r3, #0
  4099f4:	d018      	beq.n	409a28 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a8>
		fd->flip_pickup = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  4099f6:	687b      	ldr	r3, [r7, #4]
  4099f8:	781b      	ldrb	r3, [r3, #0]
  4099fa:	021b      	lsls	r3, r3, #8
  4099fc:	b21a      	sxth	r2, r3
  4099fe:	687b      	ldr	r3, [r7, #4]
  409a00:	3301      	adds	r3, #1
  409a02:	781b      	ldrb	r3, [r3, #0]
  409a04:	b21b      	sxth	r3, r3
  409a06:	4313      	orrs	r3, r2
  409a08:	b21a      	sxth	r2, r3
  409a0a:	68bb      	ldr	r3, [r7, #8]
  409a0c:	f8a3 2086 	strh.w	r2, [r3, #134]	; 0x86
		fifo_ptr += FLIP_PICKUP_SZ;
  409a10:	687b      	ldr	r3, [r7, #4]
  409a12:	3302      	adds	r3, #2
  409a14:	607b      	str	r3, [r7, #4]
  409a16:	e007      	b.n	409a28 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x2a8>
  409a18:	00409719 	.word	0x00409719
  409a1c:	0040564d 	.word	0x0040564d
  409a20:	00414235 	.word	0x00414235
  409a24:	00409689 	.word	0x00409689
	}

	if (fd->header2 & ACT_RECOG_SET) {
  409a28:	68bb      	ldr	r3, [r7, #8]
  409a2a:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  409a2e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  409a32:	2b00      	cmp	r3, #0
  409a34:	d025      	beq.n	409a82 <inv_icm20648_inv_decode_one_ivory_fifo_packet+0x302>
		fd->bac_state = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  409a36:	687b      	ldr	r3, [r7, #4]
  409a38:	781b      	ldrb	r3, [r3, #0]
  409a3a:	021b      	lsls	r3, r3, #8
  409a3c:	b21a      	sxth	r2, r3
  409a3e:	687b      	ldr	r3, [r7, #4]
  409a40:	3301      	adds	r3, #1
  409a42:	781b      	ldrb	r3, [r3, #0]
  409a44:	b21b      	sxth	r3, r3
  409a46:	4313      	orrs	r3, r2
  409a48:	b21b      	sxth	r3, r3
  409a4a:	b29a      	uxth	r2, r3
  409a4c:	68bb      	ldr	r3, [r7, #8]
  409a4e:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
		fd->bac_ts     = ((0xff & fifo_ptr[2]) << 24) | ((0xff & fifo_ptr[3]) << 16) | ((0xff & fifo_ptr[4]) << 8) | (0xff & fifo_ptr[5]);
  409a52:	687b      	ldr	r3, [r7, #4]
  409a54:	3302      	adds	r3, #2
  409a56:	781b      	ldrb	r3, [r3, #0]
  409a58:	061a      	lsls	r2, r3, #24
  409a5a:	687b      	ldr	r3, [r7, #4]
  409a5c:	3303      	adds	r3, #3
  409a5e:	781b      	ldrb	r3, [r3, #0]
  409a60:	041b      	lsls	r3, r3, #16
  409a62:	431a      	orrs	r2, r3
  409a64:	687b      	ldr	r3, [r7, #4]
  409a66:	3304      	adds	r3, #4
  409a68:	781b      	ldrb	r3, [r3, #0]
  409a6a:	021b      	lsls	r3, r3, #8
  409a6c:	4313      	orrs	r3, r2
  409a6e:	687a      	ldr	r2, [r7, #4]
  409a70:	3205      	adds	r2, #5
  409a72:	7812      	ldrb	r2, [r2, #0]
  409a74:	431a      	orrs	r2, r3
  409a76:	68bb      	ldr	r3, [r7, #8]
  409a78:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		fifo_ptr += ACT_RECOG_SZ;
  409a7c:	687b      	ldr	r3, [r7, #4]
  409a7e:	3306      	adds	r3, #6
  409a80:	607b      	str	r3, [r7, #4]
	}

	odr_cntr = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  409a82:	687b      	ldr	r3, [r7, #4]
  409a84:	781b      	ldrb	r3, [r3, #0]
  409a86:	021b      	lsls	r3, r3, #8
  409a88:	b21a      	sxth	r2, r3
  409a8a:	687b      	ldr	r3, [r7, #4]
  409a8c:	3301      	adds	r3, #1
  409a8e:	781b      	ldrb	r3, [r3, #0]
  409a90:	b21b      	sxth	r3, r3
  409a92:	4313      	orrs	r3, r2
  409a94:	827b      	strh	r3, [r7, #18]
	// odr_cntr_gyro is odr_cntr & 0xfff
	// 9KHz cnt is odr_cntr >> 12
	// not used for now, needed only for FSYNC purpose
	(void)odr_cntr;
	fifo_ptr += FOOTER_SZ;
  409a96:	687b      	ldr	r3, [r7, #4]
  409a98:	3302      	adds	r3, #2
  409a9a:	607b      	str	r3, [r7, #4]

    fd->new_data = 1; // Record a new data set
  409a9c:	68bb      	ldr	r3, [r7, #8]
  409a9e:	2201      	movs	r2, #1
  409aa0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

    return fifo_ptr-fifo_ptr_start;
  409aa4:	687a      	ldr	r2, [r7, #4]
  409aa6:	697b      	ldr	r3, [r7, #20]
  409aa8:	1ad3      	subs	r3, r2, r3
}
  409aaa:	4618      	mov	r0, r3
  409aac:	3718      	adds	r7, #24
  409aae:	46bd      	mov	sp, r7
  409ab0:	bd80      	pop	{r7, pc}
  409ab2:	bf00      	nop

00409ab4 <inv_icm20648_dmp_get_accel>:

int inv_icm20648_dmp_get_accel(long acl[3])
{
  409ab4:	b580      	push	{r7, lr}
  409ab6:	b082      	sub	sp, #8
  409ab8:	af00      	add	r7, sp, #0
  409aba:	6078      	str	r0, [r7, #4]
    if(!acl) return -1;
  409abc:	687b      	ldr	r3, [r7, #4]
  409abe:	2b00      	cmp	r3, #0
  409ac0:	d102      	bne.n	409ac8 <inv_icm20648_dmp_get_accel+0x14>
  409ac2:	f04f 33ff 	mov.w	r3, #4294967295
  409ac6:	e005      	b.n	409ad4 <inv_icm20648_dmp_get_accel+0x20>
    memcpy( acl, fd.accel, 3*sizeof(long));
  409ac8:	220c      	movs	r2, #12
  409aca:	4904      	ldr	r1, [pc, #16]	; (409adc <inv_icm20648_dmp_get_accel+0x28>)
  409acc:	6878      	ldr	r0, [r7, #4]
  409ace:	4b04      	ldr	r3, [pc, #16]	; (409ae0 <inv_icm20648_dmp_get_accel+0x2c>)
  409ad0:	4798      	blx	r3
    return MPU_SUCCESS;
  409ad2:	2300      	movs	r3, #0
}
  409ad4:	4618      	mov	r0, r3
  409ad6:	3708      	adds	r7, #8
  409ad8:	46bd      	mov	sp, r7
  409ada:	bd80      	pop	{r7, pc}
  409adc:	20001f10 	.word	0x20001f10
  409ae0:	00414235 	.word	0x00414235

00409ae4 <inv_icm20648_dmp_get_raw_gyro>:

int inv_icm20648_dmp_get_raw_gyro(short raw_gyro[3])
{
  409ae4:	b480      	push	{r7}
  409ae6:	b083      	sub	sp, #12
  409ae8:	af00      	add	r7, sp, #0
  409aea:	6078      	str	r0, [r7, #4]
    if(!raw_gyro) return -1;
  409aec:	687b      	ldr	r3, [r7, #4]
  409aee:	2b00      	cmp	r3, #0
  409af0:	d102      	bne.n	409af8 <inv_icm20648_dmp_get_raw_gyro+0x14>
  409af2:	f04f 33ff 	mov.w	r3, #4294967295
  409af6:	e011      	b.n	409b1c <inv_icm20648_dmp_get_raw_gyro+0x38>
    raw_gyro[0] = fd.gyro[0];
  409af8:	4b0b      	ldr	r3, [pc, #44]	; (409b28 <inv_icm20648_dmp_get_raw_gyro+0x44>)
  409afa:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
  409afe:	687b      	ldr	r3, [r7, #4]
  409b00:	801a      	strh	r2, [r3, #0]
    raw_gyro[1] = fd.gyro[1];
  409b02:	687b      	ldr	r3, [r7, #4]
  409b04:	3302      	adds	r3, #2
  409b06:	4a08      	ldr	r2, [pc, #32]	; (409b28 <inv_icm20648_dmp_get_raw_gyro+0x44>)
  409b08:	f9b2 2042 	ldrsh.w	r2, [r2, #66]	; 0x42
  409b0c:	801a      	strh	r2, [r3, #0]
    raw_gyro[2] = fd.gyro[2];
  409b0e:	687b      	ldr	r3, [r7, #4]
  409b10:	3304      	adds	r3, #4
  409b12:	4a05      	ldr	r2, [pc, #20]	; (409b28 <inv_icm20648_dmp_get_raw_gyro+0x44>)
  409b14:	f9b2 2044 	ldrsh.w	r2, [r2, #68]	; 0x44
  409b18:	801a      	strh	r2, [r3, #0]
    return MPU_SUCCESS;
  409b1a:	2300      	movs	r3, #0
}
  409b1c:	4618      	mov	r0, r3
  409b1e:	370c      	adds	r7, #12
  409b20:	46bd      	mov	sp, r7
  409b22:	f85d 7b04 	ldr.w	r7, [sp], #4
  409b26:	4770      	bx	lr
  409b28:	20001edc 	.word	0x20001edc

00409b2c <inv_icm20648_dmp_get_gyro_bias>:


int inv_icm20648_dmp_get_gyro_bias(short gyro_bias[3])
{
  409b2c:	b580      	push	{r7, lr}
  409b2e:	b082      	sub	sp, #8
  409b30:	af00      	add	r7, sp, #0
  409b32:	6078      	str	r0, [r7, #4]
    if(!gyro_bias) return -1;
  409b34:	687b      	ldr	r3, [r7, #4]
  409b36:	2b00      	cmp	r3, #0
  409b38:	d102      	bne.n	409b40 <inv_icm20648_dmp_get_gyro_bias+0x14>
  409b3a:	f04f 33ff 	mov.w	r3, #4294967295
  409b3e:	e005      	b.n	409b4c <inv_icm20648_dmp_get_gyro_bias+0x20>
    memcpy(gyro_bias, fd.gyro_bias, 3*sizeof(short));
  409b40:	2206      	movs	r2, #6
  409b42:	4904      	ldr	r1, [pc, #16]	; (409b54 <inv_icm20648_dmp_get_gyro_bias+0x28>)
  409b44:	6878      	ldr	r0, [r7, #4]
  409b46:	4b04      	ldr	r3, [pc, #16]	; (409b58 <inv_icm20648_dmp_get_gyro_bias+0x2c>)
  409b48:	4798      	blx	r3
    return MPU_SUCCESS;
  409b4a:	2300      	movs	r3, #0
}
  409b4c:	4618      	mov	r0, r3
  409b4e:	3708      	adds	r7, #8
  409b50:	46bd      	mov	sp, r7
  409b52:	bd80      	pop	{r7, pc}
  409b54:	20001f22 	.word	0x20001f22
  409b58:	00414235 	.word	0x00414235

00409b5c <inv_icm20648_dmp_get_calibrated_gyro>:


int inv_icm20648_dmp_get_calibrated_gyro(signed long calibratedData[3], signed long raw[3], signed long bias[3])
{
  409b5c:	b480      	push	{r7}
  409b5e:	b085      	sub	sp, #20
  409b60:	af00      	add	r7, sp, #0
  409b62:	60f8      	str	r0, [r7, #12]
  409b64:	60b9      	str	r1, [r7, #8]
  409b66:	607a      	str	r2, [r7, #4]
    if(!calibratedData) return -1;
  409b68:	68fb      	ldr	r3, [r7, #12]
  409b6a:	2b00      	cmp	r3, #0
  409b6c:	d102      	bne.n	409b74 <inv_icm20648_dmp_get_calibrated_gyro+0x18>
  409b6e:	f04f 33ff 	mov.w	r3, #4294967295
  409b72:	e027      	b.n	409bc4 <inv_icm20648_dmp_get_calibrated_gyro+0x68>
    if(!raw) return -1;
  409b74:	68bb      	ldr	r3, [r7, #8]
  409b76:	2b00      	cmp	r3, #0
  409b78:	d102      	bne.n	409b80 <inv_icm20648_dmp_get_calibrated_gyro+0x24>
  409b7a:	f04f 33ff 	mov.w	r3, #4294967295
  409b7e:	e021      	b.n	409bc4 <inv_icm20648_dmp_get_calibrated_gyro+0x68>
    if(!bias) return -1;
  409b80:	687b      	ldr	r3, [r7, #4]
  409b82:	2b00      	cmp	r3, #0
  409b84:	d102      	bne.n	409b8c <inv_icm20648_dmp_get_calibrated_gyro+0x30>
  409b86:	f04f 33ff 	mov.w	r3, #4294967295
  409b8a:	e01b      	b.n	409bc4 <inv_icm20648_dmp_get_calibrated_gyro+0x68>

    calibratedData[0] = raw[0] - bias[0];
  409b8c:	68bb      	ldr	r3, [r7, #8]
  409b8e:	681a      	ldr	r2, [r3, #0]
  409b90:	687b      	ldr	r3, [r7, #4]
  409b92:	681b      	ldr	r3, [r3, #0]
  409b94:	1ad2      	subs	r2, r2, r3
  409b96:	68fb      	ldr	r3, [r7, #12]
  409b98:	601a      	str	r2, [r3, #0]
    calibratedData[1] = raw[1] - bias[1];
  409b9a:	68fb      	ldr	r3, [r7, #12]
  409b9c:	3304      	adds	r3, #4
  409b9e:	68ba      	ldr	r2, [r7, #8]
  409ba0:	3204      	adds	r2, #4
  409ba2:	6811      	ldr	r1, [r2, #0]
  409ba4:	687a      	ldr	r2, [r7, #4]
  409ba6:	3204      	adds	r2, #4
  409ba8:	6812      	ldr	r2, [r2, #0]
  409baa:	1a8a      	subs	r2, r1, r2
  409bac:	601a      	str	r2, [r3, #0]
    calibratedData[2] = raw[2] - bias[2];
  409bae:	68fb      	ldr	r3, [r7, #12]
  409bb0:	3308      	adds	r3, #8
  409bb2:	68ba      	ldr	r2, [r7, #8]
  409bb4:	3208      	adds	r2, #8
  409bb6:	6811      	ldr	r1, [r2, #0]
  409bb8:	687a      	ldr	r2, [r7, #4]
  409bba:	3208      	adds	r2, #8
  409bbc:	6812      	ldr	r2, [r2, #0]
  409bbe:	1a8a      	subs	r2, r1, r2
  409bc0:	601a      	str	r2, [r3, #0]

    return MPU_SUCCESS;
  409bc2:	2300      	movs	r3, #0
}
  409bc4:	4618      	mov	r0, r3
  409bc6:	3714      	adds	r7, #20
  409bc8:	46bd      	mov	sp, r7
  409bca:	f85d 7b04 	ldr.w	r7, [sp], #4
  409bce:	4770      	bx	lr

00409bd0 <inv_icm20648_dmp_get_6quaternion>:

int inv_icm20648_dmp_get_6quaternion(long quat[3])
{
  409bd0:	b580      	push	{r7, lr}
  409bd2:	b082      	sub	sp, #8
  409bd4:	af00      	add	r7, sp, #0
  409bd6:	6078      	str	r0, [r7, #4]
    if(!quat) return -1;
  409bd8:	687b      	ldr	r3, [r7, #4]
  409bda:	2b00      	cmp	r3, #0
  409bdc:	d102      	bne.n	409be4 <inv_icm20648_dmp_get_6quaternion+0x14>
  409bde:	f04f 33ff 	mov.w	r3, #4294967295
  409be2:	e005      	b.n	409bf0 <inv_icm20648_dmp_get_6quaternion+0x20>
    memcpy( quat, fd.dmp_3e_6quat, sizeof(fd.dmp_3e_6quat));
  409be4:	220c      	movs	r2, #12
  409be6:	4904      	ldr	r1, [pc, #16]	; (409bf8 <inv_icm20648_dmp_get_6quaternion+0x28>)
  409be8:	6878      	ldr	r0, [r7, #4]
  409bea:	4b04      	ldr	r3, [pc, #16]	; (409bfc <inv_icm20648_dmp_get_6quaternion+0x2c>)
  409bec:	4798      	blx	r3
    return MPU_SUCCESS;
  409bee:	2300      	movs	r3, #0
}
  409bf0:	4618      	mov	r0, r3
  409bf2:	3708      	adds	r7, #8
  409bf4:	46bd      	mov	sp, r7
  409bf6:	bd80      	pop	{r7, pc}
  409bf8:	20001edc 	.word	0x20001edc
  409bfc:	00414235 	.word	0x00414235

00409c00 <inv_icm20648_dmp_get_9quaternion>:

int inv_icm20648_dmp_get_9quaternion(long quat[3])
{
  409c00:	b580      	push	{r7, lr}
  409c02:	b082      	sub	sp, #8
  409c04:	af00      	add	r7, sp, #0
  409c06:	6078      	str	r0, [r7, #4]
    if(!quat) return -1;
  409c08:	687b      	ldr	r3, [r7, #4]
  409c0a:	2b00      	cmp	r3, #0
  409c0c:	d102      	bne.n	409c14 <inv_icm20648_dmp_get_9quaternion+0x14>
  409c0e:	f04f 33ff 	mov.w	r3, #4294967295
  409c12:	e005      	b.n	409c20 <inv_icm20648_dmp_get_9quaternion+0x20>
    memcpy( quat, fd.dmp_3e_9quat, sizeof(fd.dmp_3e_9quat));
  409c14:	220c      	movs	r2, #12
  409c16:	4904      	ldr	r1, [pc, #16]	; (409c28 <inv_icm20648_dmp_get_9quaternion+0x28>)
  409c18:	6878      	ldr	r0, [r7, #4]
  409c1a:	4b04      	ldr	r3, [pc, #16]	; (409c2c <inv_icm20648_dmp_get_9quaternion+0x2c>)
  409c1c:	4798      	blx	r3
    return MPU_SUCCESS;
  409c1e:	2300      	movs	r3, #0
}
  409c20:	4618      	mov	r0, r3
  409c22:	3708      	adds	r7, #8
  409c24:	46bd      	mov	sp, r7
  409c26:	bd80      	pop	{r7, pc}
  409c28:	20001ee8 	.word	0x20001ee8
  409c2c:	00414235 	.word	0x00414235

00409c30 <inv_icm20648_dmp_get_gmrvquaternion>:

int inv_icm20648_dmp_get_gmrvquaternion(long quat[3])
{
  409c30:	b580      	push	{r7, lr}
  409c32:	b082      	sub	sp, #8
  409c34:	af00      	add	r7, sp, #0
  409c36:	6078      	str	r0, [r7, #4]
    if(!quat) return -1;
  409c38:	687b      	ldr	r3, [r7, #4]
  409c3a:	2b00      	cmp	r3, #0
  409c3c:	d102      	bne.n	409c44 <inv_icm20648_dmp_get_gmrvquaternion+0x14>
  409c3e:	f04f 33ff 	mov.w	r3, #4294967295
  409c42:	e005      	b.n	409c50 <inv_icm20648_dmp_get_gmrvquaternion+0x20>
    memcpy( quat, fd.dmp_3e_geomagquat, sizeof(fd.dmp_3e_geomagquat));
  409c44:	220c      	movs	r2, #12
  409c46:	4904      	ldr	r1, [pc, #16]	; (409c58 <inv_icm20648_dmp_get_gmrvquaternion+0x28>)
  409c48:	6878      	ldr	r0, [r7, #4]
  409c4a:	4b04      	ldr	r3, [pc, #16]	; (409c5c <inv_icm20648_dmp_get_gmrvquaternion+0x2c>)
  409c4c:	4798      	blx	r3
    return MPU_SUCCESS;
  409c4e:	2300      	movs	r3, #0
}
  409c50:	4618      	mov	r0, r3
  409c52:	3708      	adds	r7, #8
  409c54:	46bd      	mov	sp, r7
  409c56:	bd80      	pop	{r7, pc}
  409c58:	20001ef8 	.word	0x20001ef8
  409c5c:	00414235 	.word	0x00414235

00409c60 <inv_icm20648_dmp_get_raw_compass>:

int inv_icm20648_dmp_get_raw_compass(long raw_compass[3])
{
  409c60:	b580      	push	{r7, lr}
  409c62:	b082      	sub	sp, #8
  409c64:	af00      	add	r7, sp, #0
  409c66:	6078      	str	r0, [r7, #4]
    if(!raw_compass) return -1;
  409c68:	687b      	ldr	r3, [r7, #4]
  409c6a:	2b00      	cmp	r3, #0
  409c6c:	d102      	bne.n	409c74 <inv_icm20648_dmp_get_raw_compass+0x14>
  409c6e:	f04f 33ff 	mov.w	r3, #4294967295
  409c72:	e005      	b.n	409c80 <inv_icm20648_dmp_get_raw_compass+0x20>
    memcpy( raw_compass, fd.compass, 3*sizeof(long));
  409c74:	220c      	movs	r2, #12
  409c76:	4904      	ldr	r1, [pc, #16]	; (409c88 <inv_icm20648_dmp_get_raw_compass+0x28>)
  409c78:	6878      	ldr	r0, [r7, #4]
  409c7a:	4b04      	ldr	r3, [pc, #16]	; (409c8c <inv_icm20648_dmp_get_raw_compass+0x2c>)
  409c7c:	4798      	blx	r3
    return MPU_SUCCESS;
  409c7e:	2300      	movs	r3, #0
}
  409c80:	4618      	mov	r0, r3
  409c82:	3708      	adds	r7, #8
  409c84:	46bd      	mov	sp, r7
  409c86:	bd80      	pop	{r7, pc}
  409c88:	20001f34 	.word	0x20001f34
  409c8c:	00414235 	.word	0x00414235

00409c90 <inv_icm20648_dmp_get_calibrated_compass>:

int inv_icm20648_dmp_get_calibrated_compass(long cal_compass[3])
{
  409c90:	b580      	push	{r7, lr}
  409c92:	b082      	sub	sp, #8
  409c94:	af00      	add	r7, sp, #0
  409c96:	6078      	str	r0, [r7, #4]
    if(!cal_compass) return -1;
  409c98:	687b      	ldr	r3, [r7, #4]
  409c9a:	2b00      	cmp	r3, #0
  409c9c:	d102      	bne.n	409ca4 <inv_icm20648_dmp_get_calibrated_compass+0x14>
  409c9e:	f04f 33ff 	mov.w	r3, #4294967295
  409ca2:	e005      	b.n	409cb0 <inv_icm20648_dmp_get_calibrated_compass+0x20>
    memcpy( cal_compass, fd.cpass_calibr, 3*sizeof(long));
  409ca4:	220c      	movs	r2, #12
  409ca6:	4904      	ldr	r1, [pc, #16]	; (409cb8 <inv_icm20648_dmp_get_calibrated_compass+0x28>)
  409ca8:	6878      	ldr	r0, [r7, #4]
  409caa:	4b04      	ldr	r3, [pc, #16]	; (409cbc <inv_icm20648_dmp_get_calibrated_compass+0x2c>)
  409cac:	4798      	blx	r3
    return MPU_SUCCESS;
  409cae:	2300      	movs	r3, #0
}
  409cb0:	4618      	mov	r0, r3
  409cb2:	3708      	adds	r7, #8
  409cb4:	46bd      	mov	sp, r7
  409cb6:	bd80      	pop	{r7, pc}
  409cb8:	20001f40 	.word	0x20001f40
  409cbc:	00414235 	.word	0x00414235

00409cc0 <inv_icm20648_dmp_get_bac_state>:

int inv_icm20648_dmp_get_bac_state(uint16_t *bac_state)
{
  409cc0:	b480      	push	{r7}
  409cc2:	b083      	sub	sp, #12
  409cc4:	af00      	add	r7, sp, #0
  409cc6:	6078      	str	r0, [r7, #4]
	if(!bac_state) return -1;
  409cc8:	687b      	ldr	r3, [r7, #4]
  409cca:	2b00      	cmp	r3, #0
  409ccc:	d102      	bne.n	409cd4 <inv_icm20648_dmp_get_bac_state+0x14>
  409cce:	f04f 33ff 	mov.w	r3, #4294967295
  409cd2:	e005      	b.n	409ce0 <inv_icm20648_dmp_get_bac_state+0x20>
	*bac_state = fd.bac_state;
  409cd4:	4b05      	ldr	r3, [pc, #20]	; (409cec <inv_icm20648_dmp_get_bac_state+0x2c>)
  409cd6:	f8b3 2084 	ldrh.w	r2, [r3, #132]	; 0x84
  409cda:	687b      	ldr	r3, [r7, #4]
  409cdc:	801a      	strh	r2, [r3, #0]
	return 0;
  409cde:	2300      	movs	r3, #0
}
  409ce0:	4618      	mov	r0, r3
  409ce2:	370c      	adds	r7, #12
  409ce4:	46bd      	mov	sp, r7
  409ce6:	f85d 7b04 	ldr.w	r7, [sp], #4
  409cea:	4770      	bx	lr
  409cec:	20001edc 	.word	0x20001edc

00409cf0 <inv_icm20648_dmp_get_bac_ts>:

int inv_icm20648_dmp_get_bac_ts(long *bac_ts)
{
  409cf0:	b480      	push	{r7}
  409cf2:	b083      	sub	sp, #12
  409cf4:	af00      	add	r7, sp, #0
  409cf6:	6078      	str	r0, [r7, #4]
	if(!bac_ts) return -1;
  409cf8:	687b      	ldr	r3, [r7, #4]
  409cfa:	2b00      	cmp	r3, #0
  409cfc:	d102      	bne.n	409d04 <inv_icm20648_dmp_get_bac_ts+0x14>
  409cfe:	f04f 33ff 	mov.w	r3, #4294967295
  409d02:	e005      	b.n	409d10 <inv_icm20648_dmp_get_bac_ts+0x20>
	*bac_ts = fd.bac_ts;
  409d04:	4b05      	ldr	r3, [pc, #20]	; (409d1c <inv_icm20648_dmp_get_bac_ts+0x2c>)
  409d06:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
  409d0a:	687b      	ldr	r3, [r7, #4]
  409d0c:	601a      	str	r2, [r3, #0]
	return 0;
  409d0e:	2300      	movs	r3, #0
}
  409d10:	4618      	mov	r0, r3
  409d12:	370c      	adds	r7, #12
  409d14:	46bd      	mov	sp, r7
  409d16:	f85d 7b04 	ldr.w	r7, [sp], #4
  409d1a:	4770      	bx	lr
  409d1c:	20001edc 	.word	0x20001edc

00409d20 <inv_icm20648_dmp_get_flip_pickup_state>:

int inv_icm20648_dmp_get_flip_pickup_state(uint16_t *flip_pickup)
{
  409d20:	b480      	push	{r7}
  409d22:	b083      	sub	sp, #12
  409d24:	af00      	add	r7, sp, #0
  409d26:	6078      	str	r0, [r7, #4]
	if(!flip_pickup) return -1;
  409d28:	687b      	ldr	r3, [r7, #4]
  409d2a:	2b00      	cmp	r3, #0
  409d2c:	d102      	bne.n	409d34 <inv_icm20648_dmp_get_flip_pickup_state+0x14>
  409d2e:	f04f 33ff 	mov.w	r3, #4294967295
  409d32:	e006      	b.n	409d42 <inv_icm20648_dmp_get_flip_pickup_state+0x22>
	*flip_pickup = fd.flip_pickup;
  409d34:	4b06      	ldr	r3, [pc, #24]	; (409d50 <inv_icm20648_dmp_get_flip_pickup_state+0x30>)
  409d36:	f9b3 3086 	ldrsh.w	r3, [r3, #134]	; 0x86
  409d3a:	b29a      	uxth	r2, r3
  409d3c:	687b      	ldr	r3, [r7, #4]
  409d3e:	801a      	strh	r2, [r3, #0]
	return 0;
  409d40:	2300      	movs	r3, #0
}
  409d42:	4618      	mov	r0, r3
  409d44:	370c      	adds	r7, #12
  409d46:	46bd      	mov	sp, r7
  409d48:	f85d 7b04 	ldr.w	r7, [sp], #4
  409d4c:	4770      	bx	lr
  409d4e:	bf00      	nop
  409d50:	20001edc 	.word	0x20001edc

00409d54 <inv_icm20648_get_accel_accuracy>:

/** Returns accuracy of accel.
 * @return Accuracy of accel with 0 being not accurate, and 3 being most accurate.
*/
int inv_icm20648_get_accel_accuracy(void)
{
  409d54:	b480      	push	{r7}
  409d56:	af00      	add	r7, sp, #0
	return fd.accel_accuracy;
  409d58:	4b03      	ldr	r3, [pc, #12]	; (409d68 <inv_icm20648_get_accel_accuracy+0x14>)
  409d5a:	f9b3 307a 	ldrsh.w	r3, [r3, #122]	; 0x7a
}
  409d5e:	4618      	mov	r0, r3
  409d60:	46bd      	mov	sp, r7
  409d62:	f85d 7b04 	ldr.w	r7, [sp], #4
  409d66:	4770      	bx	lr
  409d68:	20001edc 	.word	0x20001edc

00409d6c <inv_icm20648_get_gyro_accuracy>:

/** Returns accuracy of gyro.
 * @return Accuracy of gyro with 0 being not accurate, and 3 being most accurate.
*/
int inv_icm20648_get_gyro_accuracy(void)
{
  409d6c:	b480      	push	{r7}
  409d6e:	af00      	add	r7, sp, #0
	return fd.gyro_accuracy;
  409d70:	4b03      	ldr	r3, [pc, #12]	; (409d80 <inv_icm20648_get_gyro_accuracy+0x14>)
  409d72:	f9b3 307c 	ldrsh.w	r3, [r3, #124]	; 0x7c
}
  409d76:	4618      	mov	r0, r3
  409d78:	46bd      	mov	sp, r7
  409d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
  409d7e:	4770      	bx	lr
  409d80:	20001edc 	.word	0x20001edc

00409d84 <inv_icm20648_get_mag_accuracy>:

/** Returns accuracy of compass.
 * @return Accuracy of compass with 0 being not accurate, and 3 being most accurate.
*/
int inv_icm20648_get_mag_accuracy(void)
{
  409d84:	b480      	push	{r7}
  409d86:	af00      	add	r7, sp, #0
	return fd.cpass_accuracy;
  409d88:	4b03      	ldr	r3, [pc, #12]	; (409d98 <inv_icm20648_get_mag_accuracy+0x14>)
  409d8a:	f9b3 307e 	ldrsh.w	r3, [r3, #126]	; 0x7e
}
  409d8e:	4618      	mov	r0, r3
  409d90:	46bd      	mov	sp, r7
  409d92:	f85d 7b04 	ldr.w	r7, [sp], #4
  409d96:	4770      	bx	lr
  409d98:	20001edc 	.word	0x20001edc

00409d9c <inv_icm20648_get_gmrv_accuracy>:

/** Returns accuracy of geomagnetic rotation vector.
 * @return Accuracy of GMRV in Q29.
*/
int inv_icm20648_get_gmrv_accuracy(void)
{
  409d9c:	b480      	push	{r7}
  409d9e:	af00      	add	r7, sp, #0
	return fd.dmp_geomag_accuracyQ29;
  409da0:	4b03      	ldr	r3, [pc, #12]	; (409db0 <inv_icm20648_get_gmrv_accuracy+0x14>)
  409da2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
  409da4:	4618      	mov	r0, r3
  409da6:	46bd      	mov	sp, r7
  409da8:	f85d 7b04 	ldr.w	r7, [sp], #4
  409dac:	4770      	bx	lr
  409dae:	bf00      	nop
  409db0:	20001edc 	.word	0x20001edc

00409db4 <inv_icm20648_get_rv_accuracy>:

/** Returns accuracy of rotation vector.
 * @return Accuracy of RV in Q29.
*/
int inv_icm20648_get_rv_accuracy(void)
{
  409db4:	b480      	push	{r7}
  409db6:	af00      	add	r7, sp, #0
	return fd.dmp_rv_accuracyQ29;
  409db8:	4b03      	ldr	r3, [pc, #12]	; (409dc8 <inv_icm20648_get_rv_accuracy+0x14>)
  409dba:	699b      	ldr	r3, [r3, #24]
}
  409dbc:	4618      	mov	r0, r3
  409dbe:	46bd      	mov	sp, r7
  409dc0:	f85d 7b04 	ldr.w	r7, [sp], #4
  409dc4:	4770      	bx	lr
  409dc6:	bf00      	nop
  409dc8:	20001edc 	.word	0x20001edc

00409dcc <inv_save_setting>:
};

extern int ak09912_is_available;

static int inv_save_setting(struct inv_icm20648 * s, struct recover_regs * saved_regs)
{
  409dcc:	b590      	push	{r4, r7, lr}
  409dce:	b085      	sub	sp, #20
  409dd0:	af00      	add	r7, sp, #0
  409dd2:	6078      	str	r0, [r7, #4]
  409dd4:	6039      	str	r1, [r7, #0]
	int result = 0;
  409dd6:	2300      	movs	r3, #0
  409dd8:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_FIFO_CFG, 1, &saved_regs->fifo_cfg);
  409dda:	683b      	ldr	r3, [r7, #0]
  409ddc:	2201      	movs	r2, #1
  409dde:	2176      	movs	r1, #118	; 0x76
  409de0:	6878      	ldr	r0, [r7, #4]
  409de2:	4c5a      	ldr	r4, [pc, #360]	; (409f4c <inv_save_setting+0x180>)
  409de4:	47a0      	blx	r4
  409de6:	4602      	mov	r2, r0
  409de8:	68fb      	ldr	r3, [r7, #12]
  409dea:	4313      	orrs	r3, r2
  409dec:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_USER_CTRL, 1, &saved_regs->user_ctrl);
  409dee:	683b      	ldr	r3, [r7, #0]
  409df0:	3301      	adds	r3, #1
  409df2:	2201      	movs	r2, #1
  409df4:	2103      	movs	r1, #3
  409df6:	6878      	ldr	r0, [r7, #4]
  409df8:	4c54      	ldr	r4, [pc, #336]	; (409f4c <inv_save_setting+0x180>)
  409dfa:	47a0      	blx	r4
  409dfc:	4602      	mov	r2, r0
  409dfe:	68fb      	ldr	r3, [r7, #12]
  409e00:	4313      	orrs	r3, r2
  409e02:	60fb      	str	r3, [r7, #12]

	result = inv_icm20648_read_mems_reg(s, REG_LP_CONFIG, 1, &saved_regs->lp_config);
  409e04:	683b      	ldr	r3, [r7, #0]
  409e06:	3302      	adds	r3, #2
  409e08:	2201      	movs	r2, #1
  409e0a:	2105      	movs	r1, #5
  409e0c:	6878      	ldr	r0, [r7, #4]
  409e0e:	4c4f      	ldr	r4, [pc, #316]	; (409f4c <inv_save_setting+0x180>)
  409e10:	47a0      	blx	r4
  409e12:	60f8      	str	r0, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_INT_ENABLE, 1, &saved_regs->int_enable);
  409e14:	683b      	ldr	r3, [r7, #0]
  409e16:	3303      	adds	r3, #3
  409e18:	2201      	movs	r2, #1
  409e1a:	2110      	movs	r1, #16
  409e1c:	6878      	ldr	r0, [r7, #4]
  409e1e:	4c4b      	ldr	r4, [pc, #300]	; (409f4c <inv_save_setting+0x180>)
  409e20:	47a0      	blx	r4
  409e22:	4602      	mov	r2, r0
  409e24:	68fb      	ldr	r3, [r7, #12]
  409e26:	4313      	orrs	r3, r2
  409e28:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_INT_ENABLE_1, 1, &saved_regs->int_enable_1);
  409e2a:	683b      	ldr	r3, [r7, #0]
  409e2c:	3304      	adds	r3, #4
  409e2e:	2201      	movs	r2, #1
  409e30:	2111      	movs	r1, #17
  409e32:	6878      	ldr	r0, [r7, #4]
  409e34:	4c45      	ldr	r4, [pc, #276]	; (409f4c <inv_save_setting+0x180>)
  409e36:	47a0      	blx	r4
  409e38:	4602      	mov	r2, r0
  409e3a:	68fb      	ldr	r3, [r7, #12]
  409e3c:	4313      	orrs	r3, r2
  409e3e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_INT_ENABLE_2, 1, &saved_regs->int_enable_2);
  409e40:	683b      	ldr	r3, [r7, #0]
  409e42:	3305      	adds	r3, #5
  409e44:	2201      	movs	r2, #1
  409e46:	2112      	movs	r1, #18
  409e48:	6878      	ldr	r0, [r7, #4]
  409e4a:	4c40      	ldr	r4, [pc, #256]	; (409f4c <inv_save_setting+0x180>)
  409e4c:	47a0      	blx	r4
  409e4e:	4602      	mov	r2, r0
  409e50:	68fb      	ldr	r3, [r7, #12]
  409e52:	4313      	orrs	r3, r2
  409e54:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_FIFO_EN, 1, &saved_regs->fifo_en);
  409e56:	683b      	ldr	r3, [r7, #0]
  409e58:	3306      	adds	r3, #6
  409e5a:	2201      	movs	r2, #1
  409e5c:	2166      	movs	r1, #102	; 0x66
  409e5e:	6878      	ldr	r0, [r7, #4]
  409e60:	4c3a      	ldr	r4, [pc, #232]	; (409f4c <inv_save_setting+0x180>)
  409e62:	47a0      	blx	r4
  409e64:	4602      	mov	r2, r0
  409e66:	68fb      	ldr	r3, [r7, #12]
  409e68:	4313      	orrs	r3, r2
  409e6a:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_FIFO_EN_2, 1, &saved_regs->fifo_en_2);
  409e6c:	683b      	ldr	r3, [r7, #0]
  409e6e:	3307      	adds	r3, #7
  409e70:	2201      	movs	r2, #1
  409e72:	2167      	movs	r1, #103	; 0x67
  409e74:	6878      	ldr	r0, [r7, #4]
  409e76:	4c35      	ldr	r4, [pc, #212]	; (409f4c <inv_save_setting+0x180>)
  409e78:	47a0      	blx	r4
  409e7a:	4602      	mov	r2, r0
  409e7c:	68fb      	ldr	r3, [r7, #12]
  409e7e:	4313      	orrs	r3, r2
  409e80:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_FIFO_RST, 1, &saved_regs->fifo_rst);
  409e82:	683b      	ldr	r3, [r7, #0]
  409e84:	3308      	adds	r3, #8
  409e86:	2201      	movs	r2, #1
  409e88:	2168      	movs	r1, #104	; 0x68
  409e8a:	6878      	ldr	r0, [r7, #4]
  409e8c:	4c2f      	ldr	r4, [pc, #188]	; (409f4c <inv_save_setting+0x180>)
  409e8e:	47a0      	blx	r4
  409e90:	4602      	mov	r2, r0
  409e92:	68fb      	ldr	r3, [r7, #12]
  409e94:	4313      	orrs	r3, r2
  409e96:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_GYRO_SMPLRT_DIV, 1, &saved_regs->gyro_smplrt_div);
  409e98:	683b      	ldr	r3, [r7, #0]
  409e9a:	3309      	adds	r3, #9
  409e9c:	2201      	movs	r2, #1
  409e9e:	f44f 7180 	mov.w	r1, #256	; 0x100
  409ea2:	6878      	ldr	r0, [r7, #4]
  409ea4:	4c29      	ldr	r4, [pc, #164]	; (409f4c <inv_save_setting+0x180>)
  409ea6:	47a0      	blx	r4
  409ea8:	4602      	mov	r2, r0
  409eaa:	68fb      	ldr	r3, [r7, #12]
  409eac:	4313      	orrs	r3, r2
  409eae:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_GYRO_CONFIG_1, 1, &saved_regs->gyro_config_1);
  409eb0:	683b      	ldr	r3, [r7, #0]
  409eb2:	330a      	adds	r3, #10
  409eb4:	2201      	movs	r2, #1
  409eb6:	f240 1101 	movw	r1, #257	; 0x101
  409eba:	6878      	ldr	r0, [r7, #4]
  409ebc:	4c23      	ldr	r4, [pc, #140]	; (409f4c <inv_save_setting+0x180>)
  409ebe:	47a0      	blx	r4
  409ec0:	4602      	mov	r2, r0
  409ec2:	68fb      	ldr	r3, [r7, #12]
  409ec4:	4313      	orrs	r3, r2
  409ec6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_GYRO_CONFIG_2, 1, &saved_regs->gyro_config_2);
  409ec8:	683b      	ldr	r3, [r7, #0]
  409eca:	330b      	adds	r3, #11
  409ecc:	2201      	movs	r2, #1
  409ece:	f44f 7181 	mov.w	r1, #258	; 0x102
  409ed2:	6878      	ldr	r0, [r7, #4]
  409ed4:	4c1d      	ldr	r4, [pc, #116]	; (409f4c <inv_save_setting+0x180>)
  409ed6:	47a0      	blx	r4
  409ed8:	4602      	mov	r2, r0
  409eda:	68fb      	ldr	r3, [r7, #12]
  409edc:	4313      	orrs	r3, r2
  409ede:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, 1, &saved_regs->accel_smplrt_div_1);
  409ee0:	683b      	ldr	r3, [r7, #0]
  409ee2:	330c      	adds	r3, #12
  409ee4:	2201      	movs	r2, #1
  409ee6:	f44f 7188 	mov.w	r1, #272	; 0x110
  409eea:	6878      	ldr	r0, [r7, #4]
  409eec:	4c17      	ldr	r4, [pc, #92]	; (409f4c <inv_save_setting+0x180>)
  409eee:	47a0      	blx	r4
  409ef0:	4602      	mov	r2, r0
  409ef2:	68fb      	ldr	r3, [r7, #12]
  409ef4:	4313      	orrs	r3, r2
  409ef6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_ACCEL_SMPLRT_DIV_2, 1, &saved_regs->accel_smplrt_div_2);
  409ef8:	683b      	ldr	r3, [r7, #0]
  409efa:	330d      	adds	r3, #13
  409efc:	2201      	movs	r2, #1
  409efe:	f240 1111 	movw	r1, #273	; 0x111
  409f02:	6878      	ldr	r0, [r7, #4]
  409f04:	4c11      	ldr	r4, [pc, #68]	; (409f4c <inv_save_setting+0x180>)
  409f06:	47a0      	blx	r4
  409f08:	4602      	mov	r2, r0
  409f0a:	68fb      	ldr	r3, [r7, #12]
  409f0c:	4313      	orrs	r3, r2
  409f0e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_ACCEL_CONFIG, 1, &saved_regs->accel_config);
  409f10:	683b      	ldr	r3, [r7, #0]
  409f12:	330e      	adds	r3, #14
  409f14:	2201      	movs	r2, #1
  409f16:	f44f 718a 	mov.w	r1, #276	; 0x114
  409f1a:	6878      	ldr	r0, [r7, #4]
  409f1c:	4c0b      	ldr	r4, [pc, #44]	; (409f4c <inv_save_setting+0x180>)
  409f1e:	47a0      	blx	r4
  409f20:	4602      	mov	r2, r0
  409f22:	68fb      	ldr	r3, [r7, #12]
  409f24:	4313      	orrs	r3, r2
  409f26:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_ACCEL_CONFIG_2, 1, &saved_regs->accel_config_2);
  409f28:	683b      	ldr	r3, [r7, #0]
  409f2a:	330f      	adds	r3, #15
  409f2c:	2201      	movs	r2, #1
  409f2e:	f240 1115 	movw	r1, #277	; 0x115
  409f32:	6878      	ldr	r0, [r7, #4]
  409f34:	4c05      	ldr	r4, [pc, #20]	; (409f4c <inv_save_setting+0x180>)
  409f36:	47a0      	blx	r4
  409f38:	4602      	mov	r2, r0
  409f3a:	68fb      	ldr	r3, [r7, #12]
  409f3c:	4313      	orrs	r3, r2
  409f3e:	60fb      	str	r3, [r7, #12]

	return result;
  409f40:	68fb      	ldr	r3, [r7, #12]
}
  409f42:	4618      	mov	r0, r3
  409f44:	3714      	adds	r7, #20
  409f46:	46bd      	mov	sp, r7
  409f48:	bd90      	pop	{r4, r7, pc}
  409f4a:	bf00      	nop
  409f4c:	0040caa1 	.word	0x0040caa1

00409f50 <inv_recover_setting>:

static int inv_recover_setting(struct inv_icm20648 * s, const struct recover_regs * saved_regs)
{
  409f50:	b580      	push	{r7, lr}
  409f52:	b084      	sub	sp, #16
  409f54:	af00      	add	r7, sp, #0
  409f56:	6078      	str	r0, [r7, #4]
  409f58:	6039      	str	r1, [r7, #0]
	int result = 0;
  409f5a:	2300      	movs	r3, #0
  409f5c:	60fb      	str	r3, [r7, #12]

	// Stop sensors
	result |= inv_icm20648_write_single_mems_reg(s, REG_PWR_MGMT_2, 
  409f5e:	227f      	movs	r2, #127	; 0x7f
  409f60:	2107      	movs	r1, #7
  409f62:	6878      	ldr	r0, [r7, #4]
  409f64:	4b73      	ldr	r3, [pc, #460]	; (40a134 <inv_recover_setting+0x1e4>)
  409f66:	4798      	blx	r3
  409f68:	4602      	mov	r2, r0
  409f6a:	68fb      	ldr	r3, [r7, #12]
  409f6c:	4313      	orrs	r3, r2
  409f6e:	60fb      	str	r3, [r7, #12]
		BIT_PWR_PRESSURE_STBY | BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);

	// Restore sensor configurations
	result |= inv_icm20648_write_single_mems_reg(s, REG_GYRO_SMPLRT_DIV, saved_regs->gyro_smplrt_div);
  409f70:	683b      	ldr	r3, [r7, #0]
  409f72:	7a5b      	ldrb	r3, [r3, #9]
  409f74:	461a      	mov	r2, r3
  409f76:	f44f 7180 	mov.w	r1, #256	; 0x100
  409f7a:	6878      	ldr	r0, [r7, #4]
  409f7c:	4b6d      	ldr	r3, [pc, #436]	; (40a134 <inv_recover_setting+0x1e4>)
  409f7e:	4798      	blx	r3
  409f80:	4602      	mov	r2, r0
  409f82:	68fb      	ldr	r3, [r7, #12]
  409f84:	4313      	orrs	r3, r2
  409f86:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_GYRO_CONFIG_1, saved_regs->gyro_config_1);
  409f88:	683b      	ldr	r3, [r7, #0]
  409f8a:	7a9b      	ldrb	r3, [r3, #10]
  409f8c:	461a      	mov	r2, r3
  409f8e:	f240 1101 	movw	r1, #257	; 0x101
  409f92:	6878      	ldr	r0, [r7, #4]
  409f94:	4b67      	ldr	r3, [pc, #412]	; (40a134 <inv_recover_setting+0x1e4>)
  409f96:	4798      	blx	r3
  409f98:	4602      	mov	r2, r0
  409f9a:	68fb      	ldr	r3, [r7, #12]
  409f9c:	4313      	orrs	r3, r2
  409f9e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_GYRO_CONFIG_2, saved_regs->gyro_config_2);
  409fa0:	683b      	ldr	r3, [r7, #0]
  409fa2:	7adb      	ldrb	r3, [r3, #11]
  409fa4:	461a      	mov	r2, r3
  409fa6:	f44f 7181 	mov.w	r1, #258	; 0x102
  409faa:	6878      	ldr	r0, [r7, #4]
  409fac:	4b61      	ldr	r3, [pc, #388]	; (40a134 <inv_recover_setting+0x1e4>)
  409fae:	4798      	blx	r3
  409fb0:	4602      	mov	r2, r0
  409fb2:	68fb      	ldr	r3, [r7, #12]
  409fb4:	4313      	orrs	r3, r2
  409fb6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, saved_regs->accel_smplrt_div_1);
  409fb8:	683b      	ldr	r3, [r7, #0]
  409fba:	7b1b      	ldrb	r3, [r3, #12]
  409fbc:	461a      	mov	r2, r3
  409fbe:	f44f 7188 	mov.w	r1, #272	; 0x110
  409fc2:	6878      	ldr	r0, [r7, #4]
  409fc4:	4b5b      	ldr	r3, [pc, #364]	; (40a134 <inv_recover_setting+0x1e4>)
  409fc6:	4798      	blx	r3
  409fc8:	4602      	mov	r2, r0
  409fca:	68fb      	ldr	r3, [r7, #12]
  409fcc:	4313      	orrs	r3, r2
  409fce:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_2, saved_regs->accel_smplrt_div_2);
  409fd0:	683b      	ldr	r3, [r7, #0]
  409fd2:	7b5b      	ldrb	r3, [r3, #13]
  409fd4:	461a      	mov	r2, r3
  409fd6:	f240 1111 	movw	r1, #273	; 0x111
  409fda:	6878      	ldr	r0, [r7, #4]
  409fdc:	4b55      	ldr	r3, [pc, #340]	; (40a134 <inv_recover_setting+0x1e4>)
  409fde:	4798      	blx	r3
  409fe0:	4602      	mov	r2, r0
  409fe2:	68fb      	ldr	r3, [r7, #12]
  409fe4:	4313      	orrs	r3, r2
  409fe6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_CONFIG, saved_regs->accel_config);
  409fe8:	683b      	ldr	r3, [r7, #0]
  409fea:	7b9b      	ldrb	r3, [r3, #14]
  409fec:	461a      	mov	r2, r3
  409fee:	f44f 718a 	mov.w	r1, #276	; 0x114
  409ff2:	6878      	ldr	r0, [r7, #4]
  409ff4:	4b4f      	ldr	r3, [pc, #316]	; (40a134 <inv_recover_setting+0x1e4>)
  409ff6:	4798      	blx	r3
  409ff8:	4602      	mov	r2, r0
  409ffa:	68fb      	ldr	r3, [r7, #12]
  409ffc:	4313      	orrs	r3, r2
  409ffe:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, saved_regs->accel_config_2);
  40a000:	683b      	ldr	r3, [r7, #0]
  40a002:	7bdb      	ldrb	r3, [r3, #15]
  40a004:	461a      	mov	r2, r3
  40a006:	f240 1115 	movw	r1, #277	; 0x115
  40a00a:	6878      	ldr	r0, [r7, #4]
  40a00c:	4b49      	ldr	r3, [pc, #292]	; (40a134 <inv_recover_setting+0x1e4>)
  40a00e:	4798      	blx	r3
  40a010:	4602      	mov	r2, r0
  40a012:	68fb      	ldr	r3, [r7, #12]
  40a014:	4313      	orrs	r3, r2
  40a016:	60fb      	str	r3, [r7, #12]

	// Restore FIFO configurations
	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_CFG, saved_regs->fifo_cfg);
  40a018:	683b      	ldr	r3, [r7, #0]
  40a01a:	781b      	ldrb	r3, [r3, #0]
  40a01c:	461a      	mov	r2, r3
  40a01e:	2176      	movs	r1, #118	; 0x76
  40a020:	6878      	ldr	r0, [r7, #4]
  40a022:	4b44      	ldr	r3, [pc, #272]	; (40a134 <inv_recover_setting+0x1e4>)
  40a024:	4798      	blx	r3
  40a026:	4602      	mov	r2, r0
  40a028:	68fb      	ldr	r3, [r7, #12]
  40a02a:	4313      	orrs	r3, r2
  40a02c:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_LP_CONFIG, saved_regs->lp_config);
  40a02e:	683b      	ldr	r3, [r7, #0]
  40a030:	789b      	ldrb	r3, [r3, #2]
  40a032:	461a      	mov	r2, r3
  40a034:	2105      	movs	r1, #5
  40a036:	6878      	ldr	r0, [r7, #4]
  40a038:	4b3e      	ldr	r3, [pc, #248]	; (40a134 <inv_recover_setting+0x1e4>)
  40a03a:	4798      	blx	r3
  40a03c:	4602      	mov	r2, r0
  40a03e:	68fb      	ldr	r3, [r7, #12]
  40a040:	4313      	orrs	r3, r2
  40a042:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_INT_ENABLE, saved_regs->int_enable);
  40a044:	683b      	ldr	r3, [r7, #0]
  40a046:	78db      	ldrb	r3, [r3, #3]
  40a048:	461a      	mov	r2, r3
  40a04a:	2110      	movs	r1, #16
  40a04c:	6878      	ldr	r0, [r7, #4]
  40a04e:	4b39      	ldr	r3, [pc, #228]	; (40a134 <inv_recover_setting+0x1e4>)
  40a050:	4798      	blx	r3
  40a052:	4602      	mov	r2, r0
  40a054:	68fb      	ldr	r3, [r7, #12]
  40a056:	4313      	orrs	r3, r2
  40a058:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_INT_ENABLE_1, saved_regs->int_enable_1);
  40a05a:	683b      	ldr	r3, [r7, #0]
  40a05c:	791b      	ldrb	r3, [r3, #4]
  40a05e:	461a      	mov	r2, r3
  40a060:	2111      	movs	r1, #17
  40a062:	6878      	ldr	r0, [r7, #4]
  40a064:	4b33      	ldr	r3, [pc, #204]	; (40a134 <inv_recover_setting+0x1e4>)
  40a066:	4798      	blx	r3
  40a068:	4602      	mov	r2, r0
  40a06a:	68fb      	ldr	r3, [r7, #12]
  40a06c:	4313      	orrs	r3, r2
  40a06e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_EN, saved_regs->fifo_en);
  40a070:	683b      	ldr	r3, [r7, #0]
  40a072:	799b      	ldrb	r3, [r3, #6]
  40a074:	461a      	mov	r2, r3
  40a076:	2166      	movs	r1, #102	; 0x66
  40a078:	6878      	ldr	r0, [r7, #4]
  40a07a:	4b2e      	ldr	r3, [pc, #184]	; (40a134 <inv_recover_setting+0x1e4>)
  40a07c:	4798      	blx	r3
  40a07e:	4602      	mov	r2, r0
  40a080:	68fb      	ldr	r3, [r7, #12]
  40a082:	4313      	orrs	r3, r2
  40a084:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_EN_2, saved_regs->fifo_en_2);
  40a086:	683b      	ldr	r3, [r7, #0]
  40a088:	79db      	ldrb	r3, [r3, #7]
  40a08a:	461a      	mov	r2, r3
  40a08c:	2167      	movs	r1, #103	; 0x67
  40a08e:	6878      	ldr	r0, [r7, #4]
  40a090:	4b28      	ldr	r3, [pc, #160]	; (40a134 <inv_recover_setting+0x1e4>)
  40a092:	4798      	blx	r3
  40a094:	4602      	mov	r2, r0
  40a096:	68fb      	ldr	r3, [r7, #12]
  40a098:	4313      	orrs	r3, r2
  40a09a:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_RST, MAX_5_BIT_VALUE);
  40a09c:	221f      	movs	r2, #31
  40a09e:	2168      	movs	r1, #104	; 0x68
  40a0a0:	6878      	ldr	r0, [r7, #4]
  40a0a2:	4b24      	ldr	r3, [pc, #144]	; (40a134 <inv_recover_setting+0x1e4>)
  40a0a4:	4798      	blx	r3
  40a0a6:	4602      	mov	r2, r0
  40a0a8:	68fb      	ldr	r3, [r7, #12]
  40a0aa:	4313      	orrs	r3, r2
  40a0ac:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_FIFO_RST, saved_regs->fifo_rst);
  40a0ae:	683b      	ldr	r3, [r7, #0]
  40a0b0:	7a1b      	ldrb	r3, [r3, #8]
  40a0b2:	461a      	mov	r2, r3
  40a0b4:	2168      	movs	r1, #104	; 0x68
  40a0b6:	6878      	ldr	r0, [r7, #4]
  40a0b8:	4b1e      	ldr	r3, [pc, #120]	; (40a134 <inv_recover_setting+0x1e4>)
  40a0ba:	4798      	blx	r3
  40a0bc:	4602      	mov	r2, r0
  40a0be:	68fb      	ldr	r3, [r7, #12]
  40a0c0:	4313      	orrs	r3, r2
  40a0c2:	60fb      	str	r3, [r7, #12]

	// Reset DMP
	result |= inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, 
		(saved_regs->user_ctrl & (~BIT_FIFO_EN)) | BIT_DMP_RST);
  40a0c4:	683b      	ldr	r3, [r7, #0]
  40a0c6:	785b      	ldrb	r3, [r3, #1]
  40a0c8:	b25b      	sxtb	r3, r3
  40a0ca:	f023 0348 	bic.w	r3, r3, #72	; 0x48
  40a0ce:	b25b      	sxtb	r3, r3
  40a0d0:	f043 0308 	orr.w	r3, r3, #8
  40a0d4:	b25b      	sxtb	r3, r3
	result |= inv_icm20648_write_single_mems_reg(s, REG_USER_CTRL, 
  40a0d6:	b2db      	uxtb	r3, r3
  40a0d8:	461a      	mov	r2, r3
  40a0da:	2103      	movs	r1, #3
  40a0dc:	6878      	ldr	r0, [r7, #4]
  40a0de:	4b15      	ldr	r3, [pc, #84]	; (40a134 <inv_recover_setting+0x1e4>)
  40a0e0:	4798      	blx	r3
  40a0e2:	4602      	mov	r2, r0
  40a0e4:	68fb      	ldr	r3, [r7, #12]
  40a0e6:	4313      	orrs	r3, r2
  40a0e8:	60fb      	str	r3, [r7, #12]
	inv_icm20648_sleep_us(DMP_RESET_TIME*1000);
  40a0ea:	f644 6020 	movw	r0, #20000	; 0x4e20
  40a0ee:	4b12      	ldr	r3, [pc, #72]	; (40a138 <inv_recover_setting+0x1e8>)
  40a0f0:	4798      	blx	r3

	result |=inv_icm20648_set_dmp_address(s);
  40a0f2:	6878      	ldr	r0, [r7, #4]
  40a0f4:	4b11      	ldr	r3, [pc, #68]	; (40a13c <inv_recover_setting+0x1ec>)
  40a0f6:	4798      	blx	r3
  40a0f8:	4602      	mov	r2, r0
  40a0fa:	68fb      	ldr	r3, [r7, #12]
  40a0fc:	4313      	orrs	r3, r2
  40a0fe:	60fb      	str	r3, [r7, #12]
	result |=inv_icm20648_set_secondary(s);
  40a100:	6878      	ldr	r0, [r7, #4]
  40a102:	4b0f      	ldr	r3, [pc, #60]	; (40a140 <inv_recover_setting+0x1f0>)
  40a104:	4798      	blx	r3
  40a106:	4602      	mov	r2, r0
  40a108:	68fb      	ldr	r3, [r7, #12]
  40a10a:	4313      	orrs	r3, r2
  40a10c:	60fb      	str	r3, [r7, #12]
	result |=inv_icm20648_setup_compass_akm(s);
  40a10e:	6878      	ldr	r0, [r7, #4]
  40a110:	4b0c      	ldr	r3, [pc, #48]	; (40a144 <inv_recover_setting+0x1f4>)
  40a112:	4798      	blx	r3
  40a114:	4602      	mov	r2, r0
  40a116:	68fb      	ldr	r3, [r7, #12]
  40a118:	4313      	orrs	r3, r2
  40a11a:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20648_sleep_mems(s);
  40a11c:	6878      	ldr	r0, [r7, #4]
  40a11e:	4b0a      	ldr	r3, [pc, #40]	; (40a148 <inv_recover_setting+0x1f8>)
  40a120:	4798      	blx	r3
  40a122:	4602      	mov	r2, r0
  40a124:	68fb      	ldr	r3, [r7, #12]
  40a126:	4313      	orrs	r3, r2
  40a128:	60fb      	str	r3, [r7, #12]
	return result;
  40a12a:	68fb      	ldr	r3, [r7, #12]
}
  40a12c:	4618      	mov	r0, r3
  40a12e:	3710      	adds	r7, #16
  40a130:	46bd      	mov	sp, r7
  40a132:	bd80      	pop	{r7, pc}
  40a134:	0040c9d5 	.word	0x0040c9d5
  40a138:	004015d9 	.word	0x004015d9
  40a13c:	00405df9 	.word	0x00405df9
  40a140:	00405e45 	.word	0x00405e45
  40a144:	0040494d 	.word	0x0040494d
  40a148:	00405db9 	.word	0x00405db9

0040a14c <inv_check_accelgyro_self_test>:
*  @param[in] meanNormalTestValues average value of normal test.
*  @param[in] meanSelfTestValues   average value of self test
*  @return zero as success. A non-zero return value indicates failure in self test.
*/
static int inv_check_accelgyro_self_test(enum INV_SENSORS sensorType, uint8_t * selfTestValuesReadFromReg, int *meanNormalTestValues, int *meanSelfTestValues) 
{
  40a14c:	b480      	push	{r7}
  40a14e:	b08f      	sub	sp, #60	; 0x3c
  40a150:	af00      	add	r7, sp, #0
  40a152:	60b9      	str	r1, [r7, #8]
  40a154:	607a      	str	r2, [r7, #4]
  40a156:	603b      	str	r3, [r7, #0]
  40a158:	4603      	mov	r3, r0
  40a15a:	73fb      	strb	r3, [r7, #15]
	int ret_val;
	int lIsStOtpReadZero = 0;
  40a15c:	2300      	movs	r3, #0
  40a15e:	633b      	str	r3, [r7, #48]	; 0x30
	int l_st_otp_read[3], lDiffNormalStValues[3], i;

	ret_val = 0;
  40a160:	2300      	movs	r3, #0
  40a162:	637b      	str	r3, [r7, #52]	; 0x34
	// Calculate factory Self-Test value (ST_OTP) based on the following equation:
	// The factory Self-Test value (ST_OTP) is calculated from the ST_Code (the SELF_TEST values read)
	// using the following equation, where FS is the full scale value code:
	// st_otp = 2620/2^FS * 1.01^(st_value - 1)
	// the result of the equation is in sSelfTestEquation array
	for (i = 0; i < 3; i++) {
  40a164:	2300      	movs	r3, #0
  40a166:	62fb      	str	r3, [r7, #44]	; 0x2c
  40a168:	e023      	b.n	40a1b2 <inv_check_accelgyro_self_test+0x66>
		if (selfTestValuesReadFromReg[i] != 0) {
  40a16a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a16c:	68ba      	ldr	r2, [r7, #8]
  40a16e:	4413      	add	r3, r2
  40a170:	781b      	ldrb	r3, [r3, #0]
  40a172:	2b00      	cmp	r3, #0
  40a174:	d010      	beq.n	40a198 <inv_check_accelgyro_self_test+0x4c>
			l_st_otp_read[i] = sSelfTestEquation[selfTestValuesReadFromReg[i] - 1];
  40a176:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a178:	68ba      	ldr	r2, [r7, #8]
  40a17a:	4413      	add	r3, r2
  40a17c:	781b      	ldrb	r3, [r3, #0]
  40a17e:	3b01      	subs	r3, #1
  40a180:	4a3a      	ldr	r2, [pc, #232]	; (40a26c <inv_check_accelgyro_self_test+0x120>)
  40a182:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  40a186:	461a      	mov	r2, r3
  40a188:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a18a:	009b      	lsls	r3, r3, #2
  40a18c:	f107 0138 	add.w	r1, r7, #56	; 0x38
  40a190:	440b      	add	r3, r1
  40a192:	f843 2c18 	str.w	r2, [r3, #-24]
  40a196:	e009      	b.n	40a1ac <inv_check_accelgyro_self_test+0x60>
		} else {
			l_st_otp_read[i] = 0;
  40a198:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a19a:	009b      	lsls	r3, r3, #2
  40a19c:	f107 0238 	add.w	r2, r7, #56	; 0x38
  40a1a0:	4413      	add	r3, r2
  40a1a2:	2200      	movs	r2, #0
  40a1a4:	f843 2c18 	str.w	r2, [r3, #-24]
			lIsStOtpReadZero = 1;
  40a1a8:	2301      	movs	r3, #1
  40a1aa:	633b      	str	r3, [r7, #48]	; 0x30
	for (i = 0; i < 3; i++) {
  40a1ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a1ae:	3301      	adds	r3, #1
  40a1b0:	62fb      	str	r3, [r7, #44]	; 0x2c
  40a1b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a1b4:	2b02      	cmp	r3, #2
  40a1b6:	ddd8      	ble.n	40a16a <inv_check_accelgyro_self_test+0x1e>
	// - GYST = GY_ST_OS - GY_OS
	// - GZST = GZ_ST_OS - GZ_OS
	// - AXST = AX_ST_OS - AX_OS
	// - AYST = AY_ST_OS - AY_OS
	// - AZST = AZ_ST_OS - AZ_OS
	for (i = 0; i < 3; i++) {
  40a1b8:	2300      	movs	r3, #0
  40a1ba:	62fb      	str	r3, [r7, #44]	; 0x2c
  40a1bc:	e04b      	b.n	40a256 <inv_check_accelgyro_self_test+0x10a>
		lDiffNormalStValues[i] = meanSelfTestValues[i] - meanNormalTestValues[i];
  40a1be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a1c0:	009b      	lsls	r3, r3, #2
  40a1c2:	683a      	ldr	r2, [r7, #0]
  40a1c4:	4413      	add	r3, r2
  40a1c6:	681a      	ldr	r2, [r3, #0]
  40a1c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a1ca:	009b      	lsls	r3, r3, #2
  40a1cc:	6879      	ldr	r1, [r7, #4]
  40a1ce:	440b      	add	r3, r1
  40a1d0:	681b      	ldr	r3, [r3, #0]
  40a1d2:	1ad2      	subs	r2, r2, r3
  40a1d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a1d6:	009b      	lsls	r3, r3, #2
  40a1d8:	f107 0138 	add.w	r1, r7, #56	; 0x38
  40a1dc:	440b      	add	r3, r1
  40a1de:	f843 2c24 	str.w	r2, [r3, #-36]

		// Ensure the factory Self-Test values ST_OTP are not 0
		if (!lIsStOtpReadZero) {
  40a1e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40a1e4:	2b00      	cmp	r3, #0
  40a1e6:	d131      	bne.n	40a24c <inv_check_accelgyro_self_test+0x100>
			// Compare the current Self-Test response (GXST, GYST, GZST, AXST, AYST and AZST) to the factory Self-Test values (ST_OTP)
			// and report Self-Test is passing if all the following criteria are fulfilled:
			// (GXST / GXST_OTP)  > 0.5
			if (lDiffNormalStValues[i] < LOWER_BOUND_CHECK(l_st_otp_read[i]) )
  40a1e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a1ea:	009b      	lsls	r3, r3, #2
  40a1ec:	f107 0238 	add.w	r2, r7, #56	; 0x38
  40a1f0:	4413      	add	r3, r2
  40a1f2:	f853 2c24 	ldr.w	r2, [r3, #-36]
  40a1f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a1f8:	009b      	lsls	r3, r3, #2
  40a1fa:	f107 0138 	add.w	r1, r7, #56	; 0x38
  40a1fe:	440b      	add	r3, r1
  40a200:	f853 3c18 	ldr.w	r3, [r3, #-24]
  40a204:	105b      	asrs	r3, r3, #1
  40a206:	429a      	cmp	r2, r3
  40a208:	da01      	bge.n	40a20e <inv_check_accelgyro_self_test+0xc2>
				ret_val = 1;
  40a20a:	2301      	movs	r3, #1
  40a20c:	637b      	str	r3, [r7, #52]	; 0x34
			if (sensorType != INV_SENSOR_GYRO)
  40a20e:	7bfb      	ldrb	r3, [r7, #15]
  40a210:	2b01      	cmp	r3, #1
  40a212:	d01d      	beq.n	40a250 <inv_check_accelgyro_self_test+0x104>
				// (AXST / AXST_OTP)  < 1.5
				if (lDiffNormalStValues[i] > UPPER_BOUND_CHECK(l_st_otp_read[i]) )
  40a214:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a216:	009b      	lsls	r3, r3, #2
  40a218:	f107 0238 	add.w	r2, r7, #56	; 0x38
  40a21c:	4413      	add	r3, r2
  40a21e:	f853 2c24 	ldr.w	r2, [r3, #-36]
  40a222:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a224:	009b      	lsls	r3, r3, #2
  40a226:	f107 0138 	add.w	r1, r7, #56	; 0x38
  40a22a:	440b      	add	r3, r1
  40a22c:	f853 1c18 	ldr.w	r1, [r3, #-24]
  40a230:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a232:	009b      	lsls	r3, r3, #2
  40a234:	f107 0038 	add.w	r0, r7, #56	; 0x38
  40a238:	4403      	add	r3, r0
  40a23a:	f853 3c18 	ldr.w	r3, [r3, #-24]
  40a23e:	105b      	asrs	r3, r3, #1
  40a240:	440b      	add	r3, r1
  40a242:	429a      	cmp	r2, r3
  40a244:	dd04      	ble.n	40a250 <inv_check_accelgyro_self_test+0x104>
					ret_val = 1;
  40a246:	2301      	movs	r3, #1
  40a248:	637b      	str	r3, [r7, #52]	; 0x34
  40a24a:	e001      	b.n	40a250 <inv_check_accelgyro_self_test+0x104>
		} else
			ret_val = 1;
  40a24c:	2301      	movs	r3, #1
  40a24e:	637b      	str	r3, [r7, #52]	; 0x34
	for (i = 0; i < 3; i++) {
  40a250:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a252:	3301      	adds	r3, #1
  40a254:	62fb      	str	r3, [r7, #44]	; 0x2c
  40a256:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a258:	2b02      	cmp	r3, #2
  40a25a:	ddb0      	ble.n	40a1be <inv_check_accelgyro_self_test+0x72>
	}

	return ret_val;
  40a25c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  40a25e:	4618      	mov	r0, r3
  40a260:	373c      	adds	r7, #60	; 0x3c
  40a262:	46bd      	mov	sp, r7
  40a264:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a268:	4770      	bx	lr
  40a26a:	bf00      	nop
  40a26c:	0041bf1c 	.word	0x0041bf1c

0040a270 <inv_setup_selftest>:

static int inv_setup_selftest(struct inv_icm20648 * s, struct recover_regs * recover_regs)
{
  40a270:	b590      	push	{r4, r7, lr}
  40a272:	b085      	sub	sp, #20
  40a274:	af00      	add	r7, sp, #0
  40a276:	6078      	str	r0, [r7, #4]
  40a278:	6039      	str	r1, [r7, #0]
	int result = 0;
  40a27a:	2300      	movs	r3, #0
  40a27c:	60fb      	str	r3, [r7, #12]

	// reset static value
	memset(s->gyro_st_data, 0, sizeof(s->gyro_st_data));
  40a27e:	687b      	ldr	r3, [r7, #4]
  40a280:	3391      	adds	r3, #145	; 0x91
  40a282:	2203      	movs	r2, #3
  40a284:	2100      	movs	r1, #0
  40a286:	4618      	mov	r0, r3
  40a288:	4b6b      	ldr	r3, [pc, #428]	; (40a438 <inv_setup_selftest+0x1c8>)
  40a28a:	4798      	blx	r3
	memset(s->accel_st_data, 0, sizeof(s->accel_st_data));
  40a28c:	687b      	ldr	r3, [r7, #4]
  40a28e:	3394      	adds	r3, #148	; 0x94
  40a290:	2203      	movs	r2, #3
  40a292:	2100      	movs	r1, #0
  40a294:	4618      	mov	r0, r3
  40a296:	4b68      	ldr	r3, [pc, #416]	; (40a438 <inv_setup_selftest+0x1c8>)
  40a298:	4798      	blx	r3

	// Save the current settings
	result |= inv_save_setting(s, recover_regs);
  40a29a:	6839      	ldr	r1, [r7, #0]
  40a29c:	6878      	ldr	r0, [r7, #4]
  40a29e:	4b67      	ldr	r3, [pc, #412]	; (40a43c <inv_setup_selftest+0x1cc>)
  40a2a0:	4798      	blx	r3
  40a2a2:	4602      	mov	r2, r0
  40a2a4:	68fb      	ldr	r3, [r7, #12]
  40a2a6:	4313      	orrs	r3, r2
  40a2a8:	60fb      	str	r3, [r7, #12]

	// Wake up
	result |= inv_icm20648_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_CLK_PLL);
  40a2aa:	2201      	movs	r2, #1
  40a2ac:	2106      	movs	r1, #6
  40a2ae:	6878      	ldr	r0, [r7, #4]
  40a2b0:	4b63      	ldr	r3, [pc, #396]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a2b2:	4798      	blx	r3
  40a2b4:	4602      	mov	r2, r0
  40a2b6:	68fb      	ldr	r3, [r7, #12]
  40a2b8:	4313      	orrs	r3, r2
  40a2ba:	60fb      	str	r3, [r7, #12]

	// Stop sensors
	result |= inv_icm20648_write_single_mems_reg(s, REG_PWR_MGMT_2, BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
  40a2bc:	223f      	movs	r2, #63	; 0x3f
  40a2be:	2107      	movs	r1, #7
  40a2c0:	6878      	ldr	r0, [r7, #4]
  40a2c2:	4b5f      	ldr	r3, [pc, #380]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a2c4:	4798      	blx	r3
  40a2c6:	4602      	mov	r2, r0
  40a2c8:	68fb      	ldr	r3, [r7, #12]
  40a2ca:	4313      	orrs	r3, r2
  40a2cc:	60fb      	str	r3, [r7, #12]

	/* Perform a soft-reset of the chip by setting the MSB of PWR_MGMT_1 register
	* This will clear any prior states in the chip
	*/
	result |= inv_icm20648_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_H_RESET);               
  40a2ce:	2280      	movs	r2, #128	; 0x80
  40a2d0:	2106      	movs	r1, #6
  40a2d2:	6878      	ldr	r0, [r7, #4]
  40a2d4:	4b5a      	ldr	r3, [pc, #360]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a2d6:	4798      	blx	r3
  40a2d8:	4602      	mov	r2, r0
  40a2da:	68fb      	ldr	r3, [r7, #12]
  40a2dc:	4313      	orrs	r3, r2
  40a2de:	60fb      	str	r3, [r7, #12]
	inv_icm20648_sleep_us(100000); //100ms delay after soft reset--yd
  40a2e0:	4858      	ldr	r0, [pc, #352]	; (40a444 <inv_setup_selftest+0x1d4>)
  40a2e2:	4b59      	ldr	r3, [pc, #356]	; (40a448 <inv_setup_selftest+0x1d8>)
  40a2e4:	4798      	blx	r3

	// Wake up
	result |= inv_icm20648_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_CLK_PLL);
  40a2e6:	2201      	movs	r2, #1
  40a2e8:	2106      	movs	r1, #6
  40a2ea:	6878      	ldr	r0, [r7, #4]
  40a2ec:	4b54      	ldr	r3, [pc, #336]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a2ee:	4798      	blx	r3
  40a2f0:	4602      	mov	r2, r0
  40a2f2:	68fb      	ldr	r3, [r7, #12]
  40a2f4:	4313      	orrs	r3, r2
  40a2f6:	60fb      	str	r3, [r7, #12]
	if (result)
  40a2f8:	68fb      	ldr	r3, [r7, #12]
  40a2fa:	2b00      	cmp	r3, #0
  40a2fc:	d001      	beq.n	40a302 <inv_setup_selftest+0x92>
		return result;
  40a2fe:	68fb      	ldr	r3, [r7, #12]
  40a300:	e095      	b.n	40a42e <inv_setup_selftest+0x1be>

	// Set cycle mode
	result |= inv_icm20648_write_single_mems_reg(s, REG_LP_CONFIG, 
  40a302:	2270      	movs	r2, #112	; 0x70
  40a304:	2105      	movs	r1, #5
  40a306:	6878      	ldr	r0, [r7, #4]
  40a308:	4b4d      	ldr	r3, [pc, #308]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a30a:	4798      	blx	r3
  40a30c:	4602      	mov	r2, r0
  40a30e:	68fb      	ldr	r3, [r7, #12]
  40a310:	4313      	orrs	r3, r2
  40a312:	60fb      	str	r3, [r7, #12]
		BIT_I2C_MST_CYCLE | BIT_ACCEL_CYCLE | BIT_GYRO_CYCLE);

	// Configure FSR and DLPF for gyro
	result |= inv_icm20648_write_single_mems_reg(s, REG_GYRO_SMPLRT_DIV, SELFTEST_GYRO_SMPLRT_DIV);
  40a314:	220a      	movs	r2, #10
  40a316:	f44f 7180 	mov.w	r1, #256	; 0x100
  40a31a:	6878      	ldr	r0, [r7, #4]
  40a31c:	4b48      	ldr	r3, [pc, #288]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a31e:	4798      	blx	r3
  40a320:	4602      	mov	r2, r0
  40a322:	68fb      	ldr	r3, [r7, #12]
  40a324:	4313      	orrs	r3, r2
  40a326:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_GYRO_CONFIG_1, SELFTEST_GYRO_FS);
  40a328:	2201      	movs	r2, #1
  40a32a:	f240 1101 	movw	r1, #257	; 0x101
  40a32e:	6878      	ldr	r0, [r7, #4]
  40a330:	4b43      	ldr	r3, [pc, #268]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a332:	4798      	blx	r3
  40a334:	4602      	mov	r2, r0
  40a336:	68fb      	ldr	r3, [r7, #12]
  40a338:	4313      	orrs	r3, r2
  40a33a:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_GYRO_CONFIG_2, SELFTEST_GYRO_AVGCFG);
  40a33c:	2203      	movs	r2, #3
  40a33e:	f44f 7181 	mov.w	r1, #258	; 0x102
  40a342:	6878      	ldr	r0, [r7, #4]
  40a344:	4b3e      	ldr	r3, [pc, #248]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a346:	4798      	blx	r3
  40a348:	4602      	mov	r2, r0
  40a34a:	68fb      	ldr	r3, [r7, #12]
  40a34c:	4313      	orrs	r3, r2
  40a34e:	60fb      	str	r3, [r7, #12]

	// Configure FSR and DLPF for accel
	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, 0);
  40a350:	2200      	movs	r2, #0
  40a352:	f44f 7188 	mov.w	r1, #272	; 0x110
  40a356:	6878      	ldr	r0, [r7, #4]
  40a358:	4b39      	ldr	r3, [pc, #228]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a35a:	4798      	blx	r3
  40a35c:	4602      	mov	r2, r0
  40a35e:	68fb      	ldr	r3, [r7, #12]
  40a360:	4313      	orrs	r3, r2
  40a362:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_2, SELFTEST_ACCEL_SMPLRT_DIV);
  40a364:	220a      	movs	r2, #10
  40a366:	f240 1111 	movw	r1, #273	; 0x111
  40a36a:	6878      	ldr	r0, [r7, #4]
  40a36c:	4b34      	ldr	r3, [pc, #208]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a36e:	4798      	blx	r3
  40a370:	4602      	mov	r2, r0
  40a372:	68fb      	ldr	r3, [r7, #12]
  40a374:	4313      	orrs	r3, r2
  40a376:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_CONFIG, SELFTEST_ACCEL_FS);
  40a378:	2239      	movs	r2, #57	; 0x39
  40a37a:	f44f 718a 	mov.w	r1, #276	; 0x114
  40a37e:	6878      	ldr	r0, [r7, #4]
  40a380:	4b2f      	ldr	r3, [pc, #188]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a382:	4798      	blx	r3
  40a384:	4602      	mov	r2, r0
  40a386:	68fb      	ldr	r3, [r7, #12]
  40a388:	4313      	orrs	r3, r2
  40a38a:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, SELFTEST_ACCEL_DEC3_CFG);
  40a38c:	2202      	movs	r2, #2
  40a38e:	f240 1115 	movw	r1, #277	; 0x115
  40a392:	6878      	ldr	r0, [r7, #4]
  40a394:	4b2a      	ldr	r3, [pc, #168]	; (40a440 <inv_setup_selftest+0x1d0>)
  40a396:	4798      	blx	r3
  40a398:	4602      	mov	r2, r0
  40a39a:	68fb      	ldr	r3, [r7, #12]
  40a39c:	4313      	orrs	r3, r2
  40a39e:	60fb      	str	r3, [r7, #12]

	// Read selftest values
	// Retrieve factory Self-Test code (ST_Code) from SELF_TEST registers  (User Bank 1): 
	result |= inv_icm20648_read_mems_reg(s, REG_SELF_TEST1, 1, &s->gyro_st_data[0]);
  40a3a0:	687b      	ldr	r3, [r7, #4]
  40a3a2:	3391      	adds	r3, #145	; 0x91
  40a3a4:	2201      	movs	r2, #1
  40a3a6:	2182      	movs	r1, #130	; 0x82
  40a3a8:	6878      	ldr	r0, [r7, #4]
  40a3aa:	4c28      	ldr	r4, [pc, #160]	; (40a44c <inv_setup_selftest+0x1dc>)
  40a3ac:	47a0      	blx	r4
  40a3ae:	4602      	mov	r2, r0
  40a3b0:	68fb      	ldr	r3, [r7, #12]
  40a3b2:	4313      	orrs	r3, r2
  40a3b4:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_SELF_TEST2, 1, &s->gyro_st_data[1]);
  40a3b6:	687b      	ldr	r3, [r7, #4]
  40a3b8:	3392      	adds	r3, #146	; 0x92
  40a3ba:	2201      	movs	r2, #1
  40a3bc:	2183      	movs	r1, #131	; 0x83
  40a3be:	6878      	ldr	r0, [r7, #4]
  40a3c0:	4c22      	ldr	r4, [pc, #136]	; (40a44c <inv_setup_selftest+0x1dc>)
  40a3c2:	47a0      	blx	r4
  40a3c4:	4602      	mov	r2, r0
  40a3c6:	68fb      	ldr	r3, [r7, #12]
  40a3c8:	4313      	orrs	r3, r2
  40a3ca:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_SELF_TEST3, 1, &s->gyro_st_data[2]);
  40a3cc:	687b      	ldr	r3, [r7, #4]
  40a3ce:	3393      	adds	r3, #147	; 0x93
  40a3d0:	2201      	movs	r2, #1
  40a3d2:	2184      	movs	r1, #132	; 0x84
  40a3d4:	6878      	ldr	r0, [r7, #4]
  40a3d6:	4c1d      	ldr	r4, [pc, #116]	; (40a44c <inv_setup_selftest+0x1dc>)
  40a3d8:	47a0      	blx	r4
  40a3da:	4602      	mov	r2, r0
  40a3dc:	68fb      	ldr	r3, [r7, #12]
  40a3de:	4313      	orrs	r3, r2
  40a3e0:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_SELF_TEST4, 1, &s->accel_st_data[0]);
  40a3e2:	687b      	ldr	r3, [r7, #4]
  40a3e4:	3394      	adds	r3, #148	; 0x94
  40a3e6:	2201      	movs	r2, #1
  40a3e8:	218e      	movs	r1, #142	; 0x8e
  40a3ea:	6878      	ldr	r0, [r7, #4]
  40a3ec:	4c17      	ldr	r4, [pc, #92]	; (40a44c <inv_setup_selftest+0x1dc>)
  40a3ee:	47a0      	blx	r4
  40a3f0:	4602      	mov	r2, r0
  40a3f2:	68fb      	ldr	r3, [r7, #12]
  40a3f4:	4313      	orrs	r3, r2
  40a3f6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_SELF_TEST5, 1, &s->accel_st_data[1]);
  40a3f8:	687b      	ldr	r3, [r7, #4]
  40a3fa:	3395      	adds	r3, #149	; 0x95
  40a3fc:	2201      	movs	r2, #1
  40a3fe:	218f      	movs	r1, #143	; 0x8f
  40a400:	6878      	ldr	r0, [r7, #4]
  40a402:	4c12      	ldr	r4, [pc, #72]	; (40a44c <inv_setup_selftest+0x1dc>)
  40a404:	47a0      	blx	r4
  40a406:	4602      	mov	r2, r0
  40a408:	68fb      	ldr	r3, [r7, #12]
  40a40a:	4313      	orrs	r3, r2
  40a40c:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20648_read_mems_reg(s, REG_SELF_TEST6, 1, &s->accel_st_data[2]);
  40a40e:	687b      	ldr	r3, [r7, #4]
  40a410:	3396      	adds	r3, #150	; 0x96
  40a412:	2201      	movs	r2, #1
  40a414:	2190      	movs	r1, #144	; 0x90
  40a416:	6878      	ldr	r0, [r7, #4]
  40a418:	4c0c      	ldr	r4, [pc, #48]	; (40a44c <inv_setup_selftest+0x1dc>)
  40a41a:	47a0      	blx	r4
  40a41c:	4602      	mov	r2, r0
  40a41e:	68fb      	ldr	r3, [r7, #12]
  40a420:	4313      	orrs	r3, r2
  40a422:	60fb      	str	r3, [r7, #12]

	// Restart sensors
	inv_icm20648_sleep_us(GYRO_ENGINE_UP_TIME*1000);
  40a424:	f24c 3050 	movw	r0, #50000	; 0xc350
  40a428:	4b07      	ldr	r3, [pc, #28]	; (40a448 <inv_setup_selftest+0x1d8>)
  40a42a:	4798      	blx	r3

	return result;
  40a42c:	68fb      	ldr	r3, [r7, #12]
}
  40a42e:	4618      	mov	r0, r3
  40a430:	3714      	adds	r7, #20
  40a432:	46bd      	mov	sp, r7
  40a434:	bd90      	pop	{r4, r7, pc}
  40a436:	bf00      	nop
  40a438:	00414431 	.word	0x00414431
  40a43c:	00409dcd 	.word	0x00409dcd
  40a440:	0040c9d5 	.word	0x0040c9d5
  40a444:	000186a0 	.word	0x000186a0
  40a448:	004015d9 	.word	0x004015d9
  40a44c:	0040caa1 	.word	0x0040caa1

0040a450 <inv_selftest_read_samples>:

static int inv_selftest_read_samples(struct inv_icm20648 * self, enum INV_SENSORS type, int *sum_result, int *s)
{
  40a450:	b590      	push	{r4, r7, lr}
  40a452:	b08b      	sub	sp, #44	; 0x2c
  40a454:	af00      	add	r7, sp, #0
  40a456:	60f8      	str	r0, [r7, #12]
  40a458:	607a      	str	r2, [r7, #4]
  40a45a:	603b      	str	r3, [r7, #0]
  40a45c:	460b      	mov	r3, r1
  40a45e:	72fb      	strb	r3, [r7, #11]
	// - GZ_OS = Average (GYRO_ZOUT_H | GYRO_ZOUT_L)
	// - AX_OS = Average (ACCEL_XOUT_H | ACCEL_XOUT_L)
	// - AY_OS = Average (ACCEL_YOUT_H | ACCEL_YOUT_L)
	// - AZ_OS = Average (ACCEL_ZOUT_H | ACCEL_ZOUT_L)

	if (INV_SENSOR_GYRO == type)
  40a460:	7afb      	ldrb	r3, [r7, #11]
  40a462:	2b01      	cmp	r3, #1
  40a464:	d103      	bne.n	40a46e <inv_selftest_read_samples+0x1e>
		w = REG_GYRO_XOUT_H_SH;
  40a466:	2333      	movs	r3, #51	; 0x33
  40a468:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  40a46c:	e051      	b.n	40a512 <inv_selftest_read_samples+0xc2>
	else
		w = REG_ACCEL_XOUT_H_SH;
  40a46e:	232d      	movs	r3, #45	; 0x2d
  40a470:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	while (*s < DEF_ST_SAMPLES) {
  40a474:	e04d      	b.n	40a512 <inv_selftest_read_samples+0xc2>

		if(inv_icm20648_read_mems_reg(self, w, BYTES_PER_SENSOR, d))
  40a476:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40a47a:	b299      	uxth	r1, r3
  40a47c:	f107 0310 	add.w	r3, r7, #16
  40a480:	2206      	movs	r2, #6
  40a482:	68f8      	ldr	r0, [r7, #12]
  40a484:	4c27      	ldr	r4, [pc, #156]	; (40a524 <inv_selftest_read_samples+0xd4>)
  40a486:	47a0      	blx	r4
  40a488:	4603      	mov	r3, r0
  40a48a:	2b00      	cmp	r3, #0
  40a48c:	d002      	beq.n	40a494 <inv_selftest_read_samples+0x44>
			return -1;
  40a48e:	f04f 33ff 	mov.w	r3, #4294967295
  40a492:	e043      	b.n	40a51c <inv_selftest_read_samples+0xcc>

		for (j = 0; j < THREE_AXES; j++) {
  40a494:	2300      	movs	r3, #0
  40a496:	623b      	str	r3, [r7, #32]
  40a498:	e02f      	b.n	40a4fa <inv_selftest_read_samples+0xaa>
			vals[j] = (d[(2*j)]<<8) | (d[(2*j)+ 1] & 0xff);
  40a49a:	6a3b      	ldr	r3, [r7, #32]
  40a49c:	005b      	lsls	r3, r3, #1
  40a49e:	f107 0228 	add.w	r2, r7, #40	; 0x28
  40a4a2:	4413      	add	r3, r2
  40a4a4:	f813 3c18 	ldrb.w	r3, [r3, #-24]
  40a4a8:	021b      	lsls	r3, r3, #8
  40a4aa:	b21a      	sxth	r2, r3
  40a4ac:	6a3b      	ldr	r3, [r7, #32]
  40a4ae:	005b      	lsls	r3, r3, #1
  40a4b0:	3301      	adds	r3, #1
  40a4b2:	f107 0128 	add.w	r1, r7, #40	; 0x28
  40a4b6:	440b      	add	r3, r1
  40a4b8:	f813 3c18 	ldrb.w	r3, [r3, #-24]
  40a4bc:	b21b      	sxth	r3, r3
  40a4be:	4313      	orrs	r3, r2
  40a4c0:	b21a      	sxth	r2, r3
  40a4c2:	6a3b      	ldr	r3, [r7, #32]
  40a4c4:	005b      	lsls	r3, r3, #1
  40a4c6:	f107 0128 	add.w	r1, r7, #40	; 0x28
  40a4ca:	440b      	add	r3, r1
  40a4cc:	f823 2c10 	strh.w	r2, [r3, #-16]
			sum_result[j] += vals[j];
  40a4d0:	6a3b      	ldr	r3, [r7, #32]
  40a4d2:	009b      	lsls	r3, r3, #2
  40a4d4:	687a      	ldr	r2, [r7, #4]
  40a4d6:	441a      	add	r2, r3
  40a4d8:	6a3b      	ldr	r3, [r7, #32]
  40a4da:	009b      	lsls	r3, r3, #2
  40a4dc:	6879      	ldr	r1, [r7, #4]
  40a4de:	440b      	add	r3, r1
  40a4e0:	6819      	ldr	r1, [r3, #0]
  40a4e2:	6a3b      	ldr	r3, [r7, #32]
  40a4e4:	005b      	lsls	r3, r3, #1
  40a4e6:	f107 0028 	add.w	r0, r7, #40	; 0x28
  40a4ea:	4403      	add	r3, r0
  40a4ec:	f933 3c10 	ldrsh.w	r3, [r3, #-16]
  40a4f0:	440b      	add	r3, r1
  40a4f2:	6013      	str	r3, [r2, #0]
		for (j = 0; j < THREE_AXES; j++) {
  40a4f4:	6a3b      	ldr	r3, [r7, #32]
  40a4f6:	3301      	adds	r3, #1
  40a4f8:	623b      	str	r3, [r7, #32]
  40a4fa:	6a3b      	ldr	r3, [r7, #32]
  40a4fc:	2b02      	cmp	r3, #2
  40a4fe:	ddcc      	ble.n	40a49a <inv_selftest_read_samples+0x4a>
		}

		(*s)++;
  40a500:	683b      	ldr	r3, [r7, #0]
  40a502:	681b      	ldr	r3, [r3, #0]
  40a504:	1c5a      	adds	r2, r3, #1
  40a506:	683b      	ldr	r3, [r7, #0]
  40a508:	601a      	str	r2, [r3, #0]

		inv_icm20648_sleep_us(WAIT_TIME_BTW_2_SAMPLESREAD*1000);
  40a50a:	f242 7010 	movw	r0, #10000	; 0x2710
  40a50e:	4b06      	ldr	r3, [pc, #24]	; (40a528 <inv_selftest_read_samples+0xd8>)
  40a510:	4798      	blx	r3
	while (*s < DEF_ST_SAMPLES) {
  40a512:	683b      	ldr	r3, [r7, #0]
  40a514:	681b      	ldr	r3, [r3, #0]
  40a516:	2bc7      	cmp	r3, #199	; 0xc7
  40a518:	ddad      	ble.n	40a476 <inv_selftest_read_samples+0x26>
	}
	return 0;
  40a51a:	2300      	movs	r3, #0
}
  40a51c:	4618      	mov	r0, r3
  40a51e:	372c      	adds	r7, #44	; 0x2c
  40a520:	46bd      	mov	sp, r7
  40a522:	bd90      	pop	{r4, r7, pc}
  40a524:	0040caa1 	.word	0x0040caa1
  40a528:	004015d9 	.word	0x004015d9

0040a52c <inv_do_test_accelgyro>:

/*
*  inv_do_test_accelgyro() - do the actual test of self testing
*/
static int inv_do_test_accelgyro(struct inv_icm20648 * s, enum INV_SENSORS sensorType, int *meanValue, int *stMeanValue)
{
  40a52c:	b590      	push	{r4, r7, lr}
  40a52e:	b089      	sub	sp, #36	; 0x24
  40a530:	af00      	add	r7, sp, #0
  40a532:	60f8      	str	r0, [r7, #12]
  40a534:	607a      	str	r2, [r7, #4]
  40a536:	603b      	str	r3, [r7, #0]
  40a538:	460b      	mov	r3, r1
  40a53a:	72fb      	strb	r3, [r7, #11]
	int result, i, j;
	int lNbSamples = 0;
  40a53c:	2300      	movs	r3, #0
  40a53e:	613b      	str	r3, [r7, #16]

	// initialize output to be 0
	for (i = 0; i < THREE_AXES; i++) {
  40a540:	2300      	movs	r3, #0
  40a542:	61bb      	str	r3, [r7, #24]
  40a544:	e00e      	b.n	40a564 <inv_do_test_accelgyro+0x38>
		meanValue[i] = 0;
  40a546:	69bb      	ldr	r3, [r7, #24]
  40a548:	009b      	lsls	r3, r3, #2
  40a54a:	687a      	ldr	r2, [r7, #4]
  40a54c:	4413      	add	r3, r2
  40a54e:	2200      	movs	r2, #0
  40a550:	601a      	str	r2, [r3, #0]
		stMeanValue[i] = 0;
  40a552:	69bb      	ldr	r3, [r7, #24]
  40a554:	009b      	lsls	r3, r3, #2
  40a556:	683a      	ldr	r2, [r7, #0]
  40a558:	4413      	add	r3, r2
  40a55a:	2200      	movs	r2, #0
  40a55c:	601a      	str	r2, [r3, #0]
	for (i = 0; i < THREE_AXES; i++) {
  40a55e:	69bb      	ldr	r3, [r7, #24]
  40a560:	3301      	adds	r3, #1
  40a562:	61bb      	str	r3, [r7, #24]
  40a564:	69bb      	ldr	r3, [r7, #24]
  40a566:	2b02      	cmp	r3, #2
  40a568:	dded      	ble.n	40a546 <inv_do_test_accelgyro+0x1a>
	}

	// read the accel/gyro output
	// the output values are 16 bits wide and in 2s complement
	// Average 200 readings and save the averaged values
	result = inv_selftest_read_samples(s, sensorType, meanValue, &lNbSamples);
  40a56a:	f107 0310 	add.w	r3, r7, #16
  40a56e:	7af9      	ldrb	r1, [r7, #11]
  40a570:	687a      	ldr	r2, [r7, #4]
  40a572:	68f8      	ldr	r0, [r7, #12]
  40a574:	4c31      	ldr	r4, [pc, #196]	; (40a63c <inv_do_test_accelgyro+0x110>)
  40a576:	47a0      	blx	r4
  40a578:	61f8      	str	r0, [r7, #28]
	if (result)
  40a57a:	69fb      	ldr	r3, [r7, #28]
  40a57c:	2b00      	cmp	r3, #0
  40a57e:	d001      	beq.n	40a584 <inv_do_test_accelgyro+0x58>
		return result;
  40a580:	69fb      	ldr	r3, [r7, #28]
  40a582:	e056      	b.n	40a632 <inv_do_test_accelgyro+0x106>
	for (j = 0; j < THREE_AXES; j++) {
  40a584:	2300      	movs	r3, #0
  40a586:	617b      	str	r3, [r7, #20]
  40a588:	e00f      	b.n	40a5aa <inv_do_test_accelgyro+0x7e>
		meanValue[j] /= lNbSamples;
  40a58a:	697b      	ldr	r3, [r7, #20]
  40a58c:	009b      	lsls	r3, r3, #2
  40a58e:	687a      	ldr	r2, [r7, #4]
  40a590:	4413      	add	r3, r2
  40a592:	697a      	ldr	r2, [r7, #20]
  40a594:	0092      	lsls	r2, r2, #2
  40a596:	6879      	ldr	r1, [r7, #4]
  40a598:	440a      	add	r2, r1
  40a59a:	6811      	ldr	r1, [r2, #0]
  40a59c:	693a      	ldr	r2, [r7, #16]
  40a59e:	fb91 f2f2 	sdiv	r2, r1, r2
  40a5a2:	601a      	str	r2, [r3, #0]
	for (j = 0; j < THREE_AXES; j++) {
  40a5a4:	697b      	ldr	r3, [r7, #20]
  40a5a6:	3301      	adds	r3, #1
  40a5a8:	617b      	str	r3, [r7, #20]
  40a5aa:	697b      	ldr	r3, [r7, #20]
  40a5ac:	2b02      	cmp	r3, #2
  40a5ae:	ddec      	ble.n	40a58a <inv_do_test_accelgyro+0x5e>
	}

	// Set Self-Test Bit
	if (sensorType == INV_SENSOR_GYRO)
  40a5b0:	7afb      	ldrb	r3, [r7, #11]
  40a5b2:	2b01      	cmp	r3, #1
  40a5b4:	d107      	bne.n	40a5c6 <inv_do_test_accelgyro+0x9a>
	{
		// Enable gyroscope Self-Test by setting register User Bank 2, Register Address 02 (02h) Bit [5:3] to b111
		result = inv_icm20648_write_single_mems_reg(s, REG_GYRO_CONFIG_2, BIT_GYRO_CTEN | SELFTEST_GYRO_AVGCFG);
  40a5b6:	223b      	movs	r2, #59	; 0x3b
  40a5b8:	f44f 7181 	mov.w	r1, #258	; 0x102
  40a5bc:	68f8      	ldr	r0, [r7, #12]
  40a5be:	4b20      	ldr	r3, [pc, #128]	; (40a640 <inv_do_test_accelgyro+0x114>)
  40a5c0:	4798      	blx	r3
  40a5c2:	61f8      	str	r0, [r7, #28]
  40a5c4:	e006      	b.n	40a5d4 <inv_do_test_accelgyro+0xa8>
	} else
	{
		result = inv_icm20648_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, BIT_ACCEL_CTEN | SELFTEST_ACCEL_DEC3_CFG);
  40a5c6:	221e      	movs	r2, #30
  40a5c8:	f240 1115 	movw	r1, #277	; 0x115
  40a5cc:	68f8      	ldr	r0, [r7, #12]
  40a5ce:	4b1c      	ldr	r3, [pc, #112]	; (40a640 <inv_do_test_accelgyro+0x114>)
  40a5d0:	4798      	blx	r3
  40a5d2:	61f8      	str	r0, [r7, #28]
	}
	if (result)
  40a5d4:	69fb      	ldr	r3, [r7, #28]
  40a5d6:	2b00      	cmp	r3, #0
  40a5d8:	d001      	beq.n	40a5de <inv_do_test_accelgyro+0xb2>
		return result;
  40a5da:	69fb      	ldr	r3, [r7, #28]
  40a5dc:	e029      	b.n	40a632 <inv_do_test_accelgyro+0x106>

	// Wait 20ms for oscillations to stabilize. 
	inv_icm20648_sleep_us(DEF_ST_STABLE_TIME*1000);
  40a5de:	f644 6020 	movw	r0, #20000	; 0x4e20
  40a5e2:	4b18      	ldr	r3, [pc, #96]	; (40a644 <inv_do_test_accelgyro+0x118>)
  40a5e4:	4798      	blx	r3

	// Read the accel/gyro output and average 200 readings
	// These readings are in units of LSBs
	lNbSamples = 0; 
  40a5e6:	2300      	movs	r3, #0
  40a5e8:	613b      	str	r3, [r7, #16]
	result = inv_selftest_read_samples(s, sensorType, stMeanValue, &lNbSamples);
  40a5ea:	f107 0310 	add.w	r3, r7, #16
  40a5ee:	7af9      	ldrb	r1, [r7, #11]
  40a5f0:	683a      	ldr	r2, [r7, #0]
  40a5f2:	68f8      	ldr	r0, [r7, #12]
  40a5f4:	4c11      	ldr	r4, [pc, #68]	; (40a63c <inv_do_test_accelgyro+0x110>)
  40a5f6:	47a0      	blx	r4
  40a5f8:	61f8      	str	r0, [r7, #28]
	if (result)
  40a5fa:	69fb      	ldr	r3, [r7, #28]
  40a5fc:	2b00      	cmp	r3, #0
  40a5fe:	d001      	beq.n	40a604 <inv_do_test_accelgyro+0xd8>
		return result;
  40a600:	69fb      	ldr	r3, [r7, #28]
  40a602:	e016      	b.n	40a632 <inv_do_test_accelgyro+0x106>
	for (j = 0; j < THREE_AXES; j++) {
  40a604:	2300      	movs	r3, #0
  40a606:	617b      	str	r3, [r7, #20]
  40a608:	e00f      	b.n	40a62a <inv_do_test_accelgyro+0xfe>
		stMeanValue[j] /= lNbSamples;
  40a60a:	697b      	ldr	r3, [r7, #20]
  40a60c:	009b      	lsls	r3, r3, #2
  40a60e:	683a      	ldr	r2, [r7, #0]
  40a610:	4413      	add	r3, r2
  40a612:	697a      	ldr	r2, [r7, #20]
  40a614:	0092      	lsls	r2, r2, #2
  40a616:	6839      	ldr	r1, [r7, #0]
  40a618:	440a      	add	r2, r1
  40a61a:	6811      	ldr	r1, [r2, #0]
  40a61c:	693a      	ldr	r2, [r7, #16]
  40a61e:	fb91 f2f2 	sdiv	r2, r1, r2
  40a622:	601a      	str	r2, [r3, #0]
	for (j = 0; j < THREE_AXES; j++) {
  40a624:	697b      	ldr	r3, [r7, #20]
  40a626:	3301      	adds	r3, #1
  40a628:	617b      	str	r3, [r7, #20]
  40a62a:	697b      	ldr	r3, [r7, #20]
  40a62c:	2b02      	cmp	r3, #2
  40a62e:	ddec      	ble.n	40a60a <inv_do_test_accelgyro+0xde>
	}

	return 0;
  40a630:	2300      	movs	r3, #0
}
  40a632:	4618      	mov	r0, r3
  40a634:	3724      	adds	r7, #36	; 0x24
  40a636:	46bd      	mov	sp, r7
  40a638:	bd90      	pop	{r4, r7, pc}
  40a63a:	bf00      	nop
  40a63c:	0040a451 	.word	0x0040a451
  40a640:	0040c9d5 	.word	0x0040c9d5
  40a644:	004015d9 	.word	0x004015d9

0040a648 <inv_icm20648_run_selftest>:

int inv_icm20648_run_selftest(struct inv_icm20648 * s, int gyro_bias_regular[], int accel_bias_regular[])
{
  40a648:	b590      	push	{r4, r7, lr}
  40a64a:	b093      	sub	sp, #76	; 0x4c
  40a64c:	af00      	add	r7, sp, #0
  40a64e:	60f8      	str	r0, [r7, #12]
  40a650:	60b9      	str	r1, [r7, #8]
  40a652:	607a      	str	r2, [r7, #4]
	int accel_bias_st[THREE_AXES];
	int test_times;
	char accel_result, gyro_result, compass_result;
	struct recover_regs recover_regs;

	accel_result = 0;
  40a654:	2300      	movs	r3, #0
  40a656:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	gyro_result = 0;
  40a65a:	2300      	movs	r3, #0
  40a65c:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
	compass_result = 0;
  40a660:	2300      	movs	r3, #0
  40a662:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d

	// save original state of the chip, initialize registers, configure sensors and read ST values
	result = inv_setup_selftest(s, &recover_regs);
  40a666:	f107 0314 	add.w	r3, r7, #20
  40a66a:	4619      	mov	r1, r3
  40a66c:	68f8      	ldr	r0, [r7, #12]
  40a66e:	4b41      	ldr	r3, [pc, #260]	; (40a774 <inv_icm20648_run_selftest+0x12c>)
  40a670:	4798      	blx	r3
  40a672:	6478      	str	r0, [r7, #68]	; 0x44
	if (result)
  40a674:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a676:	2b00      	cmp	r3, #0
  40a678:	d163      	bne.n	40a742 <inv_icm20648_run_selftest+0xfa>
		goto test_fail;

	// perform self test for gyro
	test_times = DEF_ST_TRY_TIMES;	
  40a67a:	2302      	movs	r3, #2
  40a67c:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a67e:	e00d      	b.n	40a69c <inv_icm20648_run_selftest+0x54>
		result = inv_do_test_accelgyro(s, INV_SENSOR_GYRO, gyro_bias_regular, gyro_bias_st);
  40a680:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40a684:	68ba      	ldr	r2, [r7, #8]
  40a686:	2101      	movs	r1, #1
  40a688:	68f8      	ldr	r0, [r7, #12]
  40a68a:	4c3b      	ldr	r4, [pc, #236]	; (40a778 <inv_icm20648_run_selftest+0x130>)
  40a68c:	47a0      	blx	r4
  40a68e:	6478      	str	r0, [r7, #68]	; 0x44
		if (result)
  40a690:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a692:	2b00      	cmp	r3, #0
  40a694:	d006      	beq.n	40a6a4 <inv_icm20648_run_selftest+0x5c>
			test_times--;
  40a696:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a698:	3b01      	subs	r3, #1
  40a69a:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a69c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a69e:	2b00      	cmp	r3, #0
  40a6a0:	dcee      	bgt.n	40a680 <inv_icm20648_run_selftest+0x38>
  40a6a2:	e000      	b.n	40a6a6 <inv_icm20648_run_selftest+0x5e>
		else
			break;
  40a6a4:	bf00      	nop
	}
	if (result)
  40a6a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a6a8:	2b00      	cmp	r3, #0
  40a6aa:	d14c      	bne.n	40a746 <inv_icm20648_run_selftest+0xfe>
		goto test_fail;    

	// perform self test for accel
	test_times = DEF_ST_TRY_TIMES;
  40a6ac:	2302      	movs	r3, #2
  40a6ae:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a6b0:	e00d      	b.n	40a6ce <inv_icm20648_run_selftest+0x86>
		result = inv_do_test_accelgyro(s, INV_SENSOR_ACCEL, accel_bias_regular, accel_bias_st);
  40a6b2:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40a6b6:	687a      	ldr	r2, [r7, #4]
  40a6b8:	2100      	movs	r1, #0
  40a6ba:	68f8      	ldr	r0, [r7, #12]
  40a6bc:	4c2e      	ldr	r4, [pc, #184]	; (40a778 <inv_icm20648_run_selftest+0x130>)
  40a6be:	47a0      	blx	r4
  40a6c0:	6478      	str	r0, [r7, #68]	; 0x44
		if (result)
  40a6c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a6c4:	2b00      	cmp	r3, #0
  40a6c6:	d006      	beq.n	40a6d6 <inv_icm20648_run_selftest+0x8e>
			test_times--;
  40a6c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a6ca:	3b01      	subs	r3, #1
  40a6cc:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a6ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a6d0:	2b00      	cmp	r3, #0
  40a6d2:	dcee      	bgt.n	40a6b2 <inv_icm20648_run_selftest+0x6a>
  40a6d4:	e000      	b.n	40a6d8 <inv_icm20648_run_selftest+0x90>
		else
			break;
  40a6d6:	bf00      	nop
	}
	if (result)
  40a6d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a6da:	2b00      	cmp	r3, #0
  40a6dc:	d135      	bne.n	40a74a <inv_icm20648_run_selftest+0x102>
		goto test_fail;

	// check values read at various steps
	accel_result = !inv_check_accelgyro_self_test(INV_SENSOR_ACCEL, s->accel_st_data, accel_bias_regular, accel_bias_st);
  40a6de:	68fb      	ldr	r3, [r7, #12]
  40a6e0:	f103 0194 	add.w	r1, r3, #148	; 0x94
  40a6e4:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40a6e8:	687a      	ldr	r2, [r7, #4]
  40a6ea:	2000      	movs	r0, #0
  40a6ec:	4c23      	ldr	r4, [pc, #140]	; (40a77c <inv_icm20648_run_selftest+0x134>)
  40a6ee:	47a0      	blx	r4
  40a6f0:	4603      	mov	r3, r0
  40a6f2:	2b00      	cmp	r3, #0
  40a6f4:	bf0c      	ite	eq
  40a6f6:	2301      	moveq	r3, #1
  40a6f8:	2300      	movne	r3, #0
  40a6fa:	b2db      	uxtb	r3, r3
  40a6fc:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	gyro_result = !inv_check_accelgyro_self_test(INV_SENSOR_GYRO, s->gyro_st_data, gyro_bias_regular, gyro_bias_st);
  40a700:	68fb      	ldr	r3, [r7, #12]
  40a702:	f103 0191 	add.w	r1, r3, #145	; 0x91
  40a706:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40a70a:	68ba      	ldr	r2, [r7, #8]
  40a70c:	2001      	movs	r0, #1
  40a70e:	4c1b      	ldr	r4, [pc, #108]	; (40a77c <inv_icm20648_run_selftest+0x134>)
  40a710:	47a0      	blx	r4
  40a712:	4603      	mov	r3, r0
  40a714:	2b00      	cmp	r3, #0
  40a716:	bf0c      	ite	eq
  40a718:	2301      	moveq	r3, #1
  40a71a:	2300      	movne	r3, #0
  40a71c:	b2db      	uxtb	r3, r3
  40a71e:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
	if(ak09912_is_available)
  40a722:	4b17      	ldr	r3, [pc, #92]	; (40a780 <inv_icm20648_run_selftest+0x138>)
  40a724:	681b      	ldr	r3, [r3, #0]
  40a726:	2b00      	cmp	r3, #0
  40a728:	d010      	beq.n	40a74c <inv_icm20648_run_selftest+0x104>
		compass_result = !inv_icm20648_check_akm_self_test(s);
  40a72a:	68f8      	ldr	r0, [r7, #12]
  40a72c:	4b15      	ldr	r3, [pc, #84]	; (40a784 <inv_icm20648_run_selftest+0x13c>)
  40a72e:	4798      	blx	r3
  40a730:	4603      	mov	r3, r0
  40a732:	2b00      	cmp	r3, #0
  40a734:	bf0c      	ite	eq
  40a736:	2301      	moveq	r3, #1
  40a738:	2300      	movne	r3, #0
  40a73a:	b2db      	uxtb	r3, r3
  40a73c:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
  40a740:	e004      	b.n	40a74c <inv_icm20648_run_selftest+0x104>
		goto test_fail;
  40a742:	bf00      	nop
  40a744:	e002      	b.n	40a74c <inv_icm20648_run_selftest+0x104>
		goto test_fail;    
  40a746:	bf00      	nop
  40a748:	e000      	b.n	40a74c <inv_icm20648_run_selftest+0x104>
		goto test_fail;
  40a74a:	bf00      	nop

test_fail:
	// restore original state of the chips
	inv_recover_setting(s, &recover_regs);
  40a74c:	f107 0314 	add.w	r3, r7, #20
  40a750:	4619      	mov	r1, r3
  40a752:	68f8      	ldr	r0, [r7, #12]
  40a754:	4b0c      	ldr	r3, [pc, #48]	; (40a788 <inv_icm20648_run_selftest+0x140>)
  40a756:	4798      	blx	r3

	return (compass_result << 2) |
  40a758:	f997 303d 	ldrsb.w	r3, [r7, #61]	; 0x3d
  40a75c:	009a      	lsls	r2, r3, #2
		(accel_result   << 1) |
  40a75e:	f997 303f 	ldrsb.w	r3, [r7, #63]	; 0x3f
  40a762:	005b      	lsls	r3, r3, #1
	return (compass_result << 2) |
  40a764:	431a      	orrs	r2, r3
		(accel_result   << 1) |
  40a766:	f997 303e 	ldrsb.w	r3, [r7, #62]	; 0x3e
  40a76a:	4313      	orrs	r3, r2
		gyro_result;
}
  40a76c:	4618      	mov	r0, r3
  40a76e:	374c      	adds	r7, #76	; 0x4c
  40a770:	46bd      	mov	sp, r7
  40a772:	bd90      	pop	{r4, r7, pc}
  40a774:	0040a271 	.word	0x0040a271
  40a778:	0040a52d 	.word	0x0040a52d
  40a77c:	0040a14d 	.word	0x0040a14d
  40a780:	20000ee8 	.word	0x20000ee8
  40a784:	00404bed 	.word	0x00404bed
  40a788:	00409f51 	.word	0x00409f51

0040a78c <inv_icm20648_read_reg_one>:
{
	return inv_icm20648_write_reg(s, reg, &reg_value, 1);
}

static inline int inv_icm20648_read_reg_one(struct inv_icm20648 * s, uint8_t reg, uint8_t * reg_value)
{
  40a78c:	b590      	push	{r4, r7, lr}
  40a78e:	b085      	sub	sp, #20
  40a790:	af00      	add	r7, sp, #0
  40a792:	60f8      	str	r0, [r7, #12]
  40a794:	460b      	mov	r3, r1
  40a796:	607a      	str	r2, [r7, #4]
  40a798:	72fb      	strb	r3, [r7, #11]
	return inv_icm20648_read_reg(s, reg, reg_value, 1);
  40a79a:	7af9      	ldrb	r1, [r7, #11]
  40a79c:	2301      	movs	r3, #1
  40a79e:	687a      	ldr	r2, [r7, #4]
  40a7a0:	68f8      	ldr	r0, [r7, #12]
  40a7a2:	4c03      	ldr	r4, [pc, #12]	; (40a7b0 <inv_icm20648_read_reg_one+0x24>)
  40a7a4:	47a0      	blx	r4
  40a7a6:	4603      	mov	r3, r0
}
  40a7a8:	4618      	mov	r0, r3
  40a7aa:	3714      	adds	r7, #20
  40a7ac:	46bd      	mov	sp, r7
  40a7ae:	bd90      	pop	{r4, r7, pc}
  40a7b0:	0040c741 	.word	0x0040c741

0040a7b4 <sensor_type_2_android_sensor>:
/** @brief Conversion from DMP units to float format for compass scale */
#define DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION      (1/(float)(1UL<<16))
//! Convert the \a value from QN value to float. \ingroup invn_macro
#define INVN_FXP_TO_FLT(value, shift)	( (float)  (int32_t)(value) / (float)(1ULL << (shift)) )
static uint8_t sensor_type_2_android_sensor(enum inv_icm20648_sensor sensor)
{
  40a7b4:	b480      	push	{r7}
  40a7b6:	b083      	sub	sp, #12
  40a7b8:	af00      	add	r7, sp, #0
  40a7ba:	4603      	mov	r3, r0
  40a7bc:	71fb      	strb	r3, [r7, #7]
	switch(sensor) {
  40a7be:	79fb      	ldrb	r3, [r7, #7]
  40a7c0:	2b13      	cmp	r3, #19
  40a7c2:	d853      	bhi.n	40a86c <sensor_type_2_android_sensor+0xb8>
  40a7c4:	a201      	add	r2, pc, #4	; (adr r2, 40a7cc <sensor_type_2_android_sensor+0x18>)
  40a7c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40a7ca:	bf00      	nop
  40a7cc:	0040a81d 	.word	0x0040a81d
  40a7d0:	0040a821 	.word	0x0040a821
  40a7d4:	0040a825 	.word	0x0040a825
  40a7d8:	0040a829 	.word	0x0040a829
  40a7dc:	0040a82d 	.word	0x0040a82d
  40a7e0:	0040a831 	.word	0x0040a831
  40a7e4:	0040a835 	.word	0x0040a835
  40a7e8:	0040a839 	.word	0x0040a839
  40a7ec:	0040a83d 	.word	0x0040a83d
  40a7f0:	0040a841 	.word	0x0040a841
  40a7f4:	0040a845 	.word	0x0040a845
  40a7f8:	0040a849 	.word	0x0040a849
  40a7fc:	0040a84d 	.word	0x0040a84d
  40a800:	0040a851 	.word	0x0040a851
  40a804:	0040a855 	.word	0x0040a855
  40a808:	0040a859 	.word	0x0040a859
  40a80c:	0040a85d 	.word	0x0040a85d
  40a810:	0040a861 	.word	0x0040a861
  40a814:	0040a865 	.word	0x0040a865
  40a818:	0040a869 	.word	0x0040a869
	case INV_ICM20648_SENSOR_ACCELEROMETER:                 return ANDROID_SENSOR_ACCELEROMETER;
  40a81c:	2301      	movs	r3, #1
  40a81e:	e026      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_GYROSCOPE:                     return ANDROID_SENSOR_GYROSCOPE;
  40a820:	2304      	movs	r3, #4
  40a822:	e024      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_RAW_ACCELEROMETER:             return ANDROID_SENSOR_RAW_ACCELEROMETER;
  40a824:	232a      	movs	r3, #42	; 0x2a
  40a826:	e022      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_RAW_GYROSCOPE:                 return ANDROID_SENSOR_RAW_GYROSCOPE;
  40a828:	232b      	movs	r3, #43	; 0x2b
  40a82a:	e020      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:   return ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED;
  40a82c:	230e      	movs	r3, #14
  40a82e:	e01e      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED:        return ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED;
  40a830:	2310      	movs	r3, #16
  40a832:	e01c      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_ACTIVITY_CLASSIFICATON:        return ANDROID_SENSOR_ACTIVITY_CLASSIFICATON;
  40a834:	232f      	movs	r3, #47	; 0x2f
  40a836:	e01a      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_STEP_DETECTOR:                 return ANDROID_SENSOR_STEP_DETECTOR;
  40a838:	2312      	movs	r3, #18
  40a83a:	e018      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_STEP_COUNTER:                  return ANDROID_SENSOR_STEP_COUNTER;
  40a83c:	2313      	movs	r3, #19
  40a83e:	e016      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_GAME_ROTATION_VECTOR:          return ANDROID_SENSOR_GAME_ROTATION_VECTOR;
  40a840:	230f      	movs	r3, #15
  40a842:	e014      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_ROTATION_VECTOR:               return ANDROID_SENSOR_ROTATION_VECTOR;
  40a844:	230b      	movs	r3, #11
  40a846:	e012      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:   return ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR;
  40a848:	2314      	movs	r3, #20
  40a84a:	e010      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD:             return ANDROID_SENSOR_GEOMAGNETIC_FIELD;
  40a84c:	2302      	movs	r3, #2
  40a84e:	e00e      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_WAKEUP_SIGNIFICANT_MOTION:     return ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION;
  40a850:	2311      	movs	r3, #17
  40a852:	e00c      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_FLIP_PICKUP:                   return ANDROID_SENSOR_FLIP_PICKUP;
  40a854:	232e      	movs	r3, #46	; 0x2e
  40a856:	e00a      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_WAKEUP_TILT_DETECTOR:          return ANDROID_SENSOR_WAKEUP_TILT_DETECTOR;
  40a858:	2329      	movs	r3, #41	; 0x29
  40a85a:	e008      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_GRAVITY:                       return ANDROID_SENSOR_GRAVITY;
  40a85c:	2309      	movs	r3, #9
  40a85e:	e006      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_LINEAR_ACCELERATION:           return ANDROID_SENSOR_LINEAR_ACCELERATION;
  40a860:	230a      	movs	r3, #10
  40a862:	e004      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_ORIENTATION:                   return ANDROID_SENSOR_ORIENTATION;
  40a864:	2303      	movs	r3, #3
  40a866:	e002      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	case INV_ICM20648_SENSOR_B2S:                           return ANDROID_SENSOR_B2S;
  40a868:	232d      	movs	r3, #45	; 0x2d
  40a86a:	e000      	b.n	40a86e <sensor_type_2_android_sensor+0xba>
	default:                                                return ANDROID_SENSOR_NUM_MAX;
  40a86c:	232c      	movs	r3, #44	; 0x2c
	}
}
  40a86e:	4618      	mov	r0, r3
  40a870:	370c      	adds	r7, #12
  40a872:	46bd      	mov	sp, r7
  40a874:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a878:	4770      	bx	lr
  40a87a:	bf00      	nop

0040a87c <inv_icm20648_sensor_android_2_sensor_type>:

enum inv_icm20648_sensor inv_icm20648_sensor_android_2_sensor_type(int sensor)
{
  40a87c:	b480      	push	{r7}
  40a87e:	b083      	sub	sp, #12
  40a880:	af00      	add	r7, sp, #0
  40a882:	6078      	str	r0, [r7, #4]
	switch(sensor) {
  40a884:	687b      	ldr	r3, [r7, #4]
  40a886:	3b01      	subs	r3, #1
  40a888:	2b2e      	cmp	r3, #46	; 0x2e
  40a88a:	f200 8089 	bhi.w	40a9a0 <inv_icm20648_sensor_android_2_sensor_type+0x124>
  40a88e:	a201      	add	r2, pc, #4	; (adr r2, 40a894 <inv_icm20648_sensor_android_2_sensor_type+0x18>)
  40a890:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40a894:	0040a951 	.word	0x0040a951
  40a898:	0040a981 	.word	0x0040a981
  40a89c:	0040a999 	.word	0x0040a999
  40a8a0:	0040a955 	.word	0x0040a955
  40a8a4:	0040a9a1 	.word	0x0040a9a1
  40a8a8:	0040a9a1 	.word	0x0040a9a1
  40a8ac:	0040a9a1 	.word	0x0040a9a1
  40a8b0:	0040a9a1 	.word	0x0040a9a1
  40a8b4:	0040a991 	.word	0x0040a991
  40a8b8:	0040a995 	.word	0x0040a995
  40a8bc:	0040a979 	.word	0x0040a979
  40a8c0:	0040a9a1 	.word	0x0040a9a1
  40a8c4:	0040a9a1 	.word	0x0040a9a1
  40a8c8:	0040a961 	.word	0x0040a961
  40a8cc:	0040a975 	.word	0x0040a975
  40a8d0:	0040a965 	.word	0x0040a965
  40a8d4:	0040a985 	.word	0x0040a985
  40a8d8:	0040a96d 	.word	0x0040a96d
  40a8dc:	0040a971 	.word	0x0040a971
  40a8e0:	0040a97d 	.word	0x0040a97d
  40a8e4:	0040a9a1 	.word	0x0040a9a1
  40a8e8:	0040a9a1 	.word	0x0040a9a1
  40a8ec:	0040a9a1 	.word	0x0040a9a1
  40a8f0:	0040a9a1 	.word	0x0040a9a1
  40a8f4:	0040a9a1 	.word	0x0040a9a1
  40a8f8:	0040a9a1 	.word	0x0040a9a1
  40a8fc:	0040a9a1 	.word	0x0040a9a1
  40a900:	0040a9a1 	.word	0x0040a9a1
  40a904:	0040a9a1 	.word	0x0040a9a1
  40a908:	0040a9a1 	.word	0x0040a9a1
  40a90c:	0040a9a1 	.word	0x0040a9a1
  40a910:	0040a9a1 	.word	0x0040a9a1
  40a914:	0040a9a1 	.word	0x0040a9a1
  40a918:	0040a9a1 	.word	0x0040a9a1
  40a91c:	0040a9a1 	.word	0x0040a9a1
  40a920:	0040a9a1 	.word	0x0040a9a1
  40a924:	0040a9a1 	.word	0x0040a9a1
  40a928:	0040a9a1 	.word	0x0040a9a1
  40a92c:	0040a9a1 	.word	0x0040a9a1
  40a930:	0040a9a1 	.word	0x0040a9a1
  40a934:	0040a98d 	.word	0x0040a98d
  40a938:	0040a959 	.word	0x0040a959
  40a93c:	0040a95d 	.word	0x0040a95d
  40a940:	0040a9a1 	.word	0x0040a9a1
  40a944:	0040a99d 	.word	0x0040a99d
  40a948:	0040a989 	.word	0x0040a989
  40a94c:	0040a969 	.word	0x0040a969
	case ANDROID_SENSOR_ACCELEROMETER:                    return INV_ICM20648_SENSOR_ACCELEROMETER;
  40a950:	2300      	movs	r3, #0
  40a952:	e026      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GYROSCOPE:                        return INV_ICM20648_SENSOR_GYROSCOPE;
  40a954:	2301      	movs	r3, #1
  40a956:	e024      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_RAW_ACCELEROMETER:                return INV_ICM20648_SENSOR_RAW_ACCELEROMETER;
  40a958:	2302      	movs	r3, #2
  40a95a:	e022      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_RAW_GYROSCOPE:                    return INV_ICM20648_SENSOR_RAW_GYROSCOPE;
  40a95c:	2303      	movs	r3, #3
  40a95e:	e020      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:      return INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED;
  40a960:	2304      	movs	r3, #4
  40a962:	e01e      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED:           return INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED;
  40a964:	2305      	movs	r3, #5
  40a966:	e01c      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_ACTIVITY_CLASSIFICATON:           return INV_ICM20648_SENSOR_ACTIVITY_CLASSIFICATON;
  40a968:	2306      	movs	r3, #6
  40a96a:	e01a      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_STEP_DETECTOR:                    return INV_ICM20648_SENSOR_STEP_DETECTOR;
  40a96c:	2307      	movs	r3, #7
  40a96e:	e018      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_STEP_COUNTER:                     return INV_ICM20648_SENSOR_STEP_COUNTER;
  40a970:	2308      	movs	r3, #8
  40a972:	e016      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GAME_ROTATION_VECTOR:             return INV_ICM20648_SENSOR_GAME_ROTATION_VECTOR;
  40a974:	2309      	movs	r3, #9
  40a976:	e014      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_ROTATION_VECTOR:                  return INV_ICM20648_SENSOR_ROTATION_VECTOR;
  40a978:	230a      	movs	r3, #10
  40a97a:	e012      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:      return INV_ICM20648_SENSOR_GEOMAGNETIC_ROTATION_VECTOR;
  40a97c:	230b      	movs	r3, #11
  40a97e:	e010      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GEOMAGNETIC_FIELD:                return INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD;
  40a980:	230c      	movs	r3, #12
  40a982:	e00e      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:        return INV_ICM20648_SENSOR_WAKEUP_SIGNIFICANT_MOTION;
  40a984:	230d      	movs	r3, #13
  40a986:	e00c      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_FLIP_PICKUP:                      return INV_ICM20648_SENSOR_FLIP_PICKUP;
  40a988:	230e      	movs	r3, #14
  40a98a:	e00a      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:             return INV_ICM20648_SENSOR_WAKEUP_TILT_DETECTOR;
  40a98c:	230f      	movs	r3, #15
  40a98e:	e008      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GRAVITY:                          return INV_ICM20648_SENSOR_GRAVITY;
  40a990:	2310      	movs	r3, #16
  40a992:	e006      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_LINEAR_ACCELERATION:              return INV_ICM20648_SENSOR_LINEAR_ACCELERATION;
  40a994:	2311      	movs	r3, #17
  40a996:	e004      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_ORIENTATION:                      return INV_ICM20648_SENSOR_ORIENTATION;
  40a998:	2312      	movs	r3, #18
  40a99a:	e002      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_B2S:                              return INV_ICM20648_SENSOR_B2S;
  40a99c:	2313      	movs	r3, #19
  40a99e:	e000      	b.n	40a9a2 <inv_icm20648_sensor_android_2_sensor_type+0x126>
	default:                                              return INV_ICM20648_SENSOR_MAX;
  40a9a0:	2314      	movs	r3, #20
	}
}
  40a9a2:	4618      	mov	r0, r3
  40a9a4:	370c      	adds	r7, #12
  40a9a6:	46bd      	mov	sp, r7
  40a9a8:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a9ac:	4770      	bx	lr
  40a9ae:	bf00      	nop

0040a9b0 <skip_sensor>:

static int skip_sensor(struct inv_icm20648 * s, unsigned char androidSensor)
{
  40a9b0:	b580      	push	{r7, lr}
  40a9b2:	b084      	sub	sp, #16
  40a9b4:	af00      	add	r7, sp, #0
  40a9b6:	6078      	str	r0, [r7, #4]
  40a9b8:	460b      	mov	r3, r1
  40a9ba:	70fb      	strb	r3, [r7, #3]
	enum inv_icm20648_sensor icm20648_sensor_id = inv_icm20648_sensor_android_2_sensor_type(androidSensor);
  40a9bc:	78fb      	ldrb	r3, [r7, #3]
  40a9be:	4618      	mov	r0, r3
  40a9c0:	4b10      	ldr	r3, [pc, #64]	; (40aa04 <skip_sensor+0x54>)
  40a9c2:	4798      	blx	r3
  40a9c4:	4603      	mov	r3, r0
  40a9c6:	73fb      	strb	r3, [r7, #15]
	uint8_t skip_sample = s->skip_sample[icm20648_sensor_id];
  40a9c8:	7bfb      	ldrb	r3, [r7, #15]
  40a9ca:	687a      	ldr	r2, [r7, #4]
  40a9cc:	4413      	add	r3, r2
  40a9ce:	f893 32ac 	ldrb.w	r3, [r3, #684]	; 0x2ac
  40a9d2:	73bb      	strb	r3, [r7, #14]

	if (s->skip_sample[icm20648_sensor_id])
  40a9d4:	7bfb      	ldrb	r3, [r7, #15]
  40a9d6:	687a      	ldr	r2, [r7, #4]
  40a9d8:	4413      	add	r3, r2
  40a9da:	f893 32ac 	ldrb.w	r3, [r3, #684]	; 0x2ac
  40a9de:	2b00      	cmp	r3, #0
  40a9e0:	d00b      	beq.n	40a9fa <skip_sensor+0x4a>
		s->skip_sample[icm20648_sensor_id]--;
  40a9e2:	7bfb      	ldrb	r3, [r7, #15]
  40a9e4:	687a      	ldr	r2, [r7, #4]
  40a9e6:	441a      	add	r2, r3
  40a9e8:	f892 22ac 	ldrb.w	r2, [r2, #684]	; 0x2ac
  40a9ec:	3a01      	subs	r2, #1
  40a9ee:	b2d1      	uxtb	r1, r2
  40a9f0:	687a      	ldr	r2, [r7, #4]
  40a9f2:	4413      	add	r3, r2
  40a9f4:	460a      	mov	r2, r1
  40a9f6:	f883 22ac 	strb.w	r2, [r3, #684]	; 0x2ac

	return skip_sample;
  40a9fa:	7bbb      	ldrb	r3, [r7, #14]
}
  40a9fc:	4618      	mov	r0, r3
  40a9fe:	3710      	adds	r7, #16
  40aa00:	46bd      	mov	sp, r7
  40aa02:	bd80      	pop	{r7, pc}
  40aa04:	0040a87d 	.word	0x0040a87d

0040aa08 <inv_icm20648_get_whoami>:

/* Identification related functions */
int inv_icm20648_get_whoami(struct inv_icm20648 * s, uint8_t * whoami)
{
  40aa08:	b580      	push	{r7, lr}
  40aa0a:	b082      	sub	sp, #8
  40aa0c:	af00      	add	r7, sp, #0
  40aa0e:	6078      	str	r0, [r7, #4]
  40aa10:	6039      	str	r1, [r7, #0]
	return inv_icm20648_read_reg_one(s, REG_WHO_AM_I, whoami);
  40aa12:	683a      	ldr	r2, [r7, #0]
  40aa14:	2100      	movs	r1, #0
  40aa16:	6878      	ldr	r0, [r7, #4]
  40aa18:	4b03      	ldr	r3, [pc, #12]	; (40aa28 <inv_icm20648_get_whoami+0x20>)
  40aa1a:	4798      	blx	r3
  40aa1c:	4603      	mov	r3, r0
}
  40aa1e:	4618      	mov	r0, r3
  40aa20:	3708      	adds	r7, #8
  40aa22:	46bd      	mov	sp, r7
  40aa24:	bd80      	pop	{r7, pc}
  40aa26:	bf00      	nop
  40aa28:	0040a78d 	.word	0x0040a78d

0040aa2c <inv_icm20648_init_matrix>:

void inv_icm20648_init_matrix(struct inv_icm20648 * s)
{
  40aa2c:	b580      	push	{r7, lr}
  40aa2e:	b082      	sub	sp, #8
  40aa30:	af00      	add	r7, sp, #0
  40aa32:	6078      	str	r0, [r7, #4]
	// initialize chip to body
	s->s_quat_chip_to_body[0] = (1L<<30);
  40aa34:	687b      	ldr	r3, [r7, #4]
  40aa36:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40aa3a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	s->s_quat_chip_to_body[1] = 0;
  40aa3e:	687b      	ldr	r3, [r7, #4]
  40aa40:	2200      	movs	r2, #0
  40aa42:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	s->s_quat_chip_to_body[2] = 0;
  40aa46:	687b      	ldr	r3, [r7, #4]
  40aa48:	2200      	movs	r2, #0
  40aa4a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
	s->s_quat_chip_to_body[3] = 0;
  40aa4e:	687b      	ldr	r3, [r7, #4]
  40aa50:	2200      	movs	r2, #0
  40aa52:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	//initialize mounting matrix
	memset(s->mounting_matrix, 0, sizeof(s->mounting_matrix));
  40aa56:	687b      	ldr	r3, [r7, #4]
  40aa58:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40aa5c:	2209      	movs	r2, #9
  40aa5e:	2100      	movs	r1, #0
  40aa60:	4618      	mov	r0, r3
  40aa62:	4b15      	ldr	r3, [pc, #84]	; (40aab8 <inv_icm20648_init_matrix+0x8c>)
  40aa64:	4798      	blx	r3
	s->mounting_matrix[0] = 1;
  40aa66:	687b      	ldr	r3, [r7, #4]
  40aa68:	2201      	movs	r2, #1
  40aa6a:	f883 2274 	strb.w	r2, [r3, #628]	; 0x274
	s->mounting_matrix[4] = 1;
  40aa6e:	687b      	ldr	r3, [r7, #4]
  40aa70:	2201      	movs	r2, #1
  40aa72:	f883 2278 	strb.w	r2, [r3, #632]	; 0x278
	s->mounting_matrix[8] = 1;
  40aa76:	687b      	ldr	r3, [r7, #4]
  40aa78:	2201      	movs	r2, #1
  40aa7a:	f883 227c 	strb.w	r2, [r3, #636]	; 0x27c
	//initialize soft iron matrix
	s->soft_iron_matrix[0] = (1L<<30);
  40aa7e:	687b      	ldr	r3, [r7, #4]
  40aa80:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40aa84:	f8c3 2288 	str.w	r2, [r3, #648]	; 0x288
	s->soft_iron_matrix[4] = (1L<<30);
  40aa88:	687b      	ldr	r3, [r7, #4]
  40aa8a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40aa8e:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
	s->soft_iron_matrix[8] = (1L<<30);
  40aa92:	687b      	ldr	r3, [r7, #4]
  40aa94:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40aa98:	f8c3 22a8 	str.w	r2, [r3, #680]	; 0x2a8

	inv_icm20648_set_chip_to_body_axis_quaternion(s, s->mounting_matrix, 0.0);
  40aa9c:	687b      	ldr	r3, [r7, #4]
  40aa9e:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40aaa2:	ed9f 0a06 	vldr	s0, [pc, #24]	; 40aabc <inv_icm20648_init_matrix+0x90>
  40aaa6:	4619      	mov	r1, r3
  40aaa8:	6878      	ldr	r0, [r7, #4]
  40aaaa:	4b05      	ldr	r3, [pc, #20]	; (40aac0 <inv_icm20648_init_matrix+0x94>)
  40aaac:	4798      	blx	r3
}
  40aaae:	bf00      	nop
  40aab0:	3708      	adds	r7, #8
  40aab2:	46bd      	mov	sp, r7
  40aab4:	bd80      	pop	{r7, pc}
  40aab6:	bf00      	nop
  40aab8:	00414431 	.word	0x00414431
  40aabc:	00000000 	.word	0x00000000
  40aac0:	00406f29 	.word	0x00406f29

0040aac4 <inv_icm20648_init_structure>:

int inv_icm20648_init_structure(struct inv_icm20648 * s)
{
  40aac4:	b590      	push	{r4, r7, lr}
  40aac6:	b085      	sub	sp, #20
  40aac8:	af00      	add	r7, sp, #0
  40aaca:	6078      	str	r0, [r7, #4]
	int i;
	inv_icm20648_base_control_init(s);
  40aacc:	6878      	ldr	r0, [r7, #4]
  40aace:	4b16      	ldr	r3, [pc, #88]	; (40ab28 <inv_icm20648_init_structure+0x64>)
  40aad0:	4798      	blx	r3
	inv_icm20648_transport_init(s);
  40aad2:	6878      	ldr	r0, [r7, #4]
  40aad4:	4b15      	ldr	r3, [pc, #84]	; (40ab2c <inv_icm20648_init_structure+0x68>)
  40aad6:	4798      	blx	r3
	inv_icm20648_augmented_init(s);
  40aad8:	6878      	ldr	r0, [r7, #4]
  40aada:	4b15      	ldr	r3, [pc, #84]	; (40ab30 <inv_icm20648_init_structure+0x6c>)
  40aadc:	4798      	blx	r3
	//Init state
	s->set_accuracy = 0;
  40aade:	687b      	ldr	r3, [r7, #4]
  40aae0:	2200      	movs	r2, #0
  40aae2:	f8a3 24f2 	strh.w	r2, [r3, #1266]	; 0x4f2
	s->new_accuracy = 0;
  40aae6:	687b      	ldr	r3, [r7, #4]
  40aae8:	2200      	movs	r2, #0
  40aaea:	f8c3 24f4 	str.w	r2, [r3, #1268]	; 0x4f4
	for(i = 0; i < GENERAL_SENSORS_MAX; i ++)
  40aaee:	2300      	movs	r3, #0
  40aaf0:	60fb      	str	r3, [r7, #12]
  40aaf2:	e010      	b.n	40ab16 <inv_icm20648_init_structure+0x52>
		s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] = 0;
  40aaf4:	68f8      	ldr	r0, [r7, #12]
  40aaf6:	4b0f      	ldr	r3, [pc, #60]	; (40ab34 <inv_icm20648_init_structure+0x70>)
  40aaf8:	4798      	blx	r3
  40aafa:	4603      	mov	r3, r0
  40aafc:	687a      	ldr	r2, [r7, #4]
  40aafe:	3359      	adds	r3, #89	; 0x59
  40ab00:	00db      	lsls	r3, r3, #3
  40ab02:	441a      	add	r2, r3
  40ab04:	f04f 0300 	mov.w	r3, #0
  40ab08:	f04f 0400 	mov.w	r4, #0
  40ab0c:	e9c2 3400 	strd	r3, r4, [r2]
	for(i = 0; i < GENERAL_SENSORS_MAX; i ++)
  40ab10:	68fb      	ldr	r3, [r7, #12]
  40ab12:	3301      	adds	r3, #1
  40ab14:	60fb      	str	r3, [r7, #12]
  40ab16:	68fb      	ldr	r3, [r7, #12]
  40ab18:	2b32      	cmp	r3, #50	; 0x32
  40ab1a:	ddeb      	ble.n	40aaf4 <inv_icm20648_init_structure+0x30>

	return 0;
  40ab1c:	2300      	movs	r3, #0
}
  40ab1e:	4618      	mov	r0, r3
  40ab20:	3714      	adds	r7, #20
  40ab22:	46bd      	mov	sp, r7
  40ab24:	bd90      	pop	{r4, r7, pc}
  40ab26:	bf00      	nop
  40ab28:	00410de5 	.word	0x00410de5
  40ab2c:	0040c7bd 	.word	0x0040c7bd
  40ab30:	00410097 	.word	0x00410097
  40ab34:	0040a87d 	.word	0x0040a87d

0040ab38 <inv_icm20648_initialize>:

int inv_icm20648_initialize(struct inv_icm20648 * s, const uint8_t *dmp3_image, uint32_t dmp3_image_size)
{
  40ab38:	b590      	push	{r4, r7, lr}
  40ab3a:	b085      	sub	sp, #20
  40ab3c:	af00      	add	r7, sp, #0
  40ab3e:	60f8      	str	r0, [r7, #12]
  40ab40:	60b9      	str	r1, [r7, #8]
  40ab42:	607a      	str	r2, [r7, #4]
	if(s->serif.is_spi) {
  40ab44:	68fb      	ldr	r3, [r7, #12]
  40ab46:	695b      	ldr	r3, [r3, #20]
  40ab48:	2b00      	cmp	r3, #0
  40ab4a:	d00b      	beq.n	40ab64 <inv_icm20648_initialize+0x2c>
		/* Hardware initialization */
		// No image to be loaded from flash, no pointer to pass.
		if (inv_icm20648_initialize_lower_driver(s, SERIAL_INTERFACE_SPI, dmp3_image, dmp3_image_size)) {
  40ab4c:	687b      	ldr	r3, [r7, #4]
  40ab4e:	68ba      	ldr	r2, [r7, #8]
  40ab50:	2102      	movs	r1, #2
  40ab52:	68f8      	ldr	r0, [r7, #12]
  40ab54:	4c0c      	ldr	r4, [pc, #48]	; (40ab88 <inv_icm20648_initialize+0x50>)
  40ab56:	47a0      	blx	r4
  40ab58:	4603      	mov	r3, r0
  40ab5a:	2b00      	cmp	r3, #0
  40ab5c:	d00e      	beq.n	40ab7c <inv_icm20648_initialize+0x44>
			return -1;
  40ab5e:	f04f 33ff 	mov.w	r3, #4294967295
  40ab62:	e00c      	b.n	40ab7e <inv_icm20648_initialize+0x46>
		}
	}
	else {
		/* Hardware initialization */
		// No image to be loaded from flash, no pointer to pass.
		if (inv_icm20648_initialize_lower_driver(s, SERIAL_INTERFACE_I2C, dmp3_image, dmp3_image_size)) {
  40ab64:	687b      	ldr	r3, [r7, #4]
  40ab66:	68ba      	ldr	r2, [r7, #8]
  40ab68:	2101      	movs	r1, #1
  40ab6a:	68f8      	ldr	r0, [r7, #12]
  40ab6c:	4c06      	ldr	r4, [pc, #24]	; (40ab88 <inv_icm20648_initialize+0x50>)
  40ab6e:	47a0      	blx	r4
  40ab70:	4603      	mov	r3, r0
  40ab72:	2b00      	cmp	r3, #0
  40ab74:	d002      	beq.n	40ab7c <inv_icm20648_initialize+0x44>
			return -1;
  40ab76:	f04f 33ff 	mov.w	r3, #4294967295
  40ab7a:	e000      	b.n	40ab7e <inv_icm20648_initialize+0x46>
		}
	}
	return 0;
  40ab7c:	2300      	movs	r3, #0
}
  40ab7e:	4618      	mov	r0, r3
  40ab80:	3714      	adds	r7, #20
  40ab82:	46bd      	mov	sp, r7
  40ab84:	bd90      	pop	{r4, r7, pc}
  40ab86:	bf00      	nop
  40ab88:	00405ef5 	.word	0x00405ef5

0040ab8c <inv_icm20648_set_fsr>:

	return 0;
}

int inv_icm20648_set_fsr(struct inv_icm20648 * s, enum inv_icm20648_sensor sensor, const void * fsr)
{
  40ab8c:	b580      	push	{r7, lr}
  40ab8e:	b088      	sub	sp, #32
  40ab90:	af00      	add	r7, sp, #0
  40ab92:	60f8      	str	r0, [r7, #12]
  40ab94:	460b      	mov	r3, r1
  40ab96:	607a      	str	r2, [r7, #4]
  40ab98:	72fb      	strb	r3, [r7, #11]
	int result = 0;
  40ab9a:	2300      	movs	r3, #0
  40ab9c:	61fb      	str	r3, [r7, #28]
	int * castedvalue = (int*) fsr;
  40ab9e:	687b      	ldr	r3, [r7, #4]
  40aba0:	617b      	str	r3, [r7, #20]
	if((sensor == INV_ICM20648_SENSOR_RAW_ACCELEROMETER) ||
  40aba2:	7afb      	ldrb	r3, [r7, #11]
  40aba4:	2b02      	cmp	r3, #2
  40aba6:	d002      	beq.n	40abae <inv_icm20648_set_fsr+0x22>
  40aba8:	7afb      	ldrb	r3, [r7, #11]
  40abaa:	2b00      	cmp	r3, #0
  40abac:	d128      	bne.n	40ac00 <inv_icm20648_set_fsr+0x74>
	   (sensor == INV_ICM20648_SENSOR_ACCELEROMETER)){
		enum mpu_accel_fs afsr;
		if(*castedvalue == 2)
  40abae:	697b      	ldr	r3, [r7, #20]
  40abb0:	681b      	ldr	r3, [r3, #0]
  40abb2:	2b02      	cmp	r3, #2
  40abb4:	d102      	bne.n	40abbc <inv_icm20648_set_fsr+0x30>
			afsr = MPU_FS_2G;
  40abb6:	2300      	movs	r3, #0
  40abb8:	76fb      	strb	r3, [r7, #27]
  40abba:	e017      	b.n	40abec <inv_icm20648_set_fsr+0x60>
		else if(*castedvalue == 4)
  40abbc:	697b      	ldr	r3, [r7, #20]
  40abbe:	681b      	ldr	r3, [r3, #0]
  40abc0:	2b04      	cmp	r3, #4
  40abc2:	d102      	bne.n	40abca <inv_icm20648_set_fsr+0x3e>
			afsr = MPU_FS_4G;
  40abc4:	2301      	movs	r3, #1
  40abc6:	76fb      	strb	r3, [r7, #27]
  40abc8:	e010      	b.n	40abec <inv_icm20648_set_fsr+0x60>
		else if(*castedvalue == 8)
  40abca:	697b      	ldr	r3, [r7, #20]
  40abcc:	681b      	ldr	r3, [r3, #0]
  40abce:	2b08      	cmp	r3, #8
  40abd0:	d102      	bne.n	40abd8 <inv_icm20648_set_fsr+0x4c>
			afsr = MPU_FS_8G;
  40abd2:	2302      	movs	r3, #2
  40abd4:	76fb      	strb	r3, [r7, #27]
  40abd6:	e009      	b.n	40abec <inv_icm20648_set_fsr+0x60>
		else if(*castedvalue == 16)
  40abd8:	697b      	ldr	r3, [r7, #20]
  40abda:	681b      	ldr	r3, [r3, #0]
  40abdc:	2b10      	cmp	r3, #16
  40abde:	d102      	bne.n	40abe6 <inv_icm20648_set_fsr+0x5a>
			afsr = MPU_FS_16G;
  40abe0:	2303      	movs	r3, #3
  40abe2:	76fb      	strb	r3, [r7, #27]
  40abe4:	e002      	b.n	40abec <inv_icm20648_set_fsr+0x60>
		else
			return -1;
  40abe6:	f04f 33ff 	mov.w	r3, #4294967295
  40abea:	e03e      	b.n	40ac6a <inv_icm20648_set_fsr+0xde>
		result |= inv_icm20648_set_accel_fullscale(s, afsr);
  40abec:	7efb      	ldrb	r3, [r7, #27]
  40abee:	4619      	mov	r1, r3
  40abf0:	68f8      	ldr	r0, [r7, #12]
  40abf2:	4b20      	ldr	r3, [pc, #128]	; (40ac74 <inv_icm20648_set_fsr+0xe8>)
  40abf4:	4798      	blx	r3
  40abf6:	4602      	mov	r2, r0
  40abf8:	69fb      	ldr	r3, [r7, #28]
  40abfa:	4313      	orrs	r3, r2
  40abfc:	61fb      	str	r3, [r7, #28]
	   (sensor == INV_ICM20648_SENSOR_ACCELEROMETER)){
  40abfe:	e033      	b.n	40ac68 <inv_icm20648_set_fsr+0xdc>
	}
	else if((sensor == INV_ICM20648_SENSOR_GYROSCOPE) ||
  40ac00:	7afb      	ldrb	r3, [r7, #11]
  40ac02:	2b01      	cmp	r3, #1
  40ac04:	d005      	beq.n	40ac12 <inv_icm20648_set_fsr+0x86>
  40ac06:	7afb      	ldrb	r3, [r7, #11]
  40ac08:	2b03      	cmp	r3, #3
  40ac0a:	d002      	beq.n	40ac12 <inv_icm20648_set_fsr+0x86>
			(sensor == INV_ICM20648_SENSOR_RAW_GYROSCOPE) ||
  40ac0c:	7afb      	ldrb	r3, [r7, #11]
  40ac0e:	2b05      	cmp	r3, #5
  40ac10:	d12a      	bne.n	40ac68 <inv_icm20648_set_fsr+0xdc>
			(sensor == INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED)) {
		enum mpu_gyro_fs gfsr;
		if(*castedvalue == 250)
  40ac12:	697b      	ldr	r3, [r7, #20]
  40ac14:	681b      	ldr	r3, [r3, #0]
  40ac16:	2bfa      	cmp	r3, #250	; 0xfa
  40ac18:	d102      	bne.n	40ac20 <inv_icm20648_set_fsr+0x94>
			gfsr = MPU_FS_250dps;
  40ac1a:	2300      	movs	r3, #0
  40ac1c:	76bb      	strb	r3, [r7, #26]
  40ac1e:	e01a      	b.n	40ac56 <inv_icm20648_set_fsr+0xca>
		else if(*castedvalue == 500)
  40ac20:	697b      	ldr	r3, [r7, #20]
  40ac22:	681b      	ldr	r3, [r3, #0]
  40ac24:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  40ac28:	d102      	bne.n	40ac30 <inv_icm20648_set_fsr+0xa4>
			gfsr = MPU_FS_500dps;
  40ac2a:	2301      	movs	r3, #1
  40ac2c:	76bb      	strb	r3, [r7, #26]
  40ac2e:	e012      	b.n	40ac56 <inv_icm20648_set_fsr+0xca>
		else if(*castedvalue == 1000)
  40ac30:	697b      	ldr	r3, [r7, #20]
  40ac32:	681b      	ldr	r3, [r3, #0]
  40ac34:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  40ac38:	d102      	bne.n	40ac40 <inv_icm20648_set_fsr+0xb4>
		 	gfsr = MPU_FS_1000dps;
  40ac3a:	2302      	movs	r3, #2
  40ac3c:	76bb      	strb	r3, [r7, #26]
  40ac3e:	e00a      	b.n	40ac56 <inv_icm20648_set_fsr+0xca>
		else if(*castedvalue == 2000)
  40ac40:	697b      	ldr	r3, [r7, #20]
  40ac42:	681b      	ldr	r3, [r3, #0]
  40ac44:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  40ac48:	d102      	bne.n	40ac50 <inv_icm20648_set_fsr+0xc4>
		 	gfsr = MPU_FS_2000dps;
  40ac4a:	2303      	movs	r3, #3
  40ac4c:	76bb      	strb	r3, [r7, #26]
  40ac4e:	e002      	b.n	40ac56 <inv_icm20648_set_fsr+0xca>
		else
			return -1;
  40ac50:	f04f 33ff 	mov.w	r3, #4294967295
  40ac54:	e009      	b.n	40ac6a <inv_icm20648_set_fsr+0xde>
		result |= inv_icm20648_set_gyro_fullscale(s, gfsr);
  40ac56:	7ebb      	ldrb	r3, [r7, #26]
  40ac58:	4619      	mov	r1, r3
  40ac5a:	68f8      	ldr	r0, [r7, #12]
  40ac5c:	4b06      	ldr	r3, [pc, #24]	; (40ac78 <inv_icm20648_set_fsr+0xec>)
  40ac5e:	4798      	blx	r3
  40ac60:	4602      	mov	r2, r0
  40ac62:	69fb      	ldr	r3, [r7, #28]
  40ac64:	4313      	orrs	r3, r2
  40ac66:	61fb      	str	r3, [r7, #28]
	}
	return result;
  40ac68:	69fb      	ldr	r3, [r7, #28]
}
  40ac6a:	4618      	mov	r0, r3
  40ac6c:	3720      	adds	r7, #32
  40ac6e:	46bd      	mov	sp, r7
  40ac70:	bd80      	pop	{r7, pc}
  40ac72:	bf00      	nop
  40ac74:	00406691 	.word	0x00406691
  40ac78:	004064e5 	.word	0x004064e5

0040ac7c <inv_icm20648_set_lowpower_or_highperformance>:
	}
	return (rc == 0) ? 3*(int)sizeof(float) : rc;
}

int inv_icm20648_set_lowpower_or_highperformance(struct inv_icm20648 * s, uint8_t lowpower_or_highperformance)
{
  40ac7c:	b580      	push	{r7, lr}
  40ac7e:	b082      	sub	sp, #8
  40ac80:	af00      	add	r7, sp, #0
  40ac82:	6078      	str	r0, [r7, #4]
  40ac84:	460b      	mov	r3, r1
  40ac86:	70fb      	strb	r3, [r7, #3]
	s->go_back_lp_when_odr_low = 0;
  40ac88:	687b      	ldr	r3, [r7, #4]
  40ac8a:	2200      	movs	r2, #0
  40ac8c:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
	if(lowpower_or_highperformance)
  40ac90:	78fb      	ldrb	r3, [r7, #3]
  40ac92:	2b00      	cmp	r3, #0
  40ac94:	d004      	beq.n	40aca0 <inv_icm20648_set_lowpower_or_highperformance+0x24>
		return inv_icm20648_enter_low_noise_mode(s);
  40ac96:	6878      	ldr	r0, [r7, #4]
  40ac98:	4b05      	ldr	r3, [pc, #20]	; (40acb0 <inv_icm20648_set_lowpower_or_highperformance+0x34>)
  40ac9a:	4798      	blx	r3
  40ac9c:	4603      	mov	r3, r0
  40ac9e:	e003      	b.n	40aca8 <inv_icm20648_set_lowpower_or_highperformance+0x2c>
	else
		return inv_icm20648_enter_duty_cycle_mode(s);
  40aca0:	6878      	ldr	r0, [r7, #4]
  40aca2:	4b04      	ldr	r3, [pc, #16]	; (40acb4 <inv_icm20648_set_lowpower_or_highperformance+0x38>)
  40aca4:	4798      	blx	r3
  40aca6:	4603      	mov	r3, r0
}
  40aca8:	4618      	mov	r0, r3
  40acaa:	3708      	adds	r7, #8
  40acac:	46bd      	mov	sp, r7
  40acae:	bd80      	pop	{r7, pc}
  40acb0:	00405ec5 	.word	0x00405ec5
  40acb4:	00405e95 	.word	0x00405e95

0040acb8 <DmpDriver_convertion>:
	return 1;
}

static void DmpDriver_convertion(signed char transformedtochar[9],
                                 const int32_t MatrixInQ30[9])
{
  40acb8:	b480      	push	{r7}
  40acba:	b085      	sub	sp, #20
  40acbc:	af00      	add	r7, sp, #0
  40acbe:	6078      	str	r0, [r7, #4]
  40acc0:	6039      	str	r1, [r7, #0]
	// To convert Q30 to signed char value
	uint8_t iter;
	for (iter = 0; iter < 9; ++iter)
  40acc2:	2300      	movs	r3, #0
  40acc4:	73fb      	strb	r3, [r7, #15]
  40acc6:	e00d      	b.n	40ace4 <DmpDriver_convertion+0x2c>
		transformedtochar[iter] = MatrixInQ30[iter] >> 30;
  40acc8:	7bfb      	ldrb	r3, [r7, #15]
  40acca:	687a      	ldr	r2, [r7, #4]
  40accc:	4413      	add	r3, r2
  40acce:	7bfa      	ldrb	r2, [r7, #15]
  40acd0:	0092      	lsls	r2, r2, #2
  40acd2:	6839      	ldr	r1, [r7, #0]
  40acd4:	440a      	add	r2, r1
  40acd6:	6812      	ldr	r2, [r2, #0]
  40acd8:	1792      	asrs	r2, r2, #30
  40acda:	b252      	sxtb	r2, r2
  40acdc:	701a      	strb	r2, [r3, #0]
	for (iter = 0; iter < 9; ++iter)
  40acde:	7bfb      	ldrb	r3, [r7, #15]
  40ace0:	3301      	adds	r3, #1
  40ace2:	73fb      	strb	r3, [r7, #15]
  40ace4:	7bfb      	ldrb	r3, [r7, #15]
  40ace6:	2b08      	cmp	r3, #8
  40ace8:	d9ee      	bls.n	40acc8 <DmpDriver_convertion+0x10>
}
  40acea:	bf00      	nop
  40acec:	3714      	adds	r7, #20
  40acee:	46bd      	mov	sp, r7
  40acf0:	f85d 7b04 	ldr.w	r7, [sp], #4
  40acf4:	4770      	bx	lr
	...

0040acf8 <inv_icm20648_set_matrix>:

int inv_icm20648_set_matrix(struct inv_icm20648 * s, const float matrix[9], enum inv_icm20648_sensor sensor)
{
  40acf8:	b580      	push	{r7, lr}
  40acfa:	b098      	sub	sp, #96	; 0x60
  40acfc:	af00      	add	r7, sp, #0
  40acfe:	60f8      	str	r0, [r7, #12]
  40ad00:	60b9      	str	r1, [r7, #8]
  40ad02:	4613      	mov	r3, r2
  40ad04:	71fb      	strb	r3, [r7, #7]
	int32_t mounting_mq30[9];
	int32_t compass_mq30[9];
	int result = 0;
  40ad06:	2300      	movs	r3, #0
  40ad08:	65fb      	str	r3, [r7, #92]	; 0x5c
	int i;

	if ((sensor == INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD)||
  40ad0a:	79fb      	ldrb	r3, [r7, #7]
  40ad0c:	2b0c      	cmp	r3, #12
  40ad0e:	d002      	beq.n	40ad16 <inv_icm20648_set_matrix+0x1e>
  40ad10:	79fb      	ldrb	r3, [r7, #7]
  40ad12:	2b04      	cmp	r3, #4
  40ad14:	d135      	bne.n	40ad82 <inv_icm20648_set_matrix+0x8a>
		(sensor == INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED)){

		for(i = 0; i < 9; ++i)
  40ad16:	2300      	movs	r3, #0
  40ad18:	65bb      	str	r3, [r7, #88]	; 0x58
  40ad1a:	e017      	b.n	40ad4c <inv_icm20648_set_matrix+0x54>
			compass_mq30[i] = (int32_t)(matrix[i] * (1 << 30));
  40ad1c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40ad1e:	009b      	lsls	r3, r3, #2
  40ad20:	68ba      	ldr	r2, [r7, #8]
  40ad22:	4413      	add	r3, r2
  40ad24:	edd3 7a00 	vldr	s15, [r3]
  40ad28:	ed9f 7a44 	vldr	s14, [pc, #272]	; 40ae3c <inv_icm20648_set_matrix+0x144>
  40ad2c:	ee67 7a87 	vmul.f32	s15, s15, s14
  40ad30:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40ad34:	ee17 2a90 	vmov	r2, s15
  40ad38:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40ad3a:	009b      	lsls	r3, r3, #2
  40ad3c:	f107 0160 	add.w	r1, r7, #96	; 0x60
  40ad40:	440b      	add	r3, r1
  40ad42:	f843 2c50 	str.w	r2, [r3, #-80]
		for(i = 0; i < 9; ++i)
  40ad46:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40ad48:	3301      	adds	r3, #1
  40ad4a:	65bb      	str	r3, [r7, #88]	; 0x58
  40ad4c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40ad4e:	2b08      	cmp	r3, #8
  40ad50:	dde4      	ble.n	40ad1c <inv_icm20648_set_matrix+0x24>

		// Convert compass mounting matrix in char
		DmpDriver_convertion(s->mounting_matrix_secondary_compass, compass_mq30);
  40ad52:	68fb      	ldr	r3, [r7, #12]
  40ad54:	f203 237d 	addw	r3, r3, #637	; 0x27d
  40ad58:	f107 0210 	add.w	r2, r7, #16
  40ad5c:	4611      	mov	r1, r2
  40ad5e:	4618      	mov	r0, r3
  40ad60:	4b37      	ldr	r3, [pc, #220]	; (40ae40 <inv_icm20648_set_matrix+0x148>)
  40ad62:	4798      	blx	r3

		//Notify new matrix to mag calculation with acc-gyr mounting matrix
		result |= inv_icm20648_compass_dmp_cal(s, s->mounting_matrix, s->mounting_matrix_secondary_compass);
  40ad64:	68fb      	ldr	r3, [r7, #12]
  40ad66:	f503 711d 	add.w	r1, r3, #628	; 0x274
  40ad6a:	68fb      	ldr	r3, [r7, #12]
  40ad6c:	f203 237d 	addw	r3, r3, #637	; 0x27d
  40ad70:	461a      	mov	r2, r3
  40ad72:	68f8      	ldr	r0, [r7, #12]
  40ad74:	4b33      	ldr	r3, [pc, #204]	; (40ae44 <inv_icm20648_set_matrix+0x14c>)
  40ad76:	4798      	blx	r3
  40ad78:	4602      	mov	r2, r0
  40ad7a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  40ad7c:	4313      	orrs	r3, r2
  40ad7e:	65fb      	str	r3, [r7, #92]	; 0x5c
  40ad80:	e056      	b.n	40ae30 <inv_icm20648_set_matrix+0x138>

	} else if ((sensor == INV_ICM20648_SENSOR_RAW_ACCELEROMETER) ||
  40ad82:	79fb      	ldrb	r3, [r7, #7]
  40ad84:	2b02      	cmp	r3, #2
  40ad86:	d00b      	beq.n	40ada0 <inv_icm20648_set_matrix+0xa8>
  40ad88:	79fb      	ldrb	r3, [r7, #7]
  40ad8a:	2b00      	cmp	r3, #0
  40ad8c:	d008      	beq.n	40ada0 <inv_icm20648_set_matrix+0xa8>
		(sensor == INV_ICM20648_SENSOR_ACCELEROMETER) ||
  40ad8e:	79fb      	ldrb	r3, [r7, #7]
  40ad90:	2b03      	cmp	r3, #3
  40ad92:	d005      	beq.n	40ada0 <inv_icm20648_set_matrix+0xa8>
		(sensor == INV_ICM20648_SENSOR_RAW_GYROSCOPE) ||
  40ad94:	79fb      	ldrb	r3, [r7, #7]
  40ad96:	2b01      	cmp	r3, #1
  40ad98:	d002      	beq.n	40ada0 <inv_icm20648_set_matrix+0xa8>
		(sensor == INV_ICM20648_SENSOR_GYROSCOPE) ||
  40ad9a:	79fb      	ldrb	r3, [r7, #7]
  40ad9c:	2b05      	cmp	r3, #5
  40ad9e:	d147      	bne.n	40ae30 <inv_icm20648_set_matrix+0x138>
		(sensor == INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED)) {

		for(i = 0; i < 9; ++i)
  40ada0:	2300      	movs	r3, #0
  40ada2:	65bb      	str	r3, [r7, #88]	; 0x58
  40ada4:	e017      	b.n	40add6 <inv_icm20648_set_matrix+0xde>
			mounting_mq30[i] = (int32_t)(matrix[i] * (1 << 30));
  40ada6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40ada8:	009b      	lsls	r3, r3, #2
  40adaa:	68ba      	ldr	r2, [r7, #8]
  40adac:	4413      	add	r3, r2
  40adae:	edd3 7a00 	vldr	s15, [r3]
  40adb2:	ed9f 7a22 	vldr	s14, [pc, #136]	; 40ae3c <inv_icm20648_set_matrix+0x144>
  40adb6:	ee67 7a87 	vmul.f32	s15, s15, s14
  40adba:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40adbe:	ee17 2a90 	vmov	r2, s15
  40adc2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40adc4:	009b      	lsls	r3, r3, #2
  40adc6:	f107 0160 	add.w	r1, r7, #96	; 0x60
  40adca:	440b      	add	r3, r1
  40adcc:	f843 2c2c 	str.w	r2, [r3, #-44]
		for(i = 0; i < 9; ++i)
  40add0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40add2:	3301      	adds	r3, #1
  40add4:	65bb      	str	r3, [r7, #88]	; 0x58
  40add6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40add8:	2b08      	cmp	r3, #8
  40adda:	dde4      	ble.n	40ada6 <inv_icm20648_set_matrix+0xae>

		// Convert mounting matrix in char
		DmpDriver_convertion(s->mounting_matrix, mounting_mq30);
  40addc:	68fb      	ldr	r3, [r7, #12]
  40adde:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40ade2:	f107 0234 	add.w	r2, r7, #52	; 0x34
  40ade6:	4611      	mov	r1, r2
  40ade8:	4618      	mov	r0, r3
  40adea:	4b15      	ldr	r3, [pc, #84]	; (40ae40 <inv_icm20648_set_matrix+0x148>)
  40adec:	4798      	blx	r3

		/*Apply new matrix */
		inv_icm20648_set_chip_to_body_axis_quaternion(s, s->mounting_matrix, 0.0);
  40adee:	68fb      	ldr	r3, [r7, #12]
  40adf0:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40adf4:	ed9f 0a14 	vldr	s0, [pc, #80]	; 40ae48 <inv_icm20648_set_matrix+0x150>
  40adf8:	4619      	mov	r1, r3
  40adfa:	68f8      	ldr	r0, [r7, #12]
  40adfc:	4b13      	ldr	r3, [pc, #76]	; (40ae4c <inv_icm20648_set_matrix+0x154>)
  40adfe:	4798      	blx	r3

		//Update Dmp B2S according to new mmatrix in q30
		result |= dmp_icm20648_set_B2S_matrix(s, (int*)mounting_mq30);
  40ae00:	f107 0334 	add.w	r3, r7, #52	; 0x34
  40ae04:	4619      	mov	r1, r3
  40ae06:	68f8      	ldr	r0, [r7, #12]
  40ae08:	4b11      	ldr	r3, [pc, #68]	; (40ae50 <inv_icm20648_set_matrix+0x158>)
  40ae0a:	4798      	blx	r3
  40ae0c:	4602      	mov	r2, r0
  40ae0e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  40ae10:	4313      	orrs	r3, r2
  40ae12:	65fb      	str	r3, [r7, #92]	; 0x5c

		//Notify new matrix to mag calculation with acc-gyr mounting matrix
		result |= inv_icm20648_compass_dmp_cal(s, s->mounting_matrix, s->mounting_matrix_secondary_compass);
  40ae14:	68fb      	ldr	r3, [r7, #12]
  40ae16:	f503 711d 	add.w	r1, r3, #628	; 0x274
  40ae1a:	68fb      	ldr	r3, [r7, #12]
  40ae1c:	f203 237d 	addw	r3, r3, #637	; 0x27d
  40ae20:	461a      	mov	r2, r3
  40ae22:	68f8      	ldr	r0, [r7, #12]
  40ae24:	4b07      	ldr	r3, [pc, #28]	; (40ae44 <inv_icm20648_set_matrix+0x14c>)
  40ae26:	4798      	blx	r3
  40ae28:	4602      	mov	r2, r0
  40ae2a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  40ae2c:	4313      	orrs	r3, r2
  40ae2e:	65fb      	str	r3, [r7, #92]	; 0x5c
	}

	return result;
  40ae30:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
}
  40ae32:	4618      	mov	r0, r3
  40ae34:	3760      	adds	r7, #96	; 0x60
  40ae36:	46bd      	mov	sp, r7
  40ae38:	bd80      	pop	{r7, pc}
  40ae3a:	bf00      	nop
  40ae3c:	4e800000 	.word	0x4e800000
  40ae40:	0040acb9 	.word	0x0040acb9
  40ae44:	004052e5 	.word	0x004052e5
  40ae48:	00000000 	.word	0x00000000
  40ae4c:	00406f29 	.word	0x00406f29
  40ae50:	00408a7d 	.word	0x00408a7d

0040ae54 <inv_icm20648_initialize_auxiliary>:

int inv_icm20648_initialize_auxiliary(struct inv_icm20648 * s)
{
  40ae54:	b580      	push	{r7, lr}
  40ae56:	b082      	sub	sp, #8
  40ae58:	af00      	add	r7, sp, #0
  40ae5a:	6078      	str	r0, [r7, #4]
	if (inv_icm20648_set_slave_compass_id(s, s->secondary_state.compass_slave_id) )
  40ae5c:	687b      	ldr	r3, [r7, #4]
  40ae5e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40ae62:	4619      	mov	r1, r3
  40ae64:	6878      	ldr	r0, [r7, #4]
  40ae66:	4b06      	ldr	r3, [pc, #24]	; (40ae80 <inv_icm20648_initialize_auxiliary+0x2c>)
  40ae68:	4798      	blx	r3
  40ae6a:	4603      	mov	r3, r0
  40ae6c:	2b00      	cmp	r3, #0
  40ae6e:	d002      	beq.n	40ae76 <inv_icm20648_initialize_auxiliary+0x22>
		return -1;
  40ae70:	f04f 33ff 	mov.w	r3, #4294967295
  40ae74:	e000      	b.n	40ae78 <inv_icm20648_initialize_auxiliary+0x24>
	return 0;
  40ae76:	2300      	movs	r3, #0
}
  40ae78:	4618      	mov	r0, r3
  40ae7a:	3708      	adds	r7, #8
  40ae7c:	46bd      	mov	sp, r7
  40ae7e:	bd80      	pop	{r7, pc}
  40ae80:	004061ed 	.word	0x004061ed

0040ae84 <inv_icm20648_soft_reset>:

int inv_icm20648_soft_reset(struct inv_icm20648 * s)
{
  40ae84:	b580      	push	{r7, lr}
  40ae86:	b084      	sub	sp, #16
  40ae88:	af00      	add	r7, sp, #0
  40ae8a:	6078      	str	r0, [r7, #4]
	//soft reset like
	int rc = inv_icm20648_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_H_RESET);
  40ae8c:	2280      	movs	r2, #128	; 0x80
  40ae8e:	2106      	movs	r1, #6
  40ae90:	6878      	ldr	r0, [r7, #4]
  40ae92:	4b05      	ldr	r3, [pc, #20]	; (40aea8 <inv_icm20648_soft_reset+0x24>)
  40ae94:	4798      	blx	r3
  40ae96:	60f8      	str	r0, [r7, #12]

	// max start-up time is 100 msec
	inv_icm20648_sleep_us(100000);
  40ae98:	4804      	ldr	r0, [pc, #16]	; (40aeac <inv_icm20648_soft_reset+0x28>)
  40ae9a:	4b05      	ldr	r3, [pc, #20]	; (40aeb0 <inv_icm20648_soft_reset+0x2c>)
  40ae9c:	4798      	blx	r3

	return rc;
  40ae9e:	68fb      	ldr	r3, [r7, #12]
}
  40aea0:	4618      	mov	r0, r3
  40aea2:	3710      	adds	r7, #16
  40aea4:	46bd      	mov	sp, r7
  40aea6:	bd80      	pop	{r7, pc}
  40aea8:	0040c9d5 	.word	0x0040c9d5
  40aeac:	000186a0 	.word	0x000186a0
  40aeb0:	004015d9 	.word	0x004015d9

0040aeb4 <inv_icm20648_enable_sensor>:

int inv_icm20648_enable_sensor(struct inv_icm20648 * s, enum inv_icm20648_sensor sensor, inv_bool_t state)
{
  40aeb4:	b590      	push	{r4, r7, lr}
  40aeb6:	b087      	sub	sp, #28
  40aeb8:	af00      	add	r7, sp, #0
  40aeba:	60f8      	str	r0, [r7, #12]
  40aebc:	460b      	mov	r3, r1
  40aebe:	607a      	str	r2, [r7, #4]
  40aec0:	72fb      	strb	r3, [r7, #11]
	uint8_t androidSensor = sensor_type_2_android_sensor(sensor);
  40aec2:	7afb      	ldrb	r3, [r7, #11]
  40aec4:	4618      	mov	r0, r3
  40aec6:	4b12      	ldr	r3, [pc, #72]	; (40af10 <inv_icm20648_enable_sensor+0x5c>)
  40aec8:	4798      	blx	r3
  40aeca:	4603      	mov	r3, r0
  40aecc:	75fb      	strb	r3, [r7, #23]

	if(0 != inv_icm20648_ctrl_enable_sensor(s, androidSensor, state))
  40aece:	687b      	ldr	r3, [r7, #4]
  40aed0:	b2da      	uxtb	r2, r3
  40aed2:	7dfb      	ldrb	r3, [r7, #23]
  40aed4:	4619      	mov	r1, r3
  40aed6:	68f8      	ldr	r0, [r7, #12]
  40aed8:	4b0e      	ldr	r3, [pc, #56]	; (40af14 <inv_icm20648_enable_sensor+0x60>)
  40aeda:	4798      	blx	r3
  40aedc:	4603      	mov	r3, r0
  40aede:	2b00      	cmp	r3, #0
  40aee0:	d002      	beq.n	40aee8 <inv_icm20648_enable_sensor+0x34>
		return -1;
  40aee2:	f04f 33ff 	mov.w	r3, #4294967295
  40aee6:	e00e      	b.n	40af06 <inv_icm20648_enable_sensor+0x52>

	//In case we disable a sensor, we reset his timestamp
	if(state == 0)
  40aee8:	687b      	ldr	r3, [r7, #4]
  40aeea:	2b00      	cmp	r3, #0
  40aeec:	d10a      	bne.n	40af04 <inv_icm20648_enable_sensor+0x50>
		s->timestamp[sensor] = 0;
  40aeee:	7afb      	ldrb	r3, [r7, #11]
  40aef0:	68fa      	ldr	r2, [r7, #12]
  40aef2:	3359      	adds	r3, #89	; 0x59
  40aef4:	00db      	lsls	r3, r3, #3
  40aef6:	441a      	add	r2, r3
  40aef8:	f04f 0300 	mov.w	r3, #0
  40aefc:	f04f 0400 	mov.w	r4, #0
  40af00:	e9c2 3400 	strd	r3, r4, [r2]

	return 0;
  40af04:	2300      	movs	r3, #0
}
  40af06:	4618      	mov	r0, r3
  40af08:	371c      	adds	r7, #28
  40af0a:	46bd      	mov	sp, r7
  40af0c:	bd90      	pop	{r4, r7, pc}
  40af0e:	bf00      	nop
  40af10:	0040a7b5 	.word	0x0040a7b5
  40af14:	00411bc5 	.word	0x00411bc5

0040af18 <inv_icm20648_set_sensor_period>:

int inv_icm20648_set_sensor_period(struct inv_icm20648 * s, enum inv_icm20648_sensor sensor, uint32_t period)
{
  40af18:	b590      	push	{r4, r7, lr}
  40af1a:	b087      	sub	sp, #28
  40af1c:	af00      	add	r7, sp, #0
  40af1e:	60f8      	str	r0, [r7, #12]
  40af20:	460b      	mov	r3, r1
  40af22:	607a      	str	r2, [r7, #4]
  40af24:	72fb      	strb	r3, [r7, #11]
	uint8_t androidSensor = sensor_type_2_android_sensor(sensor);
  40af26:	7afb      	ldrb	r3, [r7, #11]
  40af28:	4618      	mov	r0, r3
  40af2a:	4b17      	ldr	r3, [pc, #92]	; (40af88 <inv_icm20648_set_sensor_period+0x70>)
  40af2c:	4798      	blx	r3
  40af2e:	4603      	mov	r3, r0
  40af30:	75fb      	strb	r3, [r7, #23]

	if(0 != inv_icm20648_set_odr(s, androidSensor, period))
  40af32:	687b      	ldr	r3, [r7, #4]
  40af34:	b29a      	uxth	r2, r3
  40af36:	7dfb      	ldrb	r3, [r7, #23]
  40af38:	4619      	mov	r1, r3
  40af3a:	68f8      	ldr	r0, [r7, #12]
  40af3c:	4b13      	ldr	r3, [pc, #76]	; (40af8c <inv_icm20648_set_sensor_period+0x74>)
  40af3e:	4798      	blx	r3
  40af40:	4603      	mov	r3, r0
  40af42:	2b00      	cmp	r3, #0
  40af44:	d002      	beq.n	40af4c <inv_icm20648_set_sensor_period+0x34>
		return -1;
  40af46:	f04f 33ff 	mov.w	r3, #4294967295
  40af4a:	e019      	b.n	40af80 <inv_icm20648_set_sensor_period+0x68>

	// reset timestamp value and save current odr
	s->timestamp[sensor] = 0;
  40af4c:	7afb      	ldrb	r3, [r7, #11]
  40af4e:	68fa      	ldr	r2, [r7, #12]
  40af50:	3359      	adds	r3, #89	; 0x59
  40af52:	00db      	lsls	r3, r3, #3
  40af54:	441a      	add	r2, r3
  40af56:	f04f 0300 	mov.w	r3, #0
  40af5a:	f04f 0400 	mov.w	r4, #0
  40af5e:	e9c2 3400 	strd	r3, r4, [r2]
	s->sensorlist[sensor].odr_us = period * 1000;
  40af62:	7afa      	ldrb	r2, [r7, #11]
  40af64:	687b      	ldr	r3, [r7, #4]
  40af66:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  40af6a:	fb01 f303 	mul.w	r3, r1, r3
  40af6e:	f04f 0400 	mov.w	r4, #0
  40af72:	68f9      	ldr	r1, [r7, #12]
  40af74:	3239      	adds	r2, #57	; 0x39
  40af76:	0112      	lsls	r2, r2, #4
  40af78:	440a      	add	r2, r1
  40af7a:	e9c2 3400 	strd	r3, r4, [r2]
	return 0;
  40af7e:	2300      	movs	r3, #0
}
  40af80:	4618      	mov	r0, r3
  40af82:	371c      	adds	r7, #28
  40af84:	46bd      	mov	sp, r7
  40af86:	bd90      	pop	{r4, r7, pc}
  40af88:	0040a7b5 	.word	0x0040a7b5
  40af8c:	004115e1 	.word	0x004115e1

0040af90 <inv_icm20648_load>:
	}
	return 0;
}

int inv_icm20648_load(struct inv_icm20648 * s, const uint8_t * image, unsigned short size)
{
  40af90:	b590      	push	{r4, r7, lr}
  40af92:	b085      	sub	sp, #20
  40af94:	af00      	add	r7, sp, #0
  40af96:	60f8      	str	r0, [r7, #12]
  40af98:	60b9      	str	r1, [r7, #8]
  40af9a:	4613      	mov	r3, r2
  40af9c:	80fb      	strh	r3, [r7, #6]
	return inv_icm20648_firmware_load(s, image, size, DMP_LOAD_START);
  40af9e:	88fa      	ldrh	r2, [r7, #6]
  40afa0:	2390      	movs	r3, #144	; 0x90
  40afa2:	68b9      	ldr	r1, [r7, #8]
  40afa4:	68f8      	ldr	r0, [r7, #12]
  40afa6:	4c03      	ldr	r4, [pc, #12]	; (40afb4 <inv_icm20648_load+0x24>)
  40afa8:	47a0      	blx	r4
  40afaa:	4603      	mov	r3, r0
}
  40afac:	4618      	mov	r0, r3
  40afae:	3714      	adds	r7, #20
  40afb0:	46bd      	mov	sp, r7
  40afb2:	bd90      	pop	{r4, r7, pc}
  40afb4:	00408c45 	.word	0x00408c45

0040afb8 <inv_icm20648_is_streamed_sensor>:

/** @brief Returns 1 if the sensor id is a streamed sensor and not an event-based sensor */
static int inv_icm20648_is_streamed_sensor(uint8_t id)
{
  40afb8:	b480      	push	{r7}
  40afba:	b083      	sub	sp, #12
  40afbc:	af00      	add	r7, sp, #0
  40afbe:	4603      	mov	r3, r0
  40afc0:	71fb      	strb	r3, [r7, #7]
	switch(id)
  40afc2:	79fb      	ldrb	r3, [r7, #7]
  40afc4:	3b11      	subs	r3, #17
  40afc6:	2b1e      	cmp	r3, #30
  40afc8:	d842      	bhi.n	40b050 <inv_icm20648_is_streamed_sensor+0x98>
  40afca:	a201      	add	r2, pc, #4	; (adr r2, 40afd0 <inv_icm20648_is_streamed_sensor+0x18>)
  40afcc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40afd0:	0040b04d 	.word	0x0040b04d
  40afd4:	0040b04d 	.word	0x0040b04d
  40afd8:	0040b04d 	.word	0x0040b04d
  40afdc:	0040b051 	.word	0x0040b051
  40afe0:	0040b051 	.word	0x0040b051
  40afe4:	0040b051 	.word	0x0040b051
  40afe8:	0040b051 	.word	0x0040b051
  40afec:	0040b051 	.word	0x0040b051
  40aff0:	0040b051 	.word	0x0040b051
  40aff4:	0040b051 	.word	0x0040b051
  40aff8:	0040b051 	.word	0x0040b051
  40affc:	0040b051 	.word	0x0040b051
  40b000:	0040b051 	.word	0x0040b051
  40b004:	0040b051 	.word	0x0040b051
  40b008:	0040b051 	.word	0x0040b051
  40b00c:	0040b051 	.word	0x0040b051
  40b010:	0040b051 	.word	0x0040b051
  40b014:	0040b051 	.word	0x0040b051
  40b018:	0040b051 	.word	0x0040b051
  40b01c:	0040b051 	.word	0x0040b051
  40b020:	0040b051 	.word	0x0040b051
  40b024:	0040b051 	.word	0x0040b051
  40b028:	0040b051 	.word	0x0040b051
  40b02c:	0040b051 	.word	0x0040b051
  40b030:	0040b04d 	.word	0x0040b04d
  40b034:	0040b051 	.word	0x0040b051
  40b038:	0040b051 	.word	0x0040b051
  40b03c:	0040b051 	.word	0x0040b051
  40b040:	0040b04d 	.word	0x0040b04d
  40b044:	0040b04d 	.word	0x0040b04d
  40b048:	0040b04d 	.word	0x0040b04d
	case ANDROID_SENSOR_FLIP_PICKUP :
	case ANDROID_SENSOR_B2S :
	case ANDROID_SENSOR_STEP_COUNTER:
	case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION :
	case ANDROID_SENSOR_STEP_DETECTOR :
			return 0;
  40b04c:	2300      	movs	r3, #0
  40b04e:	e000      	b.n	40b052 <inv_icm20648_is_streamed_sensor+0x9a>
	default :
			return 1;
  40b050:	2301      	movs	r3, #1
	}
}
  40b052:	4618      	mov	r0, r3
  40b054:	370c      	adds	r7, #12
  40b056:	46bd      	mov	sp, r7
  40b058:	f85d 7b04 	ldr.w	r7, [sp], #4
  40b05c:	4770      	bx	lr
  40b05e:	bf00      	nop

0040b060 <inv_icm20648_updateTs>:

/** @brief Preprocess all timestamps so that they either contain very last time at which MEMS IRQ was fired
 * or last time sent for the sensor + ODR */
static uint8_t inv_icm20648_updateTs(struct inv_icm20648 * s, int * data_left_in_fifo,
	unsigned short * total_sample_cnt, uint64_t * lastIrqTimeUs)
{
  40b060:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40b064:	b0a1      	sub	sp, #132	; 0x84
  40b066:	af00      	add	r7, sp, #0
  40b068:	60f8      	str	r0, [r7, #12]
  40b06a:	60b9      	str	r1, [r7, #8]
  40b06c:	607a      	str	r2, [r7, #4]
  40b06e:	603b      	str	r3, [r7, #0]
	/** @brief Very last time in us at which IRQ was fired since flushing FIFO process was started */
	unsigned short sample_cnt_array[GENERAL_SENSORS_MAX] = {0};
  40b070:	f107 0314 	add.w	r3, r7, #20
  40b074:	2266      	movs	r2, #102	; 0x66
  40b076:	2100      	movs	r1, #0
  40b078:	4618      	mov	r0, r3
  40b07a:	4bbd      	ldr	r3, [pc, #756]	; (40b370 <inv_icm20648_updateTs+0x310>)
  40b07c:	4798      	blx	r3
	uint8_t i;

	memset(sample_cnt_array, 0, sizeof(sample_cnt_array));
  40b07e:	f107 0314 	add.w	r3, r7, #20
  40b082:	2266      	movs	r2, #102	; 0x66
  40b084:	2100      	movs	r1, #0
  40b086:	4618      	mov	r0, r3
  40b088:	4bb9      	ldr	r3, [pc, #740]	; (40b370 <inv_icm20648_updateTs+0x310>)
  40b08a:	4798      	blx	r3
	if (inv_icm20648_fifo_swmirror(s, data_left_in_fifo, total_sample_cnt, sample_cnt_array)) {
  40b08c:	f107 0314 	add.w	r3, r7, #20
  40b090:	687a      	ldr	r2, [r7, #4]
  40b092:	68b9      	ldr	r1, [r7, #8]
  40b094:	68f8      	ldr	r0, [r7, #12]
  40b096:	4cb7      	ldr	r4, [pc, #732]	; (40b374 <inv_icm20648_updateTs+0x314>)
  40b098:	47a0      	blx	r4
  40b09a:	4603      	mov	r3, r0
  40b09c:	2b00      	cmp	r3, #0
  40b09e:	d026      	beq.n	40b0ee <inv_icm20648_updateTs+0x8e>
		for(i = 0; i< GENERAL_SENSORS_MAX; i++) {
  40b0a0:	2300      	movs	r3, #0
  40b0a2:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40b0a6:	e01c      	b.n	40b0e2 <inv_icm20648_updateTs+0x82>
			if (inv_icm20648_is_streamed_sensor(i)) {
  40b0a8:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b0ac:	4618      	mov	r0, r3
  40b0ae:	4bb2      	ldr	r3, [pc, #712]	; (40b378 <inv_icm20648_updateTs+0x318>)
  40b0b0:	4798      	blx	r3
  40b0b2:	4603      	mov	r3, r0
  40b0b4:	2b00      	cmp	r3, #0
  40b0b6:	d00f      	beq.n	40b0d8 <inv_icm20648_updateTs+0x78>
				s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] = *lastIrqTimeUs;
  40b0b8:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b0bc:	4618      	mov	r0, r3
  40b0be:	4baf      	ldr	r3, [pc, #700]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b0c0:	4798      	blx	r3
  40b0c2:	4603      	mov	r3, r0
  40b0c4:	461a      	mov	r2, r3
  40b0c6:	683b      	ldr	r3, [r7, #0]
  40b0c8:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b0cc:	68f9      	ldr	r1, [r7, #12]
  40b0ce:	3259      	adds	r2, #89	; 0x59
  40b0d0:	00d2      	lsls	r2, r2, #3
  40b0d2:	440a      	add	r2, r1
  40b0d4:	e9c2 3400 	strd	r3, r4, [r2]
		for(i = 0; i< GENERAL_SENSORS_MAX; i++) {
  40b0d8:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b0dc:	3301      	adds	r3, #1
  40b0de:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40b0e2:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b0e6:	2b32      	cmp	r3, #50	; 0x32
  40b0e8:	d9de      	bls.n	40b0a8 <inv_icm20648_updateTs+0x48>
			}
		}
		return -1;
  40b0ea:	23ff      	movs	r3, #255	; 0xff
  40b0ec:	e13b      	b.n	40b366 <inv_icm20648_updateTs+0x306>
	}
	// we parse all senosr according to android type
	for (i = 0; i < GENERAL_SENSORS_MAX; i++) {
  40b0ee:	2300      	movs	r3, #0
  40b0f0:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40b0f4:	e131      	b.n	40b35a <inv_icm20648_updateTs+0x2fa>
		if (inv_icm20648_is_streamed_sensor(i)) {
  40b0f6:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b0fa:	4618      	mov	r0, r3
  40b0fc:	4b9e      	ldr	r3, [pc, #632]	; (40b378 <inv_icm20648_updateTs+0x318>)
  40b0fe:	4798      	blx	r3
  40b100:	4603      	mov	r3, r0
  40b102:	2b00      	cmp	r3, #0
  40b104:	f000 8114 	beq.w	40b330 <inv_icm20648_updateTs+0x2d0>
			if (sample_cnt_array[i]) {
  40b108:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b10c:	005b      	lsls	r3, r3, #1
  40b10e:	f107 0280 	add.w	r2, r7, #128	; 0x80
  40b112:	4413      	add	r3, r2
  40b114:	f833 3c6c 	ldrh.w	r3, [r3, #-108]
  40b118:	2b00      	cmp	r3, #0
  40b11a:	f000 8119 	beq.w	40b350 <inv_icm20648_updateTs+0x2f0>
				/** Number of samples present in MEMS FIFO last time we mirrored it */
				unsigned short fifo_sample_cnt = sample_cnt_array[i];
  40b11e:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b122:	005b      	lsls	r3, r3, #1
  40b124:	f107 0280 	add.w	r2, r7, #128	; 0x80
  40b128:	4413      	add	r3, r2
  40b12a:	f833 3c6c 	ldrh.w	r3, [r3, #-108]
  40b12e:	f8a7 307c 	strh.w	r3, [r7, #124]	; 0x7c

				/** In case of first batch we have less than the expected number of samples in the batch */
				/** To avoid a bad timestamping we recompute the startup time based on the theorical ODR and the number of samples */
				if (s->sFirstBatch[inv_icm20648_sensor_android_2_sensor_type(i)]) {
  40b132:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b136:	4618      	mov	r0, r3
  40b138:	4b90      	ldr	r3, [pc, #576]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b13a:	4798      	blx	r3
  40b13c:	4603      	mov	r3, r0
  40b13e:	461a      	mov	r2, r3
  40b140:	68fb      	ldr	r3, [r7, #12]
  40b142:	4413      	add	r3, r2
  40b144:	f893 3370 	ldrb.w	r3, [r3, #880]	; 0x370
  40b148:	2b00      	cmp	r3, #0
  40b14a:	d058      	beq.n	40b1fe <inv_icm20648_updateTs+0x19e>
					s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] += *lastIrqTimeUs-s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)]
  40b14c:	683b      	ldr	r3, [r7, #0]
  40b14e:	e9d3 5600 	ldrd	r5, r6, [r3]
  40b152:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b156:	4618      	mov	r0, r3
  40b158:	4b88      	ldr	r3, [pc, #544]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b15a:	4798      	blx	r3
  40b15c:	4603      	mov	r3, r0
  40b15e:	68fa      	ldr	r2, [r7, #12]
  40b160:	3359      	adds	r3, #89	; 0x59
  40b162:	00db      	lsls	r3, r3, #3
  40b164:	4413      	add	r3, r2
  40b166:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b16a:	1aed      	subs	r5, r5, r3
  40b16c:	eb66 0604 	sbc.w	r6, r6, r4
  40b170:	46a8      	mov	r8, r5
  40b172:	46b1      	mov	r9, r6
																	- fifo_sample_cnt*s->sensorlist[inv_icm20648_sensor_android_2_sensor_type(i)].odr_us;
  40b174:	f8b7 507c 	ldrh.w	r5, [r7, #124]	; 0x7c
  40b178:	f04f 0600 	mov.w	r6, #0
  40b17c:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b180:	4618      	mov	r0, r3
  40b182:	4b7e      	ldr	r3, [pc, #504]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b184:	4798      	blx	r3
  40b186:	4603      	mov	r3, r0
  40b188:	68fa      	ldr	r2, [r7, #12]
  40b18a:	3339      	adds	r3, #57	; 0x39
  40b18c:	011b      	lsls	r3, r3, #4
  40b18e:	4413      	add	r3, r2
  40b190:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b194:	fb03 f106 	mul.w	r1, r3, r6
  40b198:	fb05 f204 	mul.w	r2, r5, r4
  40b19c:	440a      	add	r2, r1
  40b19e:	fba5 3403 	umull	r3, r4, r5, r3
  40b1a2:	4422      	add	r2, r4
  40b1a4:	4614      	mov	r4, r2
  40b1a6:	ebb8 0803 	subs.w	r8, r8, r3
  40b1aa:	eb69 0904 	sbc.w	r9, r9, r4
  40b1ae:	4644      	mov	r4, r8
  40b1b0:	464d      	mov	r5, r9
					s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] += *lastIrqTimeUs-s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)]
  40b1b2:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b1b6:	4618      	mov	r0, r3
  40b1b8:	4b70      	ldr	r3, [pc, #448]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b1ba:	4798      	blx	r3
  40b1bc:	4603      	mov	r3, r0
  40b1be:	4618      	mov	r0, r3
  40b1c0:	68fa      	ldr	r2, [r7, #12]
  40b1c2:	3359      	adds	r3, #89	; 0x59
  40b1c4:	00db      	lsls	r3, r3, #3
  40b1c6:	4413      	add	r3, r2
  40b1c8:	e9d3 2300 	ldrd	r2, r3, [r3]
  40b1cc:	eb12 0804 	adds.w	r8, r2, r4
  40b1d0:	eb43 0905 	adc.w	r9, r3, r5
  40b1d4:	4643      	mov	r3, r8
  40b1d6:	464c      	mov	r4, r9
  40b1d8:	68f9      	ldr	r1, [r7, #12]
  40b1da:	f100 0259 	add.w	r2, r0, #89	; 0x59
  40b1de:	00d2      	lsls	r2, r2, #3
  40b1e0:	440a      	add	r2, r1
  40b1e2:	e9c2 3400 	strd	r3, r4, [r2]
					s->sFirstBatch[inv_icm20648_sensor_android_2_sensor_type(i)] = 0;
  40b1e6:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b1ea:	4618      	mov	r0, r3
  40b1ec:	4b63      	ldr	r3, [pc, #396]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b1ee:	4798      	blx	r3
  40b1f0:	4603      	mov	r3, r0
  40b1f2:	461a      	mov	r2, r3
  40b1f4:	68fb      	ldr	r3, [r7, #12]
  40b1f6:	4413      	add	r3, r2
  40b1f8:	2200      	movs	r2, #0
  40b1fa:	f883 2370 	strb.w	r2, [r3, #880]	; 0x370
				first time to be printed is t1+(t2-t1)/N
				- t1 is last time we sent data
				- t2 is when IRQ was fired so that we pop the FIFO
				- N is number of samples */

				if(s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] == 0) {
  40b1fe:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b202:	4618      	mov	r0, r3
  40b204:	4b5d      	ldr	r3, [pc, #372]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b206:	4798      	blx	r3
  40b208:	4603      	mov	r3, r0
  40b20a:	68fa      	ldr	r2, [r7, #12]
  40b20c:	3359      	adds	r3, #89	; 0x59
  40b20e:	00db      	lsls	r3, r3, #3
  40b210:	4413      	add	r3, r2
  40b212:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b216:	4323      	orrs	r3, r4
  40b218:	d15c      	bne.n	40b2d4 <inv_icm20648_updateTs+0x274>
					s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] = *lastIrqTimeUs;
  40b21a:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b21e:	4618      	mov	r0, r3
  40b220:	4b56      	ldr	r3, [pc, #344]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b222:	4798      	blx	r3
  40b224:	4603      	mov	r3, r0
  40b226:	461a      	mov	r2, r3
  40b228:	683b      	ldr	r3, [r7, #0]
  40b22a:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b22e:	68f9      	ldr	r1, [r7, #12]
  40b230:	3259      	adds	r2, #89	; 0x59
  40b232:	00d2      	lsls	r2, r2, #3
  40b234:	440a      	add	r2, r1
  40b236:	e9c2 3400 	strd	r3, r4, [r2]
					s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] -= s->sensorlist[inv_icm20648_sensor_android_2_sensor_type(i)].odr_us*(fifo_sample_cnt);
  40b23a:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b23e:	4618      	mov	r0, r3
  40b240:	4b4e      	ldr	r3, [pc, #312]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b242:	4798      	blx	r3
  40b244:	4603      	mov	r3, r0
  40b246:	68fa      	ldr	r2, [r7, #12]
  40b248:	3339      	adds	r3, #57	; 0x39
  40b24a:	011b      	lsls	r3, r3, #4
  40b24c:	4413      	add	r3, r2
  40b24e:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b252:	f8b7 307c 	ldrh.w	r3, [r7, #124]	; 0x7c
  40b256:	f04f 0400 	mov.w	r4, #0
  40b25a:	fb03 f502 	mul.w	r5, r3, r2
  40b25e:	fb01 f004 	mul.w	r0, r1, r4
  40b262:	4428      	add	r0, r5
  40b264:	fba1 4503 	umull	r4, r5, r1, r3
  40b268:	1943      	adds	r3, r0, r5
  40b26a:	461d      	mov	r5, r3
  40b26c:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b270:	4618      	mov	r0, r3
  40b272:	4b42      	ldr	r3, [pc, #264]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b274:	4798      	blx	r3
  40b276:	4603      	mov	r3, r0
  40b278:	4618      	mov	r0, r3
  40b27a:	68fa      	ldr	r2, [r7, #12]
  40b27c:	3359      	adds	r3, #89	; 0x59
  40b27e:	00db      	lsls	r3, r3, #3
  40b280:	4413      	add	r3, r2
  40b282:	e9d3 2300 	ldrd	r2, r3, [r3]
  40b286:	1b12      	subs	r2, r2, r4
  40b288:	eb63 0305 	sbc.w	r3, r3, r5
  40b28c:	461c      	mov	r4, r3
  40b28e:	4613      	mov	r3, r2
  40b290:	68f9      	ldr	r1, [r7, #12]
  40b292:	f100 0259 	add.w	r2, r0, #89	; 0x59
  40b296:	00d2      	lsls	r2, r2, #3
  40b298:	440a      	add	r2, r1
  40b29a:	e9c2 3400 	strd	r3, r4, [r2]
					s->sensorlist[inv_icm20648_sensor_android_2_sensor_type(i)].odr_applied_us = s->sensorlist[inv_icm20648_sensor_android_2_sensor_type(i)].odr_us;
  40b29e:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b2a2:	4618      	mov	r0, r3
  40b2a4:	4b35      	ldr	r3, [pc, #212]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b2a6:	4798      	blx	r3
  40b2a8:	4603      	mov	r3, r0
  40b2aa:	461d      	mov	r5, r3
  40b2ac:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b2b0:	4618      	mov	r0, r3
  40b2b2:	4b32      	ldr	r3, [pc, #200]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b2b4:	4798      	blx	r3
  40b2b6:	4603      	mov	r3, r0
  40b2b8:	68fa      	ldr	r2, [r7, #12]
  40b2ba:	3339      	adds	r3, #57	; 0x39
  40b2bc:	011b      	lsls	r3, r3, #4
  40b2be:	4413      	add	r3, r2
  40b2c0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b2c4:	68f9      	ldr	r1, [r7, #12]
  40b2c6:	012a      	lsls	r2, r5, #4
  40b2c8:	440a      	add	r2, r1
  40b2ca:	f502 7262 	add.w	r2, r2, #904	; 0x388
  40b2ce:	e9c2 3400 	strd	r3, r4, [r2]
  40b2d2:	e03d      	b.n	40b350 <inv_icm20648_updateTs+0x2f0>
				}
				else {
					s->sensorlist[inv_icm20648_sensor_android_2_sensor_type(i)].odr_applied_us = (*lastIrqTimeUs - s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)])/fifo_sample_cnt;
  40b2d4:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b2d8:	4618      	mov	r0, r3
  40b2da:	4b28      	ldr	r3, [pc, #160]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b2dc:	4798      	blx	r3
  40b2de:	4603      	mov	r3, r0
  40b2e0:	4698      	mov	r8, r3
  40b2e2:	683b      	ldr	r3, [r7, #0]
  40b2e4:	e9d3 5600 	ldrd	r5, r6, [r3]
  40b2e8:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b2ec:	4618      	mov	r0, r3
  40b2ee:	4b23      	ldr	r3, [pc, #140]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b2f0:	4798      	blx	r3
  40b2f2:	4603      	mov	r3, r0
  40b2f4:	68fa      	ldr	r2, [r7, #12]
  40b2f6:	3359      	adds	r3, #89	; 0x59
  40b2f8:	00db      	lsls	r3, r3, #3
  40b2fa:	4413      	add	r3, r2
  40b2fc:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b300:	4628      	mov	r0, r5
  40b302:	4631      	mov	r1, r6
  40b304:	1ac0      	subs	r0, r0, r3
  40b306:	eb61 0104 	sbc.w	r1, r1, r4
  40b30a:	f8b7 307c 	ldrh.w	r3, [r7, #124]	; 0x7c
  40b30e:	f04f 0400 	mov.w	r4, #0
  40b312:	4d1b      	ldr	r5, [pc, #108]	; (40b380 <inv_icm20648_updateTs+0x320>)
  40b314:	461a      	mov	r2, r3
  40b316:	4623      	mov	r3, r4
  40b318:	47a8      	blx	r5
  40b31a:	4603      	mov	r3, r0
  40b31c:	460c      	mov	r4, r1
  40b31e:	68f9      	ldr	r1, [r7, #12]
  40b320:	ea4f 1208 	mov.w	r2, r8, lsl #4
  40b324:	440a      	add	r2, r1
  40b326:	f502 7262 	add.w	r2, r2, #904	; 0x388
  40b32a:	e9c2 3400 	strd	r3, r4, [r2]
  40b32e:	e00f      	b.n	40b350 <inv_icm20648_updateTs+0x2f0>
				}
			}
		} else {
			/** update timestamp for all event sensors with time at which MEMS IRQ was fired */
			s->timestamp[inv_icm20648_sensor_android_2_sensor_type(i)] = *lastIrqTimeUs;
  40b330:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b334:	4618      	mov	r0, r3
  40b336:	4b11      	ldr	r3, [pc, #68]	; (40b37c <inv_icm20648_updateTs+0x31c>)
  40b338:	4798      	blx	r3
  40b33a:	4603      	mov	r3, r0
  40b33c:	461a      	mov	r2, r3
  40b33e:	683b      	ldr	r3, [r7, #0]
  40b340:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b344:	68f9      	ldr	r1, [r7, #12]
  40b346:	3259      	adds	r2, #89	; 0x59
  40b348:	00d2      	lsls	r2, r2, #3
  40b34a:	440a      	add	r2, r1
  40b34c:	e9c2 3400 	strd	r3, r4, [r2]
	for (i = 0; i < GENERAL_SENSORS_MAX; i++) {
  40b350:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b354:	3301      	adds	r3, #1
  40b356:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40b35a:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b35e:	2b32      	cmp	r3, #50	; 0x32
  40b360:	f67f aec9 	bls.w	40b0f6 <inv_icm20648_updateTs+0x96>
		}
	}

	return 0;
  40b364:	2300      	movs	r3, #0
}
  40b366:	4618      	mov	r0, r3
  40b368:	3784      	adds	r7, #132	; 0x84
  40b36a:	46bd      	mov	sp, r7
  40b36c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40b370:	00414431 	.word	0x00414431
  40b374:	00409529 	.word	0x00409529
  40b378:	0040afb9 	.word	0x0040afb9
  40b37c:	0040a87d 	.word	0x0040a87d
  40b380:	00413e69 	.word	0x00413e69

0040b384 <inv_icm20648_poll_sensor>:

int inv_icm20648_poll_sensor(struct inv_icm20648 * s, void * context,
		void (*handler)(void * context, enum inv_icm20648_sensor sensor, uint64_t timestamp, const void * data, const void *arg))
{
  40b384:	b5b0      	push	{r4, r5, r7, lr}
  40b386:	f5ad 7d08 	sub.w	sp, sp, #544	; 0x220
  40b38a:	af02      	add	r7, sp, #8
  40b38c:	f107 030c 	add.w	r3, r7, #12
  40b390:	6018      	str	r0, [r3, #0]
  40b392:	f107 0308 	add.w	r3, r7, #8
  40b396:	6019      	str	r1, [r3, #0]
  40b398:	1d3b      	adds	r3, r7, #4
  40b39a:	601a      	str	r2, [r3, #0]
	short int_read_back=0;
  40b39c:	2300      	movs	r3, #0
  40b39e:	f8a7 31f2 	strh.w	r3, [r7, #498]	; 0x1f2
	unsigned short header=0, header2 = 0;
  40b3a2:	2300      	movs	r3, #0
  40b3a4:	f8a7 31f0 	strh.w	r3, [r7, #496]	; 0x1f0
  40b3a8:	2300      	movs	r3, #0
  40b3aa:	f8a7 31ee 	strh.w	r3, [r7, #494]	; 0x1ee
	int data_left_in_fifo=0;
  40b3ae:	2300      	movs	r3, #0
  40b3b0:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
	short short_data[3] = {0};
  40b3b4:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
  40b3b8:	2200      	movs	r2, #0
  40b3ba:	601a      	str	r2, [r3, #0]
  40b3bc:	809a      	strh	r2, [r3, #4]
	signed long  long_data[3] = {0};
  40b3be:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b3c2:	2200      	movs	r2, #0
  40b3c4:	601a      	str	r2, [r3, #0]
  40b3c6:	605a      	str	r2, [r3, #4]
  40b3c8:	609a      	str	r2, [r3, #8]
	signed long  long_quat[3] = {0};
  40b3ca:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40b3ce:	2200      	movs	r2, #0
  40b3d0:	601a      	str	r2, [r3, #0]
  40b3d2:	605a      	str	r2, [r3, #4]
  40b3d4:	609a      	str	r2, [r3, #8]
	float gyro_raw_float[3];
	float gyro_bias_float[3];
	int gyro_accuracy = 0;
  40b3d6:	2300      	movs	r3, #0
  40b3d8:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
	int dummy_accuracy = 0;
  40b3dc:	2300      	movs	r3, #0
  40b3de:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
	int accel_accuracy = 0;
  40b3e2:	2300      	movs	r3, #0
  40b3e4:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
	int compass_accuracy = 0;
  40b3e8:	2300      	movs	r3, #0
  40b3ea:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
	float rv_accuracy = 0;
  40b3ee:	f04f 0300 	mov.w	r3, #0
  40b3f2:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
	float gmrv_accuracy = 0;
  40b3f6:	f04f 0300 	mov.w	r3, #0
  40b3fa:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
	float accel_float[3];
	float grv_float[4];
	float gyro_float[3];
	float compass_float[3] = {0};
  40b3fe:	f507 73b4 	add.w	r3, r7, #360	; 0x168
  40b402:	2200      	movs	r2, #0
  40b404:	601a      	str	r2, [r3, #0]
  40b406:	605a      	str	r2, [r3, #4]
  40b408:	609a      	str	r2, [r3, #8]
	float compass_raw_float[3];
	float rv_float[4];
	float gmrv_float[4];
	uint16_t pickup_state = 0;
  40b40a:	2300      	movs	r3, #0
  40b40c:	f8a7 313a 	strh.w	r3, [r7, #314]	; 0x13a
	uint64_t lastIrqTimeUs;

	inv_icm20648_identify_interrupt(s, &int_read_back);
  40b410:	f507 72f9 	add.w	r2, r7, #498	; 0x1f2
  40b414:	f107 030c 	add.w	r3, r7, #12
  40b418:	4611      	mov	r1, r2
  40b41a:	6818      	ldr	r0, [r3, #0]
  40b41c:	4b12      	ldr	r3, [pc, #72]	; (40b468 <inv_icm20648_poll_sensor+0xe4>)
  40b41e:	4798      	blx	r3

	if (int_read_back & (BIT_MSG_DMP_INT | BIT_MSG_DMP_INT_0)) {
  40b420:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40b424:	b29b      	uxth	r3, r3
  40b426:	f403 7381 	and.w	r3, r3, #258	; 0x102
  40b42a:	2b00      	cmp	r3, #0
  40b42c:	f001 812d 	beq.w	40c68a <inv_icm20648_poll_sensor+0x1306>
		lastIrqTimeUs = inv_icm20648_get_time_us();
  40b430:	4b0e      	ldr	r3, [pc, #56]	; (40b46c <inv_icm20648_poll_sensor+0xe8>)
  40b432:	4798      	blx	r3
  40b434:	4603      	mov	r3, r0
  40b436:	460c      	mov	r4, r1
  40b438:	f507 7298 	add.w	r2, r7, #304	; 0x130
  40b43c:	e9c2 3400 	strd	r3, r4, [r2]

		do {
			unsigned short total_sample_cnt = 0;
  40b440:	2300      	movs	r3, #0
  40b442:	f8a7 312e 	strh.w	r3, [r7, #302]	; 0x12e

			/* Mirror FIFO contents and stop processing FIFO if an error was detected*/
			if(inv_icm20648_updateTs(s, &data_left_in_fifo, &total_sample_cnt, &lastIrqTimeUs))
  40b446:	f507 7398 	add.w	r3, r7, #304	; 0x130
  40b44a:	f507 7297 	add.w	r2, r7, #302	; 0x12e
  40b44e:	f507 71f4 	add.w	r1, r7, #488	; 0x1e8
  40b452:	f107 000c 	add.w	r0, r7, #12
  40b456:	6800      	ldr	r0, [r0, #0]
  40b458:	4c05      	ldr	r4, [pc, #20]	; (40b470 <inv_icm20648_poll_sensor+0xec>)
  40b45a:	47a0      	blx	r4
  40b45c:	4603      	mov	r3, r0
  40b45e:	2b00      	cmp	r3, #0
  40b460:	f041 80b2 	bne.w	40c5c8 <inv_icm20648_poll_sensor+0x1244>
				break;

			while(total_sample_cnt--) {
  40b464:	f001 b890 	b.w	40c588 <inv_icm20648_poll_sensor+0x1204>
  40b468:	00408df1 	.word	0x00408df1
  40b46c:	00401105 	.word	0x00401105
  40b470:	0040b061 	.word	0x0040b061
				/* Read FIFO contents and parse it, and stop processing FIFO if an error was detected*/
				if (inv_icm20648_fifo_pop(s, &header, &header2, &data_left_in_fifo))
  40b474:	f507 73f4 	add.w	r3, r7, #488	; 0x1e8
  40b478:	f507 72f7 	add.w	r2, r7, #494	; 0x1ee
  40b47c:	f507 71f8 	add.w	r1, r7, #496	; 0x1f0
  40b480:	f107 000c 	add.w	r0, r7, #12
  40b484:	6800      	ldr	r0, [r0, #0]
  40b486:	4cc1      	ldr	r4, [pc, #772]	; (40b78c <inv_icm20648_poll_sensor+0x408>)
  40b488:	47a0      	blx	r4
  40b48a:	4603      	mov	r3, r0
  40b48c:	2b00      	cmp	r3, #0
  40b48e:	f041 8085 	bne.w	40c59c <inv_icm20648_poll_sensor+0x1218>
					break;

				/* Gyro sample available from DMP FIFO */
				if (header & GYRO_SET) {
  40b492:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40b496:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  40b49a:	2b00      	cmp	r3, #0
  40b49c:	f000 81e1 	beq.w	40b862 <inv_icm20648_poll_sensor+0x4de>
					float lScaleDeg = (1 << inv_icm20648_get_gyro_fullscale(s)) * 250.f; // From raw to dps to degree per seconds
  40b4a0:	f107 030c 	add.w	r3, r7, #12
  40b4a4:	6818      	ldr	r0, [r3, #0]
  40b4a6:	4bba      	ldr	r3, [pc, #744]	; (40b790 <inv_icm20648_poll_sensor+0x40c>)
  40b4a8:	4798      	blx	r3
  40b4aa:	4603      	mov	r3, r0
  40b4ac:	461a      	mov	r2, r3
  40b4ae:	2301      	movs	r3, #1
  40b4b0:	4093      	lsls	r3, r2
  40b4b2:	ee07 3a90 	vmov	s15, r3
  40b4b6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b4ba:	ed9f 7ab6 	vldr	s14, [pc, #728]	; 40b794 <inv_icm20648_poll_sensor+0x410>
  40b4be:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b4c2:	edc7 7a83 	vstr	s15, [r7, #524]	; 0x20c
					float lScaleDeg_bias = 2000.f; // Gyro bias from FIFO is always in 2^20 = 2000 dps regardless of fullscale
  40b4c6:	4bb4      	ldr	r3, [pc, #720]	; (40b798 <inv_icm20648_poll_sensor+0x414>)
  40b4c8:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
					signed long  lRawGyroQ15[3] = {0};
  40b4cc:	f507 7390 	add.w	r3, r7, #288	; 0x120
  40b4d0:	2200      	movs	r2, #0
  40b4d2:	601a      	str	r2, [r3, #0]
  40b4d4:	605a      	str	r2, [r3, #4]
  40b4d6:	609a      	str	r2, [r3, #8]
					signed long  lBiasGyroQ20[3] = {0};
  40b4d8:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b4dc:	461a      	mov	r2, r3
  40b4de:	2300      	movs	r3, #0
  40b4e0:	6013      	str	r3, [r2, #0]
  40b4e2:	6053      	str	r3, [r2, #4]
  40b4e4:	6093      	str	r3, [r2, #8]

					/* Read raw gyro out of DMP FIFO and convert it from Q15 raw data format to radian per seconds in Android format */
					inv_icm20648_dmp_get_raw_gyro(short_data);
  40b4e6:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
  40b4ea:	4618      	mov	r0, r3
  40b4ec:	4bab      	ldr	r3, [pc, #684]	; (40b79c <inv_icm20648_poll_sensor+0x418>)
  40b4ee:	4798      	blx	r3
					lRawGyroQ15[0] = (long) short_data[0];
  40b4f0:	f9b7 31e0 	ldrsh.w	r3, [r7, #480]	; 0x1e0
  40b4f4:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
					lRawGyroQ15[1] = (long) short_data[1];
  40b4f8:	f9b7 31e2 	ldrsh.w	r3, [r7, #482]	; 0x1e2
  40b4fc:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
					lRawGyroQ15[2] = (long) short_data[2];
  40b500:	f9b7 31e4 	ldrsh.w	r3, [r7, #484]	; 0x1e4
  40b504:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
					inv_icm20648_convert_dmp3_to_body(s, lRawGyroQ15, lScaleDeg/(1L<<15), gyro_raw_float);
  40b508:	edd7 7a83 	vldr	s15, [r7, #524]	; 0x20c
  40b50c:	ed9f 7aa4 	vldr	s14, [pc, #656]	; 40b7a0 <inv_icm20648_poll_sensor+0x41c>
  40b510:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40b514:	f507 72de 	add.w	r2, r7, #444	; 0x1bc
  40b518:	f507 7190 	add.w	r1, r7, #288	; 0x120
  40b51c:	f107 030c 	add.w	r3, r7, #12
  40b520:	eeb0 0a66 	vmov.f32	s0, s13
  40b524:	6818      	ldr	r0, [r3, #0]
  40b526:	4b9f      	ldr	r3, [pc, #636]	; (40b7a4 <inv_icm20648_poll_sensor+0x420>)
  40b528:	4798      	blx	r3

					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE) && !skip_sensor(s, ANDROID_SENSOR_RAW_GYROSCOPE)) {
  40b52a:	f107 030c 	add.w	r3, r7, #12
  40b52e:	212b      	movs	r1, #43	; 0x2b
  40b530:	6818      	ldr	r0, [r3, #0]
  40b532:	4b9d      	ldr	r3, [pc, #628]	; (40b7a8 <inv_icm20648_poll_sensor+0x424>)
  40b534:	4798      	blx	r3
  40b536:	4603      	mov	r3, r0
  40b538:	2b00      	cmp	r3, #0
  40b53a:	d041      	beq.n	40b5c0 <inv_icm20648_poll_sensor+0x23c>
  40b53c:	f107 030c 	add.w	r3, r7, #12
  40b540:	212b      	movs	r1, #43	; 0x2b
  40b542:	6818      	ldr	r0, [r3, #0]
  40b544:	4b99      	ldr	r3, [pc, #612]	; (40b7ac <inv_icm20648_poll_sensor+0x428>)
  40b546:	4798      	blx	r3
  40b548:	4603      	mov	r3, r0
  40b54a:	2b00      	cmp	r3, #0
  40b54c:	d138      	bne.n	40b5c0 <inv_icm20648_poll_sensor+0x23c>
						long out[3];
						inv_icm20648_convert_quat_rotate_fxp(s->s_quat_chip_to_body, lRawGyroQ15, out);
  40b54e:	f107 030c 	add.w	r3, r7, #12
  40b552:	681b      	ldr	r3, [r3, #0]
  40b554:	33a8      	adds	r3, #168	; 0xa8
  40b556:	f507 7284 	add.w	r2, r7, #264	; 0x108
  40b55a:	f507 7190 	add.w	r1, r7, #288	; 0x120
  40b55e:	4618      	mov	r0, r3
  40b560:	4b93      	ldr	r3, [pc, #588]	; (40b7b0 <inv_icm20648_poll_sensor+0x42c>)
  40b562:	4798      	blx	r3
						s->timestamp[INV_ICM20648_SENSOR_RAW_GYROSCOPE] += s->sensorlist[INV_ICM20648_SENSOR_RAW_GYROSCOPE].odr_applied_us;
  40b564:	f107 030c 	add.w	r3, r7, #12
  40b568:	681b      	ldr	r3, [r3, #0]
  40b56a:	f503 7338 	add.w	r3, r3, #736	; 0x2e0
  40b56e:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b572:	f107 030c 	add.w	r3, r7, #12
  40b576:	681b      	ldr	r3, [r3, #0]
  40b578:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
  40b57c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b580:	185b      	adds	r3, r3, r1
  40b582:	eb44 0402 	adc.w	r4, r4, r2
  40b586:	f107 020c 	add.w	r2, r7, #12
  40b58a:	6812      	ldr	r2, [r2, #0]
  40b58c:	f502 7238 	add.w	r2, r2, #736	; 0x2e0
  40b590:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_RAW_GYROSCOPE, s->timestamp[INV_ICM20648_SENSOR_RAW_GYROSCOPE], out, &dummy_accuracy);
  40b594:	f107 030c 	add.w	r3, r7, #12
  40b598:	681b      	ldr	r3, [r3, #0]
  40b59a:	f503 7338 	add.w	r3, r3, #736	; 0x2e0
  40b59e:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b5a2:	f107 0008 	add.w	r0, r7, #8
  40b5a6:	1d3a      	adds	r2, r7, #4
  40b5a8:	f507 71d6 	add.w	r1, r7, #428	; 0x1ac
  40b5ac:	9101      	str	r1, [sp, #4]
  40b5ae:	f507 7184 	add.w	r1, r7, #264	; 0x108
  40b5b2:	9100      	str	r1, [sp, #0]
  40b5b4:	6815      	ldr	r5, [r2, #0]
  40b5b6:	461a      	mov	r2, r3
  40b5b8:	4623      	mov	r3, r4
  40b5ba:	2103      	movs	r1, #3
  40b5bc:	6800      	ldr	r0, [r0, #0]
  40b5be:	47a8      	blx	r5
					}

					/* Read bias gyro out of DMP FIFO and convert it from Q20 raw data format to radian per seconds in Android format */
					inv_icm20648_dmp_get_gyro_bias(short_data);
  40b5c0:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
  40b5c4:	4618      	mov	r0, r3
  40b5c6:	4b7b      	ldr	r3, [pc, #492]	; (40b7b4 <inv_icm20648_poll_sensor+0x430>)
  40b5c8:	4798      	blx	r3
					lBiasGyroQ20[0] = (long) short_data[0];
  40b5ca:	f9b7 31e0 	ldrsh.w	r3, [r7, #480]	; 0x1e0
  40b5ce:	461a      	mov	r2, r3
  40b5d0:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b5d4:	601a      	str	r2, [r3, #0]
					lBiasGyroQ20[1] = (long) short_data[1];
  40b5d6:	f9b7 31e2 	ldrsh.w	r3, [r7, #482]	; 0x1e2
  40b5da:	461a      	mov	r2, r3
  40b5dc:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b5e0:	605a      	str	r2, [r3, #4]
					lBiasGyroQ20[2] = (long) short_data[2];
  40b5e2:	f9b7 31e4 	ldrsh.w	r3, [r7, #484]	; 0x1e4
  40b5e6:	461a      	mov	r2, r3
  40b5e8:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b5ec:	609a      	str	r2, [r3, #8]
					inv_icm20648_convert_dmp3_to_body(s, lBiasGyroQ20, lScaleDeg_bias/(1L<<20), gyro_bias_float);
  40b5ee:	edd7 7a82 	vldr	s15, [r7, #520]	; 0x208
  40b5f2:	ed9f 7a71 	vldr	s14, [pc, #452]	; 40b7b8 <inv_icm20648_poll_sensor+0x434>
  40b5f6:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40b5fa:	f507 72d8 	add.w	r2, r7, #432	; 0x1b0
  40b5fe:	f507 718a 	add.w	r1, r7, #276	; 0x114
  40b602:	f107 030c 	add.w	r3, r7, #12
  40b606:	eeb0 0a66 	vmov.f32	s0, s13
  40b60a:	6818      	ldr	r0, [r3, #0]
  40b60c:	4b65      	ldr	r3, [pc, #404]	; (40b7a4 <inv_icm20648_poll_sensor+0x420>)
  40b60e:	4798      	blx	r3

					/* Extract accuracy and calibrated gyro data based on raw/bias data if calibrated gyro sensor is enabled */
					gyro_accuracy = inv_icm20648_get_gyro_accuracy();
  40b610:	4b6a      	ldr	r3, [pc, #424]	; (40b7bc <inv_icm20648_poll_sensor+0x438>)
  40b612:	4798      	blx	r3
  40b614:	f8c7 0210 	str.w	r0, [r7, #528]	; 0x210
					/* If accuracy has changed previously we update the new accuracy the same time as bias*/
					if(s->set_accuracy){
  40b618:	f107 030c 	add.w	r3, r7, #12
  40b61c:	681b      	ldr	r3, [r3, #0]
  40b61e:	f9b3 34f2 	ldrsh.w	r3, [r3, #1266]	; 0x4f2
  40b622:	2b00      	cmp	r3, #0
  40b624:	d00c      	beq.n	40b640 <inv_icm20648_poll_sensor+0x2bc>
						s->set_accuracy = 0;
  40b626:	f107 030c 	add.w	r3, r7, #12
  40b62a:	681b      	ldr	r3, [r3, #0]
  40b62c:	2200      	movs	r2, #0
  40b62e:	f8a3 24f2 	strh.w	r2, [r3, #1266]	; 0x4f2
						s->new_accuracy = gyro_accuracy;
  40b632:	f107 030c 	add.w	r3, r7, #12
  40b636:	681b      	ldr	r3, [r3, #0]
  40b638:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
  40b63c:	f8c3 24f4 	str.w	r2, [r3, #1268]	; 0x4f4
					}
					/* gyro accuracy has changed, we will notify it the next time*/
					if(gyro_accuracy != s->new_accuracy){
  40b640:	f107 030c 	add.w	r3, r7, #12
  40b644:	681b      	ldr	r3, [r3, #0]
  40b646:	f8d3 24f4 	ldr.w	r2, [r3, #1268]	; 0x4f4
  40b64a:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
  40b64e:	429a      	cmp	r2, r3
  40b650:	d005      	beq.n	40b65e <inv_icm20648_poll_sensor+0x2da>
						s->set_accuracy = 1;
  40b652:	f107 030c 	add.w	r3, r7, #12
  40b656:	681b      	ldr	r3, [r3, #0]
  40b658:	2201      	movs	r2, #1
  40b65a:	f8a3 24f2 	strh.w	r2, [r3, #1266]	; 0x4f2
					}
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE) && !skip_sensor(s, ANDROID_SENSOR_GYROSCOPE)) {
  40b65e:	f107 030c 	add.w	r3, r7, #12
  40b662:	2104      	movs	r1, #4
  40b664:	6818      	ldr	r0, [r3, #0]
  40b666:	4b50      	ldr	r3, [pc, #320]	; (40b7a8 <inv_icm20648_poll_sensor+0x424>)
  40b668:	4798      	blx	r3
  40b66a:	4603      	mov	r3, r0
  40b66c:	2b00      	cmp	r3, #0
  40b66e:	d07a      	beq.n	40b766 <inv_icm20648_poll_sensor+0x3e2>
  40b670:	f107 030c 	add.w	r3, r7, #12
  40b674:	2104      	movs	r1, #4
  40b676:	6818      	ldr	r0, [r3, #0]
  40b678:	4b4c      	ldr	r3, [pc, #304]	; (40b7ac <inv_icm20648_poll_sensor+0x428>)
  40b67a:	4798      	blx	r3
  40b67c:	4603      	mov	r3, r0
  40b67e:	2b00      	cmp	r3, #0
  40b680:	d171      	bne.n	40b766 <inv_icm20648_poll_sensor+0x3e2>
						// shift to Q20 to do all calibrated gyrometer operations in Q20
						// Gyro bias from FIFO is always in 2^20 = 2000 dps regardless of fullscale
						// Raw gyro from FIFO is in 2^15 = gyro fsr (250/500/1000/2000).
						lRawGyroQ15[0] <<= 5 - (MPU_FS_2000dps - inv_icm20648_get_gyro_fullscale(s));
  40b682:	f107 030c 	add.w	r3, r7, #12
  40b686:	6818      	ldr	r0, [r3, #0]
  40b688:	4b41      	ldr	r3, [pc, #260]	; (40b790 <inv_icm20648_poll_sensor+0x40c>)
  40b68a:	4798      	blx	r3
  40b68c:	4603      	mov	r3, r0
  40b68e:	3302      	adds	r3, #2
  40b690:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
  40b694:	fa02 f303 	lsl.w	r3, r2, r3
  40b698:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
						lRawGyroQ15[1] <<= 5 - (MPU_FS_2000dps - inv_icm20648_get_gyro_fullscale(s));
  40b69c:	f107 030c 	add.w	r3, r7, #12
  40b6a0:	6818      	ldr	r0, [r3, #0]
  40b6a2:	4b3b      	ldr	r3, [pc, #236]	; (40b790 <inv_icm20648_poll_sensor+0x40c>)
  40b6a4:	4798      	blx	r3
  40b6a6:	4603      	mov	r3, r0
  40b6a8:	3302      	adds	r3, #2
  40b6aa:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
  40b6ae:	fa02 f303 	lsl.w	r3, r2, r3
  40b6b2:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
						lRawGyroQ15[2] <<= 5 - (MPU_FS_2000dps - inv_icm20648_get_gyro_fullscale(s));
  40b6b6:	f107 030c 	add.w	r3, r7, #12
  40b6ba:	6818      	ldr	r0, [r3, #0]
  40b6bc:	4b34      	ldr	r3, [pc, #208]	; (40b790 <inv_icm20648_poll_sensor+0x40c>)
  40b6be:	4798      	blx	r3
  40b6c0:	4603      	mov	r3, r0
  40b6c2:	3302      	adds	r3, #2
  40b6c4:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
  40b6c8:	fa02 f303 	lsl.w	r3, r2, r3
  40b6cc:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
						/* Compute calibrated gyro data based on raw and bias gyro data and convert it from Q20 raw data format to radian per seconds in Android format */
						inv_icm20648_dmp_get_calibrated_gyro(long_data, lRawGyroQ15, lBiasGyroQ20);
  40b6d0:	f507 728a 	add.w	r2, r7, #276	; 0x114
  40b6d4:	f507 7190 	add.w	r1, r7, #288	; 0x120
  40b6d8:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b6dc:	4618      	mov	r0, r3
  40b6de:	4b38      	ldr	r3, [pc, #224]	; (40b7c0 <inv_icm20648_poll_sensor+0x43c>)
  40b6e0:	4798      	blx	r3
						inv_icm20648_convert_dmp3_to_body(s, long_data, lScaleDeg_bias/(1L<<20), gyro_float);
  40b6e2:	edd7 7a82 	vldr	s15, [r7, #520]	; 0x208
  40b6e6:	ed9f 7a34 	vldr	s14, [pc, #208]	; 40b7b8 <inv_icm20648_poll_sensor+0x434>
  40b6ea:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40b6ee:	f507 72ba 	add.w	r2, r7, #372	; 0x174
  40b6f2:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40b6f6:	f107 030c 	add.w	r3, r7, #12
  40b6fa:	eeb0 0a66 	vmov.f32	s0, s13
  40b6fe:	6818      	ldr	r0, [r3, #0]
  40b700:	4b28      	ldr	r3, [pc, #160]	; (40b7a4 <inv_icm20648_poll_sensor+0x420>)
  40b702:	4798      	blx	r3
						s->timestamp[INV_ICM20648_SENSOR_GYROSCOPE] += s->sensorlist[INV_ICM20648_SENSOR_GYROSCOPE].odr_applied_us;
  40b704:	f107 030c 	add.w	r3, r7, #12
  40b708:	681b      	ldr	r3, [r3, #0]
  40b70a:	f503 7334 	add.w	r3, r3, #720	; 0x2d0
  40b70e:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b712:	f107 030c 	add.w	r3, r7, #12
  40b716:	681b      	ldr	r3, [r3, #0]
  40b718:	f503 7366 	add.w	r3, r3, #920	; 0x398
  40b71c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b720:	185b      	adds	r3, r3, r1
  40b722:	eb44 0402 	adc.w	r4, r4, r2
  40b726:	f107 020c 	add.w	r2, r7, #12
  40b72a:	6812      	ldr	r2, [r2, #0]
  40b72c:	f502 7234 	add.w	r2, r2, #720	; 0x2d0
  40b730:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_GYROSCOPE, s->timestamp[INV_ICM20648_SENSOR_GYROSCOPE], gyro_float, &s->new_accuracy);
  40b734:	f107 030c 	add.w	r3, r7, #12
  40b738:	681b      	ldr	r3, [r3, #0]
  40b73a:	f503 7334 	add.w	r3, r3, #720	; 0x2d0
  40b73e:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b742:	f107 020c 	add.w	r2, r7, #12
  40b746:	6812      	ldr	r2, [r2, #0]
  40b748:	f202 41f4 	addw	r1, r2, #1268	; 0x4f4
  40b74c:	f107 0008 	add.w	r0, r7, #8
  40b750:	1d3a      	adds	r2, r7, #4
  40b752:	9101      	str	r1, [sp, #4]
  40b754:	f507 71ba 	add.w	r1, r7, #372	; 0x174
  40b758:	9100      	str	r1, [sp, #0]
  40b75a:	6815      	ldr	r5, [r2, #0]
  40b75c:	461a      	mov	r2, r3
  40b75e:	4623      	mov	r3, r4
  40b760:	2101      	movs	r1, #1
  40b762:	6800      	ldr	r0, [r0, #0]
  40b764:	47a8      	blx	r5
					}
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED)  && !skip_sensor(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED)) {
  40b766:	f107 030c 	add.w	r3, r7, #12
  40b76a:	2110      	movs	r1, #16
  40b76c:	6818      	ldr	r0, [r3, #0]
  40b76e:	4b0e      	ldr	r3, [pc, #56]	; (40b7a8 <inv_icm20648_poll_sensor+0x424>)
  40b770:	4798      	blx	r3
  40b772:	4603      	mov	r3, r0
  40b774:	2b00      	cmp	r3, #0
  40b776:	d074      	beq.n	40b862 <inv_icm20648_poll_sensor+0x4de>
  40b778:	f107 030c 	add.w	r3, r7, #12
  40b77c:	2110      	movs	r1, #16
  40b77e:	6818      	ldr	r0, [r3, #0]
  40b780:	4b0a      	ldr	r3, [pc, #40]	; (40b7ac <inv_icm20648_poll_sensor+0x428>)
  40b782:	4798      	blx	r3
  40b784:	4603      	mov	r3, r0
  40b786:	2b00      	cmp	r3, #0
  40b788:	d16b      	bne.n	40b862 <inv_icm20648_poll_sensor+0x4de>
  40b78a:	e01b      	b.n	40b7c4 <inv_icm20648_poll_sensor+0x440>
  40b78c:	004095b9 	.word	0x004095b9
  40b790:	00406549 	.word	0x00406549
  40b794:	437a0000 	.word	0x437a0000
  40b798:	44fa0000 	.word	0x44fa0000
  40b79c:	00409ae5 	.word	0x00409ae5
  40b7a0:	47000000 	.word	0x47000000
  40b7a4:	00407059 	.word	0x00407059
  40b7a8:	004109f1 	.word	0x004109f1
  40b7ac:	0040a9b1 	.word	0x0040a9b1
  40b7b0:	00406ce9 	.word	0x00406ce9
  40b7b4:	00409b2d 	.word	0x00409b2d
  40b7b8:	49800000 	.word	0x49800000
  40b7bc:	00409d6d 	.word	0x00409d6d
  40b7c0:	00409b5d 	.word	0x00409b5d
						float raw_bias_gyr[6];
						raw_bias_gyr[0] = gyro_raw_float[0];
  40b7c4:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
  40b7c8:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b7cc:	601a      	str	r2, [r3, #0]
						raw_bias_gyr[1] = gyro_raw_float[1];
  40b7ce:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
  40b7d2:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b7d6:	605a      	str	r2, [r3, #4]
						raw_bias_gyr[2] = gyro_raw_float[2];
  40b7d8:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
  40b7dc:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b7e0:	609a      	str	r2, [r3, #8]
						raw_bias_gyr[3] = gyro_bias_float[0];
  40b7e2:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
  40b7e6:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b7ea:	60da      	str	r2, [r3, #12]
						raw_bias_gyr[4] = gyro_bias_float[1];
  40b7ec:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
  40b7f0:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b7f4:	611a      	str	r2, [r3, #16]
						raw_bias_gyr[5] = gyro_bias_float[2];
  40b7f6:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
  40b7fa:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b7fe:	615a      	str	r2, [r3, #20]
						s->timestamp[INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED] += s->sensorlist[INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED].odr_applied_us;
  40b800:	f107 030c 	add.w	r3, r7, #12
  40b804:	681b      	ldr	r3, [r3, #0]
  40b806:	f503 733c 	add.w	r3, r3, #752	; 0x2f0
  40b80a:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b80e:	f107 030c 	add.w	r3, r7, #12
  40b812:	681b      	ldr	r3, [r3, #0]
  40b814:	f503 7376 	add.w	r3, r3, #984	; 0x3d8
  40b818:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b81c:	185b      	adds	r3, r3, r1
  40b81e:	eb44 0402 	adc.w	r4, r4, r2
  40b822:	f107 020c 	add.w	r2, r7, #12
  40b826:	6812      	ldr	r2, [r2, #0]
  40b828:	f502 723c 	add.w	r2, r2, #752	; 0x2f0
  40b82c:	e9c2 3400 	strd	r3, r4, [r2]
						/* send raw float and bias for uncal gyr*/
						handler(context, INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED, s->timestamp[INV_ICM20648_SENSOR_GYROSCOPE_UNCALIBRATED], raw_bias_gyr, &s->new_accuracy);
  40b830:	f107 030c 	add.w	r3, r7, #12
  40b834:	681b      	ldr	r3, [r3, #0]
  40b836:	f503 733c 	add.w	r3, r3, #752	; 0x2f0
  40b83a:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b83e:	f107 020c 	add.w	r2, r7, #12
  40b842:	6812      	ldr	r2, [r2, #0]
  40b844:	f202 41f4 	addw	r1, r2, #1268	; 0x4f4
  40b848:	f107 0008 	add.w	r0, r7, #8
  40b84c:	1d3a      	adds	r2, r7, #4
  40b84e:	9101      	str	r1, [sp, #4]
  40b850:	f107 01f0 	add.w	r1, r7, #240	; 0xf0
  40b854:	9100      	str	r1, [sp, #0]
  40b856:	6815      	ldr	r5, [r2, #0]
  40b858:	461a      	mov	r2, r3
  40b85a:	4623      	mov	r3, r4
  40b85c:	2105      	movs	r1, #5
  40b85e:	6800      	ldr	r0, [r0, #0]
  40b860:	47a8      	blx	r5
					}
				}
				/* Calibrated accel sample available from DMP FIFO */
				if (header & ACCEL_SET) {
  40b862:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40b866:	b21b      	sxth	r3, r3
  40b868:	2b00      	cmp	r3, #0
  40b86a:	f280 80dc 	bge.w	40ba26 <inv_icm20648_poll_sensor+0x6a2>
					float scale;
					/* Read calibrated accel out of DMP FIFO and convert it from Q25 raw data format to m/s in Android format */
					inv_icm20648_dmp_get_accel(long_data);
  40b86e:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b872:	4618      	mov	r0, r3
  40b874:	4bbe      	ldr	r3, [pc, #760]	; (40bb70 <inv_icm20648_poll_sensor+0x7ec>)
  40b876:	4798      	blx	r3

					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER) && !skip_sensor(s, ANDROID_SENSOR_RAW_ACCELEROMETER)) {
  40b878:	f107 030c 	add.w	r3, r7, #12
  40b87c:	212a      	movs	r1, #42	; 0x2a
  40b87e:	6818      	ldr	r0, [r3, #0]
  40b880:	4bbc      	ldr	r3, [pc, #752]	; (40bb74 <inv_icm20648_poll_sensor+0x7f0>)
  40b882:	4798      	blx	r3
  40b884:	4603      	mov	r3, r0
  40b886:	2b00      	cmp	r3, #0
  40b888:	d056      	beq.n	40b938 <inv_icm20648_poll_sensor+0x5b4>
  40b88a:	f107 030c 	add.w	r3, r7, #12
  40b88e:	212a      	movs	r1, #42	; 0x2a
  40b890:	6818      	ldr	r0, [r3, #0]
  40b892:	4bb9      	ldr	r3, [pc, #740]	; (40bb78 <inv_icm20648_poll_sensor+0x7f4>)
  40b894:	4798      	blx	r3
  40b896:	4603      	mov	r3, r0
  40b898:	2b00      	cmp	r3, #0
  40b89a:	d14d      	bne.n	40b938 <inv_icm20648_poll_sensor+0x5b4>
						long out[3];
						inv_icm20648_convert_quat_rotate_fxp(s->s_quat_chip_to_body, long_data, out);
  40b89c:	f107 030c 	add.w	r3, r7, #12
  40b8a0:	681b      	ldr	r3, [r3, #0]
  40b8a2:	33a8      	adds	r3, #168	; 0xa8
  40b8a4:	f107 02e4 	add.w	r2, r7, #228	; 0xe4
  40b8a8:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40b8ac:	4618      	mov	r0, r3
  40b8ae:	4bb3      	ldr	r3, [pc, #716]	; (40bb7c <inv_icm20648_poll_sensor+0x7f8>)
  40b8b0:	4798      	blx	r3
						/* convert to raw data format to Q12/Q11/Q10/Q9 depending on full scale applied,
						so that it fits on 16bits so that it can go through any protocol, even the one which have raw data on 16b */
						out[0] = out[0] >> 15;
  40b8b2:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b8b6:	681b      	ldr	r3, [r3, #0]
  40b8b8:	13da      	asrs	r2, r3, #15
  40b8ba:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b8be:	601a      	str	r2, [r3, #0]
						out[1] = out[1] >> 15;
  40b8c0:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b8c4:	685b      	ldr	r3, [r3, #4]
  40b8c6:	13da      	asrs	r2, r3, #15
  40b8c8:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b8cc:	605a      	str	r2, [r3, #4]
						out[2] = out[2] >> 15;
  40b8ce:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b8d2:	689b      	ldr	r3, [r3, #8]
  40b8d4:	13da      	asrs	r2, r3, #15
  40b8d6:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b8da:	609a      	str	r2, [r3, #8]
						s->timestamp[INV_ICM20648_SENSOR_RAW_ACCELEROMETER] += s->sensorlist[INV_ICM20648_SENSOR_RAW_ACCELEROMETER].odr_applied_us;
  40b8dc:	f107 030c 	add.w	r3, r7, #12
  40b8e0:	681b      	ldr	r3, [r3, #0]
  40b8e2:	f503 7336 	add.w	r3, r3, #728	; 0x2d8
  40b8e6:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b8ea:	f107 030c 	add.w	r3, r7, #12
  40b8ee:	681b      	ldr	r3, [r3, #0]
  40b8f0:	f503 736a 	add.w	r3, r3, #936	; 0x3a8
  40b8f4:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b8f8:	185b      	adds	r3, r3, r1
  40b8fa:	eb44 0402 	adc.w	r4, r4, r2
  40b8fe:	f107 020c 	add.w	r2, r7, #12
  40b902:	6812      	ldr	r2, [r2, #0]
  40b904:	f502 7236 	add.w	r2, r2, #728	; 0x2d8
  40b908:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_RAW_ACCELEROMETER, s->timestamp[INV_ICM20648_SENSOR_RAW_ACCELEROMETER], out, &dummy_accuracy);
  40b90c:	f107 030c 	add.w	r3, r7, #12
  40b910:	681b      	ldr	r3, [r3, #0]
  40b912:	f503 7336 	add.w	r3, r3, #728	; 0x2d8
  40b916:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b91a:	f107 0008 	add.w	r0, r7, #8
  40b91e:	1d3a      	adds	r2, r7, #4
  40b920:	f507 71d6 	add.w	r1, r7, #428	; 0x1ac
  40b924:	9101      	str	r1, [sp, #4]
  40b926:	f107 01e4 	add.w	r1, r7, #228	; 0xe4
  40b92a:	9100      	str	r1, [sp, #0]
  40b92c:	6815      	ldr	r5, [r2, #0]
  40b92e:	461a      	mov	r2, r3
  40b930:	4623      	mov	r3, r4
  40b932:	2102      	movs	r1, #2
  40b934:	6800      	ldr	r0, [r0, #0]
  40b936:	47a8      	blx	r5
					}
					if((inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER) && !skip_sensor(s, ANDROID_SENSOR_ACCELEROMETER)) ||
  40b938:	f107 030c 	add.w	r3, r7, #12
  40b93c:	2101      	movs	r1, #1
  40b93e:	6818      	ldr	r0, [r3, #0]
  40b940:	4b8c      	ldr	r3, [pc, #560]	; (40bb74 <inv_icm20648_poll_sensor+0x7f0>)
  40b942:	4798      	blx	r3
  40b944:	4603      	mov	r3, r0
  40b946:	2b00      	cmp	r3, #0
  40b948:	d008      	beq.n	40b95c <inv_icm20648_poll_sensor+0x5d8>
  40b94a:	f107 030c 	add.w	r3, r7, #12
  40b94e:	2101      	movs	r1, #1
  40b950:	6818      	ldr	r0, [r3, #0]
  40b952:	4b89      	ldr	r3, [pc, #548]	; (40bb78 <inv_icm20648_poll_sensor+0x7f4>)
  40b954:	4798      	blx	r3
  40b956:	4603      	mov	r3, r0
  40b958:	2b00      	cmp	r3, #0
  40b95a:	d008      	beq.n	40b96e <inv_icm20648_poll_sensor+0x5ea>
					   (inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_LINEAR_ACCELERATION))) {
  40b95c:	f107 030c 	add.w	r3, r7, #12
  40b960:	210a      	movs	r1, #10
  40b962:	6818      	ldr	r0, [r3, #0]
  40b964:	4b83      	ldr	r3, [pc, #524]	; (40bb74 <inv_icm20648_poll_sensor+0x7f0>)
  40b966:	4798      	blx	r3
  40b968:	4603      	mov	r3, r0
					if((inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER) && !skip_sensor(s, ANDROID_SENSOR_ACCELEROMETER)) ||
  40b96a:	2b00      	cmp	r3, #0
  40b96c:	d05b      	beq.n	40ba26 <inv_icm20648_poll_sensor+0x6a2>
						accel_accuracy = inv_icm20648_get_accel_accuracy();
  40b96e:	4b84      	ldr	r3, [pc, #528]	; (40bb80 <inv_icm20648_poll_sensor+0x7fc>)
  40b970:	4798      	blx	r3
  40b972:	4603      	mov	r3, r0
  40b974:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
						scale = (1 << inv_icm20648_get_accel_fullscale(s)) * 2.f / (1L<<30); // Convert from raw units to g's
  40b978:	f107 030c 	add.w	r3, r7, #12
  40b97c:	6818      	ldr	r0, [r3, #0]
  40b97e:	4b81      	ldr	r3, [pc, #516]	; (40bb84 <inv_icm20648_poll_sensor+0x800>)
  40b980:	4798      	blx	r3
  40b982:	4603      	mov	r3, r0
  40b984:	461a      	mov	r2, r3
  40b986:	2301      	movs	r3, #1
  40b988:	4093      	lsls	r3, r2
  40b98a:	ee07 3a90 	vmov	s15, r3
  40b98e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b992:	ee37 7aa7 	vadd.f32	s14, s15, s15
  40b996:	eddf 6a7c 	vldr	s13, [pc, #496]	; 40bb88 <inv_icm20648_poll_sensor+0x804>
  40b99a:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40b99e:	edc7 7a81 	vstr	s15, [r7, #516]	; 0x204

						inv_icm20648_convert_dmp3_to_body(s, long_data, scale, accel_float);
  40b9a2:	f507 72c8 	add.w	r2, r7, #400	; 0x190
  40b9a6:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40b9aa:	f107 030c 	add.w	r3, r7, #12
  40b9ae:	ed97 0a81 	vldr	s0, [r7, #516]	; 0x204
  40b9b2:	6818      	ldr	r0, [r3, #0]
  40b9b4:	4b75      	ldr	r3, [pc, #468]	; (40bb8c <inv_icm20648_poll_sensor+0x808>)
  40b9b6:	4798      	blx	r3

						if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER)) {
  40b9b8:	f107 030c 	add.w	r3, r7, #12
  40b9bc:	2101      	movs	r1, #1
  40b9be:	6818      	ldr	r0, [r3, #0]
  40b9c0:	4b6c      	ldr	r3, [pc, #432]	; (40bb74 <inv_icm20648_poll_sensor+0x7f0>)
  40b9c2:	4798      	blx	r3
  40b9c4:	4603      	mov	r3, r0
  40b9c6:	2b00      	cmp	r3, #0
  40b9c8:	d02d      	beq.n	40ba26 <inv_icm20648_poll_sensor+0x6a2>
							s->timestamp[INV_ICM20648_SENSOR_ACCELEROMETER] += s->sensorlist[INV_ICM20648_SENSOR_ACCELEROMETER].odr_applied_us;
  40b9ca:	f107 030c 	add.w	r3, r7, #12
  40b9ce:	681b      	ldr	r3, [r3, #0]
  40b9d0:	f503 7332 	add.w	r3, r3, #712	; 0x2c8
  40b9d4:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b9d8:	f107 030c 	add.w	r3, r7, #12
  40b9dc:	681b      	ldr	r3, [r3, #0]
  40b9de:	f503 7362 	add.w	r3, r3, #904	; 0x388
  40b9e2:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b9e6:	185b      	adds	r3, r3, r1
  40b9e8:	eb44 0402 	adc.w	r4, r4, r2
  40b9ec:	f107 020c 	add.w	r2, r7, #12
  40b9f0:	6812      	ldr	r2, [r2, #0]
  40b9f2:	f502 7232 	add.w	r2, r2, #712	; 0x2c8
  40b9f6:	e9c2 3400 	strd	r3, r4, [r2]
							handler(context, INV_ICM20648_SENSOR_ACCELEROMETER, s->timestamp[INV_ICM20648_SENSOR_ACCELEROMETER], accel_float, &accel_accuracy);
  40b9fa:	f107 030c 	add.w	r3, r7, #12
  40b9fe:	681b      	ldr	r3, [r3, #0]
  40ba00:	f503 7332 	add.w	r3, r3, #712	; 0x2c8
  40ba04:	e9d3 3400 	ldrd	r3, r4, [r3]
  40ba08:	f107 0008 	add.w	r0, r7, #8
  40ba0c:	1d3a      	adds	r2, r7, #4
  40ba0e:	f507 71d4 	add.w	r1, r7, #424	; 0x1a8
  40ba12:	9101      	str	r1, [sp, #4]
  40ba14:	f507 71c8 	add.w	r1, r7, #400	; 0x190
  40ba18:	9100      	str	r1, [sp, #0]
  40ba1a:	6815      	ldr	r5, [r2, #0]
  40ba1c:	461a      	mov	r2, r3
  40ba1e:	4623      	mov	r3, r4
  40ba20:	2100      	movs	r1, #0
  40ba22:	6800      	ldr	r0, [r0, #0]
  40ba24:	47a8      	blx	r5
						}
					}
				}
				/* Calibrated compass sample available from DMP FIFO */
				if (header & CPASS_CALIBR_SET) {
  40ba26:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40ba2a:	f003 0320 	and.w	r3, r3, #32
  40ba2e:	2b00      	cmp	r3, #0
  40ba30:	d058      	beq.n	40bae4 <inv_icm20648_poll_sensor+0x760>
					float scale;

					/* Read calibrated compass out of DMP FIFO and convert it from Q16 raw data format to T in Android format */
					inv_icm20648_dmp_get_calibrated_compass(long_data);
  40ba32:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40ba36:	4618      	mov	r0, r3
  40ba38:	4b55      	ldr	r3, [pc, #340]	; (40bb90 <inv_icm20648_poll_sensor+0x80c>)
  40ba3a:	4798      	blx	r3

					compass_accuracy = inv_icm20648_get_mag_accuracy();
  40ba3c:	4b55      	ldr	r3, [pc, #340]	; (40bb94 <inv_icm20648_poll_sensor+0x810>)
  40ba3e:	4798      	blx	r3
  40ba40:	4603      	mov	r3, r0
  40ba42:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
					scale = DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40ba46:	f04f 535e 	mov.w	r3, #931135488	; 0x37800000
  40ba4a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
					inv_icm20648_convert_dmp3_to_body(s, long_data, scale, compass_float);
  40ba4e:	f507 72b4 	add.w	r2, r7, #360	; 0x168
  40ba52:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40ba56:	f107 030c 	add.w	r3, r7, #12
  40ba5a:	ed97 0a80 	vldr	s0, [r7, #512]	; 0x200
  40ba5e:	6818      	ldr	r0, [r3, #0]
  40ba60:	4b4a      	ldr	r3, [pc, #296]	; (40bb8c <inv_icm20648_poll_sensor+0x808>)
  40ba62:	4798      	blx	r3
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_FIELD) && !skip_sensor(s, ANDROID_SENSOR_GEOMAGNETIC_FIELD)) {
  40ba64:	f107 030c 	add.w	r3, r7, #12
  40ba68:	2102      	movs	r1, #2
  40ba6a:	6818      	ldr	r0, [r3, #0]
  40ba6c:	4b41      	ldr	r3, [pc, #260]	; (40bb74 <inv_icm20648_poll_sensor+0x7f0>)
  40ba6e:	4798      	blx	r3
  40ba70:	4603      	mov	r3, r0
  40ba72:	2b00      	cmp	r3, #0
  40ba74:	d036      	beq.n	40bae4 <inv_icm20648_poll_sensor+0x760>
  40ba76:	f107 030c 	add.w	r3, r7, #12
  40ba7a:	2102      	movs	r1, #2
  40ba7c:	6818      	ldr	r0, [r3, #0]
  40ba7e:	4b3e      	ldr	r3, [pc, #248]	; (40bb78 <inv_icm20648_poll_sensor+0x7f4>)
  40ba80:	4798      	blx	r3
  40ba82:	4603      	mov	r3, r0
  40ba84:	2b00      	cmp	r3, #0
  40ba86:	d12d      	bne.n	40bae4 <inv_icm20648_poll_sensor+0x760>
						s->timestamp[INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD] += s->sensorlist[INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD].odr_applied_us;
  40ba88:	f107 030c 	add.w	r3, r7, #12
  40ba8c:	681b      	ldr	r3, [r3, #0]
  40ba8e:	f503 734a 	add.w	r3, r3, #808	; 0x328
  40ba92:	e9d3 1200 	ldrd	r1, r2, [r3]
  40ba96:	f107 030c 	add.w	r3, r7, #12
  40ba9a:	681b      	ldr	r3, [r3, #0]
  40ba9c:	f503 6389 	add.w	r3, r3, #1096	; 0x448
  40baa0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40baa4:	185b      	adds	r3, r3, r1
  40baa6:	eb44 0402 	adc.w	r4, r4, r2
  40baaa:	f107 020c 	add.w	r2, r7, #12
  40baae:	6812      	ldr	r2, [r2, #0]
  40bab0:	f502 724a 	add.w	r2, r2, #808	; 0x328
  40bab4:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD, s->timestamp[INV_ICM20648_SENSOR_GEOMAGNETIC_FIELD], compass_float, &compass_accuracy);
  40bab8:	f107 030c 	add.w	r3, r7, #12
  40babc:	681b      	ldr	r3, [r3, #0]
  40babe:	f503 734a 	add.w	r3, r3, #808	; 0x328
  40bac2:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bac6:	f107 0008 	add.w	r0, r7, #8
  40baca:	1d3a      	adds	r2, r7, #4
  40bacc:	f507 71d2 	add.w	r1, r7, #420	; 0x1a4
  40bad0:	9101      	str	r1, [sp, #4]
  40bad2:	f507 71b4 	add.w	r1, r7, #360	; 0x168
  40bad6:	9100      	str	r1, [sp, #0]
  40bad8:	6815      	ldr	r5, [r2, #0]
  40bada:	461a      	mov	r2, r3
  40badc:	4623      	mov	r3, r4
  40bade:	210c      	movs	r1, #12
  40bae0:	6800      	ldr	r0, [r0, #0]
  40bae2:	47a8      	blx	r5
					}
				}

				/* Raw compass sample available from DMP FIFO */
				if (header & CPASS_SET) {
  40bae4:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40bae8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40baec:	2b00      	cmp	r3, #0
  40baee:	f000 80ce 	beq.w	40bc8e <inv_icm20648_poll_sensor+0x90a>
					/* Read calibrated compass out of DMP FIFO and convert it from Q16 raw data format to T in Android format */
					inv_icm20648_dmp_get_raw_compass(long_data);
  40baf2:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40baf6:	4618      	mov	r0, r3
  40baf8:	4b27      	ldr	r3, [pc, #156]	; (40bb98 <inv_icm20648_poll_sensor+0x814>)
  40bafa:	4798      	blx	r3
					compass_raw_float[0] = long_data[0] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40bafc:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
  40bb00:	ee07 3a90 	vmov	s15, r3
  40bb04:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bb08:	ed9f 7a24 	vldr	s14, [pc, #144]	; 40bb9c <inv_icm20648_poll_sensor+0x818>
  40bb0c:	ee67 7a87 	vmul.f32	s15, s15, s14
  40bb10:	edc7 7a57 	vstr	s15, [r7, #348]	; 0x15c
					compass_raw_float[1] = long_data[1] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40bb14:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
  40bb18:	ee07 3a90 	vmov	s15, r3
  40bb1c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bb20:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 40bb9c <inv_icm20648_poll_sensor+0x818>
  40bb24:	ee67 7a87 	vmul.f32	s15, s15, s14
  40bb28:	edc7 7a58 	vstr	s15, [r7, #352]	; 0x160
					compass_raw_float[2] = long_data[2] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40bb2c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
  40bb30:	ee07 3a90 	vmov	s15, r3
  40bb34:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bb38:	ed9f 7a18 	vldr	s14, [pc, #96]	; 40bb9c <inv_icm20648_poll_sensor+0x818>
  40bb3c:	ee67 7a87 	vmul.f32	s15, s15, s14
  40bb40:	edc7 7a59 	vstr	s15, [r7, #356]	; 0x164
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED) && !skip_sensor(s, ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED)) {
  40bb44:	f107 030c 	add.w	r3, r7, #12
  40bb48:	210e      	movs	r1, #14
  40bb4a:	6818      	ldr	r0, [r3, #0]
  40bb4c:	4b09      	ldr	r3, [pc, #36]	; (40bb74 <inv_icm20648_poll_sensor+0x7f0>)
  40bb4e:	4798      	blx	r3
  40bb50:	4603      	mov	r3, r0
  40bb52:	2b00      	cmp	r3, #0
  40bb54:	f000 809b 	beq.w	40bc8e <inv_icm20648_poll_sensor+0x90a>
  40bb58:	f107 030c 	add.w	r3, r7, #12
  40bb5c:	210e      	movs	r1, #14
  40bb5e:	6818      	ldr	r0, [r3, #0]
  40bb60:	4b05      	ldr	r3, [pc, #20]	; (40bb78 <inv_icm20648_poll_sensor+0x7f4>)
  40bb62:	4798      	blx	r3
  40bb64:	4603      	mov	r3, r0
  40bb66:	2b00      	cmp	r3, #0
  40bb68:	f040 8091 	bne.w	40bc8e <inv_icm20648_poll_sensor+0x90a>
  40bb6c:	e018      	b.n	40bba0 <inv_icm20648_poll_sensor+0x81c>
  40bb6e:	bf00      	nop
  40bb70:	00409ab5 	.word	0x00409ab5
  40bb74:	004109f1 	.word	0x004109f1
  40bb78:	0040a9b1 	.word	0x0040a9b1
  40bb7c:	00406ce9 	.word	0x00406ce9
  40bb80:	00409d55 	.word	0x00409d55
  40bb84:	004066f9 	.word	0x004066f9
  40bb88:	4e800000 	.word	0x4e800000
  40bb8c:	00407059 	.word	0x00407059
  40bb90:	00409c91 	.word	0x00409c91
  40bb94:	00409d85 	.word	0x00409d85
  40bb98:	00409c61 	.word	0x00409c61
  40bb9c:	37800000 	.word	0x37800000
						float raw_bias_mag[6];
						int mag_bias[3];

						raw_bias_mag[0] = compass_raw_float[0];
  40bba0:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
  40bba4:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40bba8:	601a      	str	r2, [r3, #0]
						raw_bias_mag[1] = compass_raw_float[1];
  40bbaa:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
  40bbae:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40bbb2:	605a      	str	r2, [r3, #4]
						raw_bias_mag[2] = compass_raw_float[2];
  40bbb4:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
  40bbb8:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40bbbc:	609a      	str	r2, [r3, #8]
						inv_icm20648_ctrl_get_mag_bias(s, mag_bias);
  40bbbe:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
  40bbc2:	f107 030c 	add.w	r3, r7, #12
  40bbc6:	4611      	mov	r1, r2
  40bbc8:	6818      	ldr	r0, [r3, #0]
  40bbca:	4bbf      	ldr	r3, [pc, #764]	; (40bec8 <inv_icm20648_poll_sensor+0xb44>)
  40bbcc:	4798      	blx	r3
						//calculate bias
						raw_bias_mag[3] = mag_bias[0] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40bbce:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
  40bbd2:	681b      	ldr	r3, [r3, #0]
  40bbd4:	ee07 3a90 	vmov	s15, r3
  40bbd8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bbdc:	ed9f 7abb 	vldr	s14, [pc, #748]	; 40becc <inv_icm20648_poll_sensor+0xb48>
  40bbe0:	ee67 7a87 	vmul.f32	s15, s15, s14
  40bbe4:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40bbe8:	edc3 7a03 	vstr	s15, [r3, #12]
						raw_bias_mag[4] = mag_bias[1] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40bbec:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
  40bbf0:	685b      	ldr	r3, [r3, #4]
  40bbf2:	ee07 3a90 	vmov	s15, r3
  40bbf6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bbfa:	ed9f 7ab4 	vldr	s14, [pc, #720]	; 40becc <inv_icm20648_poll_sensor+0xb48>
  40bbfe:	ee67 7a87 	vmul.f32	s15, s15, s14
  40bc02:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40bc06:	edc3 7a04 	vstr	s15, [r3, #16]
						raw_bias_mag[5] = mag_bias[2] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40bc0a:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
  40bc0e:	689b      	ldr	r3, [r3, #8]
  40bc10:	ee07 3a90 	vmov	s15, r3
  40bc14:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bc18:	ed9f 7aac 	vldr	s14, [pc, #688]	; 40becc <inv_icm20648_poll_sensor+0xb48>
  40bc1c:	ee67 7a87 	vmul.f32	s15, s15, s14
  40bc20:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40bc24:	edc3 7a05 	vstr	s15, [r3, #20]

						compass_accuracy = inv_icm20648_get_mag_accuracy();
  40bc28:	4ba9      	ldr	r3, [pc, #676]	; (40bed0 <inv_icm20648_poll_sensor+0xb4c>)
  40bc2a:	4798      	blx	r3
  40bc2c:	4603      	mov	r3, r0
  40bc2e:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
						s->timestamp[INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED] += s->sensorlist[INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED].odr_applied_us;
  40bc32:	f107 030c 	add.w	r3, r7, #12
  40bc36:	681b      	ldr	r3, [r3, #0]
  40bc38:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
  40bc3c:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bc40:	f107 030c 	add.w	r3, r7, #12
  40bc44:	681b      	ldr	r3, [r3, #0]
  40bc46:	f503 7372 	add.w	r3, r3, #968	; 0x3c8
  40bc4a:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bc4e:	185b      	adds	r3, r3, r1
  40bc50:	eb44 0402 	adc.w	r4, r4, r2
  40bc54:	f107 020c 	add.w	r2, r7, #12
  40bc58:	6812      	ldr	r2, [r2, #0]
  40bc5a:	f502 723a 	add.w	r2, r2, #744	; 0x2e8
  40bc5e:	e9c2 3400 	strd	r3, r4, [r2]
						/* send raw float and bias for uncal mag*/
						handler(context, INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED, s->timestamp[INV_ICM20648_SENSOR_MAGNETIC_FIELD_UNCALIBRATED],
  40bc62:	f107 030c 	add.w	r3, r7, #12
  40bc66:	681b      	ldr	r3, [r3, #0]
  40bc68:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
  40bc6c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bc70:	f107 0008 	add.w	r0, r7, #8
  40bc74:	1d3a      	adds	r2, r7, #4
  40bc76:	f507 71d2 	add.w	r1, r7, #420	; 0x1a4
  40bc7a:	9101      	str	r1, [sp, #4]
  40bc7c:	f107 01cc 	add.w	r1, r7, #204	; 0xcc
  40bc80:	9100      	str	r1, [sp, #0]
  40bc82:	6815      	ldr	r5, [r2, #0]
  40bc84:	461a      	mov	r2, r3
  40bc86:	4623      	mov	r3, r4
  40bc88:	2104      	movs	r1, #4
  40bc8a:	6800      	ldr	r0, [r0, #0]
  40bc8c:	47a8      	blx	r5
								raw_bias_mag, &compass_accuracy);
					}
				}
				/* 6axis AG orientation quaternion sample available from DMP FIFO */
				if (header & QUAT6_SET) {
  40bc8e:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40bc92:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  40bc96:	2b00      	cmp	r3, #0
  40bc98:	f000 81b2 	beq.w	40c000 <inv_icm20648_poll_sensor+0xc7c>
					long gravityQ16[3];
					float ref_quat[4];
					/* Read 6 axis quaternion out of DMP FIFO in Q30 */
					inv_icm20648_dmp_get_6quaternion(long_quat);
  40bc9c:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40bca0:	4618      	mov	r0, r3
  40bca2:	4b8c      	ldr	r3, [pc, #560]	; (40bed4 <inv_icm20648_poll_sensor+0xb50>)
  40bca4:	4798      	blx	r3
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GAME_ROTATION_VECTOR) && !skip_sensor(s, ANDROID_SENSOR_GAME_ROTATION_VECTOR)) {
  40bca6:	f107 030c 	add.w	r3, r7, #12
  40bcaa:	210f      	movs	r1, #15
  40bcac:	6818      	ldr	r0, [r3, #0]
  40bcae:	4b8a      	ldr	r3, [pc, #552]	; (40bed8 <inv_icm20648_poll_sensor+0xb54>)
  40bcb0:	4798      	blx	r3
  40bcb2:	4603      	mov	r3, r0
  40bcb4:	2b00      	cmp	r3, #0
  40bcb6:	d052      	beq.n	40bd5e <inv_icm20648_poll_sensor+0x9da>
  40bcb8:	f107 030c 	add.w	r3, r7, #12
  40bcbc:	210f      	movs	r1, #15
  40bcbe:	6818      	ldr	r0, [r3, #0]
  40bcc0:	4b86      	ldr	r3, [pc, #536]	; (40bedc <inv_icm20648_poll_sensor+0xb58>)
  40bcc2:	4798      	blx	r3
  40bcc4:	4603      	mov	r3, r0
  40bcc6:	2b00      	cmp	r3, #0
  40bcc8:	d149      	bne.n	40bd5e <inv_icm20648_poll_sensor+0x9da>
						/* and convert it from Q30 DMP format to Android format only if GRV sensor is enabled */
						inv_icm20648_convert_rotation_vector(s, long_quat, grv_float);
  40bcca:	f507 72c0 	add.w	r2, r7, #384	; 0x180
  40bcce:	f507 71e4 	add.w	r1, r7, #456	; 0x1c8
  40bcd2:	f107 030c 	add.w	r3, r7, #12
  40bcd6:	6818      	ldr	r0, [r3, #0]
  40bcd8:	4b81      	ldr	r3, [pc, #516]	; (40bee0 <inv_icm20648_poll_sensor+0xb5c>)
  40bcda:	4798      	blx	r3
						ref_quat[0] = grv_float[3];
  40bcdc:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
  40bce0:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40bce4:	601a      	str	r2, [r3, #0]
						ref_quat[1] = grv_float[0];
  40bce6:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
  40bcea:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40bcee:	605a      	str	r2, [r3, #4]
						ref_quat[2] = grv_float[1];
  40bcf0:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
  40bcf4:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40bcf8:	609a      	str	r2, [r3, #8]
						ref_quat[3] = grv_float[2];
  40bcfa:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
  40bcfe:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40bd02:	60da      	str	r2, [r3, #12]
						s->timestamp[INV_ICM20648_SENSOR_GAME_ROTATION_VECTOR] += s->sensorlist[INV_ICM20648_SENSOR_GAME_ROTATION_VECTOR].odr_applied_us;
  40bd04:	f107 030c 	add.w	r3, r7, #12
  40bd08:	681b      	ldr	r3, [r3, #0]
  40bd0a:	f503 7344 	add.w	r3, r3, #784	; 0x310
  40bd0e:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bd12:	f107 030c 	add.w	r3, r7, #12
  40bd16:	681b      	ldr	r3, [r3, #0]
  40bd18:	f503 6383 	add.w	r3, r3, #1048	; 0x418
  40bd1c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bd20:	185b      	adds	r3, r3, r1
  40bd22:	eb44 0402 	adc.w	r4, r4, r2
  40bd26:	f107 020c 	add.w	r2, r7, #12
  40bd2a:	6812      	ldr	r2, [r2, #0]
  40bd2c:	f502 7244 	add.w	r2, r2, #784	; 0x310
  40bd30:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_GAME_ROTATION_VECTOR, s->timestamp[INV_ICM20648_SENSOR_GAME_ROTATION_VECTOR], ref_quat, 0);
  40bd34:	f107 030c 	add.w	r3, r7, #12
  40bd38:	681b      	ldr	r3, [r3, #0]
  40bd3a:	f503 7344 	add.w	r3, r3, #784	; 0x310
  40bd3e:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bd42:	f107 0008 	add.w	r0, r7, #8
  40bd46:	1d3a      	adds	r2, r7, #4
  40bd48:	2100      	movs	r1, #0
  40bd4a:	9101      	str	r1, [sp, #4]
  40bd4c:	f107 01a4 	add.w	r1, r7, #164	; 0xa4
  40bd50:	9100      	str	r1, [sp, #0]
  40bd52:	6815      	ldr	r5, [r2, #0]
  40bd54:	461a      	mov	r2, r3
  40bd56:	4623      	mov	r3, r4
  40bd58:	2109      	movs	r1, #9
  40bd5a:	6800      	ldr	r0, [r0, #0]
  40bd5c:	47a8      	blx	r5
					}

					/* Compute gravity sensor data in Q16 in g based on 6 axis quaternion in Q30 DMP format */
					inv_icm20648_augmented_sensors_get_gravity(s, gravityQ16, long_quat);
  40bd5e:	f507 72e4 	add.w	r2, r7, #456	; 0x1c8
  40bd62:	f107 01b4 	add.w	r1, r7, #180	; 0xb4
  40bd66:	f107 030c 	add.w	r3, r7, #12
  40bd6a:	6818      	ldr	r0, [r3, #0]
  40bd6c:	4b5d      	ldr	r3, [pc, #372]	; (40bee4 <inv_icm20648_poll_sensor+0xb60>)
  40bd6e:	4798      	blx	r3
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GRAVITY) && !skip_sensor(s, ANDROID_SENSOR_GRAVITY)) {
  40bd70:	f107 030c 	add.w	r3, r7, #12
  40bd74:	2109      	movs	r1, #9
  40bd76:	6818      	ldr	r0, [r3, #0]
  40bd78:	4b57      	ldr	r3, [pc, #348]	; (40bed8 <inv_icm20648_poll_sensor+0xb54>)
  40bd7a:	4798      	blx	r3
  40bd7c:	4603      	mov	r3, r0
  40bd7e:	2b00      	cmp	r3, #0
  40bd80:	d063      	beq.n	40be4a <inv_icm20648_poll_sensor+0xac6>
  40bd82:	f107 030c 	add.w	r3, r7, #12
  40bd86:	2109      	movs	r1, #9
  40bd88:	6818      	ldr	r0, [r3, #0]
  40bd8a:	4b54      	ldr	r3, [pc, #336]	; (40bedc <inv_icm20648_poll_sensor+0xb58>)
  40bd8c:	4798      	blx	r3
  40bd8e:	4603      	mov	r3, r0
  40bd90:	2b00      	cmp	r3, #0
  40bd92:	d15a      	bne.n	40be4a <inv_icm20648_poll_sensor+0xac6>
						float gravity_float[3];
						/* Convert gravity data from Q16 to float format in g */
						gravity_float[0] = INVN_FXP_TO_FLT(gravityQ16[0], 16);
  40bd94:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
  40bd98:	681b      	ldr	r3, [r3, #0]
  40bd9a:	ee07 3a90 	vmov	s15, r3
  40bd9e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bda2:	eddf 6a51 	vldr	s13, [pc, #324]	; 40bee8 <inv_icm20648_poll_sensor+0xb64>
  40bda6:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bdaa:	f107 0398 	add.w	r3, r7, #152	; 0x98
  40bdae:	edc3 7a00 	vstr	s15, [r3]
						gravity_float[1] = INVN_FXP_TO_FLT(gravityQ16[1], 16);
  40bdb2:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
  40bdb6:	685b      	ldr	r3, [r3, #4]
  40bdb8:	ee07 3a90 	vmov	s15, r3
  40bdbc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bdc0:	eddf 6a49 	vldr	s13, [pc, #292]	; 40bee8 <inv_icm20648_poll_sensor+0xb64>
  40bdc4:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bdc8:	f107 0398 	add.w	r3, r7, #152	; 0x98
  40bdcc:	edc3 7a01 	vstr	s15, [r3, #4]
						gravity_float[2] = INVN_FXP_TO_FLT(gravityQ16[2], 16);
  40bdd0:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
  40bdd4:	689b      	ldr	r3, [r3, #8]
  40bdd6:	ee07 3a90 	vmov	s15, r3
  40bdda:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bdde:	eddf 6a42 	vldr	s13, [pc, #264]	; 40bee8 <inv_icm20648_poll_sensor+0xb64>
  40bde2:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bde6:	f107 0398 	add.w	r3, r7, #152	; 0x98
  40bdea:	edc3 7a02 	vstr	s15, [r3, #8]
						s->timestamp[INV_ICM20648_SENSOR_GRAVITY] += s->sensorlist[INV_ICM20648_SENSOR_GRAVITY].odr_applied_us;
  40bdee:	f107 030c 	add.w	r3, r7, #12
  40bdf2:	681b      	ldr	r3, [r3, #0]
  40bdf4:	f503 7352 	add.w	r3, r3, #840	; 0x348
  40bdf8:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bdfc:	f107 030c 	add.w	r3, r7, #12
  40be00:	681b      	ldr	r3, [r3, #0]
  40be02:	f503 6391 	add.w	r3, r3, #1160	; 0x488
  40be06:	e9d3 3400 	ldrd	r3, r4, [r3]
  40be0a:	185b      	adds	r3, r3, r1
  40be0c:	eb44 0402 	adc.w	r4, r4, r2
  40be10:	f107 020c 	add.w	r2, r7, #12
  40be14:	6812      	ldr	r2, [r2, #0]
  40be16:	f502 7252 	add.w	r2, r2, #840	; 0x348
  40be1a:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_GRAVITY, s->timestamp[INV_ICM20648_SENSOR_GRAVITY], gravity_float, &accel_accuracy);
  40be1e:	f107 030c 	add.w	r3, r7, #12
  40be22:	681b      	ldr	r3, [r3, #0]
  40be24:	f503 7352 	add.w	r3, r3, #840	; 0x348
  40be28:	e9d3 3400 	ldrd	r3, r4, [r3]
  40be2c:	f107 0008 	add.w	r0, r7, #8
  40be30:	1d3a      	adds	r2, r7, #4
  40be32:	f507 71d4 	add.w	r1, r7, #424	; 0x1a8
  40be36:	9101      	str	r1, [sp, #4]
  40be38:	f107 0198 	add.w	r1, r7, #152	; 0x98
  40be3c:	9100      	str	r1, [sp, #0]
  40be3e:	6815      	ldr	r5, [r2, #0]
  40be40:	461a      	mov	r2, r3
  40be42:	4623      	mov	r3, r4
  40be44:	2110      	movs	r1, #16
  40be46:	6800      	ldr	r0, [r0, #0]
  40be48:	47a8      	blx	r5
					}

					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_LINEAR_ACCELERATION) && !skip_sensor(s, ANDROID_SENSOR_LINEAR_ACCELERATION)) {
  40be4a:	f107 030c 	add.w	r3, r7, #12
  40be4e:	210a      	movs	r1, #10
  40be50:	6818      	ldr	r0, [r3, #0]
  40be52:	4b21      	ldr	r3, [pc, #132]	; (40bed8 <inv_icm20648_poll_sensor+0xb54>)
  40be54:	4798      	blx	r3
  40be56:	4603      	mov	r3, r0
  40be58:	2b00      	cmp	r3, #0
  40be5a:	f000 80d1 	beq.w	40c000 <inv_icm20648_poll_sensor+0xc7c>
  40be5e:	f107 030c 	add.w	r3, r7, #12
  40be62:	210a      	movs	r1, #10
  40be64:	6818      	ldr	r0, [r3, #0]
  40be66:	4b1d      	ldr	r3, [pc, #116]	; (40bedc <inv_icm20648_poll_sensor+0xb58>)
  40be68:	4798      	blx	r3
  40be6a:	4603      	mov	r3, r0
  40be6c:	2b00      	cmp	r3, #0
  40be6e:	f040 80c7 	bne.w	40c000 <inv_icm20648_poll_sensor+0xc7c>
						float linacc_float[3];
						long linAccQ16[3];
						long accelQ16[3];

						/* Compute linear acceleration data based on accelerometer data in Q16 g and on gravity data in Q16 g */
						accelQ16[0] = (int32_t)  ((float)(accel_float[0])*(1ULL << 16) + ( (accel_float[0]>=0)-0.5f ));
  40be72:	edd7 7a64 	vldr	s15, [r7, #400]	; 0x190
  40be76:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 40bee8 <inv_icm20648_poll_sensor+0xb64>
  40be7a:	ee27 7a87 	vmul.f32	s14, s15, s14
  40be7e:	edd7 7a64 	vldr	s15, [r7, #400]	; 0x190
  40be82:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40be86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40be8a:	db02      	blt.n	40be92 <inv_icm20648_poll_sensor+0xb0e>
  40be8c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40be90:	e001      	b.n	40be96 <inv_icm20648_poll_sensor+0xb12>
  40be92:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40be96:	ee77 7a27 	vadd.f32	s15, s14, s15
  40be9a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40be9e:	ee17 2a90 	vmov	r2, s15
  40bea2:	f107 0374 	add.w	r3, r7, #116	; 0x74
  40bea6:	601a      	str	r2, [r3, #0]
						accelQ16[1] = (int32_t)  ((float)(accel_float[1])*(1ULL << 16) + ( (accel_float[1]>=0)-0.5f ));
  40bea8:	edd7 7a65 	vldr	s15, [r7, #404]	; 0x194
  40beac:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 40bee8 <inv_icm20648_poll_sensor+0xb64>
  40beb0:	ee27 7a87 	vmul.f32	s14, s15, s14
  40beb4:	edd7 7a65 	vldr	s15, [r7, #404]	; 0x194
  40beb8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40bebc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40bec0:	db14      	blt.n	40beec <inv_icm20648_poll_sensor+0xb68>
  40bec2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40bec6:	e013      	b.n	40bef0 <inv_icm20648_poll_sensor+0xb6c>
  40bec8:	00412691 	.word	0x00412691
  40becc:	37800000 	.word	0x37800000
  40bed0:	00409d85 	.word	0x00409d85
  40bed4:	00409bd1 	.word	0x00409bd1
  40bed8:	004109f1 	.word	0x004109f1
  40bedc:	0040a9b1 	.word	0x0040a9b1
  40bee0:	00406d81 	.word	0x00406d81
  40bee4:	00410111 	.word	0x00410111
  40bee8:	47800000 	.word	0x47800000
  40beec:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40bef0:	ee77 7a27 	vadd.f32	s15, s14, s15
  40bef4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40bef8:	ee17 2a90 	vmov	r2, s15
  40befc:	f107 0374 	add.w	r3, r7, #116	; 0x74
  40bf00:	605a      	str	r2, [r3, #4]
						accelQ16[2] = (int32_t)  ((float)(accel_float[2])*(1ULL << 16) + ( (accel_float[2]>=0)-0.5f ));
  40bf02:	edd7 7a66 	vldr	s15, [r7, #408]	; 0x198
  40bf06:	ed1f 7a08 	vldr	s14, [pc, #-32]	; 40bee8 <inv_icm20648_poll_sensor+0xb64>
  40bf0a:	ee27 7a87 	vmul.f32	s14, s15, s14
  40bf0e:	edd7 7a66 	vldr	s15, [r7, #408]	; 0x198
  40bf12:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40bf16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40bf1a:	db02      	blt.n	40bf22 <inv_icm20648_poll_sensor+0xb9e>
  40bf1c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40bf20:	e001      	b.n	40bf26 <inv_icm20648_poll_sensor+0xba2>
  40bf22:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40bf26:	ee77 7a27 	vadd.f32	s15, s14, s15
  40bf2a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40bf2e:	ee17 2a90 	vmov	r2, s15
  40bf32:	f107 0374 	add.w	r3, r7, #116	; 0x74
  40bf36:	609a      	str	r2, [r3, #8]

						inv_icm20648_augmented_sensors_get_linearacceleration(linAccQ16, gravityQ16, accelQ16);
  40bf38:	f107 0274 	add.w	r2, r7, #116	; 0x74
  40bf3c:	f107 01b4 	add.w	r1, r7, #180	; 0xb4
  40bf40:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bf44:	4618      	mov	r0, r3
  40bf46:	4bc8      	ldr	r3, [pc, #800]	; (40c268 <inv_icm20648_poll_sensor+0xee4>)
  40bf48:	4798      	blx	r3
						linacc_float[0] = INVN_FXP_TO_FLT(linAccQ16[0], 16);
  40bf4a:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bf4e:	681b      	ldr	r3, [r3, #0]
  40bf50:	ee07 3a90 	vmov	s15, r3
  40bf54:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bf58:	eddf 6ac4 	vldr	s13, [pc, #784]	; 40c26c <inv_icm20648_poll_sensor+0xee8>
  40bf5c:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bf60:	f107 038c 	add.w	r3, r7, #140	; 0x8c
  40bf64:	edc3 7a00 	vstr	s15, [r3]
						linacc_float[1] = INVN_FXP_TO_FLT(linAccQ16[1], 16);
  40bf68:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bf6c:	685b      	ldr	r3, [r3, #4]
  40bf6e:	ee07 3a90 	vmov	s15, r3
  40bf72:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bf76:	eddf 6abd 	vldr	s13, [pc, #756]	; 40c26c <inv_icm20648_poll_sensor+0xee8>
  40bf7a:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bf7e:	f107 038c 	add.w	r3, r7, #140	; 0x8c
  40bf82:	edc3 7a01 	vstr	s15, [r3, #4]
						linacc_float[2] = INVN_FXP_TO_FLT(linAccQ16[2], 16);
  40bf86:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bf8a:	689b      	ldr	r3, [r3, #8]
  40bf8c:	ee07 3a90 	vmov	s15, r3
  40bf90:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bf94:	eddf 6ab5 	vldr	s13, [pc, #724]	; 40c26c <inv_icm20648_poll_sensor+0xee8>
  40bf98:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bf9c:	f107 038c 	add.w	r3, r7, #140	; 0x8c
  40bfa0:	edc3 7a02 	vstr	s15, [r3, #8]
						s->timestamp[INV_ICM20648_SENSOR_LINEAR_ACCELERATION] += s->sensorlist[INV_ICM20648_SENSOR_LINEAR_ACCELERATION].odr_applied_us;
  40bfa4:	f107 030c 	add.w	r3, r7, #12
  40bfa8:	681b      	ldr	r3, [r3, #0]
  40bfaa:	f503 7354 	add.w	r3, r3, #848	; 0x350
  40bfae:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bfb2:	f107 030c 	add.w	r3, r7, #12
  40bfb6:	681b      	ldr	r3, [r3, #0]
  40bfb8:	f503 6393 	add.w	r3, r3, #1176	; 0x498
  40bfbc:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bfc0:	185b      	adds	r3, r3, r1
  40bfc2:	eb44 0402 	adc.w	r4, r4, r2
  40bfc6:	f107 020c 	add.w	r2, r7, #12
  40bfca:	6812      	ldr	r2, [r2, #0]
  40bfcc:	f502 7254 	add.w	r2, r2, #848	; 0x350
  40bfd0:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_LINEAR_ACCELERATION, s->timestamp[INV_ICM20648_SENSOR_LINEAR_ACCELERATION], linacc_float, &accel_accuracy);
  40bfd4:	f107 030c 	add.w	r3, r7, #12
  40bfd8:	681b      	ldr	r3, [r3, #0]
  40bfda:	f503 7354 	add.w	r3, r3, #848	; 0x350
  40bfde:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bfe2:	f107 0008 	add.w	r0, r7, #8
  40bfe6:	1d3a      	adds	r2, r7, #4
  40bfe8:	f507 71d4 	add.w	r1, r7, #424	; 0x1a8
  40bfec:	9101      	str	r1, [sp, #4]
  40bfee:	f107 018c 	add.w	r1, r7, #140	; 0x8c
  40bff2:	9100      	str	r1, [sp, #0]
  40bff4:	6815      	ldr	r5, [r2, #0]
  40bff6:	461a      	mov	r2, r3
  40bff8:	4623      	mov	r3, r4
  40bffa:	2111      	movs	r1, #17
  40bffc:	6800      	ldr	r0, [r0, #0]
  40bffe:	47a8      	blx	r5
					}
				}
				/* 9axis orientation quaternion sample available from DMP FIFO */
				if (header & QUAT9_SET) {
  40c000:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40c004:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  40c008:	2b00      	cmp	r3, #0
  40c00a:	f000 80e6 	beq.w	40c1da <inv_icm20648_poll_sensor+0xe56>
					float ref_quat[4];
					/* Read 9 axis quaternion out of DMP FIFO in Q30 */
					inv_icm20648_dmp_get_9quaternion(long_quat);
  40c00e:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40c012:	4618      	mov	r0, r3
  40c014:	4b96      	ldr	r3, [pc, #600]	; (40c270 <inv_icm20648_poll_sensor+0xeec>)
  40c016:	4798      	blx	r3
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) && !skip_sensor(s, ANDROID_SENSOR_ROTATION_VECTOR)) {
  40c018:	f107 030c 	add.w	r3, r7, #12
  40c01c:	210b      	movs	r1, #11
  40c01e:	6818      	ldr	r0, [r3, #0]
  40c020:	4b94      	ldr	r3, [pc, #592]	; (40c274 <inv_icm20648_poll_sensor+0xef0>)
  40c022:	4798      	blx	r3
  40c024:	4603      	mov	r3, r0
  40c026:	2b00      	cmp	r3, #0
  40c028:	d063      	beq.n	40c0f2 <inv_icm20648_poll_sensor+0xd6e>
  40c02a:	f107 030c 	add.w	r3, r7, #12
  40c02e:	210b      	movs	r1, #11
  40c030:	6818      	ldr	r0, [r3, #0]
  40c032:	4b91      	ldr	r3, [pc, #580]	; (40c278 <inv_icm20648_poll_sensor+0xef4>)
  40c034:	4798      	blx	r3
  40c036:	4603      	mov	r3, r0
  40c038:	2b00      	cmp	r3, #0
  40c03a:	d15a      	bne.n	40c0f2 <inv_icm20648_poll_sensor+0xd6e>
						/* and convert it from Q30 DMP format to Android format only if RV sensor is enabled */
						inv_icm20648_convert_rotation_vector(s, long_quat, rv_float);
  40c03c:	f507 72a6 	add.w	r2, r7, #332	; 0x14c
  40c040:	f507 71e4 	add.w	r1, r7, #456	; 0x1c8
  40c044:	f107 030c 	add.w	r3, r7, #12
  40c048:	6818      	ldr	r0, [r3, #0]
  40c04a:	4b8c      	ldr	r3, [pc, #560]	; (40c27c <inv_icm20648_poll_sensor+0xef8>)
  40c04c:	4798      	blx	r3
						/* Read rotation vector heading accuracy out of DMP FIFO in Q29*/
						{
							float rv_accur = inv_icm20648_get_rv_accuracy();
  40c04e:	4b8c      	ldr	r3, [pc, #560]	; (40c280 <inv_icm20648_poll_sensor+0xefc>)
  40c050:	4798      	blx	r3
  40c052:	ee07 0a90 	vmov	s15, r0
  40c056:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40c05a:	edc7 7a7f 	vstr	s15, [r7, #508]	; 0x1fc
							rv_accuracy = rv_accur/(float)(1ULL << (29));
  40c05e:	ed97 7a7f 	vldr	s14, [r7, #508]	; 0x1fc
  40c062:	eddf 6a88 	vldr	s13, [pc, #544]	; 40c284 <inv_icm20648_poll_sensor+0xf00>
  40c066:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40c06a:	edc7 7a68 	vstr	s15, [r7, #416]	; 0x1a0
						}
						ref_quat[0] = rv_float[3];
  40c06e:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
  40c072:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40c076:	601a      	str	r2, [r3, #0]
						ref_quat[1] = rv_float[0];
  40c078:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
  40c07c:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40c080:	605a      	str	r2, [r3, #4]
						ref_quat[2] = rv_float[1];
  40c082:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
  40c086:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40c08a:	609a      	str	r2, [r3, #8]
						ref_quat[3] = rv_float[2];
  40c08c:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
  40c090:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40c094:	60da      	str	r2, [r3, #12]
						s->timestamp[INV_ICM20648_SENSOR_ROTATION_VECTOR] += s->sensorlist[INV_ICM20648_SENSOR_ROTATION_VECTOR].odr_applied_us;
  40c096:	f107 030c 	add.w	r3, r7, #12
  40c09a:	681b      	ldr	r3, [r3, #0]
  40c09c:	f503 7346 	add.w	r3, r3, #792	; 0x318
  40c0a0:	e9d3 1200 	ldrd	r1, r2, [r3]
  40c0a4:	f107 030c 	add.w	r3, r7, #12
  40c0a8:	681b      	ldr	r3, [r3, #0]
  40c0aa:	f503 6385 	add.w	r3, r3, #1064	; 0x428
  40c0ae:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c0b2:	185b      	adds	r3, r3, r1
  40c0b4:	eb44 0402 	adc.w	r4, r4, r2
  40c0b8:	f107 020c 	add.w	r2, r7, #12
  40c0bc:	6812      	ldr	r2, [r2, #0]
  40c0be:	f502 7246 	add.w	r2, r2, #792	; 0x318
  40c0c2:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_ROTATION_VECTOR, s->timestamp[INV_ICM20648_SENSOR_ROTATION_VECTOR], ref_quat, &rv_accuracy);
  40c0c6:	f107 030c 	add.w	r3, r7, #12
  40c0ca:	681b      	ldr	r3, [r3, #0]
  40c0cc:	f503 7346 	add.w	r3, r3, #792	; 0x318
  40c0d0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c0d4:	f107 0008 	add.w	r0, r7, #8
  40c0d8:	1d3a      	adds	r2, r7, #4
  40c0da:	f507 71d0 	add.w	r1, r7, #416	; 0x1a0
  40c0de:	9101      	str	r1, [sp, #4]
  40c0e0:	f107 0164 	add.w	r1, r7, #100	; 0x64
  40c0e4:	9100      	str	r1, [sp, #0]
  40c0e6:	6815      	ldr	r5, [r2, #0]
  40c0e8:	461a      	mov	r2, r3
  40c0ea:	4623      	mov	r3, r4
  40c0ec:	210a      	movs	r1, #10
  40c0ee:	6800      	ldr	r0, [r0, #0]
  40c0f0:	47a8      	blx	r5
					}

					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ORIENTATION) && !skip_sensor(s, ANDROID_SENSOR_ORIENTATION)) {
  40c0f2:	f107 030c 	add.w	r3, r7, #12
  40c0f6:	2103      	movs	r1, #3
  40c0f8:	6818      	ldr	r0, [r3, #0]
  40c0fa:	4b5e      	ldr	r3, [pc, #376]	; (40c274 <inv_icm20648_poll_sensor+0xef0>)
  40c0fc:	4798      	blx	r3
  40c0fe:	4603      	mov	r3, r0
  40c100:	2b00      	cmp	r3, #0
  40c102:	d06a      	beq.n	40c1da <inv_icm20648_poll_sensor+0xe56>
  40c104:	f107 030c 	add.w	r3, r7, #12
  40c108:	2103      	movs	r1, #3
  40c10a:	6818      	ldr	r0, [r3, #0]
  40c10c:	4b5a      	ldr	r3, [pc, #360]	; (40c278 <inv_icm20648_poll_sensor+0xef4>)
  40c10e:	4798      	blx	r3
  40c110:	4603      	mov	r3, r0
  40c112:	2b00      	cmp	r3, #0
  40c114:	d161      	bne.n	40c1da <inv_icm20648_poll_sensor+0xe56>
						long orientationQ16[3];
						float orientation_float[3];
						/* Compute Android-orientation sensor data based on rotation vector data in Q30 */
						inv_icm20648_augmented_sensors_get_orientation(orientationQ16, long_quat);
  40c116:	f507 72e4 	add.w	r2, r7, #456	; 0x1c8
  40c11a:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40c11e:	4611      	mov	r1, r2
  40c120:	4618      	mov	r0, r3
  40c122:	4b59      	ldr	r3, [pc, #356]	; (40c288 <inv_icm20648_poll_sensor+0xf04>)
  40c124:	4798      	blx	r3
						orientation_float[0] = INVN_FXP_TO_FLT(orientationQ16[0], 16);
  40c126:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40c12a:	681b      	ldr	r3, [r3, #0]
  40c12c:	ee07 3a90 	vmov	s15, r3
  40c130:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40c134:	eddf 6a4d 	vldr	s13, [pc, #308]	; 40c26c <inv_icm20648_poll_sensor+0xee8>
  40c138:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40c13c:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  40c140:	edc3 7a00 	vstr	s15, [r3]
						orientation_float[1] = INVN_FXP_TO_FLT(orientationQ16[1], 16);
  40c144:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40c148:	685b      	ldr	r3, [r3, #4]
  40c14a:	ee07 3a90 	vmov	s15, r3
  40c14e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40c152:	eddf 6a46 	vldr	s13, [pc, #280]	; 40c26c <inv_icm20648_poll_sensor+0xee8>
  40c156:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40c15a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  40c15e:	edc3 7a01 	vstr	s15, [r3, #4]
						orientation_float[2] = INVN_FXP_TO_FLT(orientationQ16[2], 16);
  40c162:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40c166:	689b      	ldr	r3, [r3, #8]
  40c168:	ee07 3a90 	vmov	s15, r3
  40c16c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40c170:	eddf 6a3e 	vldr	s13, [pc, #248]	; 40c26c <inv_icm20648_poll_sensor+0xee8>
  40c174:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40c178:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  40c17c:	edc3 7a02 	vstr	s15, [r3, #8]
						s->timestamp[INV_ICM20648_SENSOR_ORIENTATION] += s->sensorlist[INV_ICM20648_SENSOR_ORIENTATION].odr_applied_us;
  40c180:	f107 030c 	add.w	r3, r7, #12
  40c184:	681b      	ldr	r3, [r3, #0]
  40c186:	f503 7356 	add.w	r3, r3, #856	; 0x358
  40c18a:	e9d3 1200 	ldrd	r1, r2, [r3]
  40c18e:	f107 030c 	add.w	r3, r7, #12
  40c192:	681b      	ldr	r3, [r3, #0]
  40c194:	f503 6395 	add.w	r3, r3, #1192	; 0x4a8
  40c198:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c19c:	185b      	adds	r3, r3, r1
  40c19e:	eb44 0402 	adc.w	r4, r4, r2
  40c1a2:	f107 020c 	add.w	r2, r7, #12
  40c1a6:	6812      	ldr	r2, [r2, #0]
  40c1a8:	f502 7256 	add.w	r2, r2, #856	; 0x358
  40c1ac:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_ORIENTATION, s->timestamp[INV_ICM20648_SENSOR_ORIENTATION], orientation_float, 0);
  40c1b0:	f107 030c 	add.w	r3, r7, #12
  40c1b4:	681b      	ldr	r3, [r3, #0]
  40c1b6:	f503 7356 	add.w	r3, r3, #856	; 0x358
  40c1ba:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c1be:	f107 0008 	add.w	r0, r7, #8
  40c1c2:	1d3a      	adds	r2, r7, #4
  40c1c4:	2100      	movs	r1, #0
  40c1c6:	9101      	str	r1, [sp, #4]
  40c1c8:	f107 014c 	add.w	r1, r7, #76	; 0x4c
  40c1cc:	9100      	str	r1, [sp, #0]
  40c1ce:	6815      	ldr	r5, [r2, #0]
  40c1d0:	461a      	mov	r2, r3
  40c1d2:	4623      	mov	r3, r4
  40c1d4:	2112      	movs	r1, #18
  40c1d6:	6800      	ldr	r0, [r0, #0]
  40c1d8:	47a8      	blx	r5
					}
				}
				/* 6axis AM orientation quaternion sample available from DMP FIFO */
				if (header & GEOMAG_SET) {
  40c1da:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40c1de:	f403 7380 	and.w	r3, r3, #256	; 0x100
  40c1e2:	2b00      	cmp	r3, #0
  40c1e4:	f000 808a 	beq.w	40c2fc <inv_icm20648_poll_sensor+0xf78>
					float ref_quat[4];
					/* Read 6 axis quaternion out of DMP FIFO in Q30 and convert it to Android format */
					inv_icm20648_dmp_get_gmrvquaternion(long_quat);
  40c1e8:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40c1ec:	4618      	mov	r0, r3
  40c1ee:	4b27      	ldr	r3, [pc, #156]	; (40c28c <inv_icm20648_poll_sensor+0xf08>)
  40c1f0:	4798      	blx	r3
					if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) && !skip_sensor(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR)) {
  40c1f2:	f107 030c 	add.w	r3, r7, #12
  40c1f6:	2114      	movs	r1, #20
  40c1f8:	6818      	ldr	r0, [r3, #0]
  40c1fa:	4b1e      	ldr	r3, [pc, #120]	; (40c274 <inv_icm20648_poll_sensor+0xef0>)
  40c1fc:	4798      	blx	r3
  40c1fe:	4603      	mov	r3, r0
  40c200:	2b00      	cmp	r3, #0
  40c202:	d07b      	beq.n	40c2fc <inv_icm20648_poll_sensor+0xf78>
  40c204:	f107 030c 	add.w	r3, r7, #12
  40c208:	2114      	movs	r1, #20
  40c20a:	6818      	ldr	r0, [r3, #0]
  40c20c:	4b1a      	ldr	r3, [pc, #104]	; (40c278 <inv_icm20648_poll_sensor+0xef4>)
  40c20e:	4798      	blx	r3
  40c210:	4603      	mov	r3, r0
  40c212:	2b00      	cmp	r3, #0
  40c214:	d172      	bne.n	40c2fc <inv_icm20648_poll_sensor+0xf78>
						inv_icm20648_convert_rotation_vector(s, long_quat, gmrv_float);
  40c216:	f507 729e 	add.w	r2, r7, #316	; 0x13c
  40c21a:	f507 71e4 	add.w	r1, r7, #456	; 0x1c8
  40c21e:	f107 030c 	add.w	r3, r7, #12
  40c222:	6818      	ldr	r0, [r3, #0]
  40c224:	4b15      	ldr	r3, [pc, #84]	; (40c27c <inv_icm20648_poll_sensor+0xef8>)
  40c226:	4798      	blx	r3

						/* Read geomagnetic rotation vector heading accuracy out of DMP FIFO in Q29*/
						{
							float gmrv_acc = inv_icm20648_get_gmrv_accuracy();
  40c228:	4b19      	ldr	r3, [pc, #100]	; (40c290 <inv_icm20648_poll_sensor+0xf0c>)
  40c22a:	4798      	blx	r3
  40c22c:	ee07 0a90 	vmov	s15, r0
  40c230:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40c234:	edc7 7a7e 	vstr	s15, [r7, #504]	; 0x1f8
							gmrv_accuracy = gmrv_acc/(float)(1ULL << (29));
  40c238:	ed97 7a7e 	vldr	s14, [r7, #504]	; 0x1f8
  40c23c:	eddf 6a11 	vldr	s13, [pc, #68]	; 40c284 <inv_icm20648_poll_sensor+0xf00>
  40c240:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40c244:	edc7 7a67 	vstr	s15, [r7, #412]	; 0x19c
						}

						ref_quat[0] = gmrv_float[3];
  40c248:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
  40c24c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40c250:	601a      	str	r2, [r3, #0]
						ref_quat[1] = gmrv_float[0];
  40c252:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
  40c256:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40c25a:	605a      	str	r2, [r3, #4]
						ref_quat[2] = gmrv_float[1];
  40c25c:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
  40c260:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40c264:	e016      	b.n	40c294 <inv_icm20648_poll_sensor+0xf10>
  40c266:	bf00      	nop
  40c268:	004101e9 	.word	0x004101e9
  40c26c:	47800000 	.word	0x47800000
  40c270:	00409c01 	.word	0x00409c01
  40c274:	004109f1 	.word	0x004109f1
  40c278:	0040a9b1 	.word	0x0040a9b1
  40c27c:	00406d81 	.word	0x00406d81
  40c280:	00409db5 	.word	0x00409db5
  40c284:	4e000000 	.word	0x4e000000
  40c288:	0041025d 	.word	0x0041025d
  40c28c:	00409c31 	.word	0x00409c31
  40c290:	00409d9d 	.word	0x00409d9d
  40c294:	609a      	str	r2, [r3, #8]
						ref_quat[3] = gmrv_float[2];
  40c296:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
  40c29a:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40c29e:	60da      	str	r2, [r3, #12]
						s->timestamp[INV_ICM20648_SENSOR_GEOMAGNETIC_ROTATION_VECTOR] += s->sensorlist[INV_ICM20648_SENSOR_GEOMAGNETIC_ROTATION_VECTOR].odr_applied_us;
  40c2a0:	f107 030c 	add.w	r3, r7, #12
  40c2a4:	681b      	ldr	r3, [r3, #0]
  40c2a6:	f503 7348 	add.w	r3, r3, #800	; 0x320
  40c2aa:	e9d3 1200 	ldrd	r1, r2, [r3]
  40c2ae:	f107 030c 	add.w	r3, r7, #12
  40c2b2:	681b      	ldr	r3, [r3, #0]
  40c2b4:	f503 6387 	add.w	r3, r3, #1080	; 0x438
  40c2b8:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c2bc:	185b      	adds	r3, r3, r1
  40c2be:	eb44 0402 	adc.w	r4, r4, r2
  40c2c2:	f107 020c 	add.w	r2, r7, #12
  40c2c6:	6812      	ldr	r2, [r2, #0]
  40c2c8:	f502 7248 	add.w	r2, r2, #800	; 0x320
  40c2cc:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20648_SENSOR_GEOMAGNETIC_ROTATION_VECTOR, s->timestamp[INV_ICM20648_SENSOR_GEOMAGNETIC_ROTATION_VECTOR],
  40c2d0:	f107 030c 	add.w	r3, r7, #12
  40c2d4:	681b      	ldr	r3, [r3, #0]
  40c2d6:	f503 7348 	add.w	r3, r3, #800	; 0x320
  40c2da:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c2de:	f107 0008 	add.w	r0, r7, #8
  40c2e2:	1d3a      	adds	r2, r7, #4
  40c2e4:	f507 71ce 	add.w	r1, r7, #412	; 0x19c
  40c2e8:	9101      	str	r1, [sp, #4]
  40c2ea:	f107 013c 	add.w	r1, r7, #60	; 0x3c
  40c2ee:	9100      	str	r1, [sp, #0]
  40c2f0:	6815      	ldr	r5, [r2, #0]
  40c2f2:	461a      	mov	r2, r3
  40c2f4:	4623      	mov	r3, r4
  40c2f6:	210b      	movs	r1, #11
  40c2f8:	6800      	ldr	r0, [r0, #0]
  40c2fa:	47a8      	blx	r5
								ref_quat, &gmrv_accuracy);
					}
				}
				/* Activity recognition sample available from DMP FIFO */
				if (header2 & ACT_RECOG_SET) {
  40c2fc:	f8b7 31ee 	ldrh.w	r3, [r7, #494]	; 0x1ee
  40c300:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40c304:	2b00      	cmp	r3, #0
  40c306:	f000 80c1 	beq.w	40c48c <inv_icm20648_poll_sensor+0x1108>
					uint16_t bac_state = 0;
  40c30a:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40c30e:	2200      	movs	r2, #0
  40c310:	801a      	strh	r2, [r3, #0]
					long bac_ts = 0;
  40c312:	f107 0334 	add.w	r3, r7, #52	; 0x34
  40c316:	2200      	movs	r2, #0
  40c318:	601a      	str	r2, [r3, #0]
					int bac_event = 0;
  40c31a:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40c31e:	2200      	movs	r2, #0
  40c320:	601a      	str	r2, [r3, #0]
					struct bac_map{
						uint8_t act_id;
						enum inv_sensor_bac_event sensor_bac;
					} map[] = {
  40c322:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40c326:	4aa1      	ldr	r2, [pc, #644]	; (40c5ac <inv_icm20648_poll_sensor+0x1228>)
  40c328:	ca07      	ldmia	r2, {r0, r1, r2}
  40c32a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
						{ BAC_RUN, INV_SENSOR_BAC_EVENT_ACT_RUNNING_BEGIN},
						{ BAC_BIKE, INV_SENSOR_BAC_EVENT_ACT_ON_BICYCLE_BEGIN},
						{ BAC_STILL, INV_SENSOR_BAC_EVENT_ACT_STILL_BEGIN},
						{ BAC_TILT, INV_SENSOR_BAC_EVENT_ACT_TILT_BEGIN},
					};
					int i = 0;
  40c32e:	2300      	movs	r3, #0
  40c330:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
					/* Read activity type and associated timestamp out of DMP FIFO
					activity type is a set of 2 bytes :
					- high byte indicates activity start
					- low byte indicates activity end */
					inv_icm20648_dmp_get_bac_state(&bac_state);
  40c334:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40c338:	4618      	mov	r0, r3
  40c33a:	4b9d      	ldr	r3, [pc, #628]	; (40c5b0 <inv_icm20648_poll_sensor+0x122c>)
  40c33c:	4798      	blx	r3
					inv_icm20648_dmp_get_bac_ts(&bac_ts);
  40c33e:	f107 0334 	add.w	r3, r7, #52	; 0x34
  40c342:	4618      	mov	r0, r3
  40c344:	4b9b      	ldr	r3, [pc, #620]	; (40c5b4 <inv_icm20648_poll_sensor+0x1230>)
  40c346:	4798      	blx	r3
					//Map according to dmp bac events
					for(i = 0; i < 6; i++) {
  40c348:	2300      	movs	r3, #0
  40c34a:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
  40c34e:	e098      	b.n	40c482 <inv_icm20648_poll_sensor+0x10fe>
						if ((bac_state >> 8) & map[i].act_id){
  40c350:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40c354:	881b      	ldrh	r3, [r3, #0]
  40c356:	0a1b      	lsrs	r3, r3, #8
  40c358:	b29b      	uxth	r3, r3
  40c35a:	4619      	mov	r1, r3
  40c35c:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40c360:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
  40c364:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
  40c368:	400b      	ands	r3, r1
  40c36a:	2b00      	cmp	r3, #0
  40c36c:	d04e      	beq.n	40c40c <inv_icm20648_poll_sensor+0x1088>
							//Check if BAC is enabled
							if (inv_icm20648_ctrl_get_activitiy_classifier_on_flag(s)) {
  40c36e:	f107 030c 	add.w	r3, r7, #12
  40c372:	6818      	ldr	r0, [r3, #0]
  40c374:	4b90      	ldr	r3, [pc, #576]	; (40c5b8 <inv_icm20648_poll_sensor+0x1234>)
  40c376:	4798      	blx	r3
  40c378:	4603      	mov	r3, r0
  40c37a:	2b00      	cmp	r3, #0
  40c37c:	d020      	beq.n	40c3c0 <inv_icm20648_poll_sensor+0x103c>
								/* Start detected */
								bac_event = map[i].sensor_bac;
  40c37e:	f107 0224 	add.w	r2, r7, #36	; 0x24
  40c382:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c386:	005b      	lsls	r3, r3, #1
  40c388:	4413      	add	r3, r2
  40c38a:	f993 3001 	ldrsb.w	r3, [r3, #1]
  40c38e:	461a      	mov	r2, r3
  40c390:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40c394:	601a      	str	r2, [r3, #0]
								handler(context, INV_ICM20648_SENSOR_ACTIVITY_CLASSIFICATON, s->timestamp[INV_ICM20648_SENSOR_ACTIVITY_CLASSIFICATON], &bac_event, 0);
  40c396:	f107 030c 	add.w	r3, r7, #12
  40c39a:	681b      	ldr	r3, [r3, #0]
  40c39c:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
  40c3a0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c3a4:	f107 0008 	add.w	r0, r7, #8
  40c3a8:	1d3a      	adds	r2, r7, #4
  40c3aa:	2100      	movs	r1, #0
  40c3ac:	9101      	str	r1, [sp, #4]
  40c3ae:	f107 0130 	add.w	r1, r7, #48	; 0x30
  40c3b2:	9100      	str	r1, [sp, #0]
  40c3b4:	6815      	ldr	r5, [r2, #0]
  40c3b6:	461a      	mov	r2, r3
  40c3b8:	4623      	mov	r3, r4
  40c3ba:	2106      	movs	r1, #6
  40c3bc:	6800      	ldr	r0, [r0, #0]
  40c3be:	47a8      	blx	r5
							}
							//build event TILT only if enabled
							if((map[i].act_id == BAC_TILT) && inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_TILT_DETECTOR))
  40c3c0:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40c3c4:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
  40c3c8:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
  40c3cc:	2b10      	cmp	r3, #16
  40c3ce:	d153      	bne.n	40c478 <inv_icm20648_poll_sensor+0x10f4>
  40c3d0:	f107 030c 	add.w	r3, r7, #12
  40c3d4:	2129      	movs	r1, #41	; 0x29
  40c3d6:	6818      	ldr	r0, [r3, #0]
  40c3d8:	4b78      	ldr	r3, [pc, #480]	; (40c5bc <inv_icm20648_poll_sensor+0x1238>)
  40c3da:	4798      	blx	r3
  40c3dc:	4603      	mov	r3, r0
  40c3de:	2b00      	cmp	r3, #0
  40c3e0:	d04a      	beq.n	40c478 <inv_icm20648_poll_sensor+0x10f4>
								handler(context, INV_ICM20648_SENSOR_WAKEUP_TILT_DETECTOR, s->timestamp[INV_ICM20648_SENSOR_WAKEUP_TILT_DETECTOR], 0, 0);
  40c3e2:	f107 030c 	add.w	r3, r7, #12
  40c3e6:	681b      	ldr	r3, [r3, #0]
  40c3e8:	f503 7350 	add.w	r3, r3, #832	; 0x340
  40c3ec:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c3f0:	f107 0008 	add.w	r0, r7, #8
  40c3f4:	1d3a      	adds	r2, r7, #4
  40c3f6:	2100      	movs	r1, #0
  40c3f8:	9101      	str	r1, [sp, #4]
  40c3fa:	2100      	movs	r1, #0
  40c3fc:	9100      	str	r1, [sp, #0]
  40c3fe:	6815      	ldr	r5, [r2, #0]
  40c400:	461a      	mov	r2, r3
  40c402:	4623      	mov	r3, r4
  40c404:	210f      	movs	r1, #15
  40c406:	6800      	ldr	r0, [r0, #0]
  40c408:	47a8      	blx	r5
  40c40a:	e035      	b.n	40c478 <inv_icm20648_poll_sensor+0x10f4>
						}
						/* Check if bit tilt is set for activity end byte */
						else if (bac_state & map[i].act_id) {
  40c40c:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40c410:	881b      	ldrh	r3, [r3, #0]
  40c412:	4619      	mov	r1, r3
  40c414:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40c418:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
  40c41c:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
  40c420:	400b      	ands	r3, r1
  40c422:	2b00      	cmp	r3, #0
  40c424:	d028      	beq.n	40c478 <inv_icm20648_poll_sensor+0x10f4>
							//Check if BAC is enabled
							if (inv_icm20648_ctrl_get_activitiy_classifier_on_flag(s)) {
  40c426:	f107 030c 	add.w	r3, r7, #12
  40c42a:	6818      	ldr	r0, [r3, #0]
  40c42c:	4b62      	ldr	r3, [pc, #392]	; (40c5b8 <inv_icm20648_poll_sensor+0x1234>)
  40c42e:	4798      	blx	r3
  40c430:	4603      	mov	r3, r0
  40c432:	2b00      	cmp	r3, #0
  40c434:	d020      	beq.n	40c478 <inv_icm20648_poll_sensor+0x10f4>
								/* End detected */
								bac_event = -map[i].sensor_bac;
  40c436:	f107 0224 	add.w	r2, r7, #36	; 0x24
  40c43a:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c43e:	005b      	lsls	r3, r3, #1
  40c440:	4413      	add	r3, r2
  40c442:	f993 3001 	ldrsb.w	r3, [r3, #1]
  40c446:	425a      	negs	r2, r3
  40c448:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40c44c:	601a      	str	r2, [r3, #0]
								handler(context, INV_ICM20648_SENSOR_ACTIVITY_CLASSIFICATON, s->timestamp[INV_ICM20648_SENSOR_ACTIVITY_CLASSIFICATON], &bac_event, 0);
  40c44e:	f107 030c 	add.w	r3, r7, #12
  40c452:	681b      	ldr	r3, [r3, #0]
  40c454:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
  40c458:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c45c:	f107 0008 	add.w	r0, r7, #8
  40c460:	1d3a      	adds	r2, r7, #4
  40c462:	2100      	movs	r1, #0
  40c464:	9101      	str	r1, [sp, #4]
  40c466:	f107 0130 	add.w	r1, r7, #48	; 0x30
  40c46a:	9100      	str	r1, [sp, #0]
  40c46c:	6815      	ldr	r5, [r2, #0]
  40c46e:	461a      	mov	r2, r3
  40c470:	4623      	mov	r3, r4
  40c472:	2106      	movs	r1, #6
  40c474:	6800      	ldr	r0, [r0, #0]
  40c476:	47a8      	blx	r5
					for(i = 0; i < 6; i++) {
  40c478:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c47c:	3301      	adds	r3, #1
  40c47e:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
  40c482:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c486:	2b05      	cmp	r3, #5
  40c488:	f77f af62 	ble.w	40c350 <inv_icm20648_poll_sensor+0xfcc>
							}
						}
					}
				}
				/* Pickup sample available from DMP FIFO */
				if (header2 & FLIP_PICKUP_SET) {
  40c48c:	f8b7 31ee 	ldrh.w	r3, [r7, #494]	; 0x1ee
  40c490:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  40c494:	2b00      	cmp	r3, #0
  40c496:	d019      	beq.n	40c4cc <inv_icm20648_poll_sensor+0x1148>
					/* Read pickup type and associated timestamp out of DMP FIFO */
					inv_icm20648_dmp_get_flip_pickup_state(&pickup_state);
  40c498:	f507 739d 	add.w	r3, r7, #314	; 0x13a
  40c49c:	4618      	mov	r0, r3
  40c49e:	4b48      	ldr	r3, [pc, #288]	; (40c5c0 <inv_icm20648_poll_sensor+0x123c>)
  40c4a0:	4798      	blx	r3
					handler(context, INV_ICM20648_SENSOR_FLIP_PICKUP, s->timestamp[INV_ICM20648_SENSOR_FLIP_PICKUP], &pickup_state, 0);
  40c4a2:	f107 030c 	add.w	r3, r7, #12
  40c4a6:	681b      	ldr	r3, [r3, #0]
  40c4a8:	f503 734e 	add.w	r3, r3, #824	; 0x338
  40c4ac:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c4b0:	f107 0008 	add.w	r0, r7, #8
  40c4b4:	1d3a      	adds	r2, r7, #4
  40c4b6:	2100      	movs	r1, #0
  40c4b8:	9101      	str	r1, [sp, #4]
  40c4ba:	f507 719d 	add.w	r1, r7, #314	; 0x13a
  40c4be:	9100      	str	r1, [sp, #0]
  40c4c0:	6815      	ldr	r5, [r2, #0]
  40c4c2:	461a      	mov	r2, r3
  40c4c4:	4623      	mov	r3, r4
  40c4c6:	210e      	movs	r1, #14
  40c4c8:	6800      	ldr	r0, [r0, #0]
  40c4ca:	47a8      	blx	r5
				}

            	/* Step detector available from DMP FIFO and step counter sensor is enabled*/
				// If step detector enabled => step counter started too
				// So don't watch the step counter data if the user doesn't start the sensor
				if((header & PED_STEPDET_SET) && (inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_STEP_COUNTER))) {
  40c4cc:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40c4d0:	f003 0310 	and.w	r3, r3, #16
  40c4d4:	2b00      	cmp	r3, #0
  40c4d6:	d057      	beq.n	40c588 <inv_icm20648_poll_sensor+0x1204>
  40c4d8:	f107 030c 	add.w	r3, r7, #12
  40c4dc:	2113      	movs	r1, #19
  40c4de:	6818      	ldr	r0, [r3, #0]
  40c4e0:	4b36      	ldr	r3, [pc, #216]	; (40c5bc <inv_icm20648_poll_sensor+0x1238>)
  40c4e2:	4798      	blx	r3
  40c4e4:	4603      	mov	r3, r0
  40c4e6:	2b00      	cmp	r3, #0
  40c4e8:	d04e      	beq.n	40c588 <inv_icm20648_poll_sensor+0x1204>
					unsigned long steps;
					unsigned long lsteps;
					uint64_t stepc = 0;
  40c4ea:	f107 0218 	add.w	r2, r7, #24
  40c4ee:	f04f 0300 	mov.w	r3, #0
  40c4f2:	f04f 0400 	mov.w	r4, #0
  40c4f6:	e9c2 3400 	strd	r3, r4, [r2]
					/* Read amount of steps counted out of DMP FIFO and notify them only if updated */
					dmp_icm20648_get_pedometer_num_of_steps(s, &lsteps);
  40c4fa:	f107 0220 	add.w	r2, r7, #32
  40c4fe:	f107 030c 	add.w	r3, r7, #12
  40c502:	4611      	mov	r1, r2
  40c504:	6818      	ldr	r0, [r3, #0]
  40c506:	4b2f      	ldr	r3, [pc, #188]	; (40c5c4 <inv_icm20648_poll_sensor+0x1240>)
  40c508:	4798      	blx	r3
					// need to subtract the steps accumulated while Step Counter sensor is not active.
					steps = lsteps - s->sStepCounterToBeSubtracted;
  40c50a:	f107 0320 	add.w	r3, r7, #32
  40c50e:	681a      	ldr	r2, [r3, #0]
  40c510:	f107 030c 	add.w	r3, r7, #12
  40c514:	681b      	ldr	r3, [r3, #0]
  40c516:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  40c51a:	1ad3      	subs	r3, r2, r3
  40c51c:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
					stepc = steps;
  40c520:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
  40c524:	f04f 0400 	mov.w	r4, #0
  40c528:	f107 0218 	add.w	r2, r7, #24
  40c52c:	e9c2 3400 	strd	r3, r4, [r2]
					if(stepc != s->sOldSteps) {
  40c530:	f107 030c 	add.w	r3, r7, #12
  40c534:	681b      	ldr	r3, [r3, #0]
  40c536:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  40c53a:	4619      	mov	r1, r3
  40c53c:	f04f 0200 	mov.w	r2, #0
  40c540:	f107 0318 	add.w	r3, r7, #24
  40c544:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c548:	42a2      	cmp	r2, r4
  40c54a:	bf08      	it	eq
  40c54c:	4299      	cmpeq	r1, r3
  40c54e:	d01b      	beq.n	40c588 <inv_icm20648_poll_sensor+0x1204>
						s->sOldSteps = steps;
  40c550:	f107 030c 	add.w	r3, r7, #12
  40c554:	681b      	ldr	r3, [r3, #0]
  40c556:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
  40c55a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
						handler(context, INV_ICM20648_SENSOR_STEP_COUNTER, s->timestamp[INV_ICM20648_SENSOR_STEP_COUNTER], &stepc, 0);
  40c55e:	f107 030c 	add.w	r3, r7, #12
  40c562:	681b      	ldr	r3, [r3, #0]
  40c564:	f503 7342 	add.w	r3, r3, #776	; 0x308
  40c568:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c56c:	f107 0008 	add.w	r0, r7, #8
  40c570:	1d3a      	adds	r2, r7, #4
  40c572:	2100      	movs	r1, #0
  40c574:	9101      	str	r1, [sp, #4]
  40c576:	f107 0118 	add.w	r1, r7, #24
  40c57a:	9100      	str	r1, [sp, #0]
  40c57c:	6815      	ldr	r5, [r2, #0]
  40c57e:	461a      	mov	r2, r3
  40c580:	4623      	mov	r3, r4
  40c582:	2108      	movs	r1, #8
  40c584:	6800      	ldr	r0, [r0, #0]
  40c586:	47a8      	blx	r5
			while(total_sample_cnt--) {
  40c588:	f8b7 312e 	ldrh.w	r3, [r7, #302]	; 0x12e
  40c58c:	1e5a      	subs	r2, r3, #1
  40c58e:	b292      	uxth	r2, r2
  40c590:	f8a7 212e 	strh.w	r2, [r7, #302]	; 0x12e
  40c594:	2b00      	cmp	r3, #0
  40c596:	f47e af6d 	bne.w	40b474 <inv_icm20648_poll_sensor+0xf0>
  40c59a:	e000      	b.n	40c59e <inv_icm20648_poll_sensor+0x121a>
					break;
  40c59c:	bf00      	nop
					}
				}
			}
		} while(data_left_in_fifo);
  40c59e:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
  40c5a2:	2b00      	cmp	r3, #0
  40c5a4:	f47e af4c 	bne.w	40b440 <inv_icm20648_poll_sensor+0xbc>
  40c5a8:	e00f      	b.n	40c5ca <inv_icm20648_poll_sensor+0x1246>
  40c5aa:	bf00      	nop
  40c5ac:	0041c11c 	.word	0x0041c11c
  40c5b0:	00409cc1 	.word	0x00409cc1
  40c5b4:	00409cf1 	.word	0x00409cf1
  40c5b8:	004124f9 	.word	0x004124f9
  40c5bc:	004109f1 	.word	0x004109f1
  40c5c0:	00409d21 	.word	0x00409d21
  40c5c4:	00408665 	.word	0x00408665
				break;
  40c5c8:	bf00      	nop

		/* SMD detected by DMP */
		if (int_read_back & BIT_MSG_DMP_INT_2) {
  40c5ca:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40c5ce:	b29b      	uxth	r3, r3
  40c5d0:	f403 7300 	and.w	r3, r3, #512	; 0x200
  40c5d4:	2b00      	cmp	r3, #0
  40c5d6:	d018      	beq.n	40c60a <inv_icm20648_poll_sensor+0x1286>
			uint8_t event = 0;
  40c5d8:	f107 0317 	add.w	r3, r7, #23
  40c5dc:	2200      	movs	r2, #0
  40c5de:	701a      	strb	r2, [r3, #0]
			handler(context, INV_ICM20648_SENSOR_WAKEUP_SIGNIFICANT_MOTION, s->timestamp[INV_ICM20648_SENSOR_WAKEUP_SIGNIFICANT_MOTION], &event, 0);
  40c5e0:	f107 030c 	add.w	r3, r7, #12
  40c5e4:	681b      	ldr	r3, [r3, #0]
  40c5e6:	f503 734c 	add.w	r3, r3, #816	; 0x330
  40c5ea:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c5ee:	f107 0008 	add.w	r0, r7, #8
  40c5f2:	1d3a      	adds	r2, r7, #4
  40c5f4:	2100      	movs	r1, #0
  40c5f6:	9101      	str	r1, [sp, #4]
  40c5f8:	f107 0117 	add.w	r1, r7, #23
  40c5fc:	9100      	str	r1, [sp, #0]
  40c5fe:	6815      	ldr	r5, [r2, #0]
  40c600:	461a      	mov	r2, r3
  40c602:	4623      	mov	r3, r4
  40c604:	210d      	movs	r1, #13
  40c606:	6800      	ldr	r0, [r0, #0]
  40c608:	47a8      	blx	r5
		}
		/* Step detector triggered by DMP */
		if (int_read_back & BIT_MSG_DMP_INT_3) {
  40c60a:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40c60e:	b29b      	uxth	r3, r3
  40c610:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  40c614:	2b00      	cmp	r3, #0
  40c616:	d018      	beq.n	40c64a <inv_icm20648_poll_sensor+0x12c6>
			uint8_t event = 0;
  40c618:	f107 0316 	add.w	r3, r7, #22
  40c61c:	2200      	movs	r2, #0
  40c61e:	701a      	strb	r2, [r3, #0]
			handler(context, INV_ICM20648_SENSOR_STEP_DETECTOR, s->timestamp[INV_ICM20648_SENSOR_STEP_DETECTOR], &event, 0);
  40c620:	f107 030c 	add.w	r3, r7, #12
  40c624:	681b      	ldr	r3, [r3, #0]
  40c626:	f503 7340 	add.w	r3, r3, #768	; 0x300
  40c62a:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c62e:	f107 0008 	add.w	r0, r7, #8
  40c632:	1d3a      	adds	r2, r7, #4
  40c634:	2100      	movs	r1, #0
  40c636:	9101      	str	r1, [sp, #4]
  40c638:	f107 0116 	add.w	r1, r7, #22
  40c63c:	9100      	str	r1, [sp, #0]
  40c63e:	6815      	ldr	r5, [r2, #0]
  40c640:	461a      	mov	r2, r3
  40c642:	4623      	mov	r3, r4
  40c644:	2107      	movs	r1, #7
  40c646:	6800      	ldr	r0, [r0, #0]
  40c648:	47a8      	blx	r5
		}
		/* Bring to see detected by DMP */
		if (int_read_back & BIT_MSG_DMP_INT_5) {
  40c64a:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40c64e:	b29b      	uxth	r3, r3
  40c650:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40c654:	2b00      	cmp	r3, #0
  40c656:	d018      	beq.n	40c68a <inv_icm20648_poll_sensor+0x1306>
			uint8_t event = 0;
  40c658:	f107 0315 	add.w	r3, r7, #21
  40c65c:	2200      	movs	r2, #0
  40c65e:	701a      	strb	r2, [r3, #0]
			handler(context, INV_ICM20648_SENSOR_B2S, s->timestamp[INV_ICM20648_SENSOR_B2S], &event, 0);
  40c660:	f107 030c 	add.w	r3, r7, #12
  40c664:	681b      	ldr	r3, [r3, #0]
  40c666:	f503 7358 	add.w	r3, r3, #864	; 0x360
  40c66a:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c66e:	f107 0008 	add.w	r0, r7, #8
  40c672:	1d3a      	adds	r2, r7, #4
  40c674:	2100      	movs	r1, #0
  40c676:	9101      	str	r1, [sp, #4]
  40c678:	f107 0115 	add.w	r1, r7, #21
  40c67c:	9100      	str	r1, [sp, #0]
  40c67e:	6815      	ldr	r5, [r2, #0]
  40c680:	461a      	mov	r2, r3
  40c682:	4623      	mov	r3, r4
  40c684:	2113      	movs	r1, #19
  40c686:	6800      	ldr	r0, [r0, #0]
  40c688:	47a8      	blx	r5
		}
	}

	/* Sometimes, the chip can be put in sleep mode even if there is data in the FIFO. If we poll at this moment, the transport layer will wake-up the chip, but never put it back in sleep. */
	if (s->mems_put_to_sleep) {
  40c68a:	f107 030c 	add.w	r3, r7, #12
  40c68e:	681b      	ldr	r3, [r3, #0]
  40c690:	f993 323c 	ldrsb.w	r3, [r3, #572]	; 0x23c
  40c694:	2b00      	cmp	r3, #0
  40c696:	d004      	beq.n	40c6a2 <inv_icm20648_poll_sensor+0x131e>
		inv_icm20648_sleep_mems(s);
  40c698:	f107 030c 	add.w	r3, r7, #12
  40c69c:	6818      	ldr	r0, [r3, #0]
  40c69e:	4b04      	ldr	r3, [pc, #16]	; (40c6b0 <inv_icm20648_poll_sensor+0x132c>)
  40c6a0:	4798      	blx	r3
	}

	return 0;
  40c6a2:	2300      	movs	r3, #0
}
  40c6a4:	4618      	mov	r0, r3
  40c6a6:	f507 7706 	add.w	r7, r7, #536	; 0x218
  40c6aa:	46bd      	mov	sp, r7
  40c6ac:	bdb0      	pop	{r4, r5, r7, pc}
  40c6ae:	bf00      	nop
  40c6b0:	00405db9 	.word	0x00405db9

0040c6b4 <inv_icm20648_serif_read_reg>:
	return s->max_write;
}

static inline int inv_icm20648_serif_read_reg(struct inv_icm20648_serif * s,
		uint8_t reg, uint8_t * buf, uint32_t len)
{
  40c6b4:	b590      	push	{r4, r7, lr}
  40c6b6:	b085      	sub	sp, #20
  40c6b8:	af00      	add	r7, sp, #0
  40c6ba:	60f8      	str	r0, [r7, #12]
  40c6bc:	607a      	str	r2, [r7, #4]
  40c6be:	603b      	str	r3, [r7, #0]
  40c6c0:	460b      	mov	r3, r1
  40c6c2:	72fb      	strb	r3, [r7, #11]
	assert(s);

	if(len > s->max_read)
  40c6c4:	68fb      	ldr	r3, [r7, #12]
  40c6c6:	68da      	ldr	r2, [r3, #12]
  40c6c8:	683b      	ldr	r3, [r7, #0]
  40c6ca:	429a      	cmp	r2, r3
  40c6cc:	d202      	bcs.n	40c6d4 <inv_icm20648_serif_read_reg+0x20>
		return INV_ERROR_SIZE;
  40c6ce:	f06f 0304 	mvn.w	r3, #4
  40c6d2:	e00e      	b.n	40c6f2 <inv_icm20648_serif_read_reg+0x3e>

	if(s->read_reg(s->context, reg, buf, len) != 0)
  40c6d4:	68fb      	ldr	r3, [r7, #12]
  40c6d6:	685c      	ldr	r4, [r3, #4]
  40c6d8:	68fb      	ldr	r3, [r7, #12]
  40c6da:	6818      	ldr	r0, [r3, #0]
  40c6dc:	7af9      	ldrb	r1, [r7, #11]
  40c6de:	683b      	ldr	r3, [r7, #0]
  40c6e0:	687a      	ldr	r2, [r7, #4]
  40c6e2:	47a0      	blx	r4
  40c6e4:	4603      	mov	r3, r0
  40c6e6:	2b00      	cmp	r3, #0
  40c6e8:	d002      	beq.n	40c6f0 <inv_icm20648_serif_read_reg+0x3c>
		return INV_ERROR_TRANSPORT;
  40c6ea:	f06f 0302 	mvn.w	r3, #2
  40c6ee:	e000      	b.n	40c6f2 <inv_icm20648_serif_read_reg+0x3e>

	return 0;
  40c6f0:	2300      	movs	r3, #0
}
  40c6f2:	4618      	mov	r0, r3
  40c6f4:	3714      	adds	r7, #20
  40c6f6:	46bd      	mov	sp, r7
  40c6f8:	bd90      	pop	{r4, r7, pc}

0040c6fa <inv_icm20648_serif_write_reg>:

static inline int inv_icm20648_serif_write_reg(struct inv_icm20648_serif * s,
		uint8_t reg, const uint8_t * buf, uint32_t len)
{
  40c6fa:	b590      	push	{r4, r7, lr}
  40c6fc:	b085      	sub	sp, #20
  40c6fe:	af00      	add	r7, sp, #0
  40c700:	60f8      	str	r0, [r7, #12]
  40c702:	607a      	str	r2, [r7, #4]
  40c704:	603b      	str	r3, [r7, #0]
  40c706:	460b      	mov	r3, r1
  40c708:	72fb      	strb	r3, [r7, #11]
	assert(s);

	if(len > s->max_write)
  40c70a:	68fb      	ldr	r3, [r7, #12]
  40c70c:	691a      	ldr	r2, [r3, #16]
  40c70e:	683b      	ldr	r3, [r7, #0]
  40c710:	429a      	cmp	r2, r3
  40c712:	d202      	bcs.n	40c71a <inv_icm20648_serif_write_reg+0x20>
		return INV_ERROR_SIZE;
  40c714:	f06f 0304 	mvn.w	r3, #4
  40c718:	e00e      	b.n	40c738 <inv_icm20648_serif_write_reg+0x3e>

	if(s->write_reg(s->context, reg, buf, len) != 0)
  40c71a:	68fb      	ldr	r3, [r7, #12]
  40c71c:	689c      	ldr	r4, [r3, #8]
  40c71e:	68fb      	ldr	r3, [r7, #12]
  40c720:	6818      	ldr	r0, [r3, #0]
  40c722:	7af9      	ldrb	r1, [r7, #11]
  40c724:	683b      	ldr	r3, [r7, #0]
  40c726:	687a      	ldr	r2, [r7, #4]
  40c728:	47a0      	blx	r4
  40c72a:	4603      	mov	r3, r0
  40c72c:	2b00      	cmp	r3, #0
  40c72e:	d002      	beq.n	40c736 <inv_icm20648_serif_write_reg+0x3c>
		return INV_ERROR_TRANSPORT;
  40c730:	f06f 0302 	mvn.w	r3, #2
  40c734:	e000      	b.n	40c738 <inv_icm20648_serif_write_reg+0x3e>

	return 0;
  40c736:	2300      	movs	r3, #0
}
  40c738:	4618      	mov	r0, r3
  40c73a:	3714      	adds	r7, #20
  40c73c:	46bd      	mov	sp, r7
  40c73e:	bd90      	pop	{r4, r7, pc}

0040c740 <inv_icm20648_read_reg>:
#include "Icm20648.h"

struct inv_icm20648 * icm20648_instance;

int inv_icm20648_read_reg(struct inv_icm20648 * s, uint8_t reg,	uint8_t * buf, uint32_t len)
{
  40c740:	b590      	push	{r4, r7, lr}
  40c742:	b085      	sub	sp, #20
  40c744:	af00      	add	r7, sp, #0
  40c746:	60f8      	str	r0, [r7, #12]
  40c748:	607a      	str	r2, [r7, #4]
  40c74a:	603b      	str	r3, [r7, #0]
  40c74c:	460b      	mov	r3, r1
  40c74e:	72fb      	strb	r3, [r7, #11]
	return inv_icm20648_serif_read_reg(&s->serif, reg, buf, len);
  40c750:	68f8      	ldr	r0, [r7, #12]
  40c752:	7af9      	ldrb	r1, [r7, #11]
  40c754:	683b      	ldr	r3, [r7, #0]
  40c756:	687a      	ldr	r2, [r7, #4]
  40c758:	4c03      	ldr	r4, [pc, #12]	; (40c768 <inv_icm20648_read_reg+0x28>)
  40c75a:	47a0      	blx	r4
  40c75c:	4603      	mov	r3, r0
}
  40c75e:	4618      	mov	r0, r3
  40c760:	3714      	adds	r7, #20
  40c762:	46bd      	mov	sp, r7
  40c764:	bd90      	pop	{r4, r7, pc}
  40c766:	bf00      	nop
  40c768:	0040c6b5 	.word	0x0040c6b5

0040c76c <inv_icm20648_write_reg>:

int inv_icm20648_write_reg(struct inv_icm20648 * s, uint8_t reg, const uint8_t * buf, uint32_t len)
{
  40c76c:	b590      	push	{r4, r7, lr}
  40c76e:	b085      	sub	sp, #20
  40c770:	af00      	add	r7, sp, #0
  40c772:	60f8      	str	r0, [r7, #12]
  40c774:	607a      	str	r2, [r7, #4]
  40c776:	603b      	str	r3, [r7, #0]
  40c778:	460b      	mov	r3, r1
  40c77a:	72fb      	strb	r3, [r7, #11]
	return inv_icm20648_serif_write_reg(&s->serif, reg, buf, len);
  40c77c:	68f8      	ldr	r0, [r7, #12]
  40c77e:	7af9      	ldrb	r1, [r7, #11]
  40c780:	683b      	ldr	r3, [r7, #0]
  40c782:	687a      	ldr	r2, [r7, #4]
  40c784:	4c03      	ldr	r4, [pc, #12]	; (40c794 <inv_icm20648_write_reg+0x28>)
  40c786:	47a0      	blx	r4
  40c788:	4603      	mov	r3, r0
}
  40c78a:	4618      	mov	r0, r3
  40c78c:	3714      	adds	r7, #20
  40c78e:	46bd      	mov	sp, r7
  40c790:	bd90      	pop	{r4, r7, pc}
  40c792:	bf00      	nop
  40c794:	0040c6fb 	.word	0x0040c6fb

0040c798 <inv_icm20648_sleep_100us>:

void inv_icm20648_sleep_100us(unsigned long nHowMany100MicroSecondsToSleep)  // time in 100 us
{
  40c798:	b580      	push	{r7, lr}
  40c79a:	b082      	sub	sp, #8
  40c79c:	af00      	add	r7, sp, #0
  40c79e:	6078      	str	r0, [r7, #4]
	inv_icm20648_sleep_us(nHowMany100MicroSecondsToSleep * 100);
  40c7a0:	687b      	ldr	r3, [r7, #4]
  40c7a2:	2264      	movs	r2, #100	; 0x64
  40c7a4:	fb02 f303 	mul.w	r3, r2, r3
  40c7a8:	4618      	mov	r0, r3
  40c7aa:	4b03      	ldr	r3, [pc, #12]	; (40c7b8 <inv_icm20648_sleep_100us+0x20>)
  40c7ac:	4798      	blx	r3
}
  40c7ae:	bf00      	nop
  40c7b0:	3708      	adds	r7, #8
  40c7b2:	46bd      	mov	sp, r7
  40c7b4:	bd80      	pop	{r7, pc}
  40c7b6:	bf00      	nop
  40c7b8:	004015d9 	.word	0x004015d9

0040c7bc <inv_icm20648_transport_init>:
#include "Icm20648Defs.h"
#include "Icm20648DataBaseDriver.h"
#include "Icm20648DataBaseControl.h"

void inv_icm20648_transport_init(struct inv_icm20648 * s)
{
  40c7bc:	b480      	push	{r7}
  40c7be:	b083      	sub	sp, #12
  40c7c0:	af00      	add	r7, sp, #0
  40c7c2:	6078      	str	r0, [r7, #4]
	s->lastBank = 0x7E;
  40c7c4:	687b      	ldr	r3, [r7, #4]
  40c7c6:	227e      	movs	r2, #126	; 0x7e
  40c7c8:	f883 24db 	strb.w	r2, [r3, #1243]	; 0x4db
	s->lLastBankSelected = 0xFF;
  40c7cc:	687b      	ldr	r3, [r7, #4]
  40c7ce:	22ff      	movs	r2, #255	; 0xff
  40c7d0:	f883 24dc 	strb.w	r2, [r3, #1244]	; 0x4dc
}
  40c7d4:	bf00      	nop
  40c7d6:	370c      	adds	r7, #12
  40c7d8:	46bd      	mov	sp, r7
  40c7da:	f85d 7b04 	ldr.w	r7, [sp], #4
  40c7de:	4770      	bx	lr

0040c7e0 <check_reg_access_lp_disable>:

static uint8_t check_reg_access_lp_disable(struct inv_icm20648 * s, unsigned short reg)
{
  40c7e0:	b580      	push	{r7, lr}
  40c7e2:	b082      	sub	sp, #8
  40c7e4:	af00      	add	r7, sp, #0
  40c7e6:	6078      	str	r0, [r7, #4]
  40c7e8:	460b      	mov	r3, r1
  40c7ea:	807b      	strh	r3, [r7, #2]
	switch(reg){
  40c7ec:	887b      	ldrh	r3, [r7, #2]
  40c7ee:	2b19      	cmp	r3, #25
  40c7f0:	dc09      	bgt.n	40c806 <check_reg_access_lp_disable+0x26>
  40c7f2:	2b18      	cmp	r3, #24
  40c7f4:	da18      	bge.n	40c828 <check_reg_access_lp_disable+0x48>
  40c7f6:	2b05      	cmp	r3, #5
  40c7f8:	db18      	blt.n	40c82c <check_reg_access_lp_disable+0x4c>
  40c7fa:	2b07      	cmp	r3, #7
  40c7fc:	dd0f      	ble.n	40c81e <check_reg_access_lp_disable+0x3e>
  40c7fe:	3b0f      	subs	r3, #15
  40c800:	2b01      	cmp	r3, #1
  40c802:	d813      	bhi.n	40c82c <check_reg_access_lp_disable+0x4c>
  40c804:	e00b      	b.n	40c81e <check_reg_access_lp_disable+0x3e>
  40c806:	2b76      	cmp	r3, #118	; 0x76
  40c808:	d00e      	beq.n	40c828 <check_reg_access_lp_disable+0x48>
  40c80a:	2b76      	cmp	r3, #118	; 0x76
  40c80c:	dc03      	bgt.n	40c816 <check_reg_access_lp_disable+0x36>
  40c80e:	3b70      	subs	r3, #112	; 0x70
  40c810:	2b02      	cmp	r3, #2
  40c812:	d80b      	bhi.n	40c82c <check_reg_access_lp_disable+0x4c>
  40c814:	e003      	b.n	40c81e <check_reg_access_lp_disable+0x3e>
  40c816:	3b7e      	subs	r3, #126	; 0x7e
  40c818:	2b01      	cmp	r3, #1
  40c81a:	d807      	bhi.n	40c82c <check_reg_access_lp_disable+0x4c>
  40c81c:	e004      	b.n	40c828 <check_reg_access_lp_disable+0x48>
	case REG_INT_PIN_CFG:    /** (BANK_0 | 0x0F) */
	case REG_INT_ENABLE:     /** (BANK_0 | 0x10) */
	case REG_FIFO_COUNT_H:   /** (BANK_0 | 0x70) */
	case REG_FIFO_COUNT_L:   /** (BANK_0 | 0x71) */
	case REG_FIFO_R_W:       /** (BANK_0 | 0x72) */
		return inv_icm20648_ctrl_get_batch_mode_status(s);
  40c81e:	6878      	ldr	r0, [r7, #4]
  40c820:	4b05      	ldr	r3, [pc, #20]	; (40c838 <check_reg_access_lp_disable+0x58>)
  40c822:	4798      	blx	r3
  40c824:	4603      	mov	r3, r0
  40c826:	e003      	b.n	40c830 <check_reg_access_lp_disable+0x50>
	case REG_FIFO_CFG:       /** (BANK_0 | 0x76) */
	case REG_MEM_BANK_SEL:   /** (BANK_0 | 0x7E) */
	case REG_BANK_SEL:       /** 0x7F */
	case REG_INT_STATUS:     /** (BANK_0 | 0x19) */
	case REG_DMP_INT_STATUS: /** (BANK_0 | 0x18) */
		return 0;
  40c828:	2300      	movs	r3, #0
  40c82a:	e001      	b.n	40c830 <check_reg_access_lp_disable+0x50>
		break;
	default:
		break;
  40c82c:	bf00      	nop
	}
	return 1;
  40c82e:	2301      	movs	r3, #1
}
  40c830:	4618      	mov	r0, r3
  40c832:	3708      	adds	r7, #8
  40c834:	46bd      	mov	sp, r7
  40c836:	bd80      	pop	{r7, pc}
  40c838:	004124df 	.word	0x004124df

0040c83c <inv_set_bank>:
*  @param[in]  register bank number
*  @return     0 if successful.
*/

static int inv_set_bank(struct inv_icm20648 * s, unsigned char bank)
{
  40c83c:	b590      	push	{r4, r7, lr}
  40c83e:	b085      	sub	sp, #20
  40c840:	af00      	add	r7, sp, #0
  40c842:	6078      	str	r0, [r7, #4]
  40c844:	460b      	mov	r3, r1
  40c846:	70fb      	strb	r3, [r7, #3]
	int result;
	//if bank reg was set before, just return
	if(bank==s->lastBank) 
  40c848:	687b      	ldr	r3, [r7, #4]
  40c84a:	f893 34db 	ldrb.w	r3, [r3, #1243]	; 0x4db
  40c84e:	78fa      	ldrb	r2, [r7, #3]
  40c850:	429a      	cmp	r2, r3
  40c852:	d101      	bne.n	40c858 <inv_set_bank+0x1c>
		return 0;
  40c854:	2300      	movs	r3, #0
  40c856:	e031      	b.n	40c8bc <inv_set_bank+0x80>
	else 
		s->lastBank = bank;
  40c858:	687b      	ldr	r3, [r7, #4]
  40c85a:	78fa      	ldrb	r2, [r7, #3]
  40c85c:	f883 24db 	strb.w	r2, [r3, #1243]	; 0x4db

	result = inv_icm20648_read_reg(s, REG_BANK_SEL, &s->reg, 1);
  40c860:	687b      	ldr	r3, [r7, #4]
  40c862:	f203 42da 	addw	r2, r3, #1242	; 0x4da
  40c866:	2301      	movs	r3, #1
  40c868:	217f      	movs	r1, #127	; 0x7f
  40c86a:	6878      	ldr	r0, [r7, #4]
  40c86c:	4c15      	ldr	r4, [pc, #84]	; (40c8c4 <inv_set_bank+0x88>)
  40c86e:	47a0      	blx	r4
  40c870:	60f8      	str	r0, [r7, #12]

	if (result)
  40c872:	68fb      	ldr	r3, [r7, #12]
  40c874:	2b00      	cmp	r3, #0
  40c876:	d001      	beq.n	40c87c <inv_set_bank+0x40>
		return result;
  40c878:	68fb      	ldr	r3, [r7, #12]
  40c87a:	e01f      	b.n	40c8bc <inv_set_bank+0x80>

	s->reg &= 0xce;
  40c87c:	687b      	ldr	r3, [r7, #4]
  40c87e:	f893 34da 	ldrb.w	r3, [r3, #1242]	; 0x4da
  40c882:	f023 0331 	bic.w	r3, r3, #49	; 0x31
  40c886:	b2da      	uxtb	r2, r3
  40c888:	687b      	ldr	r3, [r7, #4]
  40c88a:	f883 24da 	strb.w	r2, [r3, #1242]	; 0x4da
	s->reg |= (bank << 4);
  40c88e:	687b      	ldr	r3, [r7, #4]
  40c890:	f893 34da 	ldrb.w	r3, [r3, #1242]	; 0x4da
  40c894:	b25a      	sxtb	r2, r3
  40c896:	78fb      	ldrb	r3, [r7, #3]
  40c898:	011b      	lsls	r3, r3, #4
  40c89a:	b25b      	sxtb	r3, r3
  40c89c:	4313      	orrs	r3, r2
  40c89e:	b25b      	sxtb	r3, r3
  40c8a0:	b2da      	uxtb	r2, r3
  40c8a2:	687b      	ldr	r3, [r7, #4]
  40c8a4:	f883 24da 	strb.w	r2, [r3, #1242]	; 0x4da
	result = inv_icm20648_write_reg(s, REG_BANK_SEL, &s->reg, 1);
  40c8a8:	687b      	ldr	r3, [r7, #4]
  40c8aa:	f203 42da 	addw	r2, r3, #1242	; 0x4da
  40c8ae:	2301      	movs	r3, #1
  40c8b0:	217f      	movs	r1, #127	; 0x7f
  40c8b2:	6878      	ldr	r0, [r7, #4]
  40c8b4:	4c04      	ldr	r4, [pc, #16]	; (40c8c8 <inv_set_bank+0x8c>)
  40c8b6:	47a0      	blx	r4
  40c8b8:	60f8      	str	r0, [r7, #12]

	return result;
  40c8ba:	68fb      	ldr	r3, [r7, #12]
}
  40c8bc:	4618      	mov	r0, r3
  40c8be:	3714      	adds	r7, #20
  40c8c0:	46bd      	mov	sp, r7
  40c8c2:	bd90      	pop	{r4, r7, pc}
  40c8c4:	0040c741 	.word	0x0040c741
  40c8c8:	0040c76d 	.word	0x0040c76d

0040c8cc <inv_icm20648_write_mems_reg>:
*  @param[in]  Length of data
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20648_write_mems_reg(struct inv_icm20648 * s, uint16_t reg, unsigned int length, const unsigned char *data)
{
  40c8cc:	b590      	push	{r4, r7, lr}
  40c8ce:	b089      	sub	sp, #36	; 0x24
  40c8d0:	af00      	add	r7, sp, #0
  40c8d2:	60f8      	str	r0, [r7, #12]
  40c8d4:	607a      	str	r2, [r7, #4]
  40c8d6:	603b      	str	r3, [r7, #0]
  40c8d8:	460b      	mov	r3, r1
  40c8da:	817b      	strh	r3, [r7, #10]
	int result = 0;
  40c8dc:	2300      	movs	r3, #0
  40c8de:	61fb      	str	r3, [r7, #28]
	unsigned int bytesWrite = 0;
  40c8e0:	2300      	movs	r3, #0
  40c8e2:	61bb      	str	r3, [r7, #24]
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40c8e4:	897b      	ldrh	r3, [r7, #10]
  40c8e6:	b2db      	uxtb	r3, r3
  40c8e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40c8ec:	75fb      	strb	r3, [r7, #23]

	unsigned char power_state = inv_icm20648_get_chip_power_state(s);
  40c8ee:	68f8      	ldr	r0, [r7, #12]
  40c8f0:	4b33      	ldr	r3, [pc, #204]	; (40c9c0 <inv_icm20648_write_mems_reg+0xf4>)
  40c8f2:	4798      	blx	r3
  40c8f4:	4603      	mov	r3, r0
  40c8f6:	75bb      	strb	r3, [r7, #22]

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40c8f8:	7dbb      	ldrb	r3, [r7, #22]
  40c8fa:	f003 0301 	and.w	r3, r3, #1
  40c8fe:	2b00      	cmp	r3, #0
  40c900:	d105      	bne.n	40c90e <inv_icm20648_write_mems_reg+0x42>
		result = inv_icm20648_set_chip_power_state(s, CHIP_AWAKE, 1);
  40c902:	2201      	movs	r2, #1
  40c904:	2101      	movs	r1, #1
  40c906:	68f8      	ldr	r0, [r7, #12]
  40c908:	4b2e      	ldr	r3, [pc, #184]	; (40c9c4 <inv_icm20648_write_mems_reg+0xf8>)
  40c90a:	4798      	blx	r3
  40c90c:	61f8      	str	r0, [r7, #28]

	if(check_reg_access_lp_disable(s, reg))    // Check if register needs LP_EN to be disabled   
  40c90e:	897b      	ldrh	r3, [r7, #10]
  40c910:	4619      	mov	r1, r3
  40c912:	68f8      	ldr	r0, [r7, #12]
  40c914:	4b2c      	ldr	r3, [pc, #176]	; (40c9c8 <inv_icm20648_write_mems_reg+0xfc>)
  40c916:	4798      	blx	r3
  40c918:	4603      	mov	r3, r0
  40c91a:	2b00      	cmp	r3, #0
  40c91c:	d008      	beq.n	40c930 <inv_icm20648_write_mems_reg+0x64>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
  40c91e:	2200      	movs	r2, #0
  40c920:	2102      	movs	r1, #2
  40c922:	68f8      	ldr	r0, [r7, #12]
  40c924:	4b27      	ldr	r3, [pc, #156]	; (40c9c4 <inv_icm20648_write_mems_reg+0xf8>)
  40c926:	4798      	blx	r3
  40c928:	4602      	mov	r2, r0
  40c92a:	69fb      	ldr	r3, [r7, #28]
  40c92c:	4313      	orrs	r3, r2
  40c92e:	61fb      	str	r3, [r7, #28]

	result |= inv_set_bank(s, reg >> 7);
  40c930:	897b      	ldrh	r3, [r7, #10]
  40c932:	09db      	lsrs	r3, r3, #7
  40c934:	b29b      	uxth	r3, r3
  40c936:	b2db      	uxtb	r3, r3
  40c938:	4619      	mov	r1, r3
  40c93a:	68f8      	ldr	r0, [r7, #12]
  40c93c:	4b23      	ldr	r3, [pc, #140]	; (40c9cc <inv_icm20648_write_mems_reg+0x100>)
  40c93e:	4798      	blx	r3
  40c940:	4602      	mov	r2, r0
  40c942:	69fb      	ldr	r3, [r7, #28]
  40c944:	4313      	orrs	r3, r2
  40c946:	61fb      	str	r3, [r7, #28]

	while (bytesWrite<length) 
  40c948:	e01f      	b.n	40c98a <inv_icm20648_write_mems_reg+0xbe>
	{
		int thisLen = min(INV_MAX_SERIAL_WRITE, length-bytesWrite);
  40c94a:	687a      	ldr	r2, [r7, #4]
  40c94c:	69bb      	ldr	r3, [r7, #24]
  40c94e:	1ad3      	subs	r3, r2, r3
  40c950:	2b10      	cmp	r3, #16
  40c952:	bf28      	it	cs
  40c954:	2310      	movcs	r3, #16
  40c956:	613b      	str	r3, [r7, #16]

		result |= inv_icm20648_write_reg(s, regOnly+bytesWrite,&data[bytesWrite], thisLen);
  40c958:	69bb      	ldr	r3, [r7, #24]
  40c95a:	b2da      	uxtb	r2, r3
  40c95c:	7dfb      	ldrb	r3, [r7, #23]
  40c95e:	4413      	add	r3, r2
  40c960:	b2d9      	uxtb	r1, r3
  40c962:	683a      	ldr	r2, [r7, #0]
  40c964:	69bb      	ldr	r3, [r7, #24]
  40c966:	441a      	add	r2, r3
  40c968:	693b      	ldr	r3, [r7, #16]
  40c96a:	68f8      	ldr	r0, [r7, #12]
  40c96c:	4c18      	ldr	r4, [pc, #96]	; (40c9d0 <inv_icm20648_write_mems_reg+0x104>)
  40c96e:	47a0      	blx	r4
  40c970:	4602      	mov	r2, r0
  40c972:	69fb      	ldr	r3, [r7, #28]
  40c974:	4313      	orrs	r3, r2
  40c976:	61fb      	str	r3, [r7, #28]

		if (result)
  40c978:	69fb      	ldr	r3, [r7, #28]
  40c97a:	2b00      	cmp	r3, #0
  40c97c:	d001      	beq.n	40c982 <inv_icm20648_write_mems_reg+0xb6>
			return result;
  40c97e:	69fb      	ldr	r3, [r7, #28]
  40c980:	e019      	b.n	40c9b6 <inv_icm20648_write_mems_reg+0xea>

		bytesWrite += thisLen;
  40c982:	693b      	ldr	r3, [r7, #16]
  40c984:	69ba      	ldr	r2, [r7, #24]
  40c986:	4413      	add	r3, r2
  40c988:	61bb      	str	r3, [r7, #24]
	while (bytesWrite<length) 
  40c98a:	69ba      	ldr	r2, [r7, #24]
  40c98c:	687b      	ldr	r3, [r7, #4]
  40c98e:	429a      	cmp	r2, r3
  40c990:	d3db      	bcc.n	40c94a <inv_icm20648_write_mems_reg+0x7e>
	}

	if(check_reg_access_lp_disable(s, reg))   //Enable LP_EN since we disabled it at begining of this function.
  40c992:	897b      	ldrh	r3, [r7, #10]
  40c994:	4619      	mov	r1, r3
  40c996:	68f8      	ldr	r0, [r7, #12]
  40c998:	4b0b      	ldr	r3, [pc, #44]	; (40c9c8 <inv_icm20648_write_mems_reg+0xfc>)
  40c99a:	4798      	blx	r3
  40c99c:	4603      	mov	r3, r0
  40c99e:	2b00      	cmp	r3, #0
  40c9a0:	d008      	beq.n	40c9b4 <inv_icm20648_write_mems_reg+0xe8>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40c9a2:	2201      	movs	r2, #1
  40c9a4:	2102      	movs	r1, #2
  40c9a6:	68f8      	ldr	r0, [r7, #12]
  40c9a8:	4b06      	ldr	r3, [pc, #24]	; (40c9c4 <inv_icm20648_write_mems_reg+0xf8>)
  40c9aa:	4798      	blx	r3
  40c9ac:	4602      	mov	r2, r0
  40c9ae:	69fb      	ldr	r3, [r7, #28]
  40c9b0:	4313      	orrs	r3, r2
  40c9b2:	61fb      	str	r3, [r7, #28]

	return result;
  40c9b4:	69fb      	ldr	r3, [r7, #28]
}
  40c9b6:	4618      	mov	r0, r3
  40c9b8:	3724      	adds	r7, #36	; 0x24
  40c9ba:	46bd      	mov	sp, r7
  40c9bc:	bd90      	pop	{r4, r7, pc}
  40c9be:	bf00      	nop
  40c9c0:	00405ced 	.word	0x00405ced
  40c9c4:	00405b8d 	.word	0x00405b8d
  40c9c8:	0040c7e1 	.word	0x0040c7e1
  40c9cc:	0040c83d 	.word	0x0040c83d
  40c9d0:	0040c76d 	.word	0x0040c76d

0040c9d4 <inv_icm20648_write_single_mems_reg>:
*  @param[in]  Register address
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20648_write_single_mems_reg(struct inv_icm20648 * s, uint16_t reg, const unsigned char data)
{
  40c9d4:	b590      	push	{r4, r7, lr}
  40c9d6:	b085      	sub	sp, #20
  40c9d8:	af00      	add	r7, sp, #0
  40c9da:	6078      	str	r0, [r7, #4]
  40c9dc:	460b      	mov	r3, r1
  40c9de:	807b      	strh	r3, [r7, #2]
  40c9e0:	4613      	mov	r3, r2
  40c9e2:	707b      	strb	r3, [r7, #1]
	int result = 0;
  40c9e4:	2300      	movs	r3, #0
  40c9e6:	60fb      	str	r3, [r7, #12]
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40c9e8:	887b      	ldrh	r3, [r7, #2]
  40c9ea:	b2db      	uxtb	r3, r3
  40c9ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40c9f0:	72fb      	strb	r3, [r7, #11]


	unsigned char power_state = inv_icm20648_get_chip_power_state(s);
  40c9f2:	6878      	ldr	r0, [r7, #4]
  40c9f4:	4b25      	ldr	r3, [pc, #148]	; (40ca8c <inv_icm20648_write_single_mems_reg+0xb8>)
  40c9f6:	4798      	blx	r3
  40c9f8:	4603      	mov	r3, r0
  40c9fa:	72bb      	strb	r3, [r7, #10]

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40c9fc:	7abb      	ldrb	r3, [r7, #10]
  40c9fe:	f003 0301 	and.w	r3, r3, #1
  40ca02:	2b00      	cmp	r3, #0
  40ca04:	d105      	bne.n	40ca12 <inv_icm20648_write_single_mems_reg+0x3e>
		result = inv_icm20648_set_chip_power_state(s, CHIP_AWAKE, 1);
  40ca06:	2201      	movs	r2, #1
  40ca08:	2101      	movs	r1, #1
  40ca0a:	6878      	ldr	r0, [r7, #4]
  40ca0c:	4b20      	ldr	r3, [pc, #128]	; (40ca90 <inv_icm20648_write_single_mems_reg+0xbc>)
  40ca0e:	4798      	blx	r3
  40ca10:	60f8      	str	r0, [r7, #12]

	if(check_reg_access_lp_disable(s, reg))   // Check if register needs LP_EN to be disabled
  40ca12:	887b      	ldrh	r3, [r7, #2]
  40ca14:	4619      	mov	r1, r3
  40ca16:	6878      	ldr	r0, [r7, #4]
  40ca18:	4b1e      	ldr	r3, [pc, #120]	; (40ca94 <inv_icm20648_write_single_mems_reg+0xc0>)
  40ca1a:	4798      	blx	r3
  40ca1c:	4603      	mov	r3, r0
  40ca1e:	2b00      	cmp	r3, #0
  40ca20:	d008      	beq.n	40ca34 <inv_icm20648_write_single_mems_reg+0x60>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
  40ca22:	2200      	movs	r2, #0
  40ca24:	2102      	movs	r1, #2
  40ca26:	6878      	ldr	r0, [r7, #4]
  40ca28:	4b19      	ldr	r3, [pc, #100]	; (40ca90 <inv_icm20648_write_single_mems_reg+0xbc>)
  40ca2a:	4798      	blx	r3
  40ca2c:	4602      	mov	r2, r0
  40ca2e:	68fb      	ldr	r3, [r7, #12]
  40ca30:	4313      	orrs	r3, r2
  40ca32:	60fb      	str	r3, [r7, #12]

	result |= inv_set_bank(s, reg >> 7);
  40ca34:	887b      	ldrh	r3, [r7, #2]
  40ca36:	09db      	lsrs	r3, r3, #7
  40ca38:	b29b      	uxth	r3, r3
  40ca3a:	b2db      	uxtb	r3, r3
  40ca3c:	4619      	mov	r1, r3
  40ca3e:	6878      	ldr	r0, [r7, #4]
  40ca40:	4b15      	ldr	r3, [pc, #84]	; (40ca98 <inv_icm20648_write_single_mems_reg+0xc4>)
  40ca42:	4798      	blx	r3
  40ca44:	4602      	mov	r2, r0
  40ca46:	68fb      	ldr	r3, [r7, #12]
  40ca48:	4313      	orrs	r3, r2
  40ca4a:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20648_write_reg(s, regOnly, &data, 1);
  40ca4c:	1c7a      	adds	r2, r7, #1
  40ca4e:	7af9      	ldrb	r1, [r7, #11]
  40ca50:	2301      	movs	r3, #1
  40ca52:	6878      	ldr	r0, [r7, #4]
  40ca54:	4c11      	ldr	r4, [pc, #68]	; (40ca9c <inv_icm20648_write_single_mems_reg+0xc8>)
  40ca56:	47a0      	blx	r4
  40ca58:	4602      	mov	r2, r0
  40ca5a:	68fb      	ldr	r3, [r7, #12]
  40ca5c:	4313      	orrs	r3, r2
  40ca5e:	60fb      	str	r3, [r7, #12]

	if(check_reg_access_lp_disable(s, reg))   //Enable LP_EN since we disabled it at begining of this function.
  40ca60:	887b      	ldrh	r3, [r7, #2]
  40ca62:	4619      	mov	r1, r3
  40ca64:	6878      	ldr	r0, [r7, #4]
  40ca66:	4b0b      	ldr	r3, [pc, #44]	; (40ca94 <inv_icm20648_write_single_mems_reg+0xc0>)
  40ca68:	4798      	blx	r3
  40ca6a:	4603      	mov	r3, r0
  40ca6c:	2b00      	cmp	r3, #0
  40ca6e:	d008      	beq.n	40ca82 <inv_icm20648_write_single_mems_reg+0xae>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40ca70:	2201      	movs	r2, #1
  40ca72:	2102      	movs	r1, #2
  40ca74:	6878      	ldr	r0, [r7, #4]
  40ca76:	4b06      	ldr	r3, [pc, #24]	; (40ca90 <inv_icm20648_write_single_mems_reg+0xbc>)
  40ca78:	4798      	blx	r3
  40ca7a:	4602      	mov	r2, r0
  40ca7c:	68fb      	ldr	r3, [r7, #12]
  40ca7e:	4313      	orrs	r3, r2
  40ca80:	60fb      	str	r3, [r7, #12]

	return result;
  40ca82:	68fb      	ldr	r3, [r7, #12]
}
  40ca84:	4618      	mov	r0, r3
  40ca86:	3714      	adds	r7, #20
  40ca88:	46bd      	mov	sp, r7
  40ca8a:	bd90      	pop	{r4, r7, pc}
  40ca8c:	00405ced 	.word	0x00405ced
  40ca90:	00405b8d 	.word	0x00405b8d
  40ca94:	0040c7e1 	.word	0x0040c7e1
  40ca98:	0040c83d 	.word	0x0040c83d
  40ca9c:	0040c76d 	.word	0x0040c76d

0040caa0 <inv_icm20648_read_mems_reg>:
*  @param[in]  Length of data
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20648_read_mems_reg(struct inv_icm20648 * s, uint16_t reg, unsigned int length, unsigned char *data)
{
  40caa0:	b590      	push	{r4, r7, lr}
  40caa2:	b08d      	sub	sp, #52	; 0x34
  40caa4:	af00      	add	r7, sp, #0
  40caa6:	60f8      	str	r0, [r7, #12]
  40caa8:	607a      	str	r2, [r7, #4]
  40caaa:	603b      	str	r3, [r7, #0]
  40caac:	460b      	mov	r3, r1
  40caae:	817b      	strh	r3, [r7, #10]
	int result = 0;
  40cab0:	2300      	movs	r3, #0
  40cab2:	62fb      	str	r3, [r7, #44]	; 0x2c
	unsigned int bytesRead = 0;
  40cab4:	2300      	movs	r3, #0
  40cab6:	62bb      	str	r3, [r7, #40]	; 0x28
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40cab8:	897b      	ldrh	r3, [r7, #10]
  40caba:	b2db      	uxtb	r3, r3
  40cabc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40cac0:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	unsigned char i, dat[INV_MAX_SERIAL_READ];
	unsigned char power_state = inv_icm20648_get_chip_power_state(s);
  40cac4:	68f8      	ldr	r0, [r7, #12]
  40cac6:	4b50      	ldr	r3, [pc, #320]	; (40cc08 <inv_icm20648_read_mems_reg+0x168>)
  40cac8:	4798      	blx	r3
  40caca:	4603      	mov	r3, r0
  40cacc:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40cad0:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
  40cad4:	f003 0301 	and.w	r3, r3, #1
  40cad8:	2b00      	cmp	r3, #0
  40cada:	d105      	bne.n	40cae8 <inv_icm20648_read_mems_reg+0x48>
		result = inv_icm20648_set_chip_power_state(s, CHIP_AWAKE, 1);
  40cadc:	2201      	movs	r2, #1
  40cade:	2101      	movs	r1, #1
  40cae0:	68f8      	ldr	r0, [r7, #12]
  40cae2:	4b4a      	ldr	r3, [pc, #296]	; (40cc0c <inv_icm20648_read_mems_reg+0x16c>)
  40cae4:	4798      	blx	r3
  40cae6:	62f8      	str	r0, [r7, #44]	; 0x2c

	if(check_reg_access_lp_disable(s, reg))   // Check if register needs LP_EN to be disabled
  40cae8:	897b      	ldrh	r3, [r7, #10]
  40caea:	4619      	mov	r1, r3
  40caec:	68f8      	ldr	r0, [r7, #12]
  40caee:	4b48      	ldr	r3, [pc, #288]	; (40cc10 <inv_icm20648_read_mems_reg+0x170>)
  40caf0:	4798      	blx	r3
  40caf2:	4603      	mov	r3, r0
  40caf4:	2b00      	cmp	r3, #0
  40caf6:	d008      	beq.n	40cb0a <inv_icm20648_read_mems_reg+0x6a>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
  40caf8:	2200      	movs	r2, #0
  40cafa:	2102      	movs	r1, #2
  40cafc:	68f8      	ldr	r0, [r7, #12]
  40cafe:	4b43      	ldr	r3, [pc, #268]	; (40cc0c <inv_icm20648_read_mems_reg+0x16c>)
  40cb00:	4798      	blx	r3
  40cb02:	4602      	mov	r2, r0
  40cb04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cb06:	4313      	orrs	r3, r2
  40cb08:	62fb      	str	r3, [r7, #44]	; 0x2c

	result |= inv_set_bank(s, reg >> 7);
  40cb0a:	897b      	ldrh	r3, [r7, #10]
  40cb0c:	09db      	lsrs	r3, r3, #7
  40cb0e:	b29b      	uxth	r3, r3
  40cb10:	b2db      	uxtb	r3, r3
  40cb12:	4619      	mov	r1, r3
  40cb14:	68f8      	ldr	r0, [r7, #12]
  40cb16:	4b3f      	ldr	r3, [pc, #252]	; (40cc14 <inv_icm20648_read_mems_reg+0x174>)
  40cb18:	4798      	blx	r3
  40cb1a:	4602      	mov	r2, r0
  40cb1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cb1e:	4313      	orrs	r3, r2
  40cb20:	62fb      	str	r3, [r7, #44]	; 0x2c

	while (bytesRead<length) 
  40cb22:	e038      	b.n	40cb96 <inv_icm20648_read_mems_reg+0xf6>
	{
		int thisLen = min(INV_MAX_SERIAL_READ, length-bytesRead);
  40cb24:	687a      	ldr	r2, [r7, #4]
  40cb26:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cb28:	1ad3      	subs	r3, r2, r3
  40cb2a:	2b10      	cmp	r3, #16
  40cb2c:	bf28      	it	cs
  40cb2e:	2310      	movcs	r3, #16
  40cb30:	623b      	str	r3, [r7, #32]
		if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40cb32:	68fb      	ldr	r3, [r7, #12]
  40cb34:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40cb38:	2b02      	cmp	r3, #2
  40cb3a:	d112      	bne.n	40cb62 <inv_icm20648_read_mems_reg+0xc2>
			result |= inv_icm20648_read_reg(s, regOnly+bytesRead, &dat[bytesRead], thisLen);
  40cb3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cb3e:	b2da      	uxtb	r2, r3
  40cb40:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  40cb44:	4413      	add	r3, r2
  40cb46:	b2d9      	uxtb	r1, r3
  40cb48:	f107 0210 	add.w	r2, r7, #16
  40cb4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cb4e:	441a      	add	r2, r3
  40cb50:	6a3b      	ldr	r3, [r7, #32]
  40cb52:	68f8      	ldr	r0, [r7, #12]
  40cb54:	4c30      	ldr	r4, [pc, #192]	; (40cc18 <inv_icm20648_read_mems_reg+0x178>)
  40cb56:	47a0      	blx	r4
  40cb58:	4602      	mov	r2, r0
  40cb5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cb5c:	4313      	orrs	r3, r2
  40cb5e:	62fb      	str	r3, [r7, #44]	; 0x2c
  40cb60:	e010      	b.n	40cb84 <inv_icm20648_read_mems_reg+0xe4>
		} else {
			result |= inv_icm20648_read_reg(s, regOnly+bytesRead, &data[bytesRead],thisLen);
  40cb62:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cb64:	b2da      	uxtb	r2, r3
  40cb66:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  40cb6a:	4413      	add	r3, r2
  40cb6c:	b2d9      	uxtb	r1, r3
  40cb6e:	683a      	ldr	r2, [r7, #0]
  40cb70:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cb72:	441a      	add	r2, r3
  40cb74:	6a3b      	ldr	r3, [r7, #32]
  40cb76:	68f8      	ldr	r0, [r7, #12]
  40cb78:	4c27      	ldr	r4, [pc, #156]	; (40cc18 <inv_icm20648_read_mems_reg+0x178>)
  40cb7a:	47a0      	blx	r4
  40cb7c:	4602      	mov	r2, r0
  40cb7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cb80:	4313      	orrs	r3, r2
  40cb82:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		if (result)
  40cb84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cb86:	2b00      	cmp	r3, #0
  40cb88:	d001      	beq.n	40cb8e <inv_icm20648_read_mems_reg+0xee>
			return result;
  40cb8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cb8c:	e038      	b.n	40cc00 <inv_icm20648_read_mems_reg+0x160>

		bytesRead += thisLen;
  40cb8e:	6a3b      	ldr	r3, [r7, #32]
  40cb90:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40cb92:	4413      	add	r3, r2
  40cb94:	62bb      	str	r3, [r7, #40]	; 0x28
	while (bytesRead<length) 
  40cb96:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40cb98:	687b      	ldr	r3, [r7, #4]
  40cb9a:	429a      	cmp	r2, r3
  40cb9c:	d3c2      	bcc.n	40cb24 <inv_icm20648_read_mems_reg+0x84>
	}

	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40cb9e:	68fb      	ldr	r3, [r7, #12]
  40cba0:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40cba4:	2b02      	cmp	r3, #2
  40cba6:	d119      	bne.n	40cbdc <inv_icm20648_read_mems_reg+0x13c>
		for (i=0; i< length; i++) {
  40cba8:	2300      	movs	r3, #0
  40cbaa:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  40cbae:	e010      	b.n	40cbd2 <inv_icm20648_read_mems_reg+0x132>
			*data= dat[i];
  40cbb0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40cbb4:	f107 0230 	add.w	r2, r7, #48	; 0x30
  40cbb8:	4413      	add	r3, r2
  40cbba:	f813 2c20 	ldrb.w	r2, [r3, #-32]
  40cbbe:	683b      	ldr	r3, [r7, #0]
  40cbc0:	701a      	strb	r2, [r3, #0]
			data++;
  40cbc2:	683b      	ldr	r3, [r7, #0]
  40cbc4:	3301      	adds	r3, #1
  40cbc6:	603b      	str	r3, [r7, #0]
		for (i=0; i< length; i++) {
  40cbc8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40cbcc:	3301      	adds	r3, #1
  40cbce:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  40cbd2:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  40cbd6:	687b      	ldr	r3, [r7, #4]
  40cbd8:	429a      	cmp	r2, r3
  40cbda:	d3e9      	bcc.n	40cbb0 <inv_icm20648_read_mems_reg+0x110>
		}
	}

	if(check_reg_access_lp_disable(s, reg))    // Check if register needs LP_EN to be enabled  
  40cbdc:	897b      	ldrh	r3, [r7, #10]
  40cbde:	4619      	mov	r1, r3
  40cbe0:	68f8      	ldr	r0, [r7, #12]
  40cbe2:	4b0b      	ldr	r3, [pc, #44]	; (40cc10 <inv_icm20648_read_mems_reg+0x170>)
  40cbe4:	4798      	blx	r3
  40cbe6:	4603      	mov	r3, r0
  40cbe8:	2b00      	cmp	r3, #0
  40cbea:	d008      	beq.n	40cbfe <inv_icm20648_read_mems_reg+0x15e>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);  //Enable LP_EN
  40cbec:	2201      	movs	r2, #1
  40cbee:	2102      	movs	r1, #2
  40cbf0:	68f8      	ldr	r0, [r7, #12]
  40cbf2:	4b06      	ldr	r3, [pc, #24]	; (40cc0c <inv_icm20648_read_mems_reg+0x16c>)
  40cbf4:	4798      	blx	r3
  40cbf6:	4602      	mov	r2, r0
  40cbf8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cbfa:	4313      	orrs	r3, r2
  40cbfc:	62fb      	str	r3, [r7, #44]	; 0x2c

	return result;
  40cbfe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  40cc00:	4618      	mov	r0, r3
  40cc02:	3734      	adds	r7, #52	; 0x34
  40cc04:	46bd      	mov	sp, r7
  40cc06:	bd90      	pop	{r4, r7, pc}
  40cc08:	00405ced 	.word	0x00405ced
  40cc0c:	00405b8d 	.word	0x00405b8d
  40cc10:	0040c7e1 	.word	0x0040c7e1
  40cc14:	0040c83d 	.word	0x0040c83d
  40cc18:	0040c741 	.word	0x0040c741

0040cc1c <inv_icm20648_read_mems>:
*  @param[in]  number of byte to be read
*  @param[in]  input data from the register
*  @return     0 if successful.
*/
int inv_icm20648_read_mems(struct inv_icm20648 * s, unsigned short reg, unsigned int length, unsigned char *data)
{
  40cc1c:	b590      	push	{r4, r7, lr}
  40cc1e:	b08f      	sub	sp, #60	; 0x3c
  40cc20:	af00      	add	r7, sp, #0
  40cc22:	60f8      	str	r0, [r7, #12]
  40cc24:	607a      	str	r2, [r7, #4]
  40cc26:	603b      	str	r3, [r7, #0]
  40cc28:	460b      	mov	r3, r1
  40cc2a:	817b      	strh	r3, [r7, #10]
	int result=0;
  40cc2c:	2300      	movs	r3, #0
  40cc2e:	637b      	str	r3, [r7, #52]	; 0x34
	unsigned int bytesWritten = 0;
  40cc30:	2300      	movs	r3, #0
  40cc32:	633b      	str	r3, [r7, #48]	; 0x30
	unsigned int thisLen;
	unsigned char i, dat[INV_MAX_SERIAL_READ] = {0};
  40cc34:	f107 0318 	add.w	r3, r7, #24
  40cc38:	2200      	movs	r2, #0
  40cc3a:	601a      	str	r2, [r3, #0]
  40cc3c:	605a      	str	r2, [r3, #4]
  40cc3e:	609a      	str	r2, [r3, #8]
  40cc40:	60da      	str	r2, [r3, #12]
	unsigned char power_state = inv_icm20648_get_chip_power_state(s);
  40cc42:	68f8      	ldr	r0, [r7, #12]
  40cc44:	4b67      	ldr	r3, [pc, #412]	; (40cde4 <inv_icm20648_read_mems+0x1c8>)
  40cc46:	4798      	blx	r3
  40cc48:	4603      	mov	r3, r0
  40cc4a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
	unsigned char lBankSelected;
	unsigned char lStartAddrSelected;

	if(!data)
  40cc4e:	683b      	ldr	r3, [r7, #0]
  40cc50:	2b00      	cmp	r3, #0
  40cc52:	d102      	bne.n	40cc5a <inv_icm20648_read_mems+0x3e>
		return -1;
  40cc54:	f04f 33ff 	mov.w	r3, #4294967295
  40cc58:	e0c0      	b.n	40cddc <inv_icm20648_read_mems+0x1c0>

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40cc5a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  40cc5e:	f003 0301 	and.w	r3, r3, #1
  40cc62:	2b00      	cmp	r3, #0
  40cc64:	d105      	bne.n	40cc72 <inv_icm20648_read_mems+0x56>
		result = inv_icm20648_set_chip_power_state(s, CHIP_AWAKE, 1);
  40cc66:	2201      	movs	r2, #1
  40cc68:	2101      	movs	r1, #1
  40cc6a:	68f8      	ldr	r0, [r7, #12]
  40cc6c:	4b5e      	ldr	r3, [pc, #376]	; (40cde8 <inv_icm20648_read_mems+0x1cc>)
  40cc6e:	4798      	blx	r3
  40cc70:	6378      	str	r0, [r7, #52]	; 0x34

	if(check_reg_access_lp_disable(s, reg))
  40cc72:	897b      	ldrh	r3, [r7, #10]
  40cc74:	4619      	mov	r1, r3
  40cc76:	68f8      	ldr	r0, [r7, #12]
  40cc78:	4b5c      	ldr	r3, [pc, #368]	; (40cdec <inv_icm20648_read_mems+0x1d0>)
  40cc7a:	4798      	blx	r3
  40cc7c:	4603      	mov	r3, r0
  40cc7e:	2b00      	cmp	r3, #0
  40cc80:	d008      	beq.n	40cc94 <inv_icm20648_read_mems+0x78>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 0);
  40cc82:	2200      	movs	r2, #0
  40cc84:	2102      	movs	r1, #2
  40cc86:	68f8      	ldr	r0, [r7, #12]
  40cc88:	4b57      	ldr	r3, [pc, #348]	; (40cde8 <inv_icm20648_read_mems+0x1cc>)
  40cc8a:	4798      	blx	r3
  40cc8c:	4602      	mov	r2, r0
  40cc8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cc90:	4313      	orrs	r3, r2
  40cc92:	637b      	str	r3, [r7, #52]	; 0x34

	result |= inv_set_bank(s, 0);
  40cc94:	2100      	movs	r1, #0
  40cc96:	68f8      	ldr	r0, [r7, #12]
  40cc98:	4b55      	ldr	r3, [pc, #340]	; (40cdf0 <inv_icm20648_read_mems+0x1d4>)
  40cc9a:	4798      	blx	r3
  40cc9c:	4602      	mov	r2, r0
  40cc9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cca0:	4313      	orrs	r3, r2
  40cca2:	637b      	str	r3, [r7, #52]	; 0x34

	lBankSelected = (reg >> 8);
  40cca4:	897b      	ldrh	r3, [r7, #10]
  40cca6:	0a1b      	lsrs	r3, r3, #8
  40cca8:	b29b      	uxth	r3, r3
  40ccaa:	b2db      	uxtb	r3, r3
  40ccac:	75fb      	strb	r3, [r7, #23]
	if (lBankSelected != s->lLastBankSelected)
  40ccae:	68fb      	ldr	r3, [r7, #12]
  40ccb0:	f893 24dc 	ldrb.w	r2, [r3, #1244]	; 0x4dc
  40ccb4:	7dfb      	ldrb	r3, [r7, #23]
  40ccb6:	429a      	cmp	r2, r3
  40ccb8:	d05b      	beq.n	40cd72 <inv_icm20648_read_mems+0x156>
	{
		result |= inv_icm20648_write_reg(s, REG_MEM_BANK_SEL, &lBankSelected, 1);
  40ccba:	f107 0217 	add.w	r2, r7, #23
  40ccbe:	2301      	movs	r3, #1
  40ccc0:	217e      	movs	r1, #126	; 0x7e
  40ccc2:	68f8      	ldr	r0, [r7, #12]
  40ccc4:	4c4b      	ldr	r4, [pc, #300]	; (40cdf4 <inv_icm20648_read_mems+0x1d8>)
  40ccc6:	47a0      	blx	r4
  40ccc8:	4602      	mov	r2, r0
  40ccca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cccc:	4313      	orrs	r3, r2
  40ccce:	637b      	str	r3, [r7, #52]	; 0x34
		if (result)
  40ccd0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ccd2:	2b00      	cmp	r3, #0
  40ccd4:	d001      	beq.n	40ccda <inv_icm20648_read_mems+0xbe>
			return result;
  40ccd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ccd8:	e080      	b.n	40cddc <inv_icm20648_read_mems+0x1c0>
		s->lLastBankSelected = lBankSelected;
  40ccda:	7dfa      	ldrb	r2, [r7, #23]
  40ccdc:	68fb      	ldr	r3, [r7, #12]
  40ccde:	f883 24dc 	strb.w	r2, [r3, #1244]	; 0x4dc
	}

	while (bytesWritten < length) 
  40cce2:	e046      	b.n	40cd72 <inv_icm20648_read_mems+0x156>
	{
		lStartAddrSelected = (reg & 0xff);
  40cce4:	897b      	ldrh	r3, [r7, #10]
  40cce6:	b2db      	uxtb	r3, r3
  40cce8:	75bb      	strb	r3, [r7, #22]
		/* Sets the starting read or write address for the selected memory, inside of the selected page (see MEM_SEL Register).
		Contents are changed after read or write of the selected memory.
		This register must be written prior to each access to initialize the register to the proper starting address.
		The address will auto increment during burst transactions.  Two consecutive bursts without re-initializing the start address would skip one address. */
		result |= inv_icm20648_write_reg(s, REG_MEM_START_ADDR, &lStartAddrSelected, 1);
  40ccea:	f107 0216 	add.w	r2, r7, #22
  40ccee:	2301      	movs	r3, #1
  40ccf0:	217c      	movs	r1, #124	; 0x7c
  40ccf2:	68f8      	ldr	r0, [r7, #12]
  40ccf4:	4c3f      	ldr	r4, [pc, #252]	; (40cdf4 <inv_icm20648_read_mems+0x1d8>)
  40ccf6:	47a0      	blx	r4
  40ccf8:	4602      	mov	r2, r0
  40ccfa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ccfc:	4313      	orrs	r3, r2
  40ccfe:	637b      	str	r3, [r7, #52]	; 0x34
		if (result)
  40cd00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cd02:	2b00      	cmp	r3, #0
  40cd04:	d001      	beq.n	40cd0a <inv_icm20648_read_mems+0xee>
			return result;
  40cd06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cd08:	e068      	b.n	40cddc <inv_icm20648_read_mems+0x1c0>

		thisLen = min(INV_MAX_SERIAL_READ, length-bytesWritten);
  40cd0a:	687a      	ldr	r2, [r7, #4]
  40cd0c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40cd0e:	1ad3      	subs	r3, r2, r3
  40cd10:	2b10      	cmp	r3, #16
  40cd12:	bf28      	it	cs
  40cd14:	2310      	movcs	r3, #16
  40cd16:	62bb      	str	r3, [r7, #40]	; 0x28
		/* Write data */
		if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40cd18:	68fb      	ldr	r3, [r7, #12]
  40cd1a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40cd1e:	2b02      	cmp	r3, #2
  40cd20:	d10d      	bne.n	40cd3e <inv_icm20648_read_mems+0x122>
			result |= inv_icm20648_read_reg(s, REG_MEM_R_W, &dat[bytesWritten], thisLen);
  40cd22:	f107 0218 	add.w	r2, r7, #24
  40cd26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40cd28:	441a      	add	r2, r3
  40cd2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cd2c:	217d      	movs	r1, #125	; 0x7d
  40cd2e:	68f8      	ldr	r0, [r7, #12]
  40cd30:	4c31      	ldr	r4, [pc, #196]	; (40cdf8 <inv_icm20648_read_mems+0x1dc>)
  40cd32:	47a0      	blx	r4
  40cd34:	4602      	mov	r2, r0
  40cd36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cd38:	4313      	orrs	r3, r2
  40cd3a:	637b      	str	r3, [r7, #52]	; 0x34
  40cd3c:	e00b      	b.n	40cd56 <inv_icm20648_read_mems+0x13a>
		} else {
			result |= inv_icm20648_read_reg(s, REG_MEM_R_W, &data[bytesWritten], thisLen);
  40cd3e:	683a      	ldr	r2, [r7, #0]
  40cd40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40cd42:	441a      	add	r2, r3
  40cd44:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cd46:	217d      	movs	r1, #125	; 0x7d
  40cd48:	68f8      	ldr	r0, [r7, #12]
  40cd4a:	4c2b      	ldr	r4, [pc, #172]	; (40cdf8 <inv_icm20648_read_mems+0x1dc>)
  40cd4c:	47a0      	blx	r4
  40cd4e:	4602      	mov	r2, r0
  40cd50:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cd52:	4313      	orrs	r3, r2
  40cd54:	637b      	str	r3, [r7, #52]	; 0x34
		}
		if (result)
  40cd56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cd58:	2b00      	cmp	r3, #0
  40cd5a:	d001      	beq.n	40cd60 <inv_icm20648_read_mems+0x144>
			return result;
  40cd5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cd5e:	e03d      	b.n	40cddc <inv_icm20648_read_mems+0x1c0>

		bytesWritten += thisLen;
  40cd60:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40cd62:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cd64:	4413      	add	r3, r2
  40cd66:	633b      	str	r3, [r7, #48]	; 0x30
		reg += thisLen;
  40cd68:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40cd6a:	b29a      	uxth	r2, r3
  40cd6c:	897b      	ldrh	r3, [r7, #10]
  40cd6e:	4413      	add	r3, r2
  40cd70:	817b      	strh	r3, [r7, #10]
	while (bytesWritten < length) 
  40cd72:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40cd74:	687b      	ldr	r3, [r7, #4]
  40cd76:	429a      	cmp	r2, r3
  40cd78:	d3b4      	bcc.n	40cce4 <inv_icm20648_read_mems+0xc8>
	}

	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40cd7a:	68fb      	ldr	r3, [r7, #12]
  40cd7c:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40cd80:	2b02      	cmp	r3, #2
  40cd82:	d119      	bne.n	40cdb8 <inv_icm20648_read_mems+0x19c>
		for (i=0; i< length; i++) {
  40cd84:	2300      	movs	r3, #0
  40cd86:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  40cd8a:	e010      	b.n	40cdae <inv_icm20648_read_mems+0x192>
			*data= dat[i];
  40cd8c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40cd90:	f107 0238 	add.w	r2, r7, #56	; 0x38
  40cd94:	4413      	add	r3, r2
  40cd96:	f813 2c20 	ldrb.w	r2, [r3, #-32]
  40cd9a:	683b      	ldr	r3, [r7, #0]
  40cd9c:	701a      	strb	r2, [r3, #0]
			data++;
  40cd9e:	683b      	ldr	r3, [r7, #0]
  40cda0:	3301      	adds	r3, #1
  40cda2:	603b      	str	r3, [r7, #0]
		for (i=0; i< length; i++) {
  40cda4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40cda8:	3301      	adds	r3, #1
  40cdaa:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  40cdae:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
  40cdb2:	687b      	ldr	r3, [r7, #4]
  40cdb4:	429a      	cmp	r2, r3
  40cdb6:	d3e9      	bcc.n	40cd8c <inv_icm20648_read_mems+0x170>
		}
	}

	//Enable LP_EN if we disabled it at begining of this function.
	if(check_reg_access_lp_disable(s, reg))
  40cdb8:	897b      	ldrh	r3, [r7, #10]
  40cdba:	4619      	mov	r1, r3
  40cdbc:	68f8      	ldr	r0, [r7, #12]
  40cdbe:	4b0b      	ldr	r3, [pc, #44]	; (40cdec <inv_icm20648_read_mems+0x1d0>)
  40cdc0:	4798      	blx	r3
  40cdc2:	4603      	mov	r3, r0
  40cdc4:	2b00      	cmp	r3, #0
  40cdc6:	d008      	beq.n	40cdda <inv_icm20648_read_mems+0x1be>
		result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40cdc8:	2201      	movs	r2, #1
  40cdca:	2102      	movs	r1, #2
  40cdcc:	68f8      	ldr	r0, [r7, #12]
  40cdce:	4b06      	ldr	r3, [pc, #24]	; (40cde8 <inv_icm20648_read_mems+0x1cc>)
  40cdd0:	4798      	blx	r3
  40cdd2:	4602      	mov	r2, r0
  40cdd4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cdd6:	4313      	orrs	r3, r2
  40cdd8:	637b      	str	r3, [r7, #52]	; 0x34

	return result;
  40cdda:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  40cddc:	4618      	mov	r0, r3
  40cdde:	373c      	adds	r7, #60	; 0x3c
  40cde0:	46bd      	mov	sp, r7
  40cde2:	bd90      	pop	{r4, r7, pc}
  40cde4:	00405ced 	.word	0x00405ced
  40cde8:	00405b8d 	.word	0x00405b8d
  40cdec:	0040c7e1 	.word	0x0040c7e1
  40cdf0:	0040c83d 	.word	0x0040c83d
  40cdf4:	0040c76d 	.word	0x0040c76d
  40cdf8:	0040c741 	.word	0x0040c741

0040cdfc <inv_icm20648_write_mems>:
*  @param[in]   number of byte to be written
*  @param[out]  output data from the register
*  @return     0 if successful.
*/
int inv_icm20648_write_mems(struct inv_icm20648 * s, unsigned short reg, unsigned int length, const unsigned char *data)
{
  40cdfc:	b590      	push	{r4, r7, lr}
  40cdfe:	b08b      	sub	sp, #44	; 0x2c
  40ce00:	af00      	add	r7, sp, #0
  40ce02:	60f8      	str	r0, [r7, #12]
  40ce04:	607a      	str	r2, [r7, #4]
  40ce06:	603b      	str	r3, [r7, #0]
  40ce08:	460b      	mov	r3, r1
  40ce0a:	817b      	strh	r3, [r7, #10]
	int result=0;
  40ce0c:	2300      	movs	r3, #0
  40ce0e:	627b      	str	r3, [r7, #36]	; 0x24
	unsigned int bytesWritten = 0;
  40ce10:	2300      	movs	r3, #0
  40ce12:	623b      	str	r3, [r7, #32]
	unsigned int thisLen;
	unsigned char lBankSelected;
	unsigned char lStartAddrSelected;

	unsigned char power_state = inv_icm20648_get_chip_power_state(s);
  40ce14:	68f8      	ldr	r0, [r7, #12]
  40ce16:	4b46      	ldr	r3, [pc, #280]	; (40cf30 <inv_icm20648_write_mems+0x134>)
  40ce18:	4798      	blx	r3
  40ce1a:	4603      	mov	r3, r0
  40ce1c:	77fb      	strb	r3, [r7, #31]

	if(!data)
  40ce1e:	683b      	ldr	r3, [r7, #0]
  40ce20:	2b00      	cmp	r3, #0
  40ce22:	d102      	bne.n	40ce2a <inv_icm20648_write_mems+0x2e>
		return -1;
  40ce24:	f04f 33ff 	mov.w	r3, #4294967295
  40ce28:	e07d      	b.n	40cf26 <inv_icm20648_write_mems+0x12a>

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40ce2a:	7ffb      	ldrb	r3, [r7, #31]
  40ce2c:	f003 0301 	and.w	r3, r3, #1
  40ce30:	2b00      	cmp	r3, #0
  40ce32:	d105      	bne.n	40ce40 <inv_icm20648_write_mems+0x44>
		result = inv_icm20648_set_chip_power_state(s, CHIP_AWAKE, 1);
  40ce34:	2201      	movs	r2, #1
  40ce36:	2101      	movs	r1, #1
  40ce38:	68f8      	ldr	r0, [r7, #12]
  40ce3a:	4b3e      	ldr	r3, [pc, #248]	; (40cf34 <inv_icm20648_write_mems+0x138>)
  40ce3c:	4798      	blx	r3
  40ce3e:	6278      	str	r0, [r7, #36]	; 0x24

	result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 0);
  40ce40:	2200      	movs	r2, #0
  40ce42:	2102      	movs	r1, #2
  40ce44:	68f8      	ldr	r0, [r7, #12]
  40ce46:	4b3b      	ldr	r3, [pc, #236]	; (40cf34 <inv_icm20648_write_mems+0x138>)
  40ce48:	4798      	blx	r3
  40ce4a:	4602      	mov	r2, r0
  40ce4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ce4e:	4313      	orrs	r3, r2
  40ce50:	627b      	str	r3, [r7, #36]	; 0x24

	result |= inv_set_bank(s, 0);
  40ce52:	2100      	movs	r1, #0
  40ce54:	68f8      	ldr	r0, [r7, #12]
  40ce56:	4b38      	ldr	r3, [pc, #224]	; (40cf38 <inv_icm20648_write_mems+0x13c>)
  40ce58:	4798      	blx	r3
  40ce5a:	4602      	mov	r2, r0
  40ce5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ce5e:	4313      	orrs	r3, r2
  40ce60:	627b      	str	r3, [r7, #36]	; 0x24

	lBankSelected = (reg >> 8);
  40ce62:	897b      	ldrh	r3, [r7, #10]
  40ce64:	0a1b      	lsrs	r3, r3, #8
  40ce66:	b29b      	uxth	r3, r3
  40ce68:	b2db      	uxtb	r3, r3
  40ce6a:	75fb      	strb	r3, [r7, #23]
	if (lBankSelected != s->lLastBankSelected)
  40ce6c:	68fb      	ldr	r3, [r7, #12]
  40ce6e:	f893 24dc 	ldrb.w	r2, [r3, #1244]	; 0x4dc
  40ce72:	7dfb      	ldrb	r3, [r7, #23]
  40ce74:	429a      	cmp	r2, r3
  40ce76:	d048      	beq.n	40cf0a <inv_icm20648_write_mems+0x10e>
	{
		result |= inv_icm20648_write_reg(s, REG_MEM_BANK_SEL, &lBankSelected, 1);
  40ce78:	f107 0217 	add.w	r2, r7, #23
  40ce7c:	2301      	movs	r3, #1
  40ce7e:	217e      	movs	r1, #126	; 0x7e
  40ce80:	68f8      	ldr	r0, [r7, #12]
  40ce82:	4c2e      	ldr	r4, [pc, #184]	; (40cf3c <inv_icm20648_write_mems+0x140>)
  40ce84:	47a0      	blx	r4
  40ce86:	4602      	mov	r2, r0
  40ce88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ce8a:	4313      	orrs	r3, r2
  40ce8c:	627b      	str	r3, [r7, #36]	; 0x24
		if (result)
  40ce8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ce90:	2b00      	cmp	r3, #0
  40ce92:	d001      	beq.n	40ce98 <inv_icm20648_write_mems+0x9c>
			return result;
  40ce94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ce96:	e046      	b.n	40cf26 <inv_icm20648_write_mems+0x12a>
		s->lLastBankSelected = lBankSelected;
  40ce98:	7dfa      	ldrb	r2, [r7, #23]
  40ce9a:	68fb      	ldr	r3, [r7, #12]
  40ce9c:	f883 24dc 	strb.w	r2, [r3, #1244]	; 0x4dc
	}

	while (bytesWritten < length) 
  40cea0:	e033      	b.n	40cf0a <inv_icm20648_write_mems+0x10e>
	{
		lStartAddrSelected = (reg & 0xff);
  40cea2:	897b      	ldrh	r3, [r7, #10]
  40cea4:	b2db      	uxtb	r3, r3
  40cea6:	75bb      	strb	r3, [r7, #22]
		/* Sets the starting read or write address for the selected memory, inside of the selected page (see MEM_SEL Register).
		Contents are changed after read or write of the selected memory.
		This register must be written prior to each access to initialize the register to the proper starting address.
		The address will auto increment during burst transactions.  Two consecutive bursts without re-initializing the start address would skip one address. */
		result |= inv_icm20648_write_reg(s, REG_MEM_START_ADDR, &lStartAddrSelected, 1);
  40cea8:	f107 0216 	add.w	r2, r7, #22
  40ceac:	2301      	movs	r3, #1
  40ceae:	217c      	movs	r1, #124	; 0x7c
  40ceb0:	68f8      	ldr	r0, [r7, #12]
  40ceb2:	4c22      	ldr	r4, [pc, #136]	; (40cf3c <inv_icm20648_write_mems+0x140>)
  40ceb4:	47a0      	blx	r4
  40ceb6:	4602      	mov	r2, r0
  40ceb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ceba:	4313      	orrs	r3, r2
  40cebc:	627b      	str	r3, [r7, #36]	; 0x24
		if (result)
  40cebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cec0:	2b00      	cmp	r3, #0
  40cec2:	d001      	beq.n	40cec8 <inv_icm20648_write_mems+0xcc>
			return result;
  40cec4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cec6:	e02e      	b.n	40cf26 <inv_icm20648_write_mems+0x12a>

		thisLen = min(INV_MAX_SERIAL_WRITE, length-bytesWritten);
  40cec8:	687a      	ldr	r2, [r7, #4]
  40ceca:	6a3b      	ldr	r3, [r7, #32]
  40cecc:	1ad3      	subs	r3, r2, r3
  40cece:	2b10      	cmp	r3, #16
  40ced0:	bf28      	it	cs
  40ced2:	2310      	movcs	r3, #16
  40ced4:	61bb      	str	r3, [r7, #24]

		/* Write data */ 
		result |= inv_icm20648_write_reg(s, REG_MEM_R_W, &data[bytesWritten], thisLen);
  40ced6:	683a      	ldr	r2, [r7, #0]
  40ced8:	6a3b      	ldr	r3, [r7, #32]
  40ceda:	441a      	add	r2, r3
  40cedc:	69bb      	ldr	r3, [r7, #24]
  40cede:	217d      	movs	r1, #125	; 0x7d
  40cee0:	68f8      	ldr	r0, [r7, #12]
  40cee2:	4c16      	ldr	r4, [pc, #88]	; (40cf3c <inv_icm20648_write_mems+0x140>)
  40cee4:	47a0      	blx	r4
  40cee6:	4602      	mov	r2, r0
  40cee8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ceea:	4313      	orrs	r3, r2
  40ceec:	627b      	str	r3, [r7, #36]	; 0x24
		if (result)
  40ceee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cef0:	2b00      	cmp	r3, #0
  40cef2:	d001      	beq.n	40cef8 <inv_icm20648_write_mems+0xfc>
			return result;
  40cef4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cef6:	e016      	b.n	40cf26 <inv_icm20648_write_mems+0x12a>

		bytesWritten += thisLen;
  40cef8:	6a3a      	ldr	r2, [r7, #32]
  40cefa:	69bb      	ldr	r3, [r7, #24]
  40cefc:	4413      	add	r3, r2
  40cefe:	623b      	str	r3, [r7, #32]
		reg += thisLen;
  40cf00:	69bb      	ldr	r3, [r7, #24]
  40cf02:	b29a      	uxth	r2, r3
  40cf04:	897b      	ldrh	r3, [r7, #10]
  40cf06:	4413      	add	r3, r2
  40cf08:	817b      	strh	r3, [r7, #10]
	while (bytesWritten < length) 
  40cf0a:	6a3a      	ldr	r2, [r7, #32]
  40cf0c:	687b      	ldr	r3, [r7, #4]
  40cf0e:	429a      	cmp	r2, r3
  40cf10:	d3c7      	bcc.n	40cea2 <inv_icm20648_write_mems+0xa6>
	}

	//Enable LP_EN since we disabled it at begining of this function.
	result |= inv_icm20648_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40cf12:	2201      	movs	r2, #1
  40cf14:	2102      	movs	r1, #2
  40cf16:	68f8      	ldr	r0, [r7, #12]
  40cf18:	4b06      	ldr	r3, [pc, #24]	; (40cf34 <inv_icm20648_write_mems+0x138>)
  40cf1a:	4798      	blx	r3
  40cf1c:	4602      	mov	r2, r0
  40cf1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cf20:	4313      	orrs	r3, r2
  40cf22:	627b      	str	r3, [r7, #36]	; 0x24

	return result;
  40cf24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  40cf26:	4618      	mov	r0, r3
  40cf28:	372c      	adds	r7, #44	; 0x2c
  40cf2a:	46bd      	mov	sp, r7
  40cf2c:	bd90      	pop	{r4, r7, pc}
  40cf2e:	bf00      	nop
  40cf30:	00405ced 	.word	0x00405ced
  40cf34:	00405b8d 	.word	0x00405b8d
  40cf38:	0040c83d 	.word	0x0040c83d
  40cf3c:	0040c76d 	.word	0x0040c76d

0040cf40 <inv_icm20648_write_single_mems_reg_core>:
*  @param[in]  Register address
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20648_write_single_mems_reg_core(struct inv_icm20648 * s, uint16_t reg, const uint8_t data)
{
  40cf40:	b590      	push	{r4, r7, lr}
  40cf42:	b085      	sub	sp, #20
  40cf44:	af00      	add	r7, sp, #0
  40cf46:	6078      	str	r0, [r7, #4]
  40cf48:	460b      	mov	r3, r1
  40cf4a:	807b      	strh	r3, [r7, #2]
  40cf4c:	4613      	mov	r3, r2
  40cf4e:	707b      	strb	r3, [r7, #1]
	int result = 0;
  40cf50:	2300      	movs	r3, #0
  40cf52:	60fb      	str	r3, [r7, #12]
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40cf54:	887b      	ldrh	r3, [r7, #2]
  40cf56:	b2db      	uxtb	r3, r3
  40cf58:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40cf5c:	72fb      	strb	r3, [r7, #11]

	result |= inv_set_bank(s, reg >> 7);
  40cf5e:	887b      	ldrh	r3, [r7, #2]
  40cf60:	09db      	lsrs	r3, r3, #7
  40cf62:	b29b      	uxth	r3, r3
  40cf64:	b2db      	uxtb	r3, r3
  40cf66:	4619      	mov	r1, r3
  40cf68:	6878      	ldr	r0, [r7, #4]
  40cf6a:	4b0a      	ldr	r3, [pc, #40]	; (40cf94 <inv_icm20648_write_single_mems_reg_core+0x54>)
  40cf6c:	4798      	blx	r3
  40cf6e:	4602      	mov	r2, r0
  40cf70:	68fb      	ldr	r3, [r7, #12]
  40cf72:	4313      	orrs	r3, r2
  40cf74:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20648_write_reg(s, regOnly, &data, 1);
  40cf76:	1c7a      	adds	r2, r7, #1
  40cf78:	7af9      	ldrb	r1, [r7, #11]
  40cf7a:	2301      	movs	r3, #1
  40cf7c:	6878      	ldr	r0, [r7, #4]
  40cf7e:	4c06      	ldr	r4, [pc, #24]	; (40cf98 <inv_icm20648_write_single_mems_reg_core+0x58>)
  40cf80:	47a0      	blx	r4
  40cf82:	4602      	mov	r2, r0
  40cf84:	68fb      	ldr	r3, [r7, #12]
  40cf86:	4313      	orrs	r3, r2
  40cf88:	60fb      	str	r3, [r7, #12]

	return result;
  40cf8a:	68fb      	ldr	r3, [r7, #12]
}
  40cf8c:	4618      	mov	r0, r3
  40cf8e:	3714      	adds	r7, #20
  40cf90:	46bd      	mov	sp, r7
  40cf92:	bd90      	pop	{r4, r7, pc}
  40cf94:	0040c83d 	.word	0x0040c83d
  40cf98:	0040c76d 	.word	0x0040c76d

0040cf9c <inv_sensor_str>:
#include "SensorTypes.h"

#include <assert.h>

const char * inv_sensor_2str(int sensor)
{
  40cf9c:	b480      	push	{r7}
  40cf9e:	b085      	sub	sp, #20
  40cfa0:	af00      	add	r7, sp, #0
  40cfa2:	6078      	str	r0, [r7, #4]
		{ "SENSOR_PRED_QUAT_0",            "SENSOR_PRED_QUAT_0_WU"},
		{ "SENSOR_PRED_QUAT_1",            "SENSOR_PRED_QUAT_1_WU"},
		{ "SENSOR_OIS_1",                  "SENSOR_OIS_1_WU"},
	};

	if (INV_SENSOR_IS_VALID(sensor)) {
  40cfa4:	687b      	ldr	r3, [r7, #4]
  40cfa6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  40cfaa:	2b43      	cmp	r3, #67	; 0x43
  40cfac:	d811      	bhi.n	40cfd2 <inv_sensor_str+0x36>
		const char * s = sensor_str[INV_SENSOR_ID_TO_TYPE(sensor)][INV_SENSOR_IS_WU(sensor)];
  40cfae:	687b      	ldr	r3, [r7, #4]
  40cfb0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  40cfb4:	687a      	ldr	r2, [r7, #4]
  40cfb6:	0fd2      	lsrs	r2, r2, #31
  40cfb8:	b2d2      	uxtb	r2, r2
  40cfba:	4611      	mov	r1, r2
  40cfbc:	4a08      	ldr	r2, [pc, #32]	; (40cfe0 <inv_sensor_str+0x44>)
  40cfbe:	005b      	lsls	r3, r3, #1
  40cfc0:	440b      	add	r3, r1
  40cfc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40cfc6:	60fb      	str	r3, [r7, #12]

		assert(s != 0); // we forgot to update the array after adding a sensor!

		if(s != 0)
  40cfc8:	68fb      	ldr	r3, [r7, #12]
  40cfca:	2b00      	cmp	r3, #0
  40cfcc:	d001      	beq.n	40cfd2 <inv_sensor_str+0x36>
			return s;
  40cfce:	68fb      	ldr	r3, [r7, #12]
  40cfd0:	e000      	b.n	40cfd4 <inv_sensor_str+0x38>
	}

	return "";
  40cfd2:	4b04      	ldr	r3, [pc, #16]	; (40cfe4 <inv_sensor_str+0x48>)
}
  40cfd4:	4618      	mov	r0, r3
  40cfd6:	3714      	adds	r7, #20
  40cfd8:	46bd      	mov	sp, r7
  40cfda:	f85d 7b04 	ldr.w	r7, [sp], #4
  40cfde:	4770      	bx	lr
  40cfe0:	20000134 	.word	0x20000134
  40cfe4:	0041c128 	.word	0x0041c128

0040cfe8 <DynProtocol_decodeVect16QxToQy>:
#define PROTOCOL_HEADING_ACCURACY_PRECISION   7

#define DYN_PROTOCOL_QX_TO_QY(value, qx, qy)	((qx >= qy) ? (value >> (qx-qy)) : (value << (qy-qx)) )

static inline int DynProtocol_decodeVect16QxToQy(const uint8_t * bytes, unsigned len, int qxIn, int qxOut,  int32_t * out)
{
  40cfe8:	b480      	push	{r7}
  40cfea:	b087      	sub	sp, #28
  40cfec:	af00      	add	r7, sp, #0
  40cfee:	60f8      	str	r0, [r7, #12]
  40cff0:	60b9      	str	r1, [r7, #8]
  40cff2:	607a      	str	r2, [r7, #4]
  40cff4:	603b      	str	r3, [r7, #0]
	unsigned i;
	for(i = 0; i < len; ++i) {
  40cff6:	2300      	movs	r3, #0
  40cff8:	617b      	str	r3, [r7, #20]
  40cffa:	e027      	b.n	40d04c <DynProtocol_decodeVect16QxToQy+0x64>
		int32_t x = (int32_t)(((int8_t *)bytes)[2*i+1] << 8) | bytes[2*i];
  40cffc:	697b      	ldr	r3, [r7, #20]
  40cffe:	005b      	lsls	r3, r3, #1
  40d000:	3301      	adds	r3, #1
  40d002:	68fa      	ldr	r2, [r7, #12]
  40d004:	4413      	add	r3, r2
  40d006:	f993 3000 	ldrsb.w	r3, [r3]
  40d00a:	021b      	lsls	r3, r3, #8
  40d00c:	697a      	ldr	r2, [r7, #20]
  40d00e:	0052      	lsls	r2, r2, #1
  40d010:	68f9      	ldr	r1, [r7, #12]
  40d012:	440a      	add	r2, r1
  40d014:	7812      	ldrb	r2, [r2, #0]
  40d016:	4313      	orrs	r3, r2
  40d018:	613b      	str	r3, [r7, #16]
		out[i] = (int32_t)DYN_PROTOCOL_QX_TO_QY(x, qxIn ,qxOut);
  40d01a:	697b      	ldr	r3, [r7, #20]
  40d01c:	009b      	lsls	r3, r3, #2
  40d01e:	6a3a      	ldr	r2, [r7, #32]
  40d020:	441a      	add	r2, r3
  40d022:	6879      	ldr	r1, [r7, #4]
  40d024:	683b      	ldr	r3, [r7, #0]
  40d026:	4299      	cmp	r1, r3
  40d028:	db06      	blt.n	40d038 <DynProtocol_decodeVect16QxToQy+0x50>
  40d02a:	6879      	ldr	r1, [r7, #4]
  40d02c:	683b      	ldr	r3, [r7, #0]
  40d02e:	1acb      	subs	r3, r1, r3
  40d030:	6939      	ldr	r1, [r7, #16]
  40d032:	fa41 f303 	asr.w	r3, r1, r3
  40d036:	e005      	b.n	40d044 <DynProtocol_decodeVect16QxToQy+0x5c>
  40d038:	6839      	ldr	r1, [r7, #0]
  40d03a:	687b      	ldr	r3, [r7, #4]
  40d03c:	1acb      	subs	r3, r1, r3
  40d03e:	6939      	ldr	r1, [r7, #16]
  40d040:	fa01 f303 	lsl.w	r3, r1, r3
  40d044:	6013      	str	r3, [r2, #0]
	for(i = 0; i < len; ++i) {
  40d046:	697b      	ldr	r3, [r7, #20]
  40d048:	3301      	adds	r3, #1
  40d04a:	617b      	str	r3, [r7, #20]
  40d04c:	697a      	ldr	r2, [r7, #20]
  40d04e:	68bb      	ldr	r3, [r7, #8]
  40d050:	429a      	cmp	r2, r3
  40d052:	d3d3      	bcc.n	40cffc <DynProtocol_decodeVect16QxToQy+0x14>
	}

	return 2*len;
  40d054:	68bb      	ldr	r3, [r7, #8]
  40d056:	005b      	lsls	r3, r3, #1
}
  40d058:	4618      	mov	r0, r3
  40d05a:	371c      	adds	r7, #28
  40d05c:	46bd      	mov	sp, r7
  40d05e:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d062:	4770      	bx	lr

0040d064 <DynProtocol_encodeQxToQyVect16>:

static inline int DynProtocol_encodeQxToQyVect16(const int32_t * in, unsigned len, int qxIn, int qxOut, uint8_t * bytes)
{
  40d064:	b480      	push	{r7}
  40d066:	b087      	sub	sp, #28
  40d068:	af00      	add	r7, sp, #0
  40d06a:	60f8      	str	r0, [r7, #12]
  40d06c:	60b9      	str	r1, [r7, #8]
  40d06e:	607a      	str	r2, [r7, #4]
  40d070:	603b      	str	r3, [r7, #0]
	unsigned i;
	for(i = 0; i < len; ++i) {
  40d072:	2300      	movs	r3, #0
  40d074:	617b      	str	r3, [r7, #20]
  40d076:	e02f      	b.n	40d0d8 <DynProtocol_encodeQxToQyVect16+0x74>
		int16_t x = (int16_t)DYN_PROTOCOL_QX_TO_QY(in[i], qxIn ,qxOut);
  40d078:	687a      	ldr	r2, [r7, #4]
  40d07a:	683b      	ldr	r3, [r7, #0]
  40d07c:	429a      	cmp	r2, r3
  40d07e:	db0b      	blt.n	40d098 <DynProtocol_encodeQxToQyVect16+0x34>
  40d080:	697b      	ldr	r3, [r7, #20]
  40d082:	009b      	lsls	r3, r3, #2
  40d084:	68fa      	ldr	r2, [r7, #12]
  40d086:	4413      	add	r3, r2
  40d088:	681a      	ldr	r2, [r3, #0]
  40d08a:	6879      	ldr	r1, [r7, #4]
  40d08c:	683b      	ldr	r3, [r7, #0]
  40d08e:	1acb      	subs	r3, r1, r3
  40d090:	fa42 f303 	asr.w	r3, r2, r3
  40d094:	b21b      	sxth	r3, r3
  40d096:	e00a      	b.n	40d0ae <DynProtocol_encodeQxToQyVect16+0x4a>
  40d098:	697b      	ldr	r3, [r7, #20]
  40d09a:	009b      	lsls	r3, r3, #2
  40d09c:	68fa      	ldr	r2, [r7, #12]
  40d09e:	4413      	add	r3, r2
  40d0a0:	681a      	ldr	r2, [r3, #0]
  40d0a2:	6839      	ldr	r1, [r7, #0]
  40d0a4:	687b      	ldr	r3, [r7, #4]
  40d0a6:	1acb      	subs	r3, r1, r3
  40d0a8:	fa02 f303 	lsl.w	r3, r2, r3
  40d0ac:	b21b      	sxth	r3, r3
  40d0ae:	827b      	strh	r3, [r7, #18]
		bytes[2*i]   = (uint8_t)((uint16_t)x & 0xFF);
  40d0b0:	697b      	ldr	r3, [r7, #20]
  40d0b2:	005b      	lsls	r3, r3, #1
  40d0b4:	6a3a      	ldr	r2, [r7, #32]
  40d0b6:	4413      	add	r3, r2
  40d0b8:	8a7a      	ldrh	r2, [r7, #18]
  40d0ba:	b2d2      	uxtb	r2, r2
  40d0bc:	701a      	strb	r2, [r3, #0]
		bytes[2*i+1] = (uint8_t)(((uint16_t)x & 0xFF00) >> 8U);
  40d0be:	697b      	ldr	r3, [r7, #20]
  40d0c0:	005b      	lsls	r3, r3, #1
  40d0c2:	3301      	adds	r3, #1
  40d0c4:	6a3a      	ldr	r2, [r7, #32]
  40d0c6:	4413      	add	r3, r2
  40d0c8:	8a7a      	ldrh	r2, [r7, #18]
  40d0ca:	0a12      	lsrs	r2, r2, #8
  40d0cc:	b292      	uxth	r2, r2
  40d0ce:	b2d2      	uxtb	r2, r2
  40d0d0:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < len; ++i) {
  40d0d2:	697b      	ldr	r3, [r7, #20]
  40d0d4:	3301      	adds	r3, #1
  40d0d6:	617b      	str	r3, [r7, #20]
  40d0d8:	697a      	ldr	r2, [r7, #20]
  40d0da:	68bb      	ldr	r3, [r7, #8]
  40d0dc:	429a      	cmp	r2, r3
  40d0de:	d3cb      	bcc.n	40d078 <DynProtocol_encodeQxToQyVect16+0x14>
	}

	return 2*len;
  40d0e0:	68bb      	ldr	r3, [r7, #8]
  40d0e2:	005b      	lsls	r3, r3, #1
}
  40d0e4:	4618      	mov	r0, r3
  40d0e6:	371c      	adds	r7, #28
  40d0e8:	46bd      	mov	sp, r7
  40d0ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d0ee:	4770      	bx	lr

0040d0f0 <DynProtocol_getPrecision>:

static int DynProtocol_getPrecision(DynProtocol_t * self, int sensor_id)
{
  40d0f0:	b480      	push	{r7}
  40d0f2:	b085      	sub	sp, #20
  40d0f4:	af00      	add	r7, sp, #0
  40d0f6:	6078      	str	r0, [r7, #4]
  40d0f8:	6039      	str	r1, [r7, #0]
	int QxIn;

	switch (sensor_id)
  40d0fa:	683b      	ldr	r3, [r7, #0]
  40d0fc:	3b01      	subs	r3, #1
  40d0fe:	2b40      	cmp	r3, #64	; 0x40
  40d100:	f200 809c 	bhi.w	40d23c <DynProtocol_getPrecision+0x14c>
  40d104:	a201      	add	r2, pc, #4	; (adr r2, 40d10c <DynProtocol_getPrecision+0x1c>)
  40d106:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d10a:	bf00      	nop
  40d10c:	0040d211 	.word	0x0040d211
  40d110:	0040d225 	.word	0x0040d225
  40d114:	0040d231 	.word	0x0040d231
  40d118:	0040d21b 	.word	0x0040d21b
  40d11c:	0040d23d 	.word	0x0040d23d
  40d120:	0040d23d 	.word	0x0040d23d
  40d124:	0040d23d 	.word	0x0040d23d
  40d128:	0040d23d 	.word	0x0040d23d
  40d12c:	0040d211 	.word	0x0040d211
  40d130:	0040d211 	.word	0x0040d211
  40d134:	0040d22b 	.word	0x0040d22b
  40d138:	0040d23d 	.word	0x0040d23d
  40d13c:	0040d237 	.word	0x0040d237
  40d140:	0040d225 	.word	0x0040d225
  40d144:	0040d22b 	.word	0x0040d22b
  40d148:	0040d21b 	.word	0x0040d21b
  40d14c:	0040d23d 	.word	0x0040d23d
  40d150:	0040d23d 	.word	0x0040d23d
  40d154:	0040d23d 	.word	0x0040d23d
  40d158:	0040d22b 	.word	0x0040d22b
  40d15c:	0040d23d 	.word	0x0040d23d
  40d160:	0040d23d 	.word	0x0040d23d
  40d164:	0040d23d 	.word	0x0040d23d
  40d168:	0040d23d 	.word	0x0040d23d
  40d16c:	0040d23d 	.word	0x0040d23d
  40d170:	0040d23d 	.word	0x0040d23d
  40d174:	0040d23d 	.word	0x0040d23d
  40d178:	0040d23d 	.word	0x0040d23d
  40d17c:	0040d22b 	.word	0x0040d22b
  40d180:	0040d23d 	.word	0x0040d23d
  40d184:	0040d23d 	.word	0x0040d23d
  40d188:	0040d23d 	.word	0x0040d23d
  40d18c:	0040d23d 	.word	0x0040d23d
  40d190:	0040d23d 	.word	0x0040d23d
  40d194:	0040d23d 	.word	0x0040d23d
  40d198:	0040d23d 	.word	0x0040d23d
  40d19c:	0040d23d 	.word	0x0040d23d
  40d1a0:	0040d23d 	.word	0x0040d23d
  40d1a4:	0040d23d 	.word	0x0040d23d
  40d1a8:	0040d23d 	.word	0x0040d23d
  40d1ac:	0040d23d 	.word	0x0040d23d
  40d1b0:	0040d23d 	.word	0x0040d23d
  40d1b4:	0040d23d 	.word	0x0040d23d
  40d1b8:	0040d23d 	.word	0x0040d23d
  40d1bc:	0040d23d 	.word	0x0040d23d
  40d1c0:	0040d23d 	.word	0x0040d23d
  40d1c4:	0040d23d 	.word	0x0040d23d
  40d1c8:	0040d23d 	.word	0x0040d23d
  40d1cc:	0040d23d 	.word	0x0040d23d
  40d1d0:	0040d23d 	.word	0x0040d23d
  40d1d4:	0040d23d 	.word	0x0040d23d
  40d1d8:	0040d23d 	.word	0x0040d23d
  40d1dc:	0040d23d 	.word	0x0040d23d
  40d1e0:	0040d23d 	.word	0x0040d23d
  40d1e4:	0040d23d 	.word	0x0040d23d
  40d1e8:	0040d23d 	.word	0x0040d23d
  40d1ec:	0040d23d 	.word	0x0040d23d
  40d1f0:	0040d23d 	.word	0x0040d23d
  40d1f4:	0040d23d 	.word	0x0040d23d
  40d1f8:	0040d23d 	.word	0x0040d23d
  40d1fc:	0040d23d 	.word	0x0040d23d
  40d200:	0040d23d 	.word	0x0040d23d
  40d204:	0040d23d 	.word	0x0040d23d
  40d208:	0040d22b 	.word	0x0040d22b
  40d20c:	0040d22b 	.word	0x0040d22b
	{
	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_GRAVITY:
	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
		QxIn = self->precision.acc;
  40d210:	687b      	ldr	r3, [r7, #4]
  40d212:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
  40d216:	60fb      	str	r3, [r7, #12]
		break;
  40d218:	e013      	b.n	40d242 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		QxIn = self->precision.gyro;
  40d21a:	687b      	ldr	r3, [r7, #4]
  40d21c:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40d220:	60fb      	str	r3, [r7, #12]
		break;
  40d222:	e00e      	b.n	40d242 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		QxIn = PROTOCOL_MAGNETOMETER_PRECISION;
  40d224:	2304      	movs	r3, #4
  40d226:	60fb      	str	r3, [r7, #12]
		break;
  40d228:	e00b      	b.n	40d242 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		QxIn = PROTOCOL_QUATERNION_PRECISION;
  40d22a:	230e      	movs	r3, #14
  40d22c:	60fb      	str	r3, [r7, #12]
		break;
  40d22e:	e008      	b.n	40d242 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
		QxIn = PROTOCOL_ORIENTATION_PRECISION;
  40d230:	2306      	movs	r3, #6
  40d232:	60fb      	str	r3, [r7, #12]
		break;
  40d234:	e005      	b.n	40d242 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
		QxIn = PROTOCOL_TEMPERATURE_PRECISION;
  40d236:	2308      	movs	r3, #8
  40d238:	60fb      	str	r3, [r7, #12]
		break;
  40d23a:	e002      	b.n	40d242 <DynProtocol_getPrecision+0x152>
	default:
		QxIn = PROTOCOL_RAW_PRECISION;
  40d23c:	2300      	movs	r3, #0
  40d23e:	60fb      	str	r3, [r7, #12]
		break;
  40d240:	bf00      	nop
	}

	return QxIn;
  40d242:	68fb      	ldr	r3, [r7, #12]
}
  40d244:	4618      	mov	r0, r3
  40d246:	3714      	adds	r7, #20
  40d248:	46bd      	mov	sp, r7
  40d24a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d24e:	4770      	bx	lr

0040d250 <DynProtocol_getPayload>:

static int16_t DynProtocol_getPayload(DynProtocol_t * self)
{
  40d250:	b580      	push	{r7, lr}
  40d252:	b084      	sub	sp, #16
  40d254:	af00      	add	r7, sp, #0
  40d256:	6078      	str	r0, [r7, #4]
	const uint8_t eventType = self->decode_state_machine.event_type;
  40d258:	687b      	ldr	r3, [r7, #4]
  40d25a:	7b1b      	ldrb	r3, [r3, #12]
  40d25c:	73fb      	strb	r3, [r7, #15]
	const enum DynProtocolEid cmdId = (enum DynProtocolEid)self->decode_state_machine.cmd_id;
  40d25e:	687b      	ldr	r3, [r7, #4]
  40d260:	7b9b      	ldrb	r3, [r3, #14]
  40d262:	73bb      	strb	r3, [r7, #14]

	if(self->decode_state_machine.received_size == 0) {
  40d264:	687b      	ldr	r3, [r7, #4]
  40d266:	8a5b      	ldrh	r3, [r3, #18]
  40d268:	2b00      	cmp	r3, #0
  40d26a:	f040 8104 	bne.w	40d476 <DynProtocol_getPayload+0x226>
		switch(eventType) {
  40d26e:	7bfb      	ldrb	r3, [r7, #15]
  40d270:	2b40      	cmp	r3, #64	; 0x40
  40d272:	d07f      	beq.n	40d374 <DynProtocol_getPayload+0x124>
  40d274:	2b80      	cmp	r3, #128	; 0x80
  40d276:	f000 80f7 	beq.w	40d468 <DynProtocol_getPayload+0x218>
  40d27a:	2b00      	cmp	r3, #0
  40d27c:	d000      	beq.n	40d280 <DynProtocol_getPayload+0x30>
				break;
			}
			break;

		default:
			break;
  40d27e:	e1cc      	b.n	40d61a <DynProtocol_getPayload+0x3ca>
			switch(cmdId) {
  40d280:	7bbb      	ldrb	r3, [r7, #14]
  40d282:	2b24      	cmp	r3, #36	; 0x24
  40d284:	d874      	bhi.n	40d370 <DynProtocol_getPayload+0x120>
  40d286:	a201      	add	r2, pc, #4	; (adr r2, 40d28c <DynProtocol_getPayload+0x3c>)
  40d288:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d28c:	0040d321 	.word	0x0040d321
  40d290:	0040d371 	.word	0x0040d371
  40d294:	0040d371 	.word	0x0040d371
  40d298:	0040d371 	.word	0x0040d371
  40d29c:	0040d371 	.word	0x0040d371
  40d2a0:	0040d371 	.word	0x0040d371
  40d2a4:	0040d371 	.word	0x0040d371
  40d2a8:	0040d371 	.word	0x0040d371
  40d2ac:	0040d371 	.word	0x0040d371
  40d2b0:	0040d371 	.word	0x0040d371
  40d2b4:	0040d371 	.word	0x0040d371
  40d2b8:	0040d371 	.word	0x0040d371
  40d2bc:	0040d371 	.word	0x0040d371
  40d2c0:	0040d371 	.word	0x0040d371
  40d2c4:	0040d371 	.word	0x0040d371
  40d2c8:	0040d371 	.word	0x0040d371
  40d2cc:	0040d329 	.word	0x0040d329
  40d2d0:	0040d32d 	.word	0x0040d32d
  40d2d4:	0040d331 	.word	0x0040d331
  40d2d8:	0040d335 	.word	0x0040d335
  40d2dc:	0040d371 	.word	0x0040d371
  40d2e0:	0040d339 	.word	0x0040d339
  40d2e4:	0040d325 	.word	0x0040d325
  40d2e8:	0040d33d 	.word	0x0040d33d
  40d2ec:	0040d371 	.word	0x0040d371
  40d2f0:	0040d341 	.word	0x0040d341
  40d2f4:	0040d345 	.word	0x0040d345
  40d2f8:	0040d349 	.word	0x0040d349
  40d2fc:	0040d34d 	.word	0x0040d34d
  40d300:	0040d351 	.word	0x0040d351
  40d304:	0040d369 	.word	0x0040d369
  40d308:	0040d36d 	.word	0x0040d36d
  40d30c:	0040d355 	.word	0x0040d355
  40d310:	0040d359 	.word	0x0040d359
  40d314:	0040d35d 	.word	0x0040d35d
  40d318:	0040d361 	.word	0x0040d361
  40d31c:	0040d365 	.word	0x0040d365
			case DYN_PROTOCOL_EID_PROTOCOLVERSION:    return 0;
  40d320:	2300      	movs	r3, #0
  40d322:	e180      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_FW_INFO:        return 0;
  40d324:	2300      	movs	r3, #0
  40d326:	e17e      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_WHO_AM_I:           return 0;
  40d328:	2300      	movs	r3, #0
  40d32a:	e17c      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_RESET:              return 0;
  40d32c:	2300      	movs	r3, #0
  40d32e:	e17a      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SETUP:              return 0;
  40d330:	2300      	movs	r3, #0
  40d332:	e178      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_CLEANUP:            return 0;
  40d334:	2300      	movs	r3, #0
  40d336:	e176      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SELF_TEST:          return 1;
  40d338:	2301      	movs	r3, #1
  40d33a:	e174      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_PING_SENSOR:        return 1;
  40d33c:	2301      	movs	r3, #1
  40d33e:	e172      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_START_SENSOR:       return 1;
  40d340:	2301      	movs	r3, #1
  40d342:	e170      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_STOP_SENSOR:        return 1;
  40d344:	2301      	movs	r3, #1
  40d346:	e16e      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:  return 1 + 4;
  40d348:	2305      	movs	r3, #5
  40d34a:	e16c      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT: return 1 + 4;
  40d34c:	2305      	movs	r3, #5
  40d34e:	e16a      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_FLUSH_SENSOR:       return 1;
  40d350:	2301      	movs	r3, #1
  40d352:	e168      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX: return 1 + 1 + (9 * 4); /* sensor + cfg_type + 3x3 q30 */
  40d354:	2326      	movs	r3, #38	; 0x26
  40d356:	e166      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SENSOR_DATA:    return 1;
  40d358:	2301      	movs	r3, #1
  40d35a:	e164      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SW_REG:         return 1 + 1;
  40d35c:	2302      	movs	r3, #2
  40d35e:	e162      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_CFG:     return 1 + 1 + 1 + 64; // sensor + size + cfg_type + max_data_size
  40d360:	2343      	movs	r3, #67	; 0x43
  40d362:	e160      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SENSOR_CFG:     return 1 + 1; // sensor + cfg_type
  40d364:	2302      	movs	r3, #2
  40d366:	e15e      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:    return 1 + 1 + (3 * 2); /* sensor + cfg_type + bias (x,y,z) in Qx */
  40d368:	2308      	movs	r3, #8
  40d36a:	e15c      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:    return 1 + 1; /* sensor + cfg_type */
  40d36c:	2302      	movs	r3, #2
  40d36e:	e15a      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
				break;
  40d370:	bf00      	nop
			break;
  40d372:	e152      	b.n	40d61a <DynProtocol_getPayload+0x3ca>
			switch(cmdId) {
  40d374:	7bbb      	ldrb	r3, [r7, #14]
  40d376:	2b24      	cmp	r3, #36	; 0x24
  40d378:	d874      	bhi.n	40d464 <DynProtocol_getPayload+0x214>
  40d37a:	a201      	add	r2, pc, #4	; (adr r2, 40d380 <DynProtocol_getPayload+0x130>)
  40d37c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d380:	0040d415 	.word	0x0040d415
  40d384:	0040d465 	.word	0x0040d465
  40d388:	0040d465 	.word	0x0040d465
  40d38c:	0040d465 	.word	0x0040d465
  40d390:	0040d465 	.word	0x0040d465
  40d394:	0040d465 	.word	0x0040d465
  40d398:	0040d465 	.word	0x0040d465
  40d39c:	0040d465 	.word	0x0040d465
  40d3a0:	0040d465 	.word	0x0040d465
  40d3a4:	0040d465 	.word	0x0040d465
  40d3a8:	0040d465 	.word	0x0040d465
  40d3ac:	0040d465 	.word	0x0040d465
  40d3b0:	0040d465 	.word	0x0040d465
  40d3b4:	0040d465 	.word	0x0040d465
  40d3b8:	0040d465 	.word	0x0040d465
  40d3bc:	0040d465 	.word	0x0040d465
  40d3c0:	0040d41d 	.word	0x0040d41d
  40d3c4:	0040d421 	.word	0x0040d421
  40d3c8:	0040d425 	.word	0x0040d425
  40d3cc:	0040d429 	.word	0x0040d429
  40d3d0:	0040d465 	.word	0x0040d465
  40d3d4:	0040d42d 	.word	0x0040d42d
  40d3d8:	0040d419 	.word	0x0040d419
  40d3dc:	0040d431 	.word	0x0040d431
  40d3e0:	0040d465 	.word	0x0040d465
  40d3e4:	0040d435 	.word	0x0040d435
  40d3e8:	0040d439 	.word	0x0040d439
  40d3ec:	0040d43d 	.word	0x0040d43d
  40d3f0:	0040d441 	.word	0x0040d441
  40d3f4:	0040d445 	.word	0x0040d445
  40d3f8:	0040d45d 	.word	0x0040d45d
  40d3fc:	0040d461 	.word	0x0040d461
  40d400:	0040d449 	.word	0x0040d449
  40d404:	0040d44d 	.word	0x0040d44d
  40d408:	0040d451 	.word	0x0040d451
  40d40c:	0040d455 	.word	0x0040d455
  40d410:	0040d459 	.word	0x0040d459
			case DYN_PROTOCOL_EID_PROTOCOLVERSION:    return 16;
  40d414:	2310      	movs	r3, #16
  40d416:	e106      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_FW_INFO:        return 16;
  40d418:	2310      	movs	r3, #16
  40d41a:	e104      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_WHO_AM_I:           return 1;
  40d41c:	2301      	movs	r3, #1
  40d41e:	e102      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_RESET:              return 1;
  40d420:	2301      	movs	r3, #1
  40d422:	e100      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SETUP:              return 1;
  40d424:	2301      	movs	r3, #1
  40d426:	e0fe      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_CLEANUP:            return 1;
  40d428:	2301      	movs	r3, #1
  40d42a:	e0fc      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SELF_TEST:          return 1;
  40d42c:	2301      	movs	r3, #1
  40d42e:	e0fa      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_PING_SENSOR:        return 1;
  40d430:	2301      	movs	r3, #1
  40d432:	e0f8      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_START_SENSOR:       return 1;
  40d434:	2301      	movs	r3, #1
  40d436:	e0f6      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_STOP_SENSOR:        return 1;
  40d438:	2301      	movs	r3, #1
  40d43a:	e0f4      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:  return 1;
  40d43c:	2301      	movs	r3, #1
  40d43e:	e0f2      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT: return 1;
  40d440:	2301      	movs	r3, #1
  40d442:	e0f0      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_FLUSH_SENSOR:       return 1;
  40d444:	2301      	movs	r3, #1
  40d446:	e0ee      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX: return 1;
  40d448:	2301      	movs	r3, #1
  40d44a:	e0ec      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SENSOR_DATA:    return 1+1+1+4+64; // rc + sensorStatus + sensorId + timestamp[0-3] + max_data_size
  40d44c:	2347      	movs	r3, #71	; 0x47
  40d44e:	e0ea      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SW_REG:         return 1;
  40d450:	2301      	movs	r3, #1
  40d452:	e0e8      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_CFG:     return 1;
  40d454:	2301      	movs	r3, #1
  40d456:	e0e6      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SENSOR_CFG:     return 1+1+1+1+64; // rc + sensor + size + cfg_type + max_data_size
  40d458:	2344      	movs	r3, #68	; 0x44
  40d45a:	e0e4      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:    return 1; /* rc */
  40d45c:	2301      	movs	r3, #1
  40d45e:	e0e2      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:    return 1 + 1 + 1 + (3 * 2); /* rc + precision + cfg_type + bias (x,y,z) in Qx */
  40d460:	2309      	movs	r3, #9
  40d462:	e0e0      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
				break;
  40d464:	bf00      	nop
			break;
  40d466:	e0d8      	b.n	40d61a <DynProtocol_getPayload+0x3ca>
			switch(cmdId) {
  40d468:	7bbb      	ldrb	r3, [r7, #14]
  40d46a:	2b30      	cmp	r3, #48	; 0x30
  40d46c:	d001      	beq.n	40d472 <DynProtocol_getPayload+0x222>
				break;
  40d46e:	bf00      	nop
			break;
  40d470:	e0d3      	b.n	40d61a <DynProtocol_getPayload+0x3ca>
				return 2;
  40d472:	2302      	movs	r3, #2
  40d474:	e0d7      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
		/* Payload content : 
		 *   - byte 0 <sensor status> 
		 *   - byte 1 <sensor id> 
		 *   - <sensor data> 
		 */
		const uint8_t sensor_id = self->decode_state_machine.tmp_buffer[1];
  40d476:	687b      	ldr	r3, [r7, #4]
  40d478:	7d5b      	ldrb	r3, [r3, #21]
  40d47a:	737b      	strb	r3, [r7, #13]

		switch(eventType) {
  40d47c:	7bfb      	ldrb	r3, [r7, #15]
  40d47e:	2b80      	cmp	r3, #128	; 0x80
  40d480:	f040 80c7 	bne.w	40d612 <DynProtocol_getPayload+0x3c2>
		case EVENT_TYPE_ASYNC:
			switch(sensor_id) {
  40d484:	7b7b      	ldrb	r3, [r7, #13]
  40d486:	2b41      	cmp	r3, #65	; 0x41
  40d488:	f200 80c0 	bhi.w	40d60c <DynProtocol_getPayload+0x3bc>
  40d48c:	a201      	add	r2, pc, #4	; (adr r2, 40d494 <DynProtocol_getPayload+0x244>)
  40d48e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d492:	bf00      	nop
  40d494:	0040d59d 	.word	0x0040d59d
  40d498:	0040d5e1 	.word	0x0040d5e1
  40d49c:	0040d5e1 	.word	0x0040d5e1
  40d4a0:	0040d5dd 	.word	0x0040d5dd
  40d4a4:	0040d5e1 	.word	0x0040d5e1
  40d4a8:	0040d5f1 	.word	0x0040d5f1
  40d4ac:	0040d5f1 	.word	0x0040d5f1
  40d4b0:	0040d60d 	.word	0x0040d60d
  40d4b4:	0040d5fd 	.word	0x0040d5fd
  40d4b8:	0040d5dd 	.word	0x0040d5dd
  40d4bc:	0040d5dd 	.word	0x0040d5dd
  40d4c0:	0040d5ed 	.word	0x0040d5ed
  40d4c4:	0040d60d 	.word	0x0040d60d
  40d4c8:	0040d5b9 	.word	0x0040d5b9
  40d4cc:	0040d5e5 	.word	0x0040d5e5
  40d4d0:	0040d5e9 	.word	0x0040d5e9
  40d4d4:	0040d5e5 	.word	0x0040d5e5
  40d4d8:	0040d5f1 	.word	0x0040d5f1
  40d4dc:	0040d5f1 	.word	0x0040d5f1
  40d4e0:	0040d5f9 	.word	0x0040d5f9
  40d4e4:	0040d5ed 	.word	0x0040d5ed
  40d4e8:	0040d605 	.word	0x0040d605
  40d4ec:	0040d5f1 	.word	0x0040d5f1
  40d4f0:	0040d5f1 	.word	0x0040d5f1
  40d4f4:	0040d5f1 	.word	0x0040d5f1
  40d4f8:	0040d5f1 	.word	0x0040d5f1
  40d4fc:	0040d5f5 	.word	0x0040d5f5
  40d500:	0040d60d 	.word	0x0040d60d
  40d504:	0040d5f1 	.word	0x0040d5f1
  40d508:	0040d5e9 	.word	0x0040d5e9
  40d50c:	0040d5b5 	.word	0x0040d5b5
  40d510:	0040d5ad 	.word	0x0040d5ad
  40d514:	0040d5ad 	.word	0x0040d5ad
  40d518:	0040d5ad 	.word	0x0040d5ad
  40d51c:	0040d5ad 	.word	0x0040d5ad
  40d520:	0040d5bd 	.word	0x0040d5bd
  40d524:	0040d5a5 	.word	0x0040d5a5
  40d528:	0040d60d 	.word	0x0040d60d
  40d52c:	0040d60d 	.word	0x0040d60d
  40d530:	0040d5c1 	.word	0x0040d5c1
  40d534:	0040d609 	.word	0x0040d609
  40d538:	0040d5cd 	.word	0x0040d5cd
  40d53c:	0040d5d1 	.word	0x0040d5d1
  40d540:	0040d5d5 	.word	0x0040d5d5
  40d544:	0040d5d9 	.word	0x0040d5d9
  40d548:	0040d5c5 	.word	0x0040d5c5
  40d54c:	0040d5c9 	.word	0x0040d5c9
  40d550:	0040d5f1 	.word	0x0040d5f1
  40d554:	0040d5f1 	.word	0x0040d5f1
  40d558:	0040d601 	.word	0x0040d601
  40d55c:	0040d601 	.word	0x0040d601
  40d560:	0040d601 	.word	0x0040d601
  40d564:	0040d601 	.word	0x0040d601
  40d568:	0040d601 	.word	0x0040d601
  40d56c:	0040d601 	.word	0x0040d601
  40d570:	0040d601 	.word	0x0040d601
  40d574:	0040d601 	.word	0x0040d601
  40d578:	0040d5f5 	.word	0x0040d5f5
  40d57c:	0040d5f1 	.word	0x0040d5f1
  40d580:	0040d60d 	.word	0x0040d60d
  40d584:	0040d5b1 	.word	0x0040d5b1
  40d588:	0040d5a9 	.word	0x0040d5a9
  40d58c:	0040d60d 	.word	0x0040d60d
  40d590:	0040d60d 	.word	0x0040d60d
  40d594:	0040d5e9 	.word	0x0040d5e9
  40d598:	0040d5e9 	.word	0x0040d5e9
			case DYN_PRO_SENSOR_TYPE_RESERVED:
				return self->decode_state_machine.received_size;
  40d59c:	687b      	ldr	r3, [r7, #4]
  40d59e:	8a5b      	ldrh	r3, [r3, #18]
  40d5a0:	b21b      	sxth	r3, r3
  40d5a2:	e040      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
				return 1+1+4+16;
  40d5a4:	2316      	movs	r3, #22
  40d5a6:	e03e      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
				return 1+1+6;
  40d5a8:	2308      	movs	r3, #8
  40d5aa:	e03c      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
			case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
			case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
			case DYN_PRO_SENSOR_TYPE_OIS:
				return 1+1+4+6;
  40d5ac:	230c      	movs	r3, #12
  40d5ae:	e03a      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_FSYNC_EVENT:
				return 1+1+4+2;
  40d5b0:	2308      	movs	r3, #8
  40d5b2:	e038      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_EIS:
				return 1+1+4+6+6+2;
  40d5b4:	2314      	movs	r3, #20
  40d5b6:	e036      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
				return 1+1+4+2;
  40d5b8:	2308      	movs	r3, #8
  40d5ba:	e034      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
				return 1+1+4+4;
  40d5bc:	230a      	movs	r3, #10
  40d5be:	e032      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
                        case DYN_PRO_SENSOR_TYPE_RAW_PPG:
                                return 1+1+4+4+1;
  40d5c0:	230b      	movs	r3, #11
  40d5c2:	e030      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_ENERGY_EXPENDITURE:
				return 1+1+4+16;
  40d5c4:	2316      	movs	r3, #22
  40d5c6:	e02e      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_DISTANCE:
				return 1+1+4+8;
  40d5c8:	230e      	movs	r3, #14
  40d5ca:	e02c      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_SLEEP_ANALYSIS:
				return 1+1+4+25;
  40d5cc:	231f      	movs	r3, #31
  40d5ce:	e02a      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_BAC_EXTENDED:
				return 1+1+4+4;
  40d5d0:	230a      	movs	r3, #10
  40d5d2:	e028      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_BAC_STATISTICS:
				return 1+1+4+44;
  40d5d4:	2332      	movs	r3, #50	; 0x32
  40d5d6:	e026      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_FLOOR_CLIMB_COUNTER:
				return 1+1+4+8;
  40d5d8:	230e      	movs	r3, #14
  40d5da:	e024      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
			case DYN_PRO_SENSOR_TYPE_GRAVITY:
			case DYN_PRO_SENSOR_TYPE_ORIENTATION:
				return 1+1+4+6+1;
  40d5dc:	230d      	movs	r3, #13
  40d5de:	e022      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
			case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
			case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
				return 1+1+4+6+1;
  40d5e0:	230d      	movs	r3, #13
  40d5e2:	e020      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
			case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
				return 1+1+4+12+1;
  40d5e4:	2313      	movs	r3, #19
  40d5e6:	e01e      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
			case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
			
			case DYN_PRO_SENSOR_TYPE_3AXIS:
			case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
				return 1+1+4+8+1;
  40d5e8:	230f      	movs	r3, #15
  40d5ea:	e01c      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
			case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
				return 1+1+4+10+1;
  40d5ec:	2311      	movs	r3, #17
  40d5ee:	e01a      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:
			case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
			case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
			case DYN_PRO_SENSOR_TYPE_PRESSURE:
			case DYN_PRO_SENSOR_TYPE_LIGHT:
				return 1+1+4+4;
  40d5f0:	230a      	movs	r3, #10
  40d5f2:	e018      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_WOM:
			case DYN_PRO_SENSOR_TYPE_BAC:
				return 1+1+4+1+4;
  40d5f4:	230b      	movs	r3, #11
  40d5f6:	e016      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
				return 1+1+4+4+4;
  40d5f8:	230e      	movs	r3, #14
  40d5fa:	e014      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_PROXIMITY:
				return 1+1+4+2;
  40d5fc:	2308      	movs	r3, #8
  40d5fe:	e012      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_CUSTOM3:
			case DYN_PRO_SENSOR_TYPE_CUSTOM4:
			case DYN_PRO_SENSOR_TYPE_CUSTOM5:
			case DYN_PRO_SENSOR_TYPE_CUSTOM6:
			case DYN_PRO_SENSOR_TYPE_CUSTOM7:
				return 1+1+4+65;
  40d600:	2347      	movs	r3, #71	; 0x47
  40d602:	e010      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_HEART_RATE:
				return 1+1+4+2+1+1;
  40d604:	230a      	movs	r3, #10
  40d606:	e00e      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			case DYN_PRO_SENSOR_TYPE_HRV:
				return 1+1+4+1+1+(2*4);
  40d608:	2310      	movs	r3, #16
  40d60a:	e00c      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
                          
			default:
				/* undefined for now */
				return -1;
  40d60c:	f04f 33ff 	mov.w	r3, #4294967295
  40d610:	e009      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
			}

		default:
			/* do not need to update expected payload */
			return self->decode_state_machine.expected_size;
  40d612:	687b      	ldr	r3, [r7, #4]
  40d614:	8a1b      	ldrh	r3, [r3, #16]
  40d616:	b21b      	sxth	r3, r3
  40d618:	e005      	b.n	40d626 <DynProtocol_getPayload+0x3d6>
		}
	}

	INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: returned payload is -1");
  40d61a:	4905      	ldr	r1, [pc, #20]	; (40d630 <DynProtocol_getPayload+0x3e0>)
  40d61c:	2002      	movs	r0, #2
  40d61e:	4b05      	ldr	r3, [pc, #20]	; (40d634 <DynProtocol_getPayload+0x3e4>)
  40d620:	4798      	blx	r3

	return -1;
  40d622:	f04f 33ff 	mov.w	r3, #4294967295
}
  40d626:	4618      	mov	r0, r3
  40d628:	3710      	adds	r7, #16
  40d62a:	46bd      	mov	sp, r7
  40d62c:	bd80      	pop	{r7, pc}
  40d62e:	bf00      	nop
  40d630:	0041cc60 	.word	0x0041cc60
  40d634:	0040ff51 	.word	0x0040ff51

0040d638 <inv_dc_little8_to_int16>:

int16_t inv_dc_little8_to_int16(const uint8_t * little8)
{
  40d638:	b480      	push	{r7}
  40d63a:	b085      	sub	sp, #20
  40d63c:	af00      	add	r7, sp, #0
  40d63e:	6078      	str	r0, [r7, #4]
        int16_t x = 0;
  40d640:	2300      	movs	r3, #0
  40d642:	81fb      	strh	r3, [r7, #14]

        x |= ((int16_t)little8[1] << 8);
  40d644:	687b      	ldr	r3, [r7, #4]
  40d646:	3301      	adds	r3, #1
  40d648:	781b      	ldrb	r3, [r3, #0]
  40d64a:	021b      	lsls	r3, r3, #8
  40d64c:	b21a      	sxth	r2, r3
  40d64e:	89fb      	ldrh	r3, [r7, #14]
  40d650:	4313      	orrs	r3, r2
  40d652:	81fb      	strh	r3, [r7, #14]
        x |= ((int16_t)little8[0]);
  40d654:	687b      	ldr	r3, [r7, #4]
  40d656:	781b      	ldrb	r3, [r3, #0]
  40d658:	b21a      	sxth	r2, r3
  40d65a:	89fb      	ldrh	r3, [r7, #14]
  40d65c:	4313      	orrs	r3, r2
  40d65e:	81fb      	strh	r3, [r7, #14]

        return x;
  40d660:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
  40d664:	4618      	mov	r0, r3
  40d666:	3714      	adds	r7, #20
  40d668:	46bd      	mov	sp, r7
  40d66a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d66e:	4770      	bx	lr

0040d670 <DynProtocol_decodeSensorEvent>:

static int DynProtocol_decodeSensorEvent(DynProtocol_t * self, const uint8_t * buffer, uint16_t size,
		DynProtocolEdata_t *edata, enum DynProtocolEtype etype)
{
  40d670:	b590      	push	{r4, r7, lr}
  40d672:	b08b      	sub	sp, #44	; 0x2c
  40d674:	af02      	add	r7, sp, #8
  40d676:	60f8      	str	r0, [r7, #12]
  40d678:	60b9      	str	r1, [r7, #8]
  40d67a:	603b      	str	r3, [r7, #0]
  40d67c:	4613      	mov	r3, r2
  40d67e:	80fb      	strh	r3, [r7, #6]
	uint16_t idx = 0, i=0;
  40d680:	2300      	movs	r3, #0
  40d682:	83fb      	strh	r3, [r7, #30]
  40d684:	2300      	movs	r3, #0
  40d686:	83bb      	strh	r3, [r7, #28]
	uint32_t *sensorStatus;
	VSensorDataAny *vSensordata;

	switch(etype) {
  40d688:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  40d68c:	2b01      	cmp	r3, #1
  40d68e:	d002      	beq.n	40d696 <DynProtocol_decodeSensorEvent+0x26>
  40d690:	2b02      	cmp	r3, #2
  40d692:	d007      	beq.n	40d6a4 <DynProtocol_decodeSensorEvent+0x34>
  40d694:	e00d      	b.n	40d6b2 <DynProtocol_decodeSensorEvent+0x42>
	case DYN_PROTOCOL_ETYPE_RESP:
		sensorStatus = &edata->d.response.sensorData.status;
  40d696:	683b      	ldr	r3, [r7, #0]
  40d698:	3308      	adds	r3, #8
  40d69a:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.response.sensorData.vdata;
  40d69c:	683b      	ldr	r3, [r7, #0]
  40d69e:	330c      	adds	r3, #12
  40d6a0:	617b      	str	r3, [r7, #20]
		break;
  40d6a2:	e00a      	b.n	40d6ba <DynProtocol_decodeSensorEvent+0x4a>
	case DYN_PROTOCOL_ETYPE_ASYNC:
		sensorStatus = &edata->d.async.sensorEvent.status;
  40d6a4:	683b      	ldr	r3, [r7, #0]
  40d6a6:	3304      	adds	r3, #4
  40d6a8:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.async.sensorEvent.vdata;
  40d6aa:	683b      	ldr	r3, [r7, #0]
  40d6ac:	3308      	adds	r3, #8
  40d6ae:	617b      	str	r3, [r7, #20]
		break;
  40d6b0:	e003      	b.n	40d6ba <DynProtocol_decodeSensorEvent+0x4a>
	case DYN_PROTOCOL_ETYPE_CMD:
	default:
		return INV_ERROR_BAD_ARG;
  40d6b2:	f06f 030a 	mvn.w	r3, #10
  40d6b6:	f000 bcb9 	b.w	40e02c <DynProtocol_decodeSensorEvent+0x9bc>
	}

	memset(vSensordata, 0, sizeof(VSensorDataAny));
  40d6ba:	2248      	movs	r2, #72	; 0x48
  40d6bc:	2100      	movs	r1, #0
  40d6be:	6978      	ldr	r0, [r7, #20]
  40d6c0:	4bb1      	ldr	r3, [pc, #708]	; (40d988 <DynProtocol_decodeSensorEvent+0x318>)
  40d6c2:	4798      	blx	r3

	*sensorStatus    = (uint32_t)(buffer[idx] & 0x03);
  40d6c4:	8bfb      	ldrh	r3, [r7, #30]
  40d6c6:	68ba      	ldr	r2, [r7, #8]
  40d6c8:	4413      	add	r3, r2
  40d6ca:	781b      	ldrb	r3, [r3, #0]
  40d6cc:	f003 0203 	and.w	r2, r3, #3
  40d6d0:	69bb      	ldr	r3, [r7, #24]
  40d6d2:	601a      	str	r2, [r3, #0]
	idx += 1;
  40d6d4:	8bfb      	ldrh	r3, [r7, #30]
  40d6d6:	3301      	adds	r3, #1
  40d6d8:	83fb      	strh	r3, [r7, #30]
	edata->sensor_id = (int)(buffer[idx]);
  40d6da:	8bfb      	ldrh	r3, [r7, #30]
  40d6dc:	68ba      	ldr	r2, [r7, #8]
  40d6de:	4413      	add	r3, r2
  40d6e0:	781b      	ldrb	r3, [r3, #0]
  40d6e2:	461a      	mov	r2, r3
  40d6e4:	683b      	ldr	r3, [r7, #0]
  40d6e6:	601a      	str	r2, [r3, #0]
	idx += 1;
  40d6e8:	8bfb      	ldrh	r3, [r7, #30]
  40d6ea:	3301      	adds	r3, #1
  40d6ec:	83fb      	strh	r3, [r7, #30]

	vSensordata->base.timestamp = (uint32_t)inv_dc_little8_to_int32(&buffer[idx]);
  40d6ee:	8bfb      	ldrh	r3, [r7, #30]
  40d6f0:	68ba      	ldr	r2, [r7, #8]
  40d6f2:	4413      	add	r3, r2
  40d6f4:	4618      	mov	r0, r3
  40d6f6:	4ba5      	ldr	r3, [pc, #660]	; (40d98c <DynProtocol_decodeSensorEvent+0x31c>)
  40d6f8:	4798      	blx	r3
  40d6fa:	4603      	mov	r3, r0
  40d6fc:	461a      	mov	r2, r3
  40d6fe:	697b      	ldr	r3, [r7, #20]
  40d700:	601a      	str	r2, [r3, #0]
	idx += 4;
  40d702:	8bfb      	ldrh	r3, [r7, #30]
  40d704:	3304      	adds	r3, #4
  40d706:	83fb      	strh	r3, [r7, #30]

	switch(edata->sensor_id) {
  40d708:	683b      	ldr	r3, [r7, #0]
  40d70a:	681b      	ldr	r3, [r3, #0]
  40d70c:	2b41      	cmp	r3, #65	; 0x41
  40d70e:	f200 8481 	bhi.w	40e014 <DynProtocol_decodeSensorEvent+0x9a4>
  40d712:	a201      	add	r2, pc, #4	; (adr r2, 40d718 <DynProtocol_decodeSensorEvent+0xa8>)
  40d714:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d718:	0040e01b 	.word	0x0040e01b
  40d71c:	0040d821 	.word	0x0040d821
  40d720:	0040d85d 	.word	0x0040d85d
  40d724:	0040de29 	.word	0x0040de29
  40d728:	0040d8e9 	.word	0x0040d8e9
  40d72c:	0040de5f 	.word	0x0040de5f
  40d730:	0040de0f 	.word	0x0040de0f
  40d734:	0040e015 	.word	0x0040e015
  40d738:	0040de75 	.word	0x0040de75
  40d73c:	0040d821 	.word	0x0040d821
  40d740:	0040d821 	.word	0x0040d821
  40d744:	0040d9cb 	.word	0x0040d9cb
  40d748:	0040e015 	.word	0x0040e015
  40d74c:	0040dab1 	.word	0x0040dab1
  40d750:	0040d893 	.word	0x0040d893
  40d754:	0040d995 	.word	0x0040d995
  40d758:	0040d925 	.word	0x0040d925
  40d75c:	0040ddf9 	.word	0x0040ddf9
  40d760:	0040ddf9 	.word	0x0040ddf9
  40d764:	0040dd7d 	.word	0x0040dd7d
  40d768:	0040d9cb 	.word	0x0040d9cb
  40d76c:	0040df77 	.word	0x0040df77
  40d770:	0040ddf9 	.word	0x0040ddf9
  40d774:	0040ddf9 	.word	0x0040ddf9
  40d778:	0040ddf9 	.word	0x0040ddf9
  40d77c:	0040ddf9 	.word	0x0040ddf9
  40d780:	0040dda9 	.word	0x0040dda9
  40d784:	0040e015 	.word	0x0040e015
  40d788:	0040ddf9 	.word	0x0040ddf9
  40d78c:	0040d995 	.word	0x0040d995
  40d790:	0040dea1 	.word	0x0040dea1
  40d794:	0040da6f 	.word	0x0040da6f
  40d798:	0040da6f 	.word	0x0040da6f
  40d79c:	0040da6f 	.word	0x0040da6f
  40d7a0:	0040da6f 	.word	0x0040da6f
  40d7a4:	0040dac9 	.word	0x0040dac9
  40d7a8:	0040df43 	.word	0x0040df43
  40d7ac:	0040e015 	.word	0x0040e015
  40d7b0:	0040e015 	.word	0x0040e015
  40d7b4:	0040dadf 	.word	0x0040dadf
  40d7b8:	0040dfbd 	.word	0x0040dfbd
  40d7bc:	0040db95 	.word	0x0040db95
  40d7c0:	0040dc49 	.word	0x0040dc49
  40d7c4:	0040dc5f 	.word	0x0040dc5f
  40d7c8:	0040dd51 	.word	0x0040dd51
  40d7cc:	0040db03 	.word	0x0040db03
  40d7d0:	0040db5b 	.word	0x0040db5b
  40d7d4:	0040ddf9 	.word	0x0040ddf9
  40d7d8:	0040ddf9 	.word	0x0040ddf9
  40d7dc:	0040df03 	.word	0x0040df03
  40d7e0:	0040df03 	.word	0x0040df03
  40d7e4:	0040df03 	.word	0x0040df03
  40d7e8:	0040df03 	.word	0x0040df03
  40d7ec:	0040df03 	.word	0x0040df03
  40d7f0:	0040df03 	.word	0x0040df03
  40d7f4:	0040df03 	.word	0x0040df03
  40d7f8:	0040df03 	.word	0x0040df03
  40d7fc:	0040ddd1 	.word	0x0040ddd1
  40d800:	0040ddf9 	.word	0x0040ddf9
  40d804:	0040e015 	.word	0x0040e015
  40d808:	0040de8b 	.word	0x0040de8b
  40d80c:	0040da21 	.word	0x0040da21
  40d810:	0040e015 	.word	0x0040e015
  40d814:	0040e015 	.word	0x0040e015
  40d818:	0040d995 	.word	0x0040d995
  40d81c:	0040d995 	.word	0x0040d995
	case DYN_PRO_SENSOR_TYPE_RESERVED:
		break;
	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_GRAVITY:
	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.acc, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d820:	8bfb      	ldrh	r3, [r7, #30]
  40d822:	68ba      	ldr	r2, [r7, #8]
  40d824:	18d0      	adds	r0, r2, r3
  40d826:	68fb      	ldr	r3, [r7, #12]
  40d828:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
  40d82c:	461a      	mov	r2, r3
  40d82e:	697b      	ldr	r3, [r7, #20]
  40d830:	3308      	adds	r3, #8
  40d832:	9300      	str	r3, [sp, #0]
  40d834:	2310      	movs	r3, #16
  40d836:	2103      	movs	r1, #3
  40d838:	4c55      	ldr	r4, [pc, #340]	; (40d990 <DynProtocol_decodeSensorEvent+0x320>)
  40d83a:	47a0      	blx	r4
  40d83c:	4603      	mov	r3, r0
  40d83e:	b29a      	uxth	r2, r3
  40d840:	8bfb      	ldrh	r3, [r7, #30]
  40d842:	4413      	add	r3, r2
  40d844:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d846:	8bfb      	ldrh	r3, [r7, #30]
  40d848:	1c5a      	adds	r2, r3, #1
  40d84a:	83fa      	strh	r2, [r7, #30]
  40d84c:	461a      	mov	r2, r3
  40d84e:	68bb      	ldr	r3, [r7, #8]
  40d850:	4413      	add	r3, r2
  40d852:	781b      	ldrb	r3, [r3, #0]
  40d854:	461a      	mov	r2, r3
  40d856:	697b      	ldr	r3, [r7, #20]
  40d858:	605a      	str	r2, [r3, #4]
		break;
  40d85a:	e3df      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d85c:	8bfb      	ldrh	r3, [r7, #30]
  40d85e:	68ba      	ldr	r2, [r7, #8]
  40d860:	18d0      	adds	r0, r2, r3
  40d862:	697b      	ldr	r3, [r7, #20]
  40d864:	3308      	adds	r3, #8
  40d866:	9300      	str	r3, [sp, #0]
  40d868:	2310      	movs	r3, #16
  40d86a:	2204      	movs	r2, #4
  40d86c:	2103      	movs	r1, #3
  40d86e:	4c48      	ldr	r4, [pc, #288]	; (40d990 <DynProtocol_decodeSensorEvent+0x320>)
  40d870:	47a0      	blx	r4
  40d872:	4603      	mov	r3, r0
  40d874:	b29a      	uxth	r2, r3
  40d876:	8bfb      	ldrh	r3, [r7, #30]
  40d878:	4413      	add	r3, r2
  40d87a:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d87c:	8bfb      	ldrh	r3, [r7, #30]
  40d87e:	1c5a      	adds	r2, r3, #1
  40d880:	83fa      	strh	r2, [r7, #30]
  40d882:	461a      	mov	r2, r3
  40d884:	68bb      	ldr	r3, [r7, #8]
  40d886:	4413      	add	r3, r2
  40d888:	781b      	ldrb	r3, [r3, #0]
  40d88a:	461a      	mov	r2, r3
  40d88c:	697b      	ldr	r3, [r7, #20]
  40d88e:	605a      	str	r2, [r3, #4]
		break;
  40d890:	e3c4      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d892:	8bfb      	ldrh	r3, [r7, #30]
  40d894:	68ba      	ldr	r2, [r7, #8]
  40d896:	18d0      	adds	r0, r2, r3
  40d898:	697b      	ldr	r3, [r7, #20]
  40d89a:	3308      	adds	r3, #8
  40d89c:	9300      	str	r3, [sp, #0]
  40d89e:	2310      	movs	r3, #16
  40d8a0:	2204      	movs	r2, #4
  40d8a2:	2103      	movs	r1, #3
  40d8a4:	4c3a      	ldr	r4, [pc, #232]	; (40d990 <DynProtocol_decodeSensorEvent+0x320>)
  40d8a6:	47a0      	blx	r4
  40d8a8:	4603      	mov	r3, r0
  40d8aa:	b29a      	uxth	r2, r3
  40d8ac:	8bfb      	ldrh	r3, [r7, #30]
  40d8ae:	4413      	add	r3, r2
  40d8b0:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[3]);
  40d8b2:	8bfb      	ldrh	r3, [r7, #30]
  40d8b4:	68ba      	ldr	r2, [r7, #8]
  40d8b6:	18d0      	adds	r0, r2, r3
  40d8b8:	697b      	ldr	r3, [r7, #20]
  40d8ba:	3314      	adds	r3, #20
  40d8bc:	9300      	str	r3, [sp, #0]
  40d8be:	2310      	movs	r3, #16
  40d8c0:	2204      	movs	r2, #4
  40d8c2:	2103      	movs	r1, #3
  40d8c4:	4c32      	ldr	r4, [pc, #200]	; (40d990 <DynProtocol_decodeSensorEvent+0x320>)
  40d8c6:	47a0      	blx	r4
  40d8c8:	4603      	mov	r3, r0
  40d8ca:	b29a      	uxth	r2, r3
  40d8cc:	8bfb      	ldrh	r3, [r7, #30]
  40d8ce:	4413      	add	r3, r2
  40d8d0:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d8d2:	8bfb      	ldrh	r3, [r7, #30]
  40d8d4:	1c5a      	adds	r2, r3, #1
  40d8d6:	83fa      	strh	r2, [r7, #30]
  40d8d8:	461a      	mov	r2, r3
  40d8da:	68bb      	ldr	r3, [r7, #8]
  40d8dc:	4413      	add	r3, r2
  40d8de:	781b      	ldrb	r3, [r3, #0]
  40d8e0:	461a      	mov	r2, r3
  40d8e2:	697b      	ldr	r3, [r7, #20]
  40d8e4:	605a      	str	r2, [r3, #4]
		break;
  40d8e6:	e399      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d8e8:	8bfb      	ldrh	r3, [r7, #30]
  40d8ea:	68ba      	ldr	r2, [r7, #8]
  40d8ec:	18d0      	adds	r0, r2, r3
  40d8ee:	68fb      	ldr	r3, [r7, #12]
  40d8f0:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40d8f4:	461a      	mov	r2, r3
  40d8f6:	697b      	ldr	r3, [r7, #20]
  40d8f8:	3308      	adds	r3, #8
  40d8fa:	9300      	str	r3, [sp, #0]
  40d8fc:	2310      	movs	r3, #16
  40d8fe:	2103      	movs	r1, #3
  40d900:	4c23      	ldr	r4, [pc, #140]	; (40d990 <DynProtocol_decodeSensorEvent+0x320>)
  40d902:	47a0      	blx	r4
  40d904:	4603      	mov	r3, r0
  40d906:	b29a      	uxth	r2, r3
  40d908:	8bfb      	ldrh	r3, [r7, #30]
  40d90a:	4413      	add	r3, r2
  40d90c:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d90e:	8bfb      	ldrh	r3, [r7, #30]
  40d910:	1c5a      	adds	r2, r3, #1
  40d912:	83fa      	strh	r2, [r7, #30]
  40d914:	461a      	mov	r2, r3
  40d916:	68bb      	ldr	r3, [r7, #8]
  40d918:	4413      	add	r3, r2
  40d91a:	781b      	ldrb	r3, [r3, #0]
  40d91c:	461a      	mov	r2, r3
  40d91e:	697b      	ldr	r3, [r7, #20]
  40d920:	605a      	str	r2, [r3, #4]
		break;
  40d922:	e37b      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d924:	8bfb      	ldrh	r3, [r7, #30]
  40d926:	68ba      	ldr	r2, [r7, #8]
  40d928:	18d0      	adds	r0, r2, r3
  40d92a:	68fb      	ldr	r3, [r7, #12]
  40d92c:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40d930:	461a      	mov	r2, r3
  40d932:	697b      	ldr	r3, [r7, #20]
  40d934:	3308      	adds	r3, #8
  40d936:	9300      	str	r3, [sp, #0]
  40d938:	2310      	movs	r3, #16
  40d93a:	2103      	movs	r1, #3
  40d93c:	4c14      	ldr	r4, [pc, #80]	; (40d990 <DynProtocol_decodeSensorEvent+0x320>)
  40d93e:	47a0      	blx	r4
  40d940:	4603      	mov	r3, r0
  40d942:	b29a      	uxth	r2, r3
  40d944:	8bfb      	ldrh	r3, [r7, #30]
  40d946:	4413      	add	r3, r2
  40d948:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[3]);
  40d94a:	8bfb      	ldrh	r3, [r7, #30]
  40d94c:	68ba      	ldr	r2, [r7, #8]
  40d94e:	18d0      	adds	r0, r2, r3
  40d950:	68fb      	ldr	r3, [r7, #12]
  40d952:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40d956:	461a      	mov	r2, r3
  40d958:	697b      	ldr	r3, [r7, #20]
  40d95a:	3314      	adds	r3, #20
  40d95c:	9300      	str	r3, [sp, #0]
  40d95e:	2310      	movs	r3, #16
  40d960:	2103      	movs	r1, #3
  40d962:	4c0b      	ldr	r4, [pc, #44]	; (40d990 <DynProtocol_decodeSensorEvent+0x320>)
  40d964:	47a0      	blx	r4
  40d966:	4603      	mov	r3, r0
  40d968:	b29a      	uxth	r2, r3
  40d96a:	8bfb      	ldrh	r3, [r7, #30]
  40d96c:	4413      	add	r3, r2
  40d96e:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d970:	8bfb      	ldrh	r3, [r7, #30]
  40d972:	1c5a      	adds	r2, r3, #1
  40d974:	83fa      	strh	r2, [r7, #30]
  40d976:	461a      	mov	r2, r3
  40d978:	68bb      	ldr	r3, [r7, #8]
  40d97a:	4413      	add	r3, r2
  40d97c:	781b      	ldrb	r3, [r3, #0]
  40d97e:	461a      	mov	r2, r3
  40d980:	697b      	ldr	r3, [r7, #20]
  40d982:	605a      	str	r2, [r3, #4]
		break;
  40d984:	e34a      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
  40d986:	bf00      	nop
  40d988:	00414431 	.word	0x00414431
  40d98c:	0040fa3f 	.word	0x0040fa3f
  40d990:	0040cfe9 	.word	0x0040cfe9
	case DYN_PRO_SENSOR_TYPE_3AXIS:
	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 4, PROTOCOL_QUATERNION_PRECISION, 30, (int32_t*)&vSensordata->data.u32[0]);
  40d994:	8bfb      	ldrh	r3, [r7, #30]
  40d996:	68ba      	ldr	r2, [r7, #8]
  40d998:	18d0      	adds	r0, r2, r3
  40d99a:	697b      	ldr	r3, [r7, #20]
  40d99c:	3308      	adds	r3, #8
  40d99e:	9300      	str	r3, [sp, #0]
  40d9a0:	231e      	movs	r3, #30
  40d9a2:	220e      	movs	r2, #14
  40d9a4:	2104      	movs	r1, #4
  40d9a6:	4c78      	ldr	r4, [pc, #480]	; (40db88 <DynProtocol_decodeSensorEvent+0x518>)
  40d9a8:	47a0      	blx	r4
  40d9aa:	4603      	mov	r3, r0
  40d9ac:	b29a      	uxth	r2, r3
  40d9ae:	8bfb      	ldrh	r3, [r7, #30]
  40d9b0:	4413      	add	r3, r2
  40d9b2:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d9b4:	8bfb      	ldrh	r3, [r7, #30]
  40d9b6:	1c5a      	adds	r2, r3, #1
  40d9b8:	83fa      	strh	r2, [r7, #30]
  40d9ba:	461a      	mov	r2, r3
  40d9bc:	68bb      	ldr	r3, [r7, #8]
  40d9be:	4413      	add	r3, r2
  40d9c0:	781b      	ldrb	r3, [r3, #0]
  40d9c2:	461a      	mov	r2, r3
  40d9c4:	697b      	ldr	r3, [r7, #20]
  40d9c6:	605a      	str	r2, [r3, #4]
		break;
  40d9c8:	e328      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 4, PROTOCOL_QUATERNION_PRECISION, 30, (int32_t*)&vSensordata->data.u32[0]);
  40d9ca:	8bfb      	ldrh	r3, [r7, #30]
  40d9cc:	68ba      	ldr	r2, [r7, #8]
  40d9ce:	18d0      	adds	r0, r2, r3
  40d9d0:	697b      	ldr	r3, [r7, #20]
  40d9d2:	3308      	adds	r3, #8
  40d9d4:	9300      	str	r3, [sp, #0]
  40d9d6:	231e      	movs	r3, #30
  40d9d8:	220e      	movs	r2, #14
  40d9da:	2104      	movs	r1, #4
  40d9dc:	4c6a      	ldr	r4, [pc, #424]	; (40db88 <DynProtocol_decodeSensorEvent+0x518>)
  40d9de:	47a0      	blx	r4
  40d9e0:	4603      	mov	r3, r0
  40d9e2:	b29a      	uxth	r2, r3
  40d9e4:	8bfb      	ldrh	r3, [r7, #30]
  40d9e6:	4413      	add	r3, r2
  40d9e8:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_HEADING_ACCURACY_PRECISION, 16, (int32_t*)&vSensordata->data.u32[4]);
  40d9ea:	8bfb      	ldrh	r3, [r7, #30]
  40d9ec:	68ba      	ldr	r2, [r7, #8]
  40d9ee:	18d0      	adds	r0, r2, r3
  40d9f0:	697b      	ldr	r3, [r7, #20]
  40d9f2:	3318      	adds	r3, #24
  40d9f4:	9300      	str	r3, [sp, #0]
  40d9f6:	2310      	movs	r3, #16
  40d9f8:	2207      	movs	r2, #7
  40d9fa:	2101      	movs	r1, #1
  40d9fc:	4c62      	ldr	r4, [pc, #392]	; (40db88 <DynProtocol_decodeSensorEvent+0x518>)
  40d9fe:	47a0      	blx	r4
  40da00:	4603      	mov	r3, r0
  40da02:	b29a      	uxth	r2, r3
  40da04:	8bfb      	ldrh	r3, [r7, #30]
  40da06:	4413      	add	r3, r2
  40da08:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40da0a:	8bfb      	ldrh	r3, [r7, #30]
  40da0c:	1c5a      	adds	r2, r3, #1
  40da0e:	83fa      	strh	r2, [r7, #30]
  40da10:	461a      	mov	r2, r3
  40da12:	68bb      	ldr	r3, [r7, #8]
  40da14:	4413      	add	r3, r2
  40da16:	781b      	ldrb	r3, [r3, #0]
  40da18:	461a      	mov	r2, r3
  40da1a:	697b      	ldr	r3, [r7, #20]
  40da1c:	605a      	str	r2, [r3, #4]
		break;
  40da1e:	e2fd      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
		vSensordata->base.timestamp = 0;
  40da20:	697b      	ldr	r3, [r7, #20]
  40da22:	2200      	movs	r2, #0
  40da24:	601a      	str	r2, [r3, #0]
		idx -= 4;
  40da26:	8bfb      	ldrh	r3, [r7, #30]
  40da28:	3b04      	subs	r3, #4
  40da2a:	83fb      	strh	r3, [r7, #30]
		vSensordata->data.u32[0] = inv_dc_le_to_int16(&buffer[idx]);
  40da2c:	8bfb      	ldrh	r3, [r7, #30]
  40da2e:	68ba      	ldr	r2, [r7, #8]
  40da30:	4413      	add	r3, r2
  40da32:	4618      	mov	r0, r3
  40da34:	4b55      	ldr	r3, [pc, #340]	; (40db8c <DynProtocol_decodeSensorEvent+0x51c>)
  40da36:	4798      	blx	r3
  40da38:	4603      	mov	r3, r0
  40da3a:	461a      	mov	r2, r3
  40da3c:	697b      	ldr	r3, [r7, #20]
  40da3e:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_le_to_int16(&buffer[idx+2]);
  40da40:	8bfb      	ldrh	r3, [r7, #30]
  40da42:	3302      	adds	r3, #2
  40da44:	68ba      	ldr	r2, [r7, #8]
  40da46:	4413      	add	r3, r2
  40da48:	4618      	mov	r0, r3
  40da4a:	4b50      	ldr	r3, [pc, #320]	; (40db8c <DynProtocol_decodeSensorEvent+0x51c>)
  40da4c:	4798      	blx	r3
  40da4e:	4603      	mov	r3, r0
  40da50:	461a      	mov	r2, r3
  40da52:	697b      	ldr	r3, [r7, #20]
  40da54:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_le_to_int16(&buffer[idx+4]);
  40da56:	8bfb      	ldrh	r3, [r7, #30]
  40da58:	3304      	adds	r3, #4
  40da5a:	68ba      	ldr	r2, [r7, #8]
  40da5c:	4413      	add	r3, r2
  40da5e:	4618      	mov	r0, r3
  40da60:	4b4a      	ldr	r3, [pc, #296]	; (40db8c <DynProtocol_decodeSensorEvent+0x51c>)
  40da62:	4798      	blx	r3
  40da64:	4603      	mov	r3, r0
  40da66:	461a      	mov	r2, r3
  40da68:	697b      	ldr	r3, [r7, #20]
  40da6a:	611a      	str	r2, [r3, #16]
		break;
  40da6c:	e2d6      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
	case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
	case DYN_PRO_SENSOR_TYPE_OIS:
		vSensordata->data.u32[0] = inv_dc_le_to_int16(&buffer[idx]);
  40da6e:	8bfb      	ldrh	r3, [r7, #30]
  40da70:	68ba      	ldr	r2, [r7, #8]
  40da72:	4413      	add	r3, r2
  40da74:	4618      	mov	r0, r3
  40da76:	4b45      	ldr	r3, [pc, #276]	; (40db8c <DynProtocol_decodeSensorEvent+0x51c>)
  40da78:	4798      	blx	r3
  40da7a:	4603      	mov	r3, r0
  40da7c:	461a      	mov	r2, r3
  40da7e:	697b      	ldr	r3, [r7, #20]
  40da80:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_le_to_int16(&buffer[idx+2]);
  40da82:	8bfb      	ldrh	r3, [r7, #30]
  40da84:	3302      	adds	r3, #2
  40da86:	68ba      	ldr	r2, [r7, #8]
  40da88:	4413      	add	r3, r2
  40da8a:	4618      	mov	r0, r3
  40da8c:	4b3f      	ldr	r3, [pc, #252]	; (40db8c <DynProtocol_decodeSensorEvent+0x51c>)
  40da8e:	4798      	blx	r3
  40da90:	4603      	mov	r3, r0
  40da92:	461a      	mov	r2, r3
  40da94:	697b      	ldr	r3, [r7, #20]
  40da96:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_le_to_int16(&buffer[idx+4]);
  40da98:	8bfb      	ldrh	r3, [r7, #30]
  40da9a:	3304      	adds	r3, #4
  40da9c:	68ba      	ldr	r2, [r7, #8]
  40da9e:	4413      	add	r3, r2
  40daa0:	4618      	mov	r0, r3
  40daa2:	4b3a      	ldr	r3, [pc, #232]	; (40db8c <DynProtocol_decodeSensorEvent+0x51c>)
  40daa4:	4798      	blx	r3
  40daa6:	4603      	mov	r3, r0
  40daa8:	461a      	mov	r2, r3
  40daaa:	697b      	ldr	r3, [r7, #20]
  40daac:	611a      	str	r2, [r3, #16]
		break;
  40daae:	e2b5      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
		DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_TEMPERATURE_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40dab0:	8bfb      	ldrh	r3, [r7, #30]
  40dab2:	68ba      	ldr	r2, [r7, #8]
  40dab4:	18d0      	adds	r0, r2, r3
  40dab6:	697b      	ldr	r3, [r7, #20]
  40dab8:	3308      	adds	r3, #8
  40daba:	9300      	str	r3, [sp, #0]
  40dabc:	2310      	movs	r3, #16
  40dabe:	2208      	movs	r2, #8
  40dac0:	2101      	movs	r1, #1
  40dac2:	4c31      	ldr	r4, [pc, #196]	; (40db88 <DynProtocol_decodeSensorEvent+0x518>)
  40dac4:	47a0      	blx	r4
		break;
  40dac6:	e2a9      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40dac8:	8bfb      	ldrh	r3, [r7, #30]
  40daca:	68ba      	ldr	r2, [r7, #8]
  40dacc:	4413      	add	r3, r2
  40dace:	4618      	mov	r0, r3
  40dad0:	4b2f      	ldr	r3, [pc, #188]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40dad2:	4798      	blx	r3
  40dad4:	4603      	mov	r3, r0
  40dad6:	461a      	mov	r2, r3
  40dad8:	697b      	ldr	r3, [r7, #20]
  40dada:	609a      	str	r2, [r3, #8]
		break;
  40dadc:	e29e      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_RAW_PPG:
                vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]); 
  40dade:	8bfb      	ldrh	r3, [r7, #30]
  40dae0:	68ba      	ldr	r2, [r7, #8]
  40dae2:	4413      	add	r3, r2
  40dae4:	4618      	mov	r0, r3
  40dae6:	4b2a      	ldr	r3, [pc, #168]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40dae8:	4798      	blx	r3
  40daea:	4603      	mov	r3, r0
  40daec:	461a      	mov	r2, r3
  40daee:	697b      	ldr	r3, [r7, #20]
  40daf0:	609a      	str	r2, [r3, #8]
                vSensordata->data.u8[0] = buffer[idx+4]; 
  40daf2:	8bfb      	ldrh	r3, [r7, #30]
  40daf4:	3304      	adds	r3, #4
  40daf6:	68ba      	ldr	r2, [r7, #8]
  40daf8:	4413      	add	r3, r2
  40dafa:	781a      	ldrb	r2, [r3, #0]
  40dafc:	697b      	ldr	r3, [r7, #20]
  40dafe:	721a      	strb	r2, [r3, #8]
		break;                
  40db00:	e28c      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_ENERGY_EXPENDITURE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40db02:	8bfb      	ldrh	r3, [r7, #30]
  40db04:	68ba      	ldr	r2, [r7, #8]
  40db06:	4413      	add	r3, r2
  40db08:	4618      	mov	r0, r3
  40db0a:	4b21      	ldr	r3, [pc, #132]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40db0c:	4798      	blx	r3
  40db0e:	4603      	mov	r3, r0
  40db10:	461a      	mov	r2, r3
  40db12:	697b      	ldr	r3, [r7, #20]
  40db14:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40db16:	8bfb      	ldrh	r3, [r7, #30]
  40db18:	3304      	adds	r3, #4
  40db1a:	68ba      	ldr	r2, [r7, #8]
  40db1c:	4413      	add	r3, r2
  40db1e:	4618      	mov	r0, r3
  40db20:	4b1b      	ldr	r3, [pc, #108]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40db22:	4798      	blx	r3
  40db24:	4603      	mov	r3, r0
  40db26:	461a      	mov	r2, r3
  40db28:	697b      	ldr	r3, [r7, #20]
  40db2a:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_little8_to_int32(&buffer[idx+8]);
  40db2c:	8bfb      	ldrh	r3, [r7, #30]
  40db2e:	3308      	adds	r3, #8
  40db30:	68ba      	ldr	r2, [r7, #8]
  40db32:	4413      	add	r3, r2
  40db34:	4618      	mov	r0, r3
  40db36:	4b16      	ldr	r3, [pc, #88]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40db38:	4798      	blx	r3
  40db3a:	4603      	mov	r3, r0
  40db3c:	461a      	mov	r2, r3
  40db3e:	697b      	ldr	r3, [r7, #20]
  40db40:	611a      	str	r2, [r3, #16]
		vSensordata->data.u32[3] = inv_dc_little8_to_int32(&buffer[idx+12]);
  40db42:	8bfb      	ldrh	r3, [r7, #30]
  40db44:	330c      	adds	r3, #12
  40db46:	68ba      	ldr	r2, [r7, #8]
  40db48:	4413      	add	r3, r2
  40db4a:	4618      	mov	r0, r3
  40db4c:	4b10      	ldr	r3, [pc, #64]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40db4e:	4798      	blx	r3
  40db50:	4603      	mov	r3, r0
  40db52:	461a      	mov	r2, r3
  40db54:	697b      	ldr	r3, [r7, #20]
  40db56:	615a      	str	r2, [r3, #20]
		break;
  40db58:	e260      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_DISTANCE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40db5a:	8bfb      	ldrh	r3, [r7, #30]
  40db5c:	68ba      	ldr	r2, [r7, #8]
  40db5e:	4413      	add	r3, r2
  40db60:	4618      	mov	r0, r3
  40db62:	4b0b      	ldr	r3, [pc, #44]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40db64:	4798      	blx	r3
  40db66:	4603      	mov	r3, r0
  40db68:	461a      	mov	r2, r3
  40db6a:	697b      	ldr	r3, [r7, #20]
  40db6c:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40db6e:	8bfb      	ldrh	r3, [r7, #30]
  40db70:	3304      	adds	r3, #4
  40db72:	68ba      	ldr	r2, [r7, #8]
  40db74:	4413      	add	r3, r2
  40db76:	4618      	mov	r0, r3
  40db78:	4b05      	ldr	r3, [pc, #20]	; (40db90 <DynProtocol_decodeSensorEvent+0x520>)
  40db7a:	4798      	blx	r3
  40db7c:	4603      	mov	r3, r0
  40db7e:	461a      	mov	r2, r3
  40db80:	697b      	ldr	r3, [r7, #20]
  40db82:	60da      	str	r2, [r3, #12]
		break;
  40db84:	e24a      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
  40db86:	bf00      	nop
  40db88:	0040cfe9 	.word	0x0040cfe9
  40db8c:	0040fa8f 	.word	0x0040fa8f
  40db90:	0040fa3f 	.word	0x0040fa3f
	case DYN_PRO_SENSOR_TYPE_SLEEP_ANALYSIS:
		vSensordata->data.u8[0]  = buffer[idx];
  40db94:	8bfb      	ldrh	r3, [r7, #30]
  40db96:	68ba      	ldr	r2, [r7, #8]
  40db98:	4413      	add	r3, r2
  40db9a:	781a      	ldrb	r2, [r3, #0]
  40db9c:	697b      	ldr	r3, [r7, #20]
  40db9e:	721a      	strb	r2, [r3, #8]
		vSensordata->data.u8[1]  = buffer[idx+1];
  40dba0:	8bfb      	ldrh	r3, [r7, #30]
  40dba2:	3301      	adds	r3, #1
  40dba4:	68ba      	ldr	r2, [r7, #8]
  40dba6:	4413      	add	r3, r2
  40dba8:	781a      	ldrb	r2, [r3, #0]
  40dbaa:	697b      	ldr	r3, [r7, #20]
  40dbac:	725a      	strb	r2, [r3, #9]
		vSensordata->data.u8[2]  = buffer[idx+2];
  40dbae:	8bfb      	ldrh	r3, [r7, #30]
  40dbb0:	3302      	adds	r3, #2
  40dbb2:	68ba      	ldr	r2, [r7, #8]
  40dbb4:	4413      	add	r3, r2
  40dbb6:	781a      	ldrb	r2, [r3, #0]
  40dbb8:	697b      	ldr	r3, [r7, #20]
  40dbba:	729a      	strb	r2, [r3, #10]
		vSensordata->data.u8[3]  = buffer[idx+3];
  40dbbc:	8bfb      	ldrh	r3, [r7, #30]
  40dbbe:	3303      	adds	r3, #3
  40dbc0:	68ba      	ldr	r2, [r7, #8]
  40dbc2:	4413      	add	r3, r2
  40dbc4:	781a      	ldrb	r2, [r3, #0]
  40dbc6:	697b      	ldr	r3, [r7, #20]
  40dbc8:	72da      	strb	r2, [r3, #11]
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40dbca:	8bfb      	ldrh	r3, [r7, #30]
  40dbcc:	3304      	adds	r3, #4
  40dbce:	68ba      	ldr	r2, [r7, #8]
  40dbd0:	4413      	add	r3, r2
  40dbd2:	4618      	mov	r0, r3
  40dbd4:	4b93      	ldr	r3, [pc, #588]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dbd6:	4798      	blx	r3
  40dbd8:	4603      	mov	r3, r0
  40dbda:	461a      	mov	r2, r3
  40dbdc:	697b      	ldr	r3, [r7, #20]
  40dbde:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+8]);
  40dbe0:	8bfb      	ldrh	r3, [r7, #30]
  40dbe2:	3308      	adds	r3, #8
  40dbe4:	68ba      	ldr	r2, [r7, #8]
  40dbe6:	4413      	add	r3, r2
  40dbe8:	4618      	mov	r0, r3
  40dbea:	4b8e      	ldr	r3, [pc, #568]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dbec:	4798      	blx	r3
  40dbee:	4603      	mov	r3, r0
  40dbf0:	461a      	mov	r2, r3
  40dbf2:	697b      	ldr	r3, [r7, #20]
  40dbf4:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_little8_to_int32(&buffer[idx+12]);
  40dbf6:	8bfb      	ldrh	r3, [r7, #30]
  40dbf8:	330c      	adds	r3, #12
  40dbfa:	68ba      	ldr	r2, [r7, #8]
  40dbfc:	4413      	add	r3, r2
  40dbfe:	4618      	mov	r0, r3
  40dc00:	4b88      	ldr	r3, [pc, #544]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dc02:	4798      	blx	r3
  40dc04:	4603      	mov	r3, r0
  40dc06:	461a      	mov	r2, r3
  40dc08:	697b      	ldr	r3, [r7, #20]
  40dc0a:	611a      	str	r2, [r3, #16]
		vSensordata->data.u32[3] = inv_dc_little8_to_int32(&buffer[idx+16]);
  40dc0c:	8bfb      	ldrh	r3, [r7, #30]
  40dc0e:	3310      	adds	r3, #16
  40dc10:	68ba      	ldr	r2, [r7, #8]
  40dc12:	4413      	add	r3, r2
  40dc14:	4618      	mov	r0, r3
  40dc16:	4b83      	ldr	r3, [pc, #524]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dc18:	4798      	blx	r3
  40dc1a:	4603      	mov	r3, r0
  40dc1c:	461a      	mov	r2, r3
  40dc1e:	697b      	ldr	r3, [r7, #20]
  40dc20:	615a      	str	r2, [r3, #20]
		vSensordata->data.u32[4] = inv_dc_little8_to_int32(&buffer[idx+20]);
  40dc22:	8bfb      	ldrh	r3, [r7, #30]
  40dc24:	3314      	adds	r3, #20
  40dc26:	68ba      	ldr	r2, [r7, #8]
  40dc28:	4413      	add	r3, r2
  40dc2a:	4618      	mov	r0, r3
  40dc2c:	4b7d      	ldr	r3, [pc, #500]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dc2e:	4798      	blx	r3
  40dc30:	4603      	mov	r3, r0
  40dc32:	461a      	mov	r2, r3
  40dc34:	697b      	ldr	r3, [r7, #20]
  40dc36:	619a      	str	r2, [r3, #24]
		vSensordata->data.u8[4]  = buffer[idx+24];
  40dc38:	8bfb      	ldrh	r3, [r7, #30]
  40dc3a:	3318      	adds	r3, #24
  40dc3c:	68ba      	ldr	r2, [r7, #8]
  40dc3e:	4413      	add	r3, r2
  40dc40:	781a      	ldrb	r2, [r3, #0]
  40dc42:	697b      	ldr	r3, [r7, #20]
  40dc44:	731a      	strb	r2, [r3, #12]
		break;
  40dc46:	e1e9      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_BAC_EXTENDED:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40dc48:	8bfb      	ldrh	r3, [r7, #30]
  40dc4a:	68ba      	ldr	r2, [r7, #8]
  40dc4c:	4413      	add	r3, r2
  40dc4e:	4618      	mov	r0, r3
  40dc50:	4b74      	ldr	r3, [pc, #464]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dc52:	4798      	blx	r3
  40dc54:	4603      	mov	r3, r0
  40dc56:	461a      	mov	r2, r3
  40dc58:	697b      	ldr	r3, [r7, #20]
  40dc5a:	609a      	str	r2, [r3, #8]
		break;
  40dc5c:	e1de      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_BAC_STATISTICS:
		vSensordata->data.u32[0]  = inv_dc_little8_to_int32(&buffer[idx]);
  40dc5e:	8bfb      	ldrh	r3, [r7, #30]
  40dc60:	68ba      	ldr	r2, [r7, #8]
  40dc62:	4413      	add	r3, r2
  40dc64:	4618      	mov	r0, r3
  40dc66:	4b6f      	ldr	r3, [pc, #444]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dc68:	4798      	blx	r3
  40dc6a:	4603      	mov	r3, r0
  40dc6c:	461a      	mov	r2, r3
  40dc6e:	697b      	ldr	r3, [r7, #20]
  40dc70:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1]  = inv_dc_little8_to_int32(&buffer[idx+4]);
  40dc72:	8bfb      	ldrh	r3, [r7, #30]
  40dc74:	3304      	adds	r3, #4
  40dc76:	68ba      	ldr	r2, [r7, #8]
  40dc78:	4413      	add	r3, r2
  40dc7a:	4618      	mov	r0, r3
  40dc7c:	4b69      	ldr	r3, [pc, #420]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dc7e:	4798      	blx	r3
  40dc80:	4603      	mov	r3, r0
  40dc82:	461a      	mov	r2, r3
  40dc84:	697b      	ldr	r3, [r7, #20]
  40dc86:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2]  = inv_dc_little8_to_int32(&buffer[idx+8]);
  40dc88:	8bfb      	ldrh	r3, [r7, #30]
  40dc8a:	3308      	adds	r3, #8
  40dc8c:	68ba      	ldr	r2, [r7, #8]
  40dc8e:	4413      	add	r3, r2
  40dc90:	4618      	mov	r0, r3
  40dc92:	4b64      	ldr	r3, [pc, #400]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dc94:	4798      	blx	r3
  40dc96:	4603      	mov	r3, r0
  40dc98:	461a      	mov	r2, r3
  40dc9a:	697b      	ldr	r3, [r7, #20]
  40dc9c:	611a      	str	r2, [r3, #16]
		vSensordata->data.u32[3]  = inv_dc_little8_to_int32(&buffer[idx+12]);
  40dc9e:	8bfb      	ldrh	r3, [r7, #30]
  40dca0:	330c      	adds	r3, #12
  40dca2:	68ba      	ldr	r2, [r7, #8]
  40dca4:	4413      	add	r3, r2
  40dca6:	4618      	mov	r0, r3
  40dca8:	4b5e      	ldr	r3, [pc, #376]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dcaa:	4798      	blx	r3
  40dcac:	4603      	mov	r3, r0
  40dcae:	461a      	mov	r2, r3
  40dcb0:	697b      	ldr	r3, [r7, #20]
  40dcb2:	615a      	str	r2, [r3, #20]
		vSensordata->data.u32[4]  = inv_dc_little8_to_int32(&buffer[idx+16]);
  40dcb4:	8bfb      	ldrh	r3, [r7, #30]
  40dcb6:	3310      	adds	r3, #16
  40dcb8:	68ba      	ldr	r2, [r7, #8]
  40dcba:	4413      	add	r3, r2
  40dcbc:	4618      	mov	r0, r3
  40dcbe:	4b59      	ldr	r3, [pc, #356]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dcc0:	4798      	blx	r3
  40dcc2:	4603      	mov	r3, r0
  40dcc4:	461a      	mov	r2, r3
  40dcc6:	697b      	ldr	r3, [r7, #20]
  40dcc8:	619a      	str	r2, [r3, #24]
		vSensordata->data.u32[5]  = inv_dc_little8_to_int32(&buffer[idx+20]);
  40dcca:	8bfb      	ldrh	r3, [r7, #30]
  40dccc:	3314      	adds	r3, #20
  40dcce:	68ba      	ldr	r2, [r7, #8]
  40dcd0:	4413      	add	r3, r2
  40dcd2:	4618      	mov	r0, r3
  40dcd4:	4b53      	ldr	r3, [pc, #332]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dcd6:	4798      	blx	r3
  40dcd8:	4603      	mov	r3, r0
  40dcda:	461a      	mov	r2, r3
  40dcdc:	697b      	ldr	r3, [r7, #20]
  40dcde:	61da      	str	r2, [r3, #28]
		vSensordata->data.u32[6]  = inv_dc_little8_to_int32(&buffer[idx+24]);
  40dce0:	8bfb      	ldrh	r3, [r7, #30]
  40dce2:	3318      	adds	r3, #24
  40dce4:	68ba      	ldr	r2, [r7, #8]
  40dce6:	4413      	add	r3, r2
  40dce8:	4618      	mov	r0, r3
  40dcea:	4b4e      	ldr	r3, [pc, #312]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dcec:	4798      	blx	r3
  40dcee:	4603      	mov	r3, r0
  40dcf0:	461a      	mov	r2, r3
  40dcf2:	697b      	ldr	r3, [r7, #20]
  40dcf4:	621a      	str	r2, [r3, #32]
		vSensordata->data.u32[7]  = inv_dc_little8_to_int32(&buffer[idx+28]);
  40dcf6:	8bfb      	ldrh	r3, [r7, #30]
  40dcf8:	331c      	adds	r3, #28
  40dcfa:	68ba      	ldr	r2, [r7, #8]
  40dcfc:	4413      	add	r3, r2
  40dcfe:	4618      	mov	r0, r3
  40dd00:	4b48      	ldr	r3, [pc, #288]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd02:	4798      	blx	r3
  40dd04:	4603      	mov	r3, r0
  40dd06:	461a      	mov	r2, r3
  40dd08:	697b      	ldr	r3, [r7, #20]
  40dd0a:	625a      	str	r2, [r3, #36]	; 0x24
		vSensordata->data.u32[8]  = inv_dc_little8_to_int32(&buffer[idx+32]);
  40dd0c:	8bfb      	ldrh	r3, [r7, #30]
  40dd0e:	3320      	adds	r3, #32
  40dd10:	68ba      	ldr	r2, [r7, #8]
  40dd12:	4413      	add	r3, r2
  40dd14:	4618      	mov	r0, r3
  40dd16:	4b43      	ldr	r3, [pc, #268]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd18:	4798      	blx	r3
  40dd1a:	4603      	mov	r3, r0
  40dd1c:	461a      	mov	r2, r3
  40dd1e:	697b      	ldr	r3, [r7, #20]
  40dd20:	629a      	str	r2, [r3, #40]	; 0x28
		vSensordata->data.u32[9]  = inv_dc_little8_to_int32(&buffer[idx+36]);
  40dd22:	8bfb      	ldrh	r3, [r7, #30]
  40dd24:	3324      	adds	r3, #36	; 0x24
  40dd26:	68ba      	ldr	r2, [r7, #8]
  40dd28:	4413      	add	r3, r2
  40dd2a:	4618      	mov	r0, r3
  40dd2c:	4b3d      	ldr	r3, [pc, #244]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd2e:	4798      	blx	r3
  40dd30:	4603      	mov	r3, r0
  40dd32:	461a      	mov	r2, r3
  40dd34:	697b      	ldr	r3, [r7, #20]
  40dd36:	62da      	str	r2, [r3, #44]	; 0x2c
		vSensordata->data.u32[10] = inv_dc_little8_to_int32(&buffer[idx+40]);
  40dd38:	8bfb      	ldrh	r3, [r7, #30]
  40dd3a:	3328      	adds	r3, #40	; 0x28
  40dd3c:	68ba      	ldr	r2, [r7, #8]
  40dd3e:	4413      	add	r3, r2
  40dd40:	4618      	mov	r0, r3
  40dd42:	4b38      	ldr	r3, [pc, #224]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd44:	4798      	blx	r3
  40dd46:	4603      	mov	r3, r0
  40dd48:	461a      	mov	r2, r3
  40dd4a:	697b      	ldr	r3, [r7, #20]
  40dd4c:	631a      	str	r2, [r3, #48]	; 0x30
		break;
  40dd4e:	e165      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_FLOOR_CLIMB_COUNTER:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40dd50:	8bfb      	ldrh	r3, [r7, #30]
  40dd52:	68ba      	ldr	r2, [r7, #8]
  40dd54:	4413      	add	r3, r2
  40dd56:	4618      	mov	r0, r3
  40dd58:	4b32      	ldr	r3, [pc, #200]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd5a:	4798      	blx	r3
  40dd5c:	4603      	mov	r3, r0
  40dd5e:	461a      	mov	r2, r3
  40dd60:	697b      	ldr	r3, [r7, #20]
  40dd62:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40dd64:	8bfb      	ldrh	r3, [r7, #30]
  40dd66:	3304      	adds	r3, #4
  40dd68:	68ba      	ldr	r2, [r7, #8]
  40dd6a:	4413      	add	r3, r2
  40dd6c:	4618      	mov	r0, r3
  40dd6e:	4b2d      	ldr	r3, [pc, #180]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd70:	4798      	blx	r3
  40dd72:	4603      	mov	r3, r0
  40dd74:	461a      	mov	r2, r3
  40dd76:	697b      	ldr	r3, [r7, #20]
  40dd78:	60da      	str	r2, [r3, #12]
		break;
  40dd7a:	e14f      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40dd7c:	8bfb      	ldrh	r3, [r7, #30]
  40dd7e:	68ba      	ldr	r2, [r7, #8]
  40dd80:	4413      	add	r3, r2
  40dd82:	4618      	mov	r0, r3
  40dd84:	4b27      	ldr	r3, [pc, #156]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd86:	4798      	blx	r3
  40dd88:	4603      	mov	r3, r0
  40dd8a:	461a      	mov	r2, r3
  40dd8c:	697b      	ldr	r3, [r7, #20]
  40dd8e:	609a      	str	r2, [r3, #8]
		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx+4]);
  40dd90:	8bfb      	ldrh	r3, [r7, #30]
  40dd92:	3304      	adds	r3, #4
  40dd94:	68ba      	ldr	r2, [r7, #8]
  40dd96:	4413      	add	r3, r2
  40dd98:	4618      	mov	r0, r3
  40dd9a:	4b22      	ldr	r3, [pc, #136]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40dd9c:	4798      	blx	r3
  40dd9e:	4603      	mov	r3, r0
  40dda0:	461a      	mov	r2, r3
  40dda2:	697b      	ldr	r3, [r7, #20]
  40dda4:	601a      	str	r2, [r3, #0]
		break;
  40dda6:	e139      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_BAC:
		vSensordata->data.u8[0] = buffer[idx++];
  40dda8:	8bfb      	ldrh	r3, [r7, #30]
  40ddaa:	1c5a      	adds	r2, r3, #1
  40ddac:	83fa      	strh	r2, [r7, #30]
  40ddae:	461a      	mov	r2, r3
  40ddb0:	68bb      	ldr	r3, [r7, #8]
  40ddb2:	4413      	add	r3, r2
  40ddb4:	781a      	ldrb	r2, [r3, #0]
  40ddb6:	697b      	ldr	r3, [r7, #20]
  40ddb8:	721a      	strb	r2, [r3, #8]
		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
  40ddba:	8bfb      	ldrh	r3, [r7, #30]
  40ddbc:	68ba      	ldr	r2, [r7, #8]
  40ddbe:	4413      	add	r3, r2
  40ddc0:	4618      	mov	r0, r3
  40ddc2:	4b18      	ldr	r3, [pc, #96]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40ddc4:	4798      	blx	r3
  40ddc6:	4603      	mov	r3, r0
  40ddc8:	461a      	mov	r2, r3
  40ddca:	697b      	ldr	r3, [r7, #20]
  40ddcc:	601a      	str	r2, [r3, #0]
		break;
  40ddce:	e125      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_WOM:
		vSensordata->data.u8[0] = buffer[idx++];
  40ddd0:	8bfb      	ldrh	r3, [r7, #30]
  40ddd2:	1c5a      	adds	r2, r3, #1
  40ddd4:	83fa      	strh	r2, [r7, #30]
  40ddd6:	461a      	mov	r2, r3
  40ddd8:	68bb      	ldr	r3, [r7, #8]
  40ddda:	4413      	add	r3, r2
  40dddc:	781a      	ldrb	r2, [r3, #0]
  40ddde:	697b      	ldr	r3, [r7, #20]
  40dde0:	721a      	strb	r2, [r3, #8]
		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
  40dde2:	8bfb      	ldrh	r3, [r7, #30]
  40dde4:	68ba      	ldr	r2, [r7, #8]
  40dde6:	4413      	add	r3, r2
  40dde8:	4618      	mov	r0, r3
  40ddea:	4b0e      	ldr	r3, [pc, #56]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40ddec:	4798      	blx	r3
  40ddee:	4603      	mov	r3, r0
  40ddf0:	461a      	mov	r2, r3
  40ddf2:	697b      	ldr	r3, [r7, #20]
  40ddf4:	601a      	str	r2, [r3, #0]
		break;
  40ddf6:	e111      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_STEP_DETECTOR:
	case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:
	case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:
	case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
  40ddf8:	8bfb      	ldrh	r3, [r7, #30]
  40ddfa:	68ba      	ldr	r2, [r7, #8]
  40ddfc:	4413      	add	r3, r2
  40ddfe:	4618      	mov	r0, r3
  40de00:	4b08      	ldr	r3, [pc, #32]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40de02:	4798      	blx	r3
  40de04:	4603      	mov	r3, r0
  40de06:	461a      	mov	r2, r3
  40de08:	697b      	ldr	r3, [r7, #20]
  40de0a:	601a      	str	r2, [r3, #0]
		break;
  40de0c:	e106      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_PRESSURE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40de0e:	8bfb      	ldrh	r3, [r7, #30]
  40de10:	68ba      	ldr	r2, [r7, #8]
  40de12:	4413      	add	r3, r2
  40de14:	4618      	mov	r0, r3
  40de16:	4b03      	ldr	r3, [pc, #12]	; (40de24 <DynProtocol_decodeSensorEvent+0x7b4>)
  40de18:	4798      	blx	r3
  40de1a:	4603      	mov	r3, r0
  40de1c:	461a      	mov	r2, r3
  40de1e:	697b      	ldr	r3, [r7, #20]
  40de20:	609a      	str	r2, [r3, #8]
		break;
  40de22:	e0fb      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
  40de24:	0040fa3f 	.word	0x0040fa3f
	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_ORIENTATION_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40de28:	8bfb      	ldrh	r3, [r7, #30]
  40de2a:	68ba      	ldr	r2, [r7, #8]
  40de2c:	18d0      	adds	r0, r2, r3
  40de2e:	697b      	ldr	r3, [r7, #20]
  40de30:	3308      	adds	r3, #8
  40de32:	9300      	str	r3, [sp, #0]
  40de34:	2310      	movs	r3, #16
  40de36:	2206      	movs	r2, #6
  40de38:	2103      	movs	r1, #3
  40de3a:	4c7e      	ldr	r4, [pc, #504]	; (40e034 <DynProtocol_decodeSensorEvent+0x9c4>)
  40de3c:	47a0      	blx	r4
  40de3e:	4603      	mov	r3, r0
  40de40:	b29a      	uxth	r2, r3
  40de42:	8bfb      	ldrh	r3, [r7, #30]
  40de44:	4413      	add	r3, r2
  40de46:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40de48:	8bfb      	ldrh	r3, [r7, #30]
  40de4a:	1c5a      	adds	r2, r3, #1
  40de4c:	83fa      	strh	r2, [r7, #30]
  40de4e:	461a      	mov	r2, r3
  40de50:	68bb      	ldr	r3, [r7, #8]
  40de52:	4413      	add	r3, r2
  40de54:	781b      	ldrb	r3, [r3, #0]
  40de56:	461a      	mov	r2, r3
  40de58:	697b      	ldr	r3, [r7, #20]
  40de5a:	605a      	str	r2, [r3, #4]
		break;
  40de5c:	e0de      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_LIGHT:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40de5e:	8bfb      	ldrh	r3, [r7, #30]
  40de60:	68ba      	ldr	r2, [r7, #8]
  40de62:	4413      	add	r3, r2
  40de64:	4618      	mov	r0, r3
  40de66:	4b74      	ldr	r3, [pc, #464]	; (40e038 <DynProtocol_decodeSensorEvent+0x9c8>)
  40de68:	4798      	blx	r3
  40de6a:	4603      	mov	r3, r0
  40de6c:	461a      	mov	r2, r3
  40de6e:	697b      	ldr	r3, [r7, #20]
  40de70:	609a      	str	r2, [r3, #8]
		break;
  40de72:	e0d3      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_PROXIMITY:
		vSensordata->data.u32[0] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);
  40de74:	8bfb      	ldrh	r3, [r7, #30]
  40de76:	68ba      	ldr	r2, [r7, #8]
  40de78:	4413      	add	r3, r2
  40de7a:	4618      	mov	r0, r3
  40de7c:	4b6f      	ldr	r3, [pc, #444]	; (40e03c <DynProtocol_decodeSensorEvent+0x9cc>)
  40de7e:	4798      	blx	r3
  40de80:	4603      	mov	r3, r0
  40de82:	461a      	mov	r2, r3
  40de84:	697b      	ldr	r3, [r7, #20]
  40de86:	609a      	str	r2, [r3, #8]
		break;
  40de88:	e0c8      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_FSYNC_EVENT:
		vSensordata->data.u32[0] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);
  40de8a:	8bfb      	ldrh	r3, [r7, #30]
  40de8c:	68ba      	ldr	r2, [r7, #8]
  40de8e:	4413      	add	r3, r2
  40de90:	4618      	mov	r0, r3
  40de92:	4b6a      	ldr	r3, [pc, #424]	; (40e03c <DynProtocol_decodeSensorEvent+0x9cc>)
  40de94:	4798      	blx	r3
  40de96:	4603      	mov	r3, r0
  40de98:	461a      	mov	r2, r3
  40de9a:	697b      	ldr	r3, [r7, #20]
  40de9c:	609a      	str	r2, [r3, #8]
		break;
  40de9e:	e0bd      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_EIS:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
  40dea0:	8bfb      	ldrh	r3, [r7, #30]
  40dea2:	68ba      	ldr	r2, [r7, #8]
  40dea4:	18d0      	adds	r0, r2, r3
  40dea6:	68fb      	ldr	r3, [r7, #12]
  40dea8:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40deac:	461a      	mov	r2, r3
  40deae:	697b      	ldr	r3, [r7, #20]
  40deb0:	3308      	adds	r3, #8
  40deb2:	9300      	str	r3, [sp, #0]
  40deb4:	2310      	movs	r3, #16
  40deb6:	2103      	movs	r1, #3
  40deb8:	4c5e      	ldr	r4, [pc, #376]	; (40e034 <DynProtocol_decodeSensorEvent+0x9c4>)
  40deba:	47a0      	blx	r4
  40debc:	4603      	mov	r3, r0
  40debe:	b29a      	uxth	r2, r3
  40dec0:	8bfb      	ldrh	r3, [r7, #30]
  40dec2:	4413      	add	r3, r2
  40dec4:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[3]);
  40dec6:	8bfb      	ldrh	r3, [r7, #30]
  40dec8:	68ba      	ldr	r2, [r7, #8]
  40deca:	18d0      	adds	r0, r2, r3
  40decc:	68fb      	ldr	r3, [r7, #12]
  40dece:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40ded2:	461a      	mov	r2, r3
  40ded4:	697b      	ldr	r3, [r7, #20]
  40ded6:	3314      	adds	r3, #20
  40ded8:	9300      	str	r3, [sp, #0]
  40deda:	2310      	movs	r3, #16
  40dedc:	2103      	movs	r1, #3
  40dede:	4c55      	ldr	r4, [pc, #340]	; (40e034 <DynProtocol_decodeSensorEvent+0x9c4>)
  40dee0:	47a0      	blx	r4
  40dee2:	4603      	mov	r3, r0
  40dee4:	b29a      	uxth	r2, r3
  40dee6:	8bfb      	ldrh	r3, [r7, #30]
  40dee8:	4413      	add	r3, r2
  40deea:	83fb      	strh	r3, [r7, #30]
		vSensordata->data.u32[6] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);
  40deec:	8bfb      	ldrh	r3, [r7, #30]
  40deee:	68ba      	ldr	r2, [r7, #8]
  40def0:	4413      	add	r3, r2
  40def2:	4618      	mov	r0, r3
  40def4:	4b51      	ldr	r3, [pc, #324]	; (40e03c <DynProtocol_decodeSensorEvent+0x9cc>)
  40def6:	4798      	blx	r3
  40def8:	4603      	mov	r3, r0
  40defa:	461a      	mov	r2, r3
  40defc:	697b      	ldr	r3, [r7, #20]
  40defe:	621a      	str	r2, [r3, #32]
		break;
  40df00:	e08c      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	case DYN_PRO_SENSOR_TYPE_CUSTOM6:
	case DYN_PRO_SENSOR_TYPE_CUSTOM7:
	{
		/* meta data contains size of custom sensors.
		 * Check size is not bigger than VSensorData array */
		vSensordata->base.meta_data = buffer[idx++];
  40df02:	8bfb      	ldrh	r3, [r7, #30]
  40df04:	1c5a      	adds	r2, r3, #1
  40df06:	83fa      	strh	r2, [r7, #30]
  40df08:	461a      	mov	r2, r3
  40df0a:	68bb      	ldr	r3, [r7, #8]
  40df0c:	4413      	add	r3, r2
  40df0e:	781b      	ldrb	r3, [r3, #0]
  40df10:	461a      	mov	r2, r3
  40df12:	697b      	ldr	r3, [r7, #20]
  40df14:	605a      	str	r2, [r3, #4]
		if(vSensordata->base.meta_data > sizeof(vSensordata->data.u8))
  40df16:	697b      	ldr	r3, [r7, #20]
  40df18:	685b      	ldr	r3, [r3, #4]
  40df1a:	2b40      	cmp	r3, #64	; 0x40
  40df1c:	d902      	bls.n	40df24 <DynProtocol_decodeSensorEvent+0x8b4>
			return -1;
  40df1e:	f04f 33ff 	mov.w	r3, #4294967295
  40df22:	e083      	b.n	40e02c <DynProtocol_decodeSensorEvent+0x9bc>

		memcpy(vSensordata->data.u8, &buffer[idx], vSensordata->base.meta_data);
  40df24:	697b      	ldr	r3, [r7, #20]
  40df26:	f103 0008 	add.w	r0, r3, #8
  40df2a:	8bfb      	ldrh	r3, [r7, #30]
  40df2c:	68ba      	ldr	r2, [r7, #8]
  40df2e:	18d1      	adds	r1, r2, r3
  40df30:	697b      	ldr	r3, [r7, #20]
  40df32:	685b      	ldr	r3, [r3, #4]
  40df34:	461a      	mov	r2, r3
  40df36:	4b42      	ldr	r3, [pc, #264]	; (40e040 <DynProtocol_decodeSensorEvent+0x9d0>)
  40df38:	4798      	blx	r3
		//hard code the payload size until payload has a fixed value for custom sensors
		idx += sizeof(vSensordata->data.u8);
  40df3a:	8bfb      	ldrh	r3, [r7, #30]
  40df3c:	3340      	adds	r3, #64	; 0x40
  40df3e:	83fb      	strh	r3, [r7, #30]
		break;
  40df40:	e06c      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	}

	case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
		for (i=0; i<4; i++) {
  40df42:	2300      	movs	r3, #0
  40df44:	83bb      	strh	r3, [r7, #28]
  40df46:	e012      	b.n	40df6e <DynProtocol_decodeSensorEvent+0x8fe>
			vSensordata->data.u32[i] = inv_dc_little8_to_int32(&buffer[idx]); // raw pressure
  40df48:	8bbc      	ldrh	r4, [r7, #28]
  40df4a:	8bfb      	ldrh	r3, [r7, #30]
  40df4c:	68ba      	ldr	r2, [r7, #8]
  40df4e:	4413      	add	r3, r2
  40df50:	4618      	mov	r0, r3
  40df52:	4b39      	ldr	r3, [pc, #228]	; (40e038 <DynProtocol_decodeSensorEvent+0x9c8>)
  40df54:	4798      	blx	r3
  40df56:	4603      	mov	r3, r0
  40df58:	4619      	mov	r1, r3
  40df5a:	697b      	ldr	r3, [r7, #20]
  40df5c:	1ca2      	adds	r2, r4, #2
  40df5e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			idx += 4;
  40df62:	8bfb      	ldrh	r3, [r7, #30]
  40df64:	3304      	adds	r3, #4
  40df66:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40df68:	8bbb      	ldrh	r3, [r7, #28]
  40df6a:	3301      	adds	r3, #1
  40df6c:	83bb      	strh	r3, [r7, #28]
  40df6e:	8bbb      	ldrh	r3, [r7, #28]
  40df70:	2b03      	cmp	r3, #3
  40df72:	d9e9      	bls.n	40df48 <DynProtocol_decodeSensorEvent+0x8d8>
		}
		break;
  40df74:	e052      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>

	case DYN_PRO_SENSOR_TYPE_HEART_RATE:
	{
		// ppm
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_HRM_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40df76:	8bfb      	ldrh	r3, [r7, #30]
  40df78:	68ba      	ldr	r2, [r7, #8]
  40df7a:	18d0      	adds	r0, r2, r3
  40df7c:	697b      	ldr	r3, [r7, #20]
  40df7e:	3308      	adds	r3, #8
  40df80:	9300      	str	r3, [sp, #0]
  40df82:	2310      	movs	r3, #16
  40df84:	2207      	movs	r2, #7
  40df86:	2101      	movs	r1, #1
  40df88:	4c2a      	ldr	r4, [pc, #168]	; (40e034 <DynProtocol_decodeSensorEvent+0x9c4>)
  40df8a:	47a0      	blx	r4
  40df8c:	4603      	mov	r3, r0
  40df8e:	b29a      	uxth	r2, r3
  40df90:	8bfb      	ldrh	r3, [r7, #30]
  40df92:	4413      	add	r3, r2
  40df94:	83fb      	strh	r3, [r7, #30]
				  
		// confidence
		vSensordata->data.u8[0] = buffer[idx++];
  40df96:	8bfb      	ldrh	r3, [r7, #30]
  40df98:	1c5a      	adds	r2, r3, #1
  40df9a:	83fa      	strh	r2, [r7, #30]
  40df9c:	461a      	mov	r2, r3
  40df9e:	68bb      	ldr	r3, [r7, #8]
  40dfa0:	4413      	add	r3, r2
  40dfa2:	781a      	ldrb	r2, [r3, #0]
  40dfa4:	697b      	ldr	r3, [r7, #20]
  40dfa6:	721a      	strb	r2, [r3, #8]

		// sqi
		vSensordata->data.u8[1] = buffer[idx++];
  40dfa8:	8bfb      	ldrh	r3, [r7, #30]
  40dfaa:	1c5a      	adds	r2, r3, #1
  40dfac:	83fa      	strh	r2, [r7, #30]
  40dfae:	461a      	mov	r2, r3
  40dfb0:	68bb      	ldr	r3, [r7, #8]
  40dfb2:	4413      	add	r3, r2
  40dfb4:	781a      	ldrb	r2, [r3, #0]
  40dfb6:	697b      	ldr	r3, [r7, #20]
  40dfb8:	725a      	strb	r2, [r3, #9]

		break;
  40dfba:	e02f      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	}
        
	case DYN_PRO_SENSOR_TYPE_HRV:
	{
		// RR_count
		vSensordata->data.u8[0] = buffer[idx];
  40dfbc:	8bfb      	ldrh	r3, [r7, #30]
  40dfbe:	68ba      	ldr	r2, [r7, #8]
  40dfc0:	4413      	add	r3, r2
  40dfc2:	781a      	ldrb	r2, [r3, #0]
  40dfc4:	697b      	ldr	r3, [r7, #20]
  40dfc6:	721a      	strb	r2, [r3, #8]
		idx += 1;
  40dfc8:	8bfb      	ldrh	r3, [r7, #30]
  40dfca:	3301      	adds	r3, #1
  40dfcc:	83fb      	strh	r3, [r7, #30]

		// paddingDummy
		vSensordata->data.u8[1] = buffer[idx];
  40dfce:	8bfb      	ldrh	r3, [r7, #30]
  40dfd0:	68ba      	ldr	r2, [r7, #8]
  40dfd2:	4413      	add	r3, r2
  40dfd4:	781a      	ldrb	r2, [r3, #0]
  40dfd6:	697b      	ldr	r3, [r7, #20]
  40dfd8:	725a      	strb	r2, [r3, #9]
		idx += 1;
  40dfda:	8bfb      	ldrh	r3, [r7, #30]
  40dfdc:	3301      	adds	r3, #1
  40dfde:	83fb      	strh	r3, [r7, #30]
		
		// RR_interval
		for (i=0; i<4; i++) {
  40dfe0:	2300      	movs	r3, #0
  40dfe2:	83bb      	strh	r3, [r7, #28]
  40dfe4:	e012      	b.n	40e00c <DynProtocol_decodeSensorEvent+0x99c>
			vSensordata->data.u16[i] = inv_dc_little8_to_int16(&buffer[idx]);
  40dfe6:	8bbc      	ldrh	r4, [r7, #28]
  40dfe8:	8bfb      	ldrh	r3, [r7, #30]
  40dfea:	68ba      	ldr	r2, [r7, #8]
  40dfec:	4413      	add	r3, r2
  40dfee:	4618      	mov	r0, r3
  40dff0:	4b14      	ldr	r3, [pc, #80]	; (40e044 <DynProtocol_decodeSensorEvent+0x9d4>)
  40dff2:	4798      	blx	r3
  40dff4:	4603      	mov	r3, r0
  40dff6:	b299      	uxth	r1, r3
  40dff8:	697b      	ldr	r3, [r7, #20]
  40dffa:	1d22      	adds	r2, r4, #4
  40dffc:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			idx += 2;
  40e000:	8bfb      	ldrh	r3, [r7, #30]
  40e002:	3302      	adds	r3, #2
  40e004:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40e006:	8bbb      	ldrh	r3, [r7, #28]
  40e008:	3301      	adds	r3, #1
  40e00a:	83bb      	strh	r3, [r7, #28]
  40e00c:	8bbb      	ldrh	r3, [r7, #28]
  40e00e:	2b03      	cmp	r3, #3
  40e010:	d9e9      	bls.n	40dfe6 <DynProtocol_decodeSensorEvent+0x976>
		}

		break;
  40e012:	e003      	b.n	40e01c <DynProtocol_decodeSensorEvent+0x9ac>
	}                
                
                
	default:
		return -1;
  40e014:	f04f 33ff 	mov.w	r3, #4294967295
  40e018:	e008      	b.n	40e02c <DynProtocol_decodeSensorEvent+0x9bc>
		break;
  40e01a:	bf00      	nop
	}

	// check if we did not read more bytes than actually transfered by protocol
	if(idx > size)
  40e01c:	8bfa      	ldrh	r2, [r7, #30]
  40e01e:	88fb      	ldrh	r3, [r7, #6]
  40e020:	429a      	cmp	r2, r3
  40e022:	d902      	bls.n	40e02a <DynProtocol_decodeSensorEvent+0x9ba>
		return -1;
  40e024:	f04f 33ff 	mov.w	r3, #4294967295
  40e028:	e000      	b.n	40e02c <DynProtocol_decodeSensorEvent+0x9bc>

	return 0;
  40e02a:	2300      	movs	r3, #0

}
  40e02c:	4618      	mov	r0, r3
  40e02e:	3724      	adds	r7, #36	; 0x24
  40e030:	46bd      	mov	sp, r7
  40e032:	bd90      	pop	{r4, r7, pc}
  40e034:	0040cfe9 	.word	0x0040cfe9
  40e038:	0040fa3f 	.word	0x0040fa3f
  40e03c:	0040fa8f 	.word	0x0040fa8f
  40e040:	00414235 	.word	0x00414235
  40e044:	0040d639 	.word	0x0040d639

0040e048 <DynProtocol_decodePktCommand>:

static int DynProtocol_decodePktCommand(DynProtocol_t * self,
		struct DynProtocolEdata * edata)
{
  40e048:	b590      	push	{r4, r7, lr}
  40e04a:	b089      	sub	sp, #36	; 0x24
  40e04c:	af02      	add	r7, sp, #8
  40e04e:	6078      	str	r0, [r7, #4]
  40e050:	6039      	str	r1, [r7, #0]
	int i, precision;
	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
  40e052:	687b      	ldr	r3, [r7, #4]
  40e054:	3314      	adds	r3, #20
  40e056:	613b      	str	r3, [r7, #16]

	if(self->decode_state_machine.cmd_id == DYN_PROTOCOL_EID_PROTOCOLVERSION) {
  40e058:	687b      	ldr	r3, [r7, #4]
  40e05a:	7b9b      	ldrb	r3, [r3, #14]
  40e05c:	2b00      	cmp	r3, #0
  40e05e:	d103      	bne.n	40e068 <DynProtocol_decodePktCommand+0x20>
		edata->sensor_id = 0;
  40e060:	683b      	ldr	r3, [r7, #0]
  40e062:	2200      	movs	r2, #0
  40e064:	601a      	str	r2, [r3, #0]
  40e066:	e0b9      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>
	}
	else {
		edata->sensor_id = buf[0];
  40e068:	693b      	ldr	r3, [r7, #16]
  40e06a:	781b      	ldrb	r3, [r3, #0]
  40e06c:	461a      	mov	r2, r3
  40e06e:	683b      	ldr	r3, [r7, #0]
  40e070:	601a      	str	r2, [r3, #0]

		switch(self->decode_state_machine.cmd_id) {
  40e072:	687b      	ldr	r3, [r7, #4]
  40e074:	7b9b      	ldrb	r3, [r3, #14]
  40e076:	3b1b      	subs	r3, #27
  40e078:	2b09      	cmp	r3, #9
  40e07a:	f200 80ae 	bhi.w	40e1da <DynProtocol_decodePktCommand+0x192>
  40e07e:	a201      	add	r2, pc, #4	; (adr r2, 40e084 <DynProtocol_decodePktCommand+0x3c>)
  40e080:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40e084:	0040e0ad 	.word	0x0040e0ad
  40e088:	0040e0c1 	.word	0x0040e0c1
  40e08c:	0040e1db 	.word	0x0040e1db
  40e090:	0040e1a9 	.word	0x0040e1a9
  40e094:	0040e19b 	.word	0x0040e19b
  40e098:	0040e0d5 	.word	0x0040e0d5
  40e09c:	0040e1db 	.word	0x0040e1db
  40e0a0:	0040e115 	.word	0x0040e115
  40e0a4:	0040e11f 	.word	0x0040e11f
  40e0a8:	0040e18d 	.word	0x0040e18d
		case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:
			edata->d.command.period = (uint32_t)inv_dc_little8_to_int32(&buf[1]);
  40e0ac:	693b      	ldr	r3, [r7, #16]
  40e0ae:	3301      	adds	r3, #1
  40e0b0:	4618      	mov	r0, r3
  40e0b2:	4b4d      	ldr	r3, [pc, #308]	; (40e1e8 <DynProtocol_decodePktCommand+0x1a0>)
  40e0b4:	4798      	blx	r3
  40e0b6:	4603      	mov	r3, r0
  40e0b8:	461a      	mov	r2, r3
  40e0ba:	683b      	ldr	r3, [r7, #0]
  40e0bc:	605a      	str	r2, [r3, #4]
			break;
  40e0be:	e08d      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>

		case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT:
			edata->d.command.timeout = (uint32_t)inv_dc_little8_to_int32(&buf[1]);
  40e0c0:	693b      	ldr	r3, [r7, #16]
  40e0c2:	3301      	adds	r3, #1
  40e0c4:	4618      	mov	r0, r3
  40e0c6:	4b48      	ldr	r3, [pc, #288]	; (40e1e8 <DynProtocol_decodePktCommand+0x1a0>)
  40e0c8:	4798      	blx	r3
  40e0ca:	4603      	mov	r3, r0
  40e0cc:	461a      	mov	r2, r3
  40e0ce:	683b      	ldr	r3, [r7, #0]
  40e0d0:	605a      	str	r2, [r3, #4]
			break;
  40e0d2:	e083      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>

		case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX:
		{
			edata->d.command.cfg.base.type = buf[1];
  40e0d4:	693b      	ldr	r3, [r7, #16]
  40e0d6:	3301      	adds	r3, #1
  40e0d8:	781b      	ldrb	r3, [r3, #0]
  40e0da:	461a      	mov	r2, r3
  40e0dc:	683b      	ldr	r3, [r7, #0]
  40e0de:	605a      	str	r2, [r3, #4]
			for (i = 0; i < 9; i++)
  40e0e0:	2300      	movs	r3, #0
  40e0e2:	617b      	str	r3, [r7, #20]
  40e0e4:	e012      	b.n	40e10c <DynProtocol_decodePktCommand+0xc4>
				((VSensorConfigReferenceFrame *)&edata->d.command.cfg)->matrix[i] = (intq30_t) inv_dc_little8_to_int32(&buf[2 + i * 4]);
  40e0e6:	683b      	ldr	r3, [r7, #0]
  40e0e8:	1d1c      	adds	r4, r3, #4
  40e0ea:	697b      	ldr	r3, [r7, #20]
  40e0ec:	009b      	lsls	r3, r3, #2
  40e0ee:	3302      	adds	r3, #2
  40e0f0:	461a      	mov	r2, r3
  40e0f2:	693b      	ldr	r3, [r7, #16]
  40e0f4:	4413      	add	r3, r2
  40e0f6:	4618      	mov	r0, r3
  40e0f8:	4b3b      	ldr	r3, [pc, #236]	; (40e1e8 <DynProtocol_decodePktCommand+0x1a0>)
  40e0fa:	4798      	blx	r3
  40e0fc:	4602      	mov	r2, r0
  40e0fe:	697b      	ldr	r3, [r7, #20]
  40e100:	3302      	adds	r3, #2
  40e102:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
			for (i = 0; i < 9; i++)
  40e106:	697b      	ldr	r3, [r7, #20]
  40e108:	3301      	adds	r3, #1
  40e10a:	617b      	str	r3, [r7, #20]
  40e10c:	697b      	ldr	r3, [r7, #20]
  40e10e:	2b08      	cmp	r3, #8
  40e110:	dde9      	ble.n	40e0e6 <DynProtocol_decodePktCommand+0x9e>
			break;
  40e112:	e063      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>
		}

		case DYN_PROTOCOL_EID_GET_SW_REG:
			edata->d.command.regAddr = buf[1];
  40e114:	693b      	ldr	r3, [r7, #16]
  40e116:	785a      	ldrb	r2, [r3, #1]
  40e118:	683b      	ldr	r3, [r7, #0]
  40e11a:	711a      	strb	r2, [r3, #4]
			break;
  40e11c:	e05e      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>

		case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
		{
			edata->d.command.cfg.base.type = buf[1];
  40e11e:	693b      	ldr	r3, [r7, #16]
  40e120:	3301      	adds	r3, #1
  40e122:	781b      	ldrb	r3, [r3, #0]
  40e124:	461a      	mov	r2, r3
  40e126:	683b      	ldr	r3, [r7, #0]
  40e128:	605a      	str	r2, [r3, #4]
			edata->d.command.cfg.base.size = (uint32_t)buf[2];
  40e12a:	693b      	ldr	r3, [r7, #16]
  40e12c:	3302      	adds	r3, #2
  40e12e:	781b      	ldrb	r3, [r3, #0]
  40e130:	461a      	mov	r2, r3
  40e132:	683b      	ldr	r3, [r7, #0]
  40e134:	609a      	str	r2, [r3, #8]

			switch (edata->d.command.cfg.base.type) {
  40e136:	683b      	ldr	r3, [r7, #0]
  40e138:	685b      	ldr	r3, [r3, #4]
  40e13a:	2b03      	cmp	r3, #3
  40e13c:	d111      	bne.n	40e162 <DynProtocol_decodePktCommand+0x11a>
			case VSENSOR_CONFIG_TYPE_OFFSET:
			{
				precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40e13e:	683b      	ldr	r3, [r7, #0]
  40e140:	681b      	ldr	r3, [r3, #0]
  40e142:	4619      	mov	r1, r3
  40e144:	6878      	ldr	r0, [r7, #4]
  40e146:	4b29      	ldr	r3, [pc, #164]	; (40e1ec <DynProtocol_decodePktCommand+0x1a4>)
  40e148:	4798      	blx	r3
  40e14a:	60f8      	str	r0, [r7, #12]
				DynProtocol_decodeVect16QxToQy(&buf[3], 3, precision, 16, (int32_t*)&edata->d.command.cfg.buffer[0]);
  40e14c:	693b      	ldr	r3, [r7, #16]
  40e14e:	1cd8      	adds	r0, r3, #3
  40e150:	683b      	ldr	r3, [r7, #0]
  40e152:	330c      	adds	r3, #12
  40e154:	9300      	str	r3, [sp, #0]
  40e156:	2310      	movs	r3, #16
  40e158:	68fa      	ldr	r2, [r7, #12]
  40e15a:	2103      	movs	r1, #3
  40e15c:	4c24      	ldr	r4, [pc, #144]	; (40e1f0 <DynProtocol_decodePktCommand+0x1a8>)
  40e15e:	47a0      	blx	r4
				break;
  40e160:	e013      	b.n	40e18a <DynProtocol_decodePktCommand+0x142>
			}

			default:
				if(buf[2] > sizeof(edata->d.command.cfg.buffer))
  40e162:	693b      	ldr	r3, [r7, #16]
  40e164:	3302      	adds	r3, #2
  40e166:	781b      	ldrb	r3, [r3, #0]
  40e168:	2b40      	cmp	r3, #64	; 0x40
  40e16a:	d902      	bls.n	40e172 <DynProtocol_decodePktCommand+0x12a>
					return -1;
  40e16c:	f04f 33ff 	mov.w	r3, #4294967295
  40e170:	e035      	b.n	40e1de <DynProtocol_decodePktCommand+0x196>

				memcpy(edata->d.command.cfg.buffer, &buf[3], buf[2]);
  40e172:	683b      	ldr	r3, [r7, #0]
  40e174:	f103 000c 	add.w	r0, r3, #12
  40e178:	693b      	ldr	r3, [r7, #16]
  40e17a:	1cd9      	adds	r1, r3, #3
  40e17c:	693b      	ldr	r3, [r7, #16]
  40e17e:	3302      	adds	r3, #2
  40e180:	781b      	ldrb	r3, [r3, #0]
  40e182:	461a      	mov	r2, r3
  40e184:	4b1b      	ldr	r3, [pc, #108]	; (40e1f4 <DynProtocol_decodePktCommand+0x1ac>)
  40e186:	4798      	blx	r3
				break;
  40e188:	bf00      	nop
			}
			break;
  40e18a:	e027      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>
		}

		case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
			edata->d.command.cfg.base.type = buf[1];
  40e18c:	693b      	ldr	r3, [r7, #16]
  40e18e:	3301      	adds	r3, #1
  40e190:	781b      	ldrb	r3, [r3, #0]
  40e192:	461a      	mov	r2, r3
  40e194:	683b      	ldr	r3, [r7, #0]
  40e196:	605a      	str	r2, [r3, #4]
			break;
  40e198:	e020      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>

		case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
			edata->d.command.cfg.base.type = buf[1];
  40e19a:	693b      	ldr	r3, [r7, #16]
  40e19c:	3301      	adds	r3, #1
  40e19e:	781b      	ldrb	r3, [r3, #0]
  40e1a0:	461a      	mov	r2, r3
  40e1a2:	683b      	ldr	r3, [r7, #0]
  40e1a4:	605a      	str	r2, [r3, #4]
			break;
  40e1a6:	e019      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>

		case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:
			edata->d.command.cfg.base.type = buf[1];
  40e1a8:	693b      	ldr	r3, [r7, #16]
  40e1aa:	3301      	adds	r3, #1
  40e1ac:	781b      	ldrb	r3, [r3, #0]
  40e1ae:	461a      	mov	r2, r3
  40e1b0:	683b      	ldr	r3, [r7, #0]
  40e1b2:	605a      	str	r2, [r3, #4]
			precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40e1b4:	683b      	ldr	r3, [r7, #0]
  40e1b6:	681b      	ldr	r3, [r3, #0]
  40e1b8:	4619      	mov	r1, r3
  40e1ba:	6878      	ldr	r0, [r7, #4]
  40e1bc:	4b0b      	ldr	r3, [pc, #44]	; (40e1ec <DynProtocol_decodePktCommand+0x1a4>)
  40e1be:	4798      	blx	r3
  40e1c0:	60f8      	str	r0, [r7, #12]
			DynProtocol_decodeVect16QxToQy(&buf[2], 3, precision, 16, &((VSensorConfigOffset *)&edata->d.command.cfg)->vect[0]);
  40e1c2:	693b      	ldr	r3, [r7, #16]
  40e1c4:	1c98      	adds	r0, r3, #2
  40e1c6:	683b      	ldr	r3, [r7, #0]
  40e1c8:	3304      	adds	r3, #4
  40e1ca:	3308      	adds	r3, #8
  40e1cc:	9300      	str	r3, [sp, #0]
  40e1ce:	2310      	movs	r3, #16
  40e1d0:	68fa      	ldr	r2, [r7, #12]
  40e1d2:	2103      	movs	r1, #3
  40e1d4:	4c06      	ldr	r4, [pc, #24]	; (40e1f0 <DynProtocol_decodePktCommand+0x1a8>)
  40e1d6:	47a0      	blx	r4
			break;
  40e1d8:	e000      	b.n	40e1dc <DynProtocol_decodePktCommand+0x194>

		default:
			break;
  40e1da:	bf00      	nop
		}
	}

	return 0;
  40e1dc:	2300      	movs	r3, #0
}
  40e1de:	4618      	mov	r0, r3
  40e1e0:	371c      	adds	r7, #28
  40e1e2:	46bd      	mov	sp, r7
  40e1e4:	bd90      	pop	{r4, r7, pc}
  40e1e6:	bf00      	nop
  40e1e8:	0040fa3f 	.word	0x0040fa3f
  40e1ec:	0040d0f1 	.word	0x0040d0f1
  40e1f0:	0040cfe9 	.word	0x0040cfe9
  40e1f4:	00414235 	.word	0x00414235

0040e1f8 <DynProtocol_decodePktResponse>:

static int DynProtocol_decodePktResponse(DynProtocol_t * self,
		struct DynProtocolEdata * edata)
{
  40e1f8:	b590      	push	{r4, r7, lr}
  40e1fa:	b089      	sub	sp, #36	; 0x24
  40e1fc:	af02      	add	r7, sp, #8
  40e1fe:	6078      	str	r0, [r7, #4]
  40e200:	6039      	str	r1, [r7, #0]
	int precision;
	int rc = 0;
  40e202:	2300      	movs	r3, #0
  40e204:	617b      	str	r3, [r7, #20]
	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
  40e206:	687b      	ldr	r3, [r7, #4]
  40e208:	3314      	adds	r3, #20
  40e20a:	613b      	str	r3, [r7, #16]
	const uint16_t len = self->decode_state_machine.received_size;
  40e20c:	687b      	ldr	r3, [r7, #4]
  40e20e:	8a5b      	ldrh	r3, [r3, #18]
  40e210:	81fb      	strh	r3, [r7, #14]

	switch(self->decode_state_machine.cmd_id) {
  40e212:	687b      	ldr	r3, [r7, #4]
  40e214:	7b9b      	ldrb	r3, [r3, #14]
  40e216:	2b24      	cmp	r3, #36	; 0x24
  40e218:	f200 80d8 	bhi.w	40e3cc <DynProtocol_decodePktResponse+0x1d4>
  40e21c:	a201      	add	r2, pc, #4	; (adr r2, 40e224 <DynProtocol_decodePktResponse+0x2c>)
  40e21e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40e222:	bf00      	nop
  40e224:	0040e2b9 	.word	0x0040e2b9
  40e228:	0040e3cd 	.word	0x0040e3cd
  40e22c:	0040e3cd 	.word	0x0040e3cd
  40e230:	0040e3cd 	.word	0x0040e3cd
  40e234:	0040e3cd 	.word	0x0040e3cd
  40e238:	0040e3cd 	.word	0x0040e3cd
  40e23c:	0040e3cd 	.word	0x0040e3cd
  40e240:	0040e3cd 	.word	0x0040e3cd
  40e244:	0040e3cd 	.word	0x0040e3cd
  40e248:	0040e3cd 	.word	0x0040e3cd
  40e24c:	0040e3cd 	.word	0x0040e3cd
  40e250:	0040e3cd 	.word	0x0040e3cd
  40e254:	0040e3cd 	.word	0x0040e3cd
  40e258:	0040e3cd 	.word	0x0040e3cd
  40e25c:	0040e3cd 	.word	0x0040e3cd
  40e260:	0040e3cd 	.word	0x0040e3cd
  40e264:	0040e3cd 	.word	0x0040e3cd
  40e268:	0040e3cd 	.word	0x0040e3cd
  40e26c:	0040e3cd 	.word	0x0040e3cd
  40e270:	0040e3cd 	.word	0x0040e3cd
  40e274:	0040e3cd 	.word	0x0040e3cd
  40e278:	0040e3cd 	.word	0x0040e3cd
  40e27c:	0040e2b9 	.word	0x0040e2b9
  40e280:	0040e3cd 	.word	0x0040e3cd
  40e284:	0040e3cd 	.word	0x0040e3cd
  40e288:	0040e3cd 	.word	0x0040e3cd
  40e28c:	0040e3cd 	.word	0x0040e3cd
  40e290:	0040e3cd 	.word	0x0040e3cd
  40e294:	0040e3cd 	.word	0x0040e3cd
  40e298:	0040e3cd 	.word	0x0040e3cd
  40e29c:	0040e3cd 	.word	0x0040e3cd
  40e2a0:	0040e381 	.word	0x0040e381
  40e2a4:	0040e3cd 	.word	0x0040e3cd
  40e2a8:	0040e2cf 	.word	0x0040e2cf
  40e2ac:	0040e3cd 	.word	0x0040e3cd
  40e2b0:	0040e3cd 	.word	0x0040e3cd
  40e2b4:	0040e2f9 	.word	0x0040e2f9
	case DYN_PROTOCOL_EID_PROTOCOLVERSION:
	case DYN_PROTOCOL_EID_GET_FW_INFO:
		memcpy(edata->d.response.version, buf, sizeof(edata->d.response.version) - 1);
  40e2b8:	683b      	ldr	r3, [r7, #0]
  40e2ba:	3304      	adds	r3, #4
  40e2bc:	220f      	movs	r2, #15
  40e2be:	6939      	ldr	r1, [r7, #16]
  40e2c0:	4618      	mov	r0, r3
  40e2c2:	4b49      	ldr	r3, [pc, #292]	; (40e3e8 <DynProtocol_decodePktResponse+0x1f0>)
  40e2c4:	4798      	blx	r3
		edata->d.response.version[sizeof(edata->d.response.version)-1] = '\0';
  40e2c6:	683b      	ldr	r3, [r7, #0]
  40e2c8:	2200      	movs	r2, #0
  40e2ca:	74da      	strb	r2, [r3, #19]
		break;
  40e2cc:	e086      	b.n	40e3dc <DynProtocol_decodePktResponse+0x1e4>

	case DYN_PROTOCOL_EID_GET_SENSOR_DATA:
	{
		edata->d.response.sensorData.rc = (int)(int8_t)buf[0];
  40e2ce:	693b      	ldr	r3, [r7, #16]
  40e2d0:	781b      	ldrb	r3, [r3, #0]
  40e2d2:	b25b      	sxtb	r3, r3
  40e2d4:	461a      	mov	r2, r3
  40e2d6:	683b      	ldr	r3, [r7, #0]
  40e2d8:	605a      	str	r2, [r3, #4]
		if(edata->d.response.sensorData.rc == 0)
  40e2da:	683b      	ldr	r3, [r7, #0]
  40e2dc:	685b      	ldr	r3, [r3, #4]
  40e2de:	2b00      	cmp	r3, #0
  40e2e0:	d17b      	bne.n	40e3da <DynProtocol_decodePktResponse+0x1e2>
			rc = DynProtocol_decodeSensorEvent(self, &buf[1], len, edata, DYN_PROTOCOL_ETYPE_RESP);
  40e2e2:	693b      	ldr	r3, [r7, #16]
  40e2e4:	1c59      	adds	r1, r3, #1
  40e2e6:	89fa      	ldrh	r2, [r7, #14]
  40e2e8:	2301      	movs	r3, #1
  40e2ea:	9300      	str	r3, [sp, #0]
  40e2ec:	683b      	ldr	r3, [r7, #0]
  40e2ee:	6878      	ldr	r0, [r7, #4]
  40e2f0:	4c3e      	ldr	r4, [pc, #248]	; (40e3ec <DynProtocol_decodePktResponse+0x1f4>)
  40e2f2:	47a0      	blx	r4
  40e2f4:	6178      	str	r0, [r7, #20]
		break;
  40e2f6:	e070      	b.n	40e3da <DynProtocol_decodePktResponse+0x1e2>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
	{
		edata->d.response.sensorcfg.rc = (int)(int8_t)buf[0];
  40e2f8:	693b      	ldr	r3, [r7, #16]
  40e2fa:	781b      	ldrb	r3, [r3, #0]
  40e2fc:	b25b      	sxtb	r3, r3
  40e2fe:	461a      	mov	r2, r3
  40e300:	683b      	ldr	r3, [r7, #0]
  40e302:	605a      	str	r2, [r3, #4]
		edata->d.response.sensorcfg.cfg.base.type = buf[1];
  40e304:	693b      	ldr	r3, [r7, #16]
  40e306:	3301      	adds	r3, #1
  40e308:	781b      	ldrb	r3, [r3, #0]
  40e30a:	461a      	mov	r2, r3
  40e30c:	683b      	ldr	r3, [r7, #0]
  40e30e:	609a      	str	r2, [r3, #8]
		edata->d.response.sensorcfg.cfg.base.size = (uint32_t)buf[2];
  40e310:	693b      	ldr	r3, [r7, #16]
  40e312:	3302      	adds	r3, #2
  40e314:	781b      	ldrb	r3, [r3, #0]
  40e316:	461a      	mov	r2, r3
  40e318:	683b      	ldr	r3, [r7, #0]
  40e31a:	60da      	str	r2, [r3, #12]

		switch (edata->d.response.sensorcfg.cfg.base.type) {
  40e31c:	683b      	ldr	r3, [r7, #0]
  40e31e:	689b      	ldr	r3, [r3, #8]
  40e320:	2b03      	cmp	r3, #3
  40e322:	d118      	bne.n	40e356 <DynProtocol_decodePktResponse+0x15e>
		case VSENSOR_CONFIG_TYPE_OFFSET:
		{
			edata->sensor_id = (int)(int8_t)buf[3];
  40e324:	693b      	ldr	r3, [r7, #16]
  40e326:	3303      	adds	r3, #3
  40e328:	781b      	ldrb	r3, [r3, #0]
  40e32a:	b25b      	sxtb	r3, r3
  40e32c:	461a      	mov	r2, r3
  40e32e:	683b      	ldr	r3, [r7, #0]
  40e330:	601a      	str	r2, [r3, #0]
			precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40e332:	683b      	ldr	r3, [r7, #0]
  40e334:	681b      	ldr	r3, [r3, #0]
  40e336:	4619      	mov	r1, r3
  40e338:	6878      	ldr	r0, [r7, #4]
  40e33a:	4b2d      	ldr	r3, [pc, #180]	; (40e3f0 <DynProtocol_decodePktResponse+0x1f8>)
  40e33c:	4798      	blx	r3
  40e33e:	60b8      	str	r0, [r7, #8]
			DynProtocol_decodeVect16QxToQy(&buf[4], 3, precision, 16, (int32_t*)&edata->d.response.sensorcfg.cfg.buffer[0]);
  40e340:	693b      	ldr	r3, [r7, #16]
  40e342:	1d18      	adds	r0, r3, #4
  40e344:	683b      	ldr	r3, [r7, #0]
  40e346:	3310      	adds	r3, #16
  40e348:	9300      	str	r3, [sp, #0]
  40e34a:	2310      	movs	r3, #16
  40e34c:	68ba      	ldr	r2, [r7, #8]
  40e34e:	2103      	movs	r1, #3
  40e350:	4c28      	ldr	r4, [pc, #160]	; (40e3f4 <DynProtocol_decodePktResponse+0x1fc>)
  40e352:	47a0      	blx	r4
			break;
  40e354:	e013      	b.n	40e37e <DynProtocol_decodePktResponse+0x186>
		}

		default:
			if(buf[2] > sizeof(edata->d.response.sensorcfg.cfg.buffer))
  40e356:	693b      	ldr	r3, [r7, #16]
  40e358:	3302      	adds	r3, #2
  40e35a:	781b      	ldrb	r3, [r3, #0]
  40e35c:	2b40      	cmp	r3, #64	; 0x40
  40e35e:	d902      	bls.n	40e366 <DynProtocol_decodePktResponse+0x16e>
				return -1;
  40e360:	f04f 33ff 	mov.w	r3, #4294967295
  40e364:	e03b      	b.n	40e3de <DynProtocol_decodePktResponse+0x1e6>

			memcpy(edata->d.response.sensorcfg.cfg.buffer, &buf[3], buf[2]);
  40e366:	683b      	ldr	r3, [r7, #0]
  40e368:	f103 0010 	add.w	r0, r3, #16
  40e36c:	693b      	ldr	r3, [r7, #16]
  40e36e:	1cd9      	adds	r1, r3, #3
  40e370:	693b      	ldr	r3, [r7, #16]
  40e372:	3302      	adds	r3, #2
  40e374:	781b      	ldrb	r3, [r3, #0]
  40e376:	461a      	mov	r2, r3
  40e378:	4b1b      	ldr	r3, [pc, #108]	; (40e3e8 <DynProtocol_decodePktResponse+0x1f0>)
  40e37a:	4798      	blx	r3
			break;
  40e37c:	bf00      	nop
		}

		break;
  40e37e:	e02d      	b.n	40e3dc <DynProtocol_decodePktResponse+0x1e4>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
		edata->d.response.sensorcfg.rc = (int)(int8_t)buf[0];
  40e380:	693b      	ldr	r3, [r7, #16]
  40e382:	781b      	ldrb	r3, [r3, #0]
  40e384:	b25b      	sxtb	r3, r3
  40e386:	461a      	mov	r2, r3
  40e388:	683b      	ldr	r3, [r7, #0]
  40e38a:	605a      	str	r2, [r3, #4]
		edata->sensor_id = (int)(int8_t)buf[1];
  40e38c:	693b      	ldr	r3, [r7, #16]
  40e38e:	3301      	adds	r3, #1
  40e390:	781b      	ldrb	r3, [r3, #0]
  40e392:	b25b      	sxtb	r3, r3
  40e394:	461a      	mov	r2, r3
  40e396:	683b      	ldr	r3, [r7, #0]
  40e398:	601a      	str	r2, [r3, #0]
		edata->d.response.sensorcfg.cfg.base.type = buf[2];
  40e39a:	693b      	ldr	r3, [r7, #16]
  40e39c:	3302      	adds	r3, #2
  40e39e:	781b      	ldrb	r3, [r3, #0]
  40e3a0:	461a      	mov	r2, r3
  40e3a2:	683b      	ldr	r3, [r7, #0]
  40e3a4:	609a      	str	r2, [r3, #8]
		precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40e3a6:	683b      	ldr	r3, [r7, #0]
  40e3a8:	681b      	ldr	r3, [r3, #0]
  40e3aa:	4619      	mov	r1, r3
  40e3ac:	6878      	ldr	r0, [r7, #4]
  40e3ae:	4b10      	ldr	r3, [pc, #64]	; (40e3f0 <DynProtocol_decodePktResponse+0x1f8>)
  40e3b0:	4798      	blx	r3
  40e3b2:	60b8      	str	r0, [r7, #8]
		DynProtocol_decodeVect16QxToQy(&buf[3], 3, precision, 16, &((VSensorConfigOffset *)&edata->d.response.sensorcfg.cfg)->vect[0]);
  40e3b4:	693b      	ldr	r3, [r7, #16]
  40e3b6:	1cd8      	adds	r0, r3, #3
  40e3b8:	683b      	ldr	r3, [r7, #0]
  40e3ba:	3308      	adds	r3, #8
  40e3bc:	3308      	adds	r3, #8
  40e3be:	9300      	str	r3, [sp, #0]
  40e3c0:	2310      	movs	r3, #16
  40e3c2:	68ba      	ldr	r2, [r7, #8]
  40e3c4:	2103      	movs	r1, #3
  40e3c6:	4c0b      	ldr	r4, [pc, #44]	; (40e3f4 <DynProtocol_decodePktResponse+0x1fc>)
  40e3c8:	47a0      	blx	r4
		break;
  40e3ca:	e007      	b.n	40e3dc <DynProtocol_decodePktResponse+0x1e4>

	default:
		edata->d.response.rc = (int)(int8_t)buf[0];
  40e3cc:	693b      	ldr	r3, [r7, #16]
  40e3ce:	781b      	ldrb	r3, [r3, #0]
  40e3d0:	b25b      	sxtb	r3, r3
  40e3d2:	461a      	mov	r2, r3
  40e3d4:	683b      	ldr	r3, [r7, #0]
  40e3d6:	605a      	str	r2, [r3, #4]
  40e3d8:	e000      	b.n	40e3dc <DynProtocol_decodePktResponse+0x1e4>
		break;
  40e3da:	bf00      	nop
	}

	return rc;
  40e3dc:	697b      	ldr	r3, [r7, #20]
}
  40e3de:	4618      	mov	r0, r3
  40e3e0:	371c      	adds	r7, #28
  40e3e2:	46bd      	mov	sp, r7
  40e3e4:	bd90      	pop	{r4, r7, pc}
  40e3e6:	bf00      	nop
  40e3e8:	00414235 	.word	0x00414235
  40e3ec:	0040d671 	.word	0x0040d671
  40e3f0:	0040d0f1 	.word	0x0040d0f1
  40e3f4:	0040cfe9 	.word	0x0040cfe9

0040e3f8 <DynProtocol_decodePktAsync>:

static int DynProtocol_decodePktAsync(DynProtocol_t * self,
		struct DynProtocolEdata * edata)
{
  40e3f8:	b590      	push	{r4, r7, lr}
  40e3fa:	b087      	sub	sp, #28
  40e3fc:	af02      	add	r7, sp, #8
  40e3fe:	6078      	str	r0, [r7, #4]
  40e400:	6039      	str	r1, [r7, #0]
	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
  40e402:	687b      	ldr	r3, [r7, #4]
  40e404:	3314      	adds	r3, #20
  40e406:	60fb      	str	r3, [r7, #12]
	const uint16_t len = self->decode_state_machine.received_size;
  40e408:	687b      	ldr	r3, [r7, #4]
  40e40a:	8a5b      	ldrh	r3, [r3, #18]
  40e40c:	817b      	strh	r3, [r7, #10]

	switch(self->decode_state_machine.cmd_id) {
  40e40e:	687b      	ldr	r3, [r7, #4]
  40e410:	7b9b      	ldrb	r3, [r3, #14]
  40e412:	2b30      	cmp	r3, #48	; 0x30
  40e414:	d109      	bne.n	40e42a <DynProtocol_decodePktAsync+0x32>
	case DYN_PROTOCOL_EID_NEW_SENSOR_DATA:
		return DynProtocol_decodeSensorEvent(self, buf, len, edata, DYN_PROTOCOL_ETYPE_ASYNC);
  40e416:	897a      	ldrh	r2, [r7, #10]
  40e418:	2302      	movs	r3, #2
  40e41a:	9300      	str	r3, [sp, #0]
  40e41c:	683b      	ldr	r3, [r7, #0]
  40e41e:	68f9      	ldr	r1, [r7, #12]
  40e420:	6878      	ldr	r0, [r7, #4]
  40e422:	4c05      	ldr	r4, [pc, #20]	; (40e438 <DynProtocol_decodePktAsync+0x40>)
  40e424:	47a0      	blx	r4
  40e426:	4603      	mov	r3, r0
  40e428:	e001      	b.n	40e42e <DynProtocol_decodePktAsync+0x36>

	default:
		return -1;
  40e42a:	f04f 33ff 	mov.w	r3, #4294967295
	}
}
  40e42e:	4618      	mov	r0, r3
  40e430:	3714      	adds	r7, #20
  40e432:	46bd      	mov	sp, r7
  40e434:	bd90      	pop	{r4, r7, pc}
  40e436:	bf00      	nop
  40e438:	0040d671 	.word	0x0040d671

0040e43c <DynProtocol_callEventCB>:
static inline void DynProtocol_callEventCB(DynProtocol_t * self,
	enum DynProtocolEtype etype,
	enum DynProtocolEid eid,
	const DynProtocolEdata_t * edata
)
{
  40e43c:	b590      	push	{r4, r7, lr}
  40e43e:	b085      	sub	sp, #20
  40e440:	af00      	add	r7, sp, #0
  40e442:	60f8      	str	r0, [r7, #12]
  40e444:	607b      	str	r3, [r7, #4]
  40e446:	460b      	mov	r3, r1
  40e448:	72fb      	strb	r3, [r7, #11]
  40e44a:	4613      	mov	r3, r2
  40e44c:	72bb      	strb	r3, [r7, #10]
	if(self->event_cb) {
  40e44e:	68fb      	ldr	r3, [r7, #12]
  40e450:	681b      	ldr	r3, [r3, #0]
  40e452:	2b00      	cmp	r3, #0
  40e454:	d007      	beq.n	40e466 <DynProtocol_callEventCB+0x2a>
		self->event_cb(etype, eid, edata, self->event_cb_cookie);
  40e456:	68fb      	ldr	r3, [r7, #12]
  40e458:	681c      	ldr	r4, [r3, #0]
  40e45a:	68fb      	ldr	r3, [r7, #12]
  40e45c:	685b      	ldr	r3, [r3, #4]
  40e45e:	7ab9      	ldrb	r1, [r7, #10]
  40e460:	7af8      	ldrb	r0, [r7, #11]
  40e462:	687a      	ldr	r2, [r7, #4]
  40e464:	47a0      	blx	r4
	}
}
  40e466:	bf00      	nop
  40e468:	3714      	adds	r7, #20
  40e46a:	46bd      	mov	sp, r7
  40e46c:	bd90      	pop	{r4, r7, pc}
	...

0040e470 <DynProtocol_doProcess>:

static int DynProtocol_doProcess(DynProtocol_t * self)
{
  40e470:	b590      	push	{r4, r7, lr}
  40e472:	b0a7      	sub	sp, #156	; 0x9c
  40e474:	af00      	add	r7, sp, #0
  40e476:	6078      	str	r0, [r7, #4]
	struct DynProtocolEdata edata;
	enum DynProtocolEtype etype;
	int rc;

	self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
  40e478:	687b      	ldr	r3, [r7, #4]
  40e47a:	2200      	movs	r2, #0
  40e47c:	721a      	strb	r2, [r3, #8]

	switch(self->decode_state_machine.event_type) {
  40e47e:	687b      	ldr	r3, [r7, #4]
  40e480:	7b1b      	ldrb	r3, [r3, #12]
  40e482:	2b40      	cmp	r3, #64	; 0x40
  40e484:	d00f      	beq.n	40e4a6 <DynProtocol_doProcess+0x36>
  40e486:	2b80      	cmp	r3, #128	; 0x80
  40e488:	d019      	beq.n	40e4be <DynProtocol_doProcess+0x4e>
  40e48a:	2b00      	cmp	r3, #0
  40e48c:	d123      	bne.n	40e4d6 <DynProtocol_doProcess+0x66>
	case EVENT_TYPE_CMD:
		rc = DynProtocol_decodePktCommand(self, &edata);
  40e48e:	f107 030c 	add.w	r3, r7, #12
  40e492:	4619      	mov	r1, r3
  40e494:	6878      	ldr	r0, [r7, #4]
  40e496:	4b20      	ldr	r3, [pc, #128]	; (40e518 <DynProtocol_doProcess+0xa8>)
  40e498:	4798      	blx	r3
  40e49a:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
		etype = DYN_PROTOCOL_ETYPE_CMD;
  40e49e:	2300      	movs	r3, #0
  40e4a0:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		break;
  40e4a4:	e01e      	b.n	40e4e4 <DynProtocol_doProcess+0x74>

	case EVENT_TYPE_RESP:
		rc = DynProtocol_decodePktResponse(self, &edata);
  40e4a6:	f107 030c 	add.w	r3, r7, #12
  40e4aa:	4619      	mov	r1, r3
  40e4ac:	6878      	ldr	r0, [r7, #4]
  40e4ae:	4b1b      	ldr	r3, [pc, #108]	; (40e51c <DynProtocol_doProcess+0xac>)
  40e4b0:	4798      	blx	r3
  40e4b2:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
		etype = DYN_PROTOCOL_ETYPE_RESP;
  40e4b6:	2301      	movs	r3, #1
  40e4b8:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		break;
  40e4bc:	e012      	b.n	40e4e4 <DynProtocol_doProcess+0x74>

	case EVENT_TYPE_ASYNC:
		rc = DynProtocol_decodePktAsync(self, &edata);
  40e4be:	f107 030c 	add.w	r3, r7, #12
  40e4c2:	4619      	mov	r1, r3
  40e4c4:	6878      	ldr	r0, [r7, #4]
  40e4c6:	4b16      	ldr	r3, [pc, #88]	; (40e520 <DynProtocol_doProcess+0xb0>)
  40e4c8:	4798      	blx	r3
  40e4ca:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
		etype = DYN_PROTOCOL_ETYPE_ASYNC;
  40e4ce:	2302      	movs	r3, #2
  40e4d0:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		break;
  40e4d4:	e006      	b.n	40e4e4 <DynProtocol_doProcess+0x74>

	default:
		INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: Unexpected packet type");
  40e4d6:	4913      	ldr	r1, [pc, #76]	; (40e524 <DynProtocol_doProcess+0xb4>)
  40e4d8:	2002      	movs	r0, #2
  40e4da:	4b13      	ldr	r3, [pc, #76]	; (40e528 <DynProtocol_doProcess+0xb8>)
  40e4dc:	4798      	blx	r3
		return -1;
  40e4de:	f04f 33ff 	mov.w	r3, #4294967295
  40e4e2:	e014      	b.n	40e50e <DynProtocol_doProcess+0x9e>
	}

	if(rc == 0) {
  40e4e4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  40e4e8:	2b00      	cmp	r3, #0
  40e4ea:	d10a      	bne.n	40e502 <DynProtocol_doProcess+0x92>
		DynProtocol_callEventCB(self, etype, (enum DynProtocolEid)self->decode_state_machine.cmd_id, &edata);
  40e4ec:	687b      	ldr	r3, [r7, #4]
  40e4ee:	7b9a      	ldrb	r2, [r3, #14]
  40e4f0:	f107 030c 	add.w	r3, r7, #12
  40e4f4:	f897 1097 	ldrb.w	r1, [r7, #151]	; 0x97
  40e4f8:	6878      	ldr	r0, [r7, #4]
  40e4fa:	4c0c      	ldr	r4, [pc, #48]	; (40e52c <DynProtocol_doProcess+0xbc>)
  40e4fc:	47a0      	blx	r4
		return 1;
  40e4fe:	2301      	movs	r3, #1
  40e500:	e005      	b.n	40e50e <DynProtocol_doProcess+0x9e>
	} else {
		INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected packet received.");
  40e502:	490b      	ldr	r1, [pc, #44]	; (40e530 <DynProtocol_doProcess+0xc0>)
  40e504:	2001      	movs	r0, #1
  40e506:	4b08      	ldr	r3, [pc, #32]	; (40e528 <DynProtocol_doProcess+0xb8>)
  40e508:	4798      	blx	r3
	}

	return rc;
  40e50a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
}
  40e50e:	4618      	mov	r0, r3
  40e510:	379c      	adds	r7, #156	; 0x9c
  40e512:	46bd      	mov	sp, r7
  40e514:	bd90      	pop	{r4, r7, pc}
  40e516:	bf00      	nop
  40e518:	0040e049 	.word	0x0040e049
  40e51c:	0040e1f9 	.word	0x0040e1f9
  40e520:	0040e3f9 	.word	0x0040e3f9
  40e524:	0041cc84 	.word	0x0041cc84
  40e528:	0040ff51 	.word	0x0040ff51
  40e52c:	0040e43d 	.word	0x0040e43d
  40e530:	0041cca8 	.word	0x0041cca8

0040e534 <DynProtocol_encodeSensorEvent>:

static int DynProtocol_encodeSensorEvent(DynProtocol_t * self, const DynProtocolEdata_t *edata,
		uint8_t * outBuffer, uint16_t maxBufferSize, enum DynProtocolEtype etype)
{
  40e534:	b590      	push	{r4, r7, lr}
  40e536:	b08b      	sub	sp, #44	; 0x2c
  40e538:	af02      	add	r7, sp, #8
  40e53a:	60f8      	str	r0, [r7, #12]
  40e53c:	60b9      	str	r1, [r7, #8]
  40e53e:	607a      	str	r2, [r7, #4]
  40e540:	807b      	strh	r3, [r7, #2]
	uint16_t idx = 0, i=0;
  40e542:	2300      	movs	r3, #0
  40e544:	83fb      	strh	r3, [r7, #30]
  40e546:	2300      	movs	r3, #0
  40e548:	83bb      	strh	r3, [r7, #28]
	uint32_t sensorStatus;
	uint32_t timestamp;
	const VSensorDataAny *vSensordata;

	switch(etype) {
  40e54a:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  40e54e:	2b01      	cmp	r3, #1
  40e550:	d002      	beq.n	40e558 <DynProtocol_encodeSensorEvent+0x24>
  40e552:	2b02      	cmp	r3, #2
  40e554:	d007      	beq.n	40e566 <DynProtocol_encodeSensorEvent+0x32>
  40e556:	e00d      	b.n	40e574 <DynProtocol_encodeSensorEvent+0x40>
	case DYN_PROTOCOL_ETYPE_RESP:
		sensorStatus = edata->d.response.sensorData.status;
  40e558:	68bb      	ldr	r3, [r7, #8]
  40e55a:	689b      	ldr	r3, [r3, #8]
  40e55c:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.response.sensorData.vdata;
  40e55e:	68bb      	ldr	r3, [r7, #8]
  40e560:	330c      	adds	r3, #12
  40e562:	617b      	str	r3, [r7, #20]
		break;
  40e564:	e00a      	b.n	40e57c <DynProtocol_encodeSensorEvent+0x48>

	case DYN_PROTOCOL_ETYPE_ASYNC:
		sensorStatus = edata->d.async.sensorEvent.status;
  40e566:	68bb      	ldr	r3, [r7, #8]
  40e568:	685b      	ldr	r3, [r3, #4]
  40e56a:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.async.sensorEvent.vdata;
  40e56c:	68bb      	ldr	r3, [r7, #8]
  40e56e:	3308      	adds	r3, #8
  40e570:	617b      	str	r3, [r7, #20]
		break;
  40e572:	e003      	b.n	40e57c <DynProtocol_encodeSensorEvent+0x48>

	case DYN_PROTOCOL_ETYPE_CMD:
	default:
		return INV_ERROR_BAD_ARG;
  40e574:	f06f 030a 	mvn.w	r3, #10
  40e578:	f000 bdef 	b.w	40f15a <DynProtocol_encodeSensorEvent+0xc26>
	}

	timestamp = (uint32_t)vSensordata->base.timestamp;
  40e57c:	697b      	ldr	r3, [r7, #20]
  40e57e:	681b      	ldr	r3, [r3, #0]
  40e580:	613b      	str	r3, [r7, #16]

	if(maxBufferSize < 4) {
  40e582:	887b      	ldrh	r3, [r7, #2]
  40e584:	2b03      	cmp	r3, #3
  40e586:	f240 85a3 	bls.w	40f0d0 <DynProtocol_encodeSensorEvent+0xb9c>
		goto error_size;
	}

	outBuffer[idx] = (uint8_t)(sensorStatus & 0x03);
  40e58a:	8bfb      	ldrh	r3, [r7, #30]
  40e58c:	687a      	ldr	r2, [r7, #4]
  40e58e:	4413      	add	r3, r2
  40e590:	69ba      	ldr	r2, [r7, #24]
  40e592:	b2d2      	uxtb	r2, r2
  40e594:	f002 0203 	and.w	r2, r2, #3
  40e598:	b2d2      	uxtb	r2, r2
  40e59a:	701a      	strb	r2, [r3, #0]
	idx += 1;
  40e59c:	8bfb      	ldrh	r3, [r7, #30]
  40e59e:	3301      	adds	r3, #1
  40e5a0:	83fb      	strh	r3, [r7, #30]
	outBuffer[idx] = (uint8_t)edata->sensor_id;
  40e5a2:	8bfb      	ldrh	r3, [r7, #30]
  40e5a4:	687a      	ldr	r2, [r7, #4]
  40e5a6:	4413      	add	r3, r2
  40e5a8:	68ba      	ldr	r2, [r7, #8]
  40e5aa:	6812      	ldr	r2, [r2, #0]
  40e5ac:	b2d2      	uxtb	r2, r2
  40e5ae:	701a      	strb	r2, [r3, #0]
	idx += 1;
  40e5b0:	8bfb      	ldrh	r3, [r7, #30]
  40e5b2:	3301      	adds	r3, #1
  40e5b4:	83fb      	strh	r3, [r7, #30]

	inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40e5b6:	6938      	ldr	r0, [r7, #16]
  40e5b8:	8bfb      	ldrh	r3, [r7, #30]
  40e5ba:	687a      	ldr	r2, [r7, #4]
  40e5bc:	4413      	add	r3, r2
  40e5be:	4619      	mov	r1, r3
  40e5c0:	4bbd      	ldr	r3, [pc, #756]	; (40e8b8 <DynProtocol_encodeSensorEvent+0x384>)
  40e5c2:	4798      	blx	r3
	idx += 4;
  40e5c4:	8bfb      	ldrh	r3, [r7, #30]
  40e5c6:	3304      	adds	r3, #4
  40e5c8:	83fb      	strh	r3, [r7, #30]

	maxBufferSize -= idx;
  40e5ca:	887a      	ldrh	r2, [r7, #2]
  40e5cc:	8bfb      	ldrh	r3, [r7, #30]
  40e5ce:	1ad3      	subs	r3, r2, r3
  40e5d0:	807b      	strh	r3, [r7, #2]

	switch(edata->sensor_id) {
  40e5d2:	68bb      	ldr	r3, [r7, #8]
  40e5d4:	681b      	ldr	r3, [r3, #0]
  40e5d6:	2b41      	cmp	r3, #65	; 0x41
  40e5d8:	f200 8574 	bhi.w	40f0c4 <DynProtocol_encodeSensorEvent+0xb90>
  40e5dc:	a201      	add	r2, pc, #4	; (adr r2, 40e5e4 <DynProtocol_encodeSensorEvent+0xb0>)
  40e5de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40e5e2:	bf00      	nop
  40e5e4:	0040f0cb 	.word	0x0040f0cb
  40e5e8:	0040e6ed 	.word	0x0040e6ed
  40e5ec:	0040e73d 	.word	0x0040e73d
  40e5f0:	0040ee61 	.word	0x0040ee61
  40e5f4:	0040e7ef 	.word	0x0040e7ef
  40e5f8:	0040eea7 	.word	0x0040eea7
  40e5fc:	0040ee3f 	.word	0x0040ee3f
  40e600:	0040f0c5 	.word	0x0040f0c5
  40e604:	0040eec9 	.word	0x0040eec9
  40e608:	0040e6ed 	.word	0x0040e6ed
  40e60c:	0040e6ed 	.word	0x0040e6ed
  40e610:	0040e907 	.word	0x0040e907
  40e614:	0040f0c5 	.word	0x0040f0c5
  40e618:	0040ea11 	.word	0x0040ea11
  40e61c:	0040e785 	.word	0x0040e785
  40e620:	0040e8c1 	.word	0x0040e8c1
  40e624:	0040e83f 	.word	0x0040e83f
  40e628:	0040ee21 	.word	0x0040ee21
  40e62c:	0040ee21 	.word	0x0040ee21
  40e630:	0040ed87 	.word	0x0040ed87
  40e634:	0040e907 	.word	0x0040e907
  40e638:	0040f009 	.word	0x0040f009
  40e63c:	0040ee21 	.word	0x0040ee21
  40e640:	0040ee21 	.word	0x0040ee21
  40e644:	0040ee21 	.word	0x0040ee21
  40e648:	0040ee21 	.word	0x0040ee21
  40e64c:	0040edbd 	.word	0x0040edbd
  40e650:	0040f0c5 	.word	0x0040f0c5
  40e654:	0040ee21 	.word	0x0040ee21
  40e658:	0040e8c1 	.word	0x0040e8c1
  40e65c:	0040ef0d 	.word	0x0040ef0d
  40e660:	0040e9c7 	.word	0x0040e9c7
  40e664:	0040e9c7 	.word	0x0040e9c7
  40e668:	0040e9c7 	.word	0x0040e9c7
  40e66c:	0040e9c7 	.word	0x0040e9c7
  40e670:	0040ea35 	.word	0x0040ea35
  40e674:	0040efcf 	.word	0x0040efcf
  40e678:	0040f0c5 	.word	0x0040f0c5
  40e67c:	0040f0c5 	.word	0x0040f0c5
  40e680:	0040ea57 	.word	0x0040ea57
  40e684:	0040f059 	.word	0x0040f059
  40e688:	0040eb3d 	.word	0x0040eb3d
  40e68c:	0040ec19 	.word	0x0040ec19
  40e690:	0040ec3b 	.word	0x0040ec3b
  40e694:	0040ed4d 	.word	0x0040ed4d
  40e698:	0040ea8b 	.word	0x0040ea8b
  40e69c:	0040eaf5 	.word	0x0040eaf5
  40e6a0:	0040ee21 	.word	0x0040ee21
  40e6a4:	0040ee21 	.word	0x0040ee21
  40e6a8:	0040ef83 	.word	0x0040ef83
  40e6ac:	0040ef83 	.word	0x0040ef83
  40e6b0:	0040ef83 	.word	0x0040ef83
  40e6b4:	0040ef83 	.word	0x0040ef83
  40e6b8:	0040ef83 	.word	0x0040ef83
  40e6bc:	0040ef83 	.word	0x0040ef83
  40e6c0:	0040ef83 	.word	0x0040ef83
  40e6c4:	0040ef83 	.word	0x0040ef83
  40e6c8:	0040edf1 	.word	0x0040edf1
  40e6cc:	0040ee21 	.word	0x0040ee21
  40e6d0:	0040f0c5 	.word	0x0040f0c5
  40e6d4:	0040eeeb 	.word	0x0040eeeb
  40e6d8:	0040e96f 	.word	0x0040e96f
  40e6dc:	0040f0c5 	.word	0x0040f0c5
  40e6e0:	0040f0c5 	.word	0x0040f0c5
  40e6e4:	0040e8c1 	.word	0x0040e8c1
  40e6e8:	0040e8c1 	.word	0x0040e8c1
		break;

	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_GRAVITY:
	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
		if(maxBufferSize < 6+1)
  40e6ec:	887b      	ldrh	r3, [r7, #2]
  40e6ee:	2b06      	cmp	r3, #6
  40e6f0:	f240 84f0 	bls.w	40f0d4 <DynProtocol_encodeSensorEvent+0xba0>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.acc, &outBuffer[idx]);
  40e6f4:	697b      	ldr	r3, [r7, #20]
  40e6f6:	f103 0008 	add.w	r0, r3, #8
  40e6fa:	68fb      	ldr	r3, [r7, #12]
  40e6fc:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
  40e700:	4619      	mov	r1, r3
  40e702:	8bfb      	ldrh	r3, [r7, #30]
  40e704:	687a      	ldr	r2, [r7, #4]
  40e706:	4413      	add	r3, r2
  40e708:	9300      	str	r3, [sp, #0]
  40e70a:	460b      	mov	r3, r1
  40e70c:	2210      	movs	r2, #16
  40e70e:	2103      	movs	r1, #3
  40e710:	4c6a      	ldr	r4, [pc, #424]	; (40e8bc <DynProtocol_encodeSensorEvent+0x388>)
  40e712:	47a0      	blx	r4
  40e714:	4603      	mov	r3, r0
  40e716:	b29a      	uxth	r2, r3
  40e718:	8bfb      	ldrh	r3, [r7, #30]
  40e71a:	4413      	add	r3, r2
  40e71c:	83fb      	strh	r3, [r7, #30]
		/* report accuracy */
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e71e:	8bfb      	ldrh	r3, [r7, #30]
  40e720:	1c5a      	adds	r2, r3, #1
  40e722:	83fa      	strh	r2, [r7, #30]
  40e724:	461a      	mov	r2, r3
  40e726:	687b      	ldr	r3, [r7, #4]
  40e728:	4413      	add	r3, r2
  40e72a:	697a      	ldr	r2, [r7, #20]
  40e72c:	6852      	ldr	r2, [r2, #4]
  40e72e:	b2d2      	uxtb	r2, r2
  40e730:	f002 0207 	and.w	r2, r2, #7
  40e734:	b2d2      	uxtb	r2, r2
  40e736:	701a      	strb	r2, [r3, #0]
		break;
  40e738:	f000 bcc8 	b.w	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
		if(maxBufferSize < 6+1)
  40e73c:	887b      	ldrh	r3, [r7, #2]
  40e73e:	2b06      	cmp	r3, #6
  40e740:	f240 84ca 	bls.w	40f0d8 <DynProtocol_encodeSensorEvent+0xba4>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
  40e744:	697b      	ldr	r3, [r7, #20]
  40e746:	f103 0008 	add.w	r0, r3, #8
  40e74a:	8bfb      	ldrh	r3, [r7, #30]
  40e74c:	687a      	ldr	r2, [r7, #4]
  40e74e:	4413      	add	r3, r2
  40e750:	9300      	str	r3, [sp, #0]
  40e752:	2304      	movs	r3, #4
  40e754:	2210      	movs	r2, #16
  40e756:	2103      	movs	r1, #3
  40e758:	4c58      	ldr	r4, [pc, #352]	; (40e8bc <DynProtocol_encodeSensorEvent+0x388>)
  40e75a:	47a0      	blx	r4
  40e75c:	4603      	mov	r3, r0
  40e75e:	b29a      	uxth	r2, r3
  40e760:	8bfb      	ldrh	r3, [r7, #30]
  40e762:	4413      	add	r3, r2
  40e764:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e766:	8bfb      	ldrh	r3, [r7, #30]
  40e768:	1c5a      	adds	r2, r3, #1
  40e76a:	83fa      	strh	r2, [r7, #30]
  40e76c:	461a      	mov	r2, r3
  40e76e:	687b      	ldr	r3, [r7, #4]
  40e770:	4413      	add	r3, r2
  40e772:	697a      	ldr	r2, [r7, #20]
  40e774:	6852      	ldr	r2, [r2, #4]
  40e776:	b2d2      	uxtb	r2, r2
  40e778:	f002 0207 	and.w	r2, r2, #7
  40e77c:	b2d2      	uxtb	r2, r2
  40e77e:	701a      	strb	r2, [r3, #0]
		break;
  40e780:	f000 bca4 	b.w	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		if(maxBufferSize < 13)
  40e784:	887b      	ldrh	r3, [r7, #2]
  40e786:	2b0c      	cmp	r3, #12
  40e788:	f240 84a8 	bls.w	40f0dc <DynProtocol_encodeSensorEvent+0xba8>
			goto error_size;
		// uncalibrated data
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
  40e78c:	697b      	ldr	r3, [r7, #20]
  40e78e:	f103 0008 	add.w	r0, r3, #8
  40e792:	8bfb      	ldrh	r3, [r7, #30]
  40e794:	687a      	ldr	r2, [r7, #4]
  40e796:	4413      	add	r3, r2
  40e798:	9300      	str	r3, [sp, #0]
  40e79a:	2304      	movs	r3, #4
  40e79c:	2210      	movs	r2, #16
  40e79e:	2103      	movs	r1, #3
  40e7a0:	4c46      	ldr	r4, [pc, #280]	; (40e8bc <DynProtocol_encodeSensorEvent+0x388>)
  40e7a2:	47a0      	blx	r4
  40e7a4:	4603      	mov	r3, r0
  40e7a6:	b29a      	uxth	r2, r3
  40e7a8:	8bfb      	ldrh	r3, [r7, #30]
  40e7aa:	4413      	add	r3, r2
  40e7ac:	83fb      	strh	r3, [r7, #30]
		// bias
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
  40e7ae:	697b      	ldr	r3, [r7, #20]
  40e7b0:	f103 0014 	add.w	r0, r3, #20
  40e7b4:	8bfb      	ldrh	r3, [r7, #30]
  40e7b6:	687a      	ldr	r2, [r7, #4]
  40e7b8:	4413      	add	r3, r2
  40e7ba:	9300      	str	r3, [sp, #0]
  40e7bc:	2304      	movs	r3, #4
  40e7be:	2210      	movs	r2, #16
  40e7c0:	2103      	movs	r1, #3
  40e7c2:	4c3e      	ldr	r4, [pc, #248]	; (40e8bc <DynProtocol_encodeSensorEvent+0x388>)
  40e7c4:	47a0      	blx	r4
  40e7c6:	4603      	mov	r3, r0
  40e7c8:	b29a      	uxth	r2, r3
  40e7ca:	8bfb      	ldrh	r3, [r7, #30]
  40e7cc:	4413      	add	r3, r2
  40e7ce:	83fb      	strh	r3, [r7, #30]
		// accuracy
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e7d0:	8bfb      	ldrh	r3, [r7, #30]
  40e7d2:	1c5a      	adds	r2, r3, #1
  40e7d4:	83fa      	strh	r2, [r7, #30]
  40e7d6:	461a      	mov	r2, r3
  40e7d8:	687b      	ldr	r3, [r7, #4]
  40e7da:	4413      	add	r3, r2
  40e7dc:	697a      	ldr	r2, [r7, #20]
  40e7de:	6852      	ldr	r2, [r2, #4]
  40e7e0:	b2d2      	uxtb	r2, r2
  40e7e2:	f002 0207 	and.w	r2, r2, #7
  40e7e6:	b2d2      	uxtb	r2, r2
  40e7e8:	701a      	strb	r2, [r3, #0]
		break;
  40e7ea:	f000 bc6f 	b.w	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
		if(maxBufferSize < 6+1)
  40e7ee:	887b      	ldrh	r3, [r7, #2]
  40e7f0:	2b06      	cmp	r3, #6
  40e7f2:	f240 8475 	bls.w	40f0e0 <DynProtocol_encodeSensorEvent+0xbac>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40e7f6:	697b      	ldr	r3, [r7, #20]
  40e7f8:	f103 0008 	add.w	r0, r3, #8
  40e7fc:	68fb      	ldr	r3, [r7, #12]
  40e7fe:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40e802:	4619      	mov	r1, r3
  40e804:	8bfb      	ldrh	r3, [r7, #30]
  40e806:	687a      	ldr	r2, [r7, #4]
  40e808:	4413      	add	r3, r2
  40e80a:	9300      	str	r3, [sp, #0]
  40e80c:	460b      	mov	r3, r1
  40e80e:	2210      	movs	r2, #16
  40e810:	2103      	movs	r1, #3
  40e812:	4c2a      	ldr	r4, [pc, #168]	; (40e8bc <DynProtocol_encodeSensorEvent+0x388>)
  40e814:	47a0      	blx	r4
  40e816:	4603      	mov	r3, r0
  40e818:	b29a      	uxth	r2, r3
  40e81a:	8bfb      	ldrh	r3, [r7, #30]
  40e81c:	4413      	add	r3, r2
  40e81e:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e820:	8bfb      	ldrh	r3, [r7, #30]
  40e822:	1c5a      	adds	r2, r3, #1
  40e824:	83fa      	strh	r2, [r7, #30]
  40e826:	461a      	mov	r2, r3
  40e828:	687b      	ldr	r3, [r7, #4]
  40e82a:	4413      	add	r3, r2
  40e82c:	697a      	ldr	r2, [r7, #20]
  40e82e:	6852      	ldr	r2, [r2, #4]
  40e830:	b2d2      	uxtb	r2, r2
  40e832:	f002 0207 	and.w	r2, r2, #7
  40e836:	b2d2      	uxtb	r2, r2
  40e838:	701a      	strb	r2, [r3, #0]
		break;
  40e83a:	f000 bc47 	b.w	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		if(maxBufferSize < 13)
  40e83e:	887b      	ldrh	r3, [r7, #2]
  40e840:	2b0c      	cmp	r3, #12
  40e842:	f240 844f 	bls.w	40f0e4 <DynProtocol_encodeSensorEvent+0xbb0>
			goto error_size;
		// uncalibrated data
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40e846:	697b      	ldr	r3, [r7, #20]
  40e848:	f103 0008 	add.w	r0, r3, #8
  40e84c:	68fb      	ldr	r3, [r7, #12]
  40e84e:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40e852:	4619      	mov	r1, r3
  40e854:	8bfb      	ldrh	r3, [r7, #30]
  40e856:	687a      	ldr	r2, [r7, #4]
  40e858:	4413      	add	r3, r2
  40e85a:	9300      	str	r3, [sp, #0]
  40e85c:	460b      	mov	r3, r1
  40e85e:	2210      	movs	r2, #16
  40e860:	2103      	movs	r1, #3
  40e862:	4c16      	ldr	r4, [pc, #88]	; (40e8bc <DynProtocol_encodeSensorEvent+0x388>)
  40e864:	47a0      	blx	r4
  40e866:	4603      	mov	r3, r0
  40e868:	b29a      	uxth	r2, r3
  40e86a:	8bfb      	ldrh	r3, [r7, #30]
  40e86c:	4413      	add	r3, r2
  40e86e:	83fb      	strh	r3, [r7, #30]
		// bias
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40e870:	697b      	ldr	r3, [r7, #20]
  40e872:	f103 0014 	add.w	r0, r3, #20
  40e876:	68fb      	ldr	r3, [r7, #12]
  40e878:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40e87c:	4619      	mov	r1, r3
  40e87e:	8bfb      	ldrh	r3, [r7, #30]
  40e880:	687a      	ldr	r2, [r7, #4]
  40e882:	4413      	add	r3, r2
  40e884:	9300      	str	r3, [sp, #0]
  40e886:	460b      	mov	r3, r1
  40e888:	2210      	movs	r2, #16
  40e88a:	2103      	movs	r1, #3
  40e88c:	4c0b      	ldr	r4, [pc, #44]	; (40e8bc <DynProtocol_encodeSensorEvent+0x388>)
  40e88e:	47a0      	blx	r4
  40e890:	4603      	mov	r3, r0
  40e892:	b29a      	uxth	r2, r3
  40e894:	8bfb      	ldrh	r3, [r7, #30]
  40e896:	4413      	add	r3, r2
  40e898:	83fb      	strh	r3, [r7, #30]
		// accuracy
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e89a:	8bfb      	ldrh	r3, [r7, #30]
  40e89c:	1c5a      	adds	r2, r3, #1
  40e89e:	83fa      	strh	r2, [r7, #30]
  40e8a0:	461a      	mov	r2, r3
  40e8a2:	687b      	ldr	r3, [r7, #4]
  40e8a4:	4413      	add	r3, r2
  40e8a6:	697a      	ldr	r2, [r7, #20]
  40e8a8:	6852      	ldr	r2, [r2, #4]
  40e8aa:	b2d2      	uxtb	r2, r2
  40e8ac:	f002 0207 	and.w	r2, r2, #7
  40e8b0:	b2d2      	uxtb	r2, r2
  40e8b2:	701a      	strb	r2, [r3, #0]
		break;
  40e8b4:	f000 bc0a 	b.w	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
  40e8b8:	0040f9c9 	.word	0x0040f9c9
  40e8bc:	0040d065 	.word	0x0040d065

	case DYN_PRO_SENSOR_TYPE_3AXIS:
	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
		if(maxBufferSize < 9)
  40e8c0:	887b      	ldrh	r3, [r7, #2]
  40e8c2:	2b08      	cmp	r3, #8
  40e8c4:	f240 8410 	bls.w	40f0e8 <DynProtocol_encodeSensorEvent+0xbb4>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 4, 30, PROTOCOL_QUATERNION_PRECISION, &outBuffer[idx]);
  40e8c8:	697b      	ldr	r3, [r7, #20]
  40e8ca:	f103 0008 	add.w	r0, r3, #8
  40e8ce:	8bfb      	ldrh	r3, [r7, #30]
  40e8d0:	687a      	ldr	r2, [r7, #4]
  40e8d2:	4413      	add	r3, r2
  40e8d4:	9300      	str	r3, [sp, #0]
  40e8d6:	230e      	movs	r3, #14
  40e8d8:	221e      	movs	r2, #30
  40e8da:	2104      	movs	r1, #4
  40e8dc:	4c94      	ldr	r4, [pc, #592]	; (40eb30 <DynProtocol_encodeSensorEvent+0x5fc>)
  40e8de:	47a0      	blx	r4
  40e8e0:	4603      	mov	r3, r0
  40e8e2:	b29a      	uxth	r2, r3
  40e8e4:	8bfb      	ldrh	r3, [r7, #30]
  40e8e6:	4413      	add	r3, r2
  40e8e8:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e8ea:	8bfb      	ldrh	r3, [r7, #30]
  40e8ec:	1c5a      	adds	r2, r3, #1
  40e8ee:	83fa      	strh	r2, [r7, #30]
  40e8f0:	461a      	mov	r2, r3
  40e8f2:	687b      	ldr	r3, [r7, #4]
  40e8f4:	4413      	add	r3, r2
  40e8f6:	697a      	ldr	r2, [r7, #20]
  40e8f8:	6852      	ldr	r2, [r2, #4]
  40e8fa:	b2d2      	uxtb	r2, r2
  40e8fc:	f002 0207 	and.w	r2, r2, #7
  40e900:	b2d2      	uxtb	r2, r2
  40e902:	701a      	strb	r2, [r3, #0]
		break;
  40e904:	e3e2      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		if(maxBufferSize < 11)
  40e906:	887b      	ldrh	r3, [r7, #2]
  40e908:	2b0a      	cmp	r3, #10
  40e90a:	f240 83ef 	bls.w	40f0ec <DynProtocol_encodeSensorEvent+0xbb8>
			goto error_size;
		// w,x,y,z in Q30
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 4, 30, PROTOCOL_QUATERNION_PRECISION, &outBuffer[idx]);
  40e90e:	697b      	ldr	r3, [r7, #20]
  40e910:	f103 0008 	add.w	r0, r3, #8
  40e914:	8bfb      	ldrh	r3, [r7, #30]
  40e916:	687a      	ldr	r2, [r7, #4]
  40e918:	4413      	add	r3, r2
  40e91a:	9300      	str	r3, [sp, #0]
  40e91c:	230e      	movs	r3, #14
  40e91e:	221e      	movs	r2, #30
  40e920:	2104      	movs	r1, #4
  40e922:	4c83      	ldr	r4, [pc, #524]	; (40eb30 <DynProtocol_encodeSensorEvent+0x5fc>)
  40e924:	47a0      	blx	r4
  40e926:	4603      	mov	r3, r0
  40e928:	b29a      	uxth	r2, r3
  40e92a:	8bfb      	ldrh	r3, [r7, #30]
  40e92c:	4413      	add	r3, r2
  40e92e:	83fb      	strh	r3, [r7, #30]
		// accuracy in q16
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[4], 1, 16, PROTOCOL_HEADING_ACCURACY_PRECISION, &outBuffer[idx]);
  40e930:	697b      	ldr	r3, [r7, #20]
  40e932:	f103 0018 	add.w	r0, r3, #24
  40e936:	8bfb      	ldrh	r3, [r7, #30]
  40e938:	687a      	ldr	r2, [r7, #4]
  40e93a:	4413      	add	r3, r2
  40e93c:	9300      	str	r3, [sp, #0]
  40e93e:	2307      	movs	r3, #7
  40e940:	2210      	movs	r2, #16
  40e942:	2101      	movs	r1, #1
  40e944:	4c7a      	ldr	r4, [pc, #488]	; (40eb30 <DynProtocol_encodeSensorEvent+0x5fc>)
  40e946:	47a0      	blx	r4
  40e948:	4603      	mov	r3, r0
  40e94a:	b29a      	uxth	r2, r3
  40e94c:	8bfb      	ldrh	r3, [r7, #30]
  40e94e:	4413      	add	r3, r2
  40e950:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e952:	8bfb      	ldrh	r3, [r7, #30]
  40e954:	1c5a      	adds	r2, r3, #1
  40e956:	83fa      	strh	r2, [r7, #30]
  40e958:	461a      	mov	r2, r3
  40e95a:	687b      	ldr	r3, [r7, #4]
  40e95c:	4413      	add	r3, r2
  40e95e:	697a      	ldr	r2, [r7, #20]
  40e960:	6852      	ldr	r2, [r2, #4]
  40e962:	b2d2      	uxtb	r2, r2
  40e964:	f002 0207 	and.w	r2, r2, #7
  40e968:	b2d2      	uxtb	r2, r2
  40e96a:	701a      	strb	r2, [r3, #0]
		break;
  40e96c:	e3ae      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
		// no timestamp
		idx -= 4;
  40e96e:	8bfb      	ldrh	r3, [r7, #30]
  40e970:	3b04      	subs	r3, #4
  40e972:	83fb      	strh	r3, [r7, #30]
		maxBufferSize += idx;
  40e974:	887a      	ldrh	r2, [r7, #2]
  40e976:	8bfb      	ldrh	r3, [r7, #30]
  40e978:	4413      	add	r3, r2
  40e97a:	807b      	strh	r3, [r7, #2]
		if(maxBufferSize < 6)
  40e97c:	887b      	ldrh	r3, [r7, #2]
  40e97e:	2b05      	cmp	r3, #5
  40e980:	f240 83b6 	bls.w	40f0f0 <DynProtocol_encodeSensorEvent+0xbbc>
			goto error_size;
		inv_dc_int16_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e984:	697b      	ldr	r3, [r7, #20]
  40e986:	689b      	ldr	r3, [r3, #8]
  40e988:	b218      	sxth	r0, r3
  40e98a:	8bfb      	ldrh	r3, [r7, #30]
  40e98c:	687a      	ldr	r2, [r7, #4]
  40e98e:	4413      	add	r3, r2
  40e990:	4619      	mov	r1, r3
  40e992:	4b68      	ldr	r3, [pc, #416]	; (40eb34 <DynProtocol_encodeSensorEvent+0x600>)
  40e994:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[1], &outBuffer[idx+2]);
  40e996:	697b      	ldr	r3, [r7, #20]
  40e998:	68db      	ldr	r3, [r3, #12]
  40e99a:	b218      	sxth	r0, r3
  40e99c:	8bfb      	ldrh	r3, [r7, #30]
  40e99e:	3302      	adds	r3, #2
  40e9a0:	687a      	ldr	r2, [r7, #4]
  40e9a2:	4413      	add	r3, r2
  40e9a4:	4619      	mov	r1, r3
  40e9a6:	4b63      	ldr	r3, [pc, #396]	; (40eb34 <DynProtocol_encodeSensorEvent+0x600>)
  40e9a8:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[2], &outBuffer[idx+4]);
  40e9aa:	697b      	ldr	r3, [r7, #20]
  40e9ac:	691b      	ldr	r3, [r3, #16]
  40e9ae:	b218      	sxth	r0, r3
  40e9b0:	8bfb      	ldrh	r3, [r7, #30]
  40e9b2:	3304      	adds	r3, #4
  40e9b4:	687a      	ldr	r2, [r7, #4]
  40e9b6:	4413      	add	r3, r2
  40e9b8:	4619      	mov	r1, r3
  40e9ba:	4b5e      	ldr	r3, [pc, #376]	; (40eb34 <DynProtocol_encodeSensorEvent+0x600>)
  40e9bc:	4798      	blx	r3
		idx += 6;
  40e9be:	8bfb      	ldrh	r3, [r7, #30]
  40e9c0:	3306      	adds	r3, #6
  40e9c2:	83fb      	strh	r3, [r7, #30]
		break;
  40e9c4:	e382      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
	case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
	case DYN_PRO_SENSOR_TYPE_OIS:
		if(maxBufferSize < 6)
  40e9c6:	887b      	ldrh	r3, [r7, #2]
  40e9c8:	2b05      	cmp	r3, #5
  40e9ca:	f240 8393 	bls.w	40f0f4 <DynProtocol_encodeSensorEvent+0xbc0>
			goto error_size;
		inv_dc_int16_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e9ce:	697b      	ldr	r3, [r7, #20]
  40e9d0:	689b      	ldr	r3, [r3, #8]
  40e9d2:	b218      	sxth	r0, r3
  40e9d4:	8bfb      	ldrh	r3, [r7, #30]
  40e9d6:	687a      	ldr	r2, [r7, #4]
  40e9d8:	4413      	add	r3, r2
  40e9da:	4619      	mov	r1, r3
  40e9dc:	4b55      	ldr	r3, [pc, #340]	; (40eb34 <DynProtocol_encodeSensorEvent+0x600>)
  40e9de:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[1], &outBuffer[idx+2]);
  40e9e0:	697b      	ldr	r3, [r7, #20]
  40e9e2:	68db      	ldr	r3, [r3, #12]
  40e9e4:	b218      	sxth	r0, r3
  40e9e6:	8bfb      	ldrh	r3, [r7, #30]
  40e9e8:	3302      	adds	r3, #2
  40e9ea:	687a      	ldr	r2, [r7, #4]
  40e9ec:	4413      	add	r3, r2
  40e9ee:	4619      	mov	r1, r3
  40e9f0:	4b50      	ldr	r3, [pc, #320]	; (40eb34 <DynProtocol_encodeSensorEvent+0x600>)
  40e9f2:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[2], &outBuffer[idx+4]);
  40e9f4:	697b      	ldr	r3, [r7, #20]
  40e9f6:	691b      	ldr	r3, [r3, #16]
  40e9f8:	b218      	sxth	r0, r3
  40e9fa:	8bfb      	ldrh	r3, [r7, #30]
  40e9fc:	3304      	adds	r3, #4
  40e9fe:	687a      	ldr	r2, [r7, #4]
  40ea00:	4413      	add	r3, r2
  40ea02:	4619      	mov	r1, r3
  40ea04:	4b4b      	ldr	r3, [pc, #300]	; (40eb34 <DynProtocol_encodeSensorEvent+0x600>)
  40ea06:	4798      	blx	r3
		idx += 6;
  40ea08:	8bfb      	ldrh	r3, [r7, #30]
  40ea0a:	3306      	adds	r3, #6
  40ea0c:	83fb      	strh	r3, [r7, #30]
		break;
  40ea0e:	e35d      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 1, 16, PROTOCOL_TEMPERATURE_PRECISION, &outBuffer[idx]);
  40ea10:	697b      	ldr	r3, [r7, #20]
  40ea12:	f103 0008 	add.w	r0, r3, #8
  40ea16:	8bfb      	ldrh	r3, [r7, #30]
  40ea18:	687a      	ldr	r2, [r7, #4]
  40ea1a:	4413      	add	r3, r2
  40ea1c:	9300      	str	r3, [sp, #0]
  40ea1e:	2308      	movs	r3, #8
  40ea20:	2210      	movs	r2, #16
  40ea22:	2101      	movs	r1, #1
  40ea24:	4c42      	ldr	r4, [pc, #264]	; (40eb30 <DynProtocol_encodeSensorEvent+0x5fc>)
  40ea26:	47a0      	blx	r4
  40ea28:	4603      	mov	r3, r0
  40ea2a:	b29a      	uxth	r2, r3
  40ea2c:	8bfb      	ldrh	r3, [r7, #30]
  40ea2e:	4413      	add	r3, r2
  40ea30:	83fb      	strh	r3, [r7, #30]
		break;
  40ea32:	e34b      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
		if(maxBufferSize < 4)
  40ea34:	887b      	ldrh	r3, [r7, #2]
  40ea36:	2b03      	cmp	r3, #3
  40ea38:	f240 835e 	bls.w	40f0f8 <DynProtocol_encodeSensorEvent+0xbc4>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40ea3c:	697b      	ldr	r3, [r7, #20]
  40ea3e:	689b      	ldr	r3, [r3, #8]
  40ea40:	4618      	mov	r0, r3
  40ea42:	8bfb      	ldrh	r3, [r7, #30]
  40ea44:	687a      	ldr	r2, [r7, #4]
  40ea46:	4413      	add	r3, r2
  40ea48:	4619      	mov	r1, r3
  40ea4a:	4b3b      	ldr	r3, [pc, #236]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40ea4c:	4798      	blx	r3
		idx += 4;
  40ea4e:	8bfb      	ldrh	r3, [r7, #30]
  40ea50:	3304      	adds	r3, #4
  40ea52:	83fb      	strh	r3, [r7, #30]
		break;
  40ea54:	e33a      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_RAW_PPG:
		if(maxBufferSize < 5)
  40ea56:	887b      	ldrh	r3, [r7, #2]
  40ea58:	2b04      	cmp	r3, #4
  40ea5a:	f240 834f 	bls.w	40f0fc <DynProtocol_encodeSensorEvent+0xbc8>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]); 
  40ea5e:	697b      	ldr	r3, [r7, #20]
  40ea60:	689b      	ldr	r3, [r3, #8]
  40ea62:	4618      	mov	r0, r3
  40ea64:	8bfb      	ldrh	r3, [r7, #30]
  40ea66:	687a      	ldr	r2, [r7, #4]
  40ea68:	4413      	add	r3, r2
  40ea6a:	4619      	mov	r1, r3
  40ea6c:	4b32      	ldr	r3, [pc, #200]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40ea6e:	4798      	blx	r3
                idx += 4;
  40ea70:	8bfb      	ldrh	r3, [r7, #30]
  40ea72:	3304      	adds	r3, #4
  40ea74:	83fb      	strh	r3, [r7, #30]
                outBuffer[idx] = vSensordata->data.u8[0]; 
  40ea76:	8bfb      	ldrh	r3, [r7, #30]
  40ea78:	687a      	ldr	r2, [r7, #4]
  40ea7a:	4413      	add	r3, r2
  40ea7c:	697a      	ldr	r2, [r7, #20]
  40ea7e:	7a12      	ldrb	r2, [r2, #8]
  40ea80:	701a      	strb	r2, [r3, #0]
                idx += 1;
  40ea82:	8bfb      	ldrh	r3, [r7, #30]
  40ea84:	3301      	adds	r3, #1
  40ea86:	83fb      	strh	r3, [r7, #30]
                break;
  40ea88:	e320      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
                
	case DYN_PRO_SENSOR_TYPE_ENERGY_EXPENDITURE:
		if(maxBufferSize < 16)
  40ea8a:	887b      	ldrh	r3, [r7, #2]
  40ea8c:	2b0f      	cmp	r3, #15
  40ea8e:	f240 8337 	bls.w	40f100 <DynProtocol_encodeSensorEvent+0xbcc>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40ea92:	697b      	ldr	r3, [r7, #20]
  40ea94:	689b      	ldr	r3, [r3, #8]
  40ea96:	4618      	mov	r0, r3
  40ea98:	8bfb      	ldrh	r3, [r7, #30]
  40ea9a:	687a      	ldr	r2, [r7, #4]
  40ea9c:	4413      	add	r3, r2
  40ea9e:	4619      	mov	r1, r3
  40eaa0:	4b25      	ldr	r3, [pc, #148]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40eaa2:	4798      	blx	r3
		idx += 4;
  40eaa4:	8bfb      	ldrh	r3, [r7, #30]
  40eaa6:	3304      	adds	r3, #4
  40eaa8:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40eaaa:	697b      	ldr	r3, [r7, #20]
  40eaac:	68db      	ldr	r3, [r3, #12]
  40eaae:	4618      	mov	r0, r3
  40eab0:	8bfb      	ldrh	r3, [r7, #30]
  40eab2:	687a      	ldr	r2, [r7, #4]
  40eab4:	4413      	add	r3, r2
  40eab6:	4619      	mov	r1, r3
  40eab8:	4b1f      	ldr	r3, [pc, #124]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40eaba:	4798      	blx	r3
		idx += 4;
  40eabc:	8bfb      	ldrh	r3, [r7, #30]
  40eabe:	3304      	adds	r3, #4
  40eac0:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[2], &outBuffer[idx]);
  40eac2:	697b      	ldr	r3, [r7, #20]
  40eac4:	691b      	ldr	r3, [r3, #16]
  40eac6:	4618      	mov	r0, r3
  40eac8:	8bfb      	ldrh	r3, [r7, #30]
  40eaca:	687a      	ldr	r2, [r7, #4]
  40eacc:	4413      	add	r3, r2
  40eace:	4619      	mov	r1, r3
  40ead0:	4b19      	ldr	r3, [pc, #100]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40ead2:	4798      	blx	r3
		idx += 4;
  40ead4:	8bfb      	ldrh	r3, [r7, #30]
  40ead6:	3304      	adds	r3, #4
  40ead8:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[3], &outBuffer[idx]);
  40eada:	697b      	ldr	r3, [r7, #20]
  40eadc:	695b      	ldr	r3, [r3, #20]
  40eade:	4618      	mov	r0, r3
  40eae0:	8bfb      	ldrh	r3, [r7, #30]
  40eae2:	687a      	ldr	r2, [r7, #4]
  40eae4:	4413      	add	r3, r2
  40eae6:	4619      	mov	r1, r3
  40eae8:	4b13      	ldr	r3, [pc, #76]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40eaea:	4798      	blx	r3
		idx += 4;
  40eaec:	8bfb      	ldrh	r3, [r7, #30]
  40eaee:	3304      	adds	r3, #4
  40eaf0:	83fb      	strh	r3, [r7, #30]
		break;
  40eaf2:	e2eb      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_DISTANCE:
		if(maxBufferSize < 8)
  40eaf4:	887b      	ldrh	r3, [r7, #2]
  40eaf6:	2b07      	cmp	r3, #7
  40eaf8:	f240 8304 	bls.w	40f104 <DynProtocol_encodeSensorEvent+0xbd0>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40eafc:	697b      	ldr	r3, [r7, #20]
  40eafe:	689b      	ldr	r3, [r3, #8]
  40eb00:	4618      	mov	r0, r3
  40eb02:	8bfb      	ldrh	r3, [r7, #30]
  40eb04:	687a      	ldr	r2, [r7, #4]
  40eb06:	4413      	add	r3, r2
  40eb08:	4619      	mov	r1, r3
  40eb0a:	4b0b      	ldr	r3, [pc, #44]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40eb0c:	4798      	blx	r3
		idx += 4;
  40eb0e:	8bfb      	ldrh	r3, [r7, #30]
  40eb10:	3304      	adds	r3, #4
  40eb12:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40eb14:	697b      	ldr	r3, [r7, #20]
  40eb16:	68db      	ldr	r3, [r3, #12]
  40eb18:	4618      	mov	r0, r3
  40eb1a:	8bfb      	ldrh	r3, [r7, #30]
  40eb1c:	687a      	ldr	r2, [r7, #4]
  40eb1e:	4413      	add	r3, r2
  40eb20:	4619      	mov	r1, r3
  40eb22:	4b05      	ldr	r3, [pc, #20]	; (40eb38 <DynProtocol_encodeSensorEvent+0x604>)
  40eb24:	4798      	blx	r3
		idx += 4;
  40eb26:	8bfb      	ldrh	r3, [r7, #30]
  40eb28:	3304      	adds	r3, #4
  40eb2a:	83fb      	strh	r3, [r7, #30]
		break;
  40eb2c:	e2ce      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
  40eb2e:	bf00      	nop
  40eb30:	0040d065 	.word	0x0040d065
  40eb34:	0040fa0d 	.word	0x0040fa0d
  40eb38:	0040f9c9 	.word	0x0040f9c9

	case DYN_PRO_SENSOR_TYPE_SLEEP_ANALYSIS:
		if(maxBufferSize < 25)
  40eb3c:	887b      	ldrh	r3, [r7, #2]
  40eb3e:	2b18      	cmp	r3, #24
  40eb40:	f240 82e2 	bls.w	40f108 <DynProtocol_encodeSensorEvent+0xbd4>
			goto error_size;
		outBuffer[idx] = vSensordata->data.u8[0]; 
  40eb44:	8bfb      	ldrh	r3, [r7, #30]
  40eb46:	687a      	ldr	r2, [r7, #4]
  40eb48:	4413      	add	r3, r2
  40eb4a:	697a      	ldr	r2, [r7, #20]
  40eb4c:	7a12      	ldrb	r2, [r2, #8]
  40eb4e:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40eb50:	8bfb      	ldrh	r3, [r7, #30]
  40eb52:	3301      	adds	r3, #1
  40eb54:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[1]; 
  40eb56:	8bfb      	ldrh	r3, [r7, #30]
  40eb58:	687a      	ldr	r2, [r7, #4]
  40eb5a:	4413      	add	r3, r2
  40eb5c:	697a      	ldr	r2, [r7, #20]
  40eb5e:	7a52      	ldrb	r2, [r2, #9]
  40eb60:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40eb62:	8bfb      	ldrh	r3, [r7, #30]
  40eb64:	3301      	adds	r3, #1
  40eb66:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[2]; 
  40eb68:	8bfb      	ldrh	r3, [r7, #30]
  40eb6a:	687a      	ldr	r2, [r7, #4]
  40eb6c:	4413      	add	r3, r2
  40eb6e:	697a      	ldr	r2, [r7, #20]
  40eb70:	7a92      	ldrb	r2, [r2, #10]
  40eb72:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40eb74:	8bfb      	ldrh	r3, [r7, #30]
  40eb76:	3301      	adds	r3, #1
  40eb78:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[3]; 
  40eb7a:	8bfb      	ldrh	r3, [r7, #30]
  40eb7c:	687a      	ldr	r2, [r7, #4]
  40eb7e:	4413      	add	r3, r2
  40eb80:	697a      	ldr	r2, [r7, #20]
  40eb82:	7ad2      	ldrb	r2, [r2, #11]
  40eb84:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40eb86:	8bfb      	ldrh	r3, [r7, #30]
  40eb88:	3301      	adds	r3, #1
  40eb8a:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40eb8c:	697b      	ldr	r3, [r7, #20]
  40eb8e:	689b      	ldr	r3, [r3, #8]
  40eb90:	4618      	mov	r0, r3
  40eb92:	8bfb      	ldrh	r3, [r7, #30]
  40eb94:	687a      	ldr	r2, [r7, #4]
  40eb96:	4413      	add	r3, r2
  40eb98:	4619      	mov	r1, r3
  40eb9a:	4b94      	ldr	r3, [pc, #592]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40eb9c:	4798      	blx	r3
		idx += 4;
  40eb9e:	8bfb      	ldrh	r3, [r7, #30]
  40eba0:	3304      	adds	r3, #4
  40eba2:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40eba4:	697b      	ldr	r3, [r7, #20]
  40eba6:	68db      	ldr	r3, [r3, #12]
  40eba8:	4618      	mov	r0, r3
  40ebaa:	8bfb      	ldrh	r3, [r7, #30]
  40ebac:	687a      	ldr	r2, [r7, #4]
  40ebae:	4413      	add	r3, r2
  40ebb0:	4619      	mov	r1, r3
  40ebb2:	4b8e      	ldr	r3, [pc, #568]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ebb4:	4798      	blx	r3
		idx += 4;
  40ebb6:	8bfb      	ldrh	r3, [r7, #30]
  40ebb8:	3304      	adds	r3, #4
  40ebba:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[2], &outBuffer[idx]);
  40ebbc:	697b      	ldr	r3, [r7, #20]
  40ebbe:	691b      	ldr	r3, [r3, #16]
  40ebc0:	4618      	mov	r0, r3
  40ebc2:	8bfb      	ldrh	r3, [r7, #30]
  40ebc4:	687a      	ldr	r2, [r7, #4]
  40ebc6:	4413      	add	r3, r2
  40ebc8:	4619      	mov	r1, r3
  40ebca:	4b88      	ldr	r3, [pc, #544]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ebcc:	4798      	blx	r3
		idx += 4;
  40ebce:	8bfb      	ldrh	r3, [r7, #30]
  40ebd0:	3304      	adds	r3, #4
  40ebd2:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[3], &outBuffer[idx]);
  40ebd4:	697b      	ldr	r3, [r7, #20]
  40ebd6:	695b      	ldr	r3, [r3, #20]
  40ebd8:	4618      	mov	r0, r3
  40ebda:	8bfb      	ldrh	r3, [r7, #30]
  40ebdc:	687a      	ldr	r2, [r7, #4]
  40ebde:	4413      	add	r3, r2
  40ebe0:	4619      	mov	r1, r3
  40ebe2:	4b82      	ldr	r3, [pc, #520]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ebe4:	4798      	blx	r3
		idx += 4;
  40ebe6:	8bfb      	ldrh	r3, [r7, #30]
  40ebe8:	3304      	adds	r3, #4
  40ebea:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[4], &outBuffer[idx]);
  40ebec:	697b      	ldr	r3, [r7, #20]
  40ebee:	699b      	ldr	r3, [r3, #24]
  40ebf0:	4618      	mov	r0, r3
  40ebf2:	8bfb      	ldrh	r3, [r7, #30]
  40ebf4:	687a      	ldr	r2, [r7, #4]
  40ebf6:	4413      	add	r3, r2
  40ebf8:	4619      	mov	r1, r3
  40ebfa:	4b7c      	ldr	r3, [pc, #496]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ebfc:	4798      	blx	r3
		idx += 4;
  40ebfe:	8bfb      	ldrh	r3, [r7, #30]
  40ec00:	3304      	adds	r3, #4
  40ec02:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[4]; 
  40ec04:	8bfb      	ldrh	r3, [r7, #30]
  40ec06:	687a      	ldr	r2, [r7, #4]
  40ec08:	4413      	add	r3, r2
  40ec0a:	697a      	ldr	r2, [r7, #20]
  40ec0c:	7b12      	ldrb	r2, [r2, #12]
  40ec0e:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40ec10:	8bfb      	ldrh	r3, [r7, #30]
  40ec12:	3301      	adds	r3, #1
  40ec14:	83fb      	strh	r3, [r7, #30]
		break;
  40ec16:	e259      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_BAC_EXTENDED:
		if(maxBufferSize < 4)
  40ec18:	887b      	ldrh	r3, [r7, #2]
  40ec1a:	2b03      	cmp	r3, #3
  40ec1c:	f240 8276 	bls.w	40f10c <DynProtocol_encodeSensorEvent+0xbd8>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40ec20:	697b      	ldr	r3, [r7, #20]
  40ec22:	689b      	ldr	r3, [r3, #8]
  40ec24:	4618      	mov	r0, r3
  40ec26:	8bfb      	ldrh	r3, [r7, #30]
  40ec28:	687a      	ldr	r2, [r7, #4]
  40ec2a:	4413      	add	r3, r2
  40ec2c:	4619      	mov	r1, r3
  40ec2e:	4b6f      	ldr	r3, [pc, #444]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ec30:	4798      	blx	r3
		idx += 4;
  40ec32:	8bfb      	ldrh	r3, [r7, #30]
  40ec34:	3304      	adds	r3, #4
  40ec36:	83fb      	strh	r3, [r7, #30]
		break;
  40ec38:	e248      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_BAC_STATISTICS:
		if(maxBufferSize < 44)
  40ec3a:	887b      	ldrh	r3, [r7, #2]
  40ec3c:	2b2b      	cmp	r3, #43	; 0x2b
  40ec3e:	f240 8267 	bls.w	40f110 <DynProtocol_encodeSensorEvent+0xbdc>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40ec42:	697b      	ldr	r3, [r7, #20]
  40ec44:	689b      	ldr	r3, [r3, #8]
  40ec46:	4618      	mov	r0, r3
  40ec48:	8bfb      	ldrh	r3, [r7, #30]
  40ec4a:	687a      	ldr	r2, [r7, #4]
  40ec4c:	4413      	add	r3, r2
  40ec4e:	4619      	mov	r1, r3
  40ec50:	4b66      	ldr	r3, [pc, #408]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ec52:	4798      	blx	r3
		idx += 4;
  40ec54:	8bfb      	ldrh	r3, [r7, #30]
  40ec56:	3304      	adds	r3, #4
  40ec58:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40ec5a:	697b      	ldr	r3, [r7, #20]
  40ec5c:	68db      	ldr	r3, [r3, #12]
  40ec5e:	4618      	mov	r0, r3
  40ec60:	8bfb      	ldrh	r3, [r7, #30]
  40ec62:	687a      	ldr	r2, [r7, #4]
  40ec64:	4413      	add	r3, r2
  40ec66:	4619      	mov	r1, r3
  40ec68:	4b60      	ldr	r3, [pc, #384]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ec6a:	4798      	blx	r3
		idx += 4;
  40ec6c:	8bfb      	ldrh	r3, [r7, #30]
  40ec6e:	3304      	adds	r3, #4
  40ec70:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[2], &outBuffer[idx]);
  40ec72:	697b      	ldr	r3, [r7, #20]
  40ec74:	691b      	ldr	r3, [r3, #16]
  40ec76:	4618      	mov	r0, r3
  40ec78:	8bfb      	ldrh	r3, [r7, #30]
  40ec7a:	687a      	ldr	r2, [r7, #4]
  40ec7c:	4413      	add	r3, r2
  40ec7e:	4619      	mov	r1, r3
  40ec80:	4b5a      	ldr	r3, [pc, #360]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ec82:	4798      	blx	r3
		idx += 4;
  40ec84:	8bfb      	ldrh	r3, [r7, #30]
  40ec86:	3304      	adds	r3, #4
  40ec88:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[3], &outBuffer[idx]);
  40ec8a:	697b      	ldr	r3, [r7, #20]
  40ec8c:	695b      	ldr	r3, [r3, #20]
  40ec8e:	4618      	mov	r0, r3
  40ec90:	8bfb      	ldrh	r3, [r7, #30]
  40ec92:	687a      	ldr	r2, [r7, #4]
  40ec94:	4413      	add	r3, r2
  40ec96:	4619      	mov	r1, r3
  40ec98:	4b54      	ldr	r3, [pc, #336]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ec9a:	4798      	blx	r3
		idx += 4;
  40ec9c:	8bfb      	ldrh	r3, [r7, #30]
  40ec9e:	3304      	adds	r3, #4
  40eca0:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[4], &outBuffer[idx]);
  40eca2:	697b      	ldr	r3, [r7, #20]
  40eca4:	699b      	ldr	r3, [r3, #24]
  40eca6:	4618      	mov	r0, r3
  40eca8:	8bfb      	ldrh	r3, [r7, #30]
  40ecaa:	687a      	ldr	r2, [r7, #4]
  40ecac:	4413      	add	r3, r2
  40ecae:	4619      	mov	r1, r3
  40ecb0:	4b4e      	ldr	r3, [pc, #312]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ecb2:	4798      	blx	r3
		idx += 4;
  40ecb4:	8bfb      	ldrh	r3, [r7, #30]
  40ecb6:	3304      	adds	r3, #4
  40ecb8:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[5], &outBuffer[idx]);
  40ecba:	697b      	ldr	r3, [r7, #20]
  40ecbc:	69db      	ldr	r3, [r3, #28]
  40ecbe:	4618      	mov	r0, r3
  40ecc0:	8bfb      	ldrh	r3, [r7, #30]
  40ecc2:	687a      	ldr	r2, [r7, #4]
  40ecc4:	4413      	add	r3, r2
  40ecc6:	4619      	mov	r1, r3
  40ecc8:	4b48      	ldr	r3, [pc, #288]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ecca:	4798      	blx	r3
		idx += 4;
  40eccc:	8bfb      	ldrh	r3, [r7, #30]
  40ecce:	3304      	adds	r3, #4
  40ecd0:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[6], &outBuffer[idx]);
  40ecd2:	697b      	ldr	r3, [r7, #20]
  40ecd4:	6a1b      	ldr	r3, [r3, #32]
  40ecd6:	4618      	mov	r0, r3
  40ecd8:	8bfb      	ldrh	r3, [r7, #30]
  40ecda:	687a      	ldr	r2, [r7, #4]
  40ecdc:	4413      	add	r3, r2
  40ecde:	4619      	mov	r1, r3
  40ece0:	4b42      	ldr	r3, [pc, #264]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ece2:	4798      	blx	r3
		idx += 4;
  40ece4:	8bfb      	ldrh	r3, [r7, #30]
  40ece6:	3304      	adds	r3, #4
  40ece8:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[7], &outBuffer[idx]);
  40ecea:	697b      	ldr	r3, [r7, #20]
  40ecec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40ecee:	4618      	mov	r0, r3
  40ecf0:	8bfb      	ldrh	r3, [r7, #30]
  40ecf2:	687a      	ldr	r2, [r7, #4]
  40ecf4:	4413      	add	r3, r2
  40ecf6:	4619      	mov	r1, r3
  40ecf8:	4b3c      	ldr	r3, [pc, #240]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ecfa:	4798      	blx	r3
		idx += 4;
  40ecfc:	8bfb      	ldrh	r3, [r7, #30]
  40ecfe:	3304      	adds	r3, #4
  40ed00:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[8], &outBuffer[idx]);
  40ed02:	697b      	ldr	r3, [r7, #20]
  40ed04:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40ed06:	4618      	mov	r0, r3
  40ed08:	8bfb      	ldrh	r3, [r7, #30]
  40ed0a:	687a      	ldr	r2, [r7, #4]
  40ed0c:	4413      	add	r3, r2
  40ed0e:	4619      	mov	r1, r3
  40ed10:	4b36      	ldr	r3, [pc, #216]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ed12:	4798      	blx	r3
		idx += 4;
  40ed14:	8bfb      	ldrh	r3, [r7, #30]
  40ed16:	3304      	adds	r3, #4
  40ed18:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[9], &outBuffer[idx]);
  40ed1a:	697b      	ldr	r3, [r7, #20]
  40ed1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40ed1e:	4618      	mov	r0, r3
  40ed20:	8bfb      	ldrh	r3, [r7, #30]
  40ed22:	687a      	ldr	r2, [r7, #4]
  40ed24:	4413      	add	r3, r2
  40ed26:	4619      	mov	r1, r3
  40ed28:	4b30      	ldr	r3, [pc, #192]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ed2a:	4798      	blx	r3
		idx += 4;
  40ed2c:	8bfb      	ldrh	r3, [r7, #30]
  40ed2e:	3304      	adds	r3, #4
  40ed30:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[10], &outBuffer[idx]);
  40ed32:	697b      	ldr	r3, [r7, #20]
  40ed34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40ed36:	4618      	mov	r0, r3
  40ed38:	8bfb      	ldrh	r3, [r7, #30]
  40ed3a:	687a      	ldr	r2, [r7, #4]
  40ed3c:	4413      	add	r3, r2
  40ed3e:	4619      	mov	r1, r3
  40ed40:	4b2a      	ldr	r3, [pc, #168]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ed42:	4798      	blx	r3
		idx += 4;
  40ed44:	8bfb      	ldrh	r3, [r7, #30]
  40ed46:	3304      	adds	r3, #4
  40ed48:	83fb      	strh	r3, [r7, #30]
		break;
  40ed4a:	e1bf      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_FLOOR_CLIMB_COUNTER:
		if(maxBufferSize < 8)
  40ed4c:	887b      	ldrh	r3, [r7, #2]
  40ed4e:	2b07      	cmp	r3, #7
  40ed50:	f240 81e0 	bls.w	40f114 <DynProtocol_encodeSensorEvent+0xbe0>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40ed54:	697b      	ldr	r3, [r7, #20]
  40ed56:	689b      	ldr	r3, [r3, #8]
  40ed58:	4618      	mov	r0, r3
  40ed5a:	8bfb      	ldrh	r3, [r7, #30]
  40ed5c:	687a      	ldr	r2, [r7, #4]
  40ed5e:	4413      	add	r3, r2
  40ed60:	4619      	mov	r1, r3
  40ed62:	4b22      	ldr	r3, [pc, #136]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ed64:	4798      	blx	r3
		idx += 4;
  40ed66:	8bfb      	ldrh	r3, [r7, #30]
  40ed68:	3304      	adds	r3, #4
  40ed6a:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40ed6c:	697b      	ldr	r3, [r7, #20]
  40ed6e:	68db      	ldr	r3, [r3, #12]
  40ed70:	4618      	mov	r0, r3
  40ed72:	8bfb      	ldrh	r3, [r7, #30]
  40ed74:	687a      	ldr	r2, [r7, #4]
  40ed76:	4413      	add	r3, r2
  40ed78:	4619      	mov	r1, r3
  40ed7a:	4b1c      	ldr	r3, [pc, #112]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ed7c:	4798      	blx	r3
		idx += 4;
  40ed7e:	8bfb      	ldrh	r3, [r7, #30]
  40ed80:	3304      	adds	r3, #4
  40ed82:	83fb      	strh	r3, [r7, #30]
		break;
  40ed84:	e1a2      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
		
	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
		if(maxBufferSize < 8)
  40ed86:	887b      	ldrh	r3, [r7, #2]
  40ed88:	2b07      	cmp	r3, #7
  40ed8a:	f240 81c5 	bls.w	40f118 <DynProtocol_encodeSensorEvent+0xbe4>
			goto error_size;
		inv_dc_int32_to_little8((int32_t)vSensordata->data.u32[0], &outBuffer[idx]);
  40ed8e:	697b      	ldr	r3, [r7, #20]
  40ed90:	689b      	ldr	r3, [r3, #8]
  40ed92:	4618      	mov	r0, r3
  40ed94:	8bfb      	ldrh	r3, [r7, #30]
  40ed96:	687a      	ldr	r2, [r7, #4]
  40ed98:	4413      	add	r3, r2
  40ed9a:	4619      	mov	r1, r3
  40ed9c:	4b13      	ldr	r3, [pc, #76]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ed9e:	4798      	blx	r3
		idx += 4;
  40eda0:	8bfb      	ldrh	r3, [r7, #30]
  40eda2:	3304      	adds	r3, #4
  40eda4:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40eda6:	6938      	ldr	r0, [r7, #16]
  40eda8:	8bfb      	ldrh	r3, [r7, #30]
  40edaa:	687a      	ldr	r2, [r7, #4]
  40edac:	4413      	add	r3, r2
  40edae:	4619      	mov	r1, r3
  40edb0:	4b0e      	ldr	r3, [pc, #56]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40edb2:	4798      	blx	r3
		idx += 4;
  40edb4:	8bfb      	ldrh	r3, [r7, #30]
  40edb6:	3304      	adds	r3, #4
  40edb8:	83fb      	strh	r3, [r7, #30]
		break;
  40edba:	e187      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>

	case DYN_PRO_SENSOR_TYPE_BAC:
		if(maxBufferSize < 5)
  40edbc:	887b      	ldrh	r3, [r7, #2]
  40edbe:	2b04      	cmp	r3, #4
  40edc0:	f240 81ac 	bls.w	40f11c <DynProtocol_encodeSensorEvent+0xbe8>
			goto error_size;
		outBuffer[idx++] = vSensordata->data.u8[0];
  40edc4:	8bfb      	ldrh	r3, [r7, #30]
  40edc6:	1c5a      	adds	r2, r3, #1
  40edc8:	83fa      	strh	r2, [r7, #30]
  40edca:	461a      	mov	r2, r3
  40edcc:	687b      	ldr	r3, [r7, #4]
  40edce:	4413      	add	r3, r2
  40edd0:	697a      	ldr	r2, [r7, #20]
  40edd2:	7a12      	ldrb	r2, [r2, #8]
  40edd4:	701a      	strb	r2, [r3, #0]
		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40edd6:	6938      	ldr	r0, [r7, #16]
  40edd8:	8bfb      	ldrh	r3, [r7, #30]
  40edda:	687a      	ldr	r2, [r7, #4]
  40eddc:	4413      	add	r3, r2
  40edde:	4619      	mov	r1, r3
  40ede0:	4b02      	ldr	r3, [pc, #8]	; (40edec <DynProtocol_encodeSensorEvent+0x8b8>)
  40ede2:	4798      	blx	r3
		idx += 4;
  40ede4:	8bfb      	ldrh	r3, [r7, #30]
  40ede6:	3304      	adds	r3, #4
  40ede8:	83fb      	strh	r3, [r7, #30]
		break;
  40edea:	e16f      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
  40edec:	0040f9c9 	.word	0x0040f9c9
	case DYN_PRO_SENSOR_TYPE_WOM:
		if(maxBufferSize < 5)
  40edf0:	887b      	ldrh	r3, [r7, #2]
  40edf2:	2b04      	cmp	r3, #4
  40edf4:	f240 8194 	bls.w	40f120 <DynProtocol_encodeSensorEvent+0xbec>
			goto error_size;
		outBuffer[idx++] = vSensordata->data.u8[0];
  40edf8:	8bfb      	ldrh	r3, [r7, #30]
  40edfa:	1c5a      	adds	r2, r3, #1
  40edfc:	83fa      	strh	r2, [r7, #30]
  40edfe:	461a      	mov	r2, r3
  40ee00:	687b      	ldr	r3, [r7, #4]
  40ee02:	4413      	add	r3, r2
  40ee04:	697a      	ldr	r2, [r7, #20]
  40ee06:	7a12      	ldrb	r2, [r2, #8]
  40ee08:	701a      	strb	r2, [r3, #0]
		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40ee0a:	6938      	ldr	r0, [r7, #16]
  40ee0c:	8bfb      	ldrh	r3, [r7, #30]
  40ee0e:	687a      	ldr	r2, [r7, #4]
  40ee10:	4413      	add	r3, r2
  40ee12:	4619      	mov	r1, r3
  40ee14:	4b9c      	ldr	r3, [pc, #624]	; (40f088 <DynProtocol_encodeSensorEvent+0xb54>)
  40ee16:	4798      	blx	r3
		idx += 4;
  40ee18:	8bfb      	ldrh	r3, [r7, #30]
  40ee1a:	3304      	adds	r3, #4
  40ee1c:	83fb      	strh	r3, [r7, #30]
		break;
  40ee1e:	e155      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:
	case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:
	case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
	{
		if(maxBufferSize < 4)
  40ee20:	887b      	ldrh	r3, [r7, #2]
  40ee22:	2b03      	cmp	r3, #3
  40ee24:	f240 817e 	bls.w	40f124 <DynProtocol_encodeSensorEvent+0xbf0>
			goto error_size;
		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40ee28:	6938      	ldr	r0, [r7, #16]
  40ee2a:	8bfb      	ldrh	r3, [r7, #30]
  40ee2c:	687a      	ldr	r2, [r7, #4]
  40ee2e:	4413      	add	r3, r2
  40ee30:	4619      	mov	r1, r3
  40ee32:	4b95      	ldr	r3, [pc, #596]	; (40f088 <DynProtocol_encodeSensorEvent+0xb54>)
  40ee34:	4798      	blx	r3
		idx += 4;
  40ee36:	8bfb      	ldrh	r3, [r7, #30]
  40ee38:	3304      	adds	r3, #4
  40ee3a:	83fb      	strh	r3, [r7, #30]
		break;
  40ee3c:	e146      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_PRESSURE:
	{
		if(maxBufferSize < 4)
  40ee3e:	887b      	ldrh	r3, [r7, #2]
  40ee40:	2b03      	cmp	r3, #3
  40ee42:	f240 8171 	bls.w	40f128 <DynProtocol_encodeSensorEvent+0xbf4>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40ee46:	697b      	ldr	r3, [r7, #20]
  40ee48:	689b      	ldr	r3, [r3, #8]
  40ee4a:	4618      	mov	r0, r3
  40ee4c:	8bfb      	ldrh	r3, [r7, #30]
  40ee4e:	687a      	ldr	r2, [r7, #4]
  40ee50:	4413      	add	r3, r2
  40ee52:	4619      	mov	r1, r3
  40ee54:	4b8c      	ldr	r3, [pc, #560]	; (40f088 <DynProtocol_encodeSensorEvent+0xb54>)
  40ee56:	4798      	blx	r3
		idx += 4;
  40ee58:	8bfb      	ldrh	r3, [r7, #30]
  40ee5a:	3304      	adds	r3, #4
  40ee5c:	83fb      	strh	r3, [r7, #30]
		break;
  40ee5e:	e135      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
	{
		if(maxBufferSize < 6+1)
  40ee60:	887b      	ldrh	r3, [r7, #2]
  40ee62:	2b06      	cmp	r3, #6
  40ee64:	f240 8162 	bls.w	40f12c <DynProtocol_encodeSensorEvent+0xbf8>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_ORIENTATION_PRECISION, &outBuffer[idx]);
  40ee68:	697b      	ldr	r3, [r7, #20]
  40ee6a:	f103 0008 	add.w	r0, r3, #8
  40ee6e:	8bfb      	ldrh	r3, [r7, #30]
  40ee70:	687a      	ldr	r2, [r7, #4]
  40ee72:	4413      	add	r3, r2
  40ee74:	9300      	str	r3, [sp, #0]
  40ee76:	2306      	movs	r3, #6
  40ee78:	2210      	movs	r2, #16
  40ee7a:	2103      	movs	r1, #3
  40ee7c:	4c83      	ldr	r4, [pc, #524]	; (40f08c <DynProtocol_encodeSensorEvent+0xb58>)
  40ee7e:	47a0      	blx	r4
  40ee80:	4603      	mov	r3, r0
  40ee82:	b29a      	uxth	r2, r3
  40ee84:	8bfb      	ldrh	r3, [r7, #30]
  40ee86:	4413      	add	r3, r2
  40ee88:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40ee8a:	8bfb      	ldrh	r3, [r7, #30]
  40ee8c:	1c5a      	adds	r2, r3, #1
  40ee8e:	83fa      	strh	r2, [r7, #30]
  40ee90:	461a      	mov	r2, r3
  40ee92:	687b      	ldr	r3, [r7, #4]
  40ee94:	4413      	add	r3, r2
  40ee96:	697a      	ldr	r2, [r7, #20]
  40ee98:	6852      	ldr	r2, [r2, #4]
  40ee9a:	b2d2      	uxtb	r2, r2
  40ee9c:	f002 0207 	and.w	r2, r2, #7
  40eea0:	b2d2      	uxtb	r2, r2
  40eea2:	701a      	strb	r2, [r3, #0]
		break;
  40eea4:	e112      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_LIGHT:
	{
		if(maxBufferSize < 4)
  40eea6:	887b      	ldrh	r3, [r7, #2]
  40eea8:	2b03      	cmp	r3, #3
  40eeaa:	f240 8141 	bls.w	40f130 <DynProtocol_encodeSensorEvent+0xbfc>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40eeae:	697b      	ldr	r3, [r7, #20]
  40eeb0:	689b      	ldr	r3, [r3, #8]
  40eeb2:	4618      	mov	r0, r3
  40eeb4:	8bfb      	ldrh	r3, [r7, #30]
  40eeb6:	687a      	ldr	r2, [r7, #4]
  40eeb8:	4413      	add	r3, r2
  40eeba:	4619      	mov	r1, r3
  40eebc:	4b72      	ldr	r3, [pc, #456]	; (40f088 <DynProtocol_encodeSensorEvent+0xb54>)
  40eebe:	4798      	blx	r3
		idx += 4;
  40eec0:	8bfb      	ldrh	r3, [r7, #30]
  40eec2:	3304      	adds	r3, #4
  40eec4:	83fb      	strh	r3, [r7, #30]
		break;
  40eec6:	e101      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_PROXIMITY:
	{
		if(maxBufferSize < 2)
  40eec8:	887b      	ldrh	r3, [r7, #2]
  40eeca:	2b01      	cmp	r3, #1
  40eecc:	f240 8132 	bls.w	40f134 <DynProtocol_encodeSensorEvent+0xc00>
			goto error_size;
		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[0], &outBuffer[idx]);
  40eed0:	697b      	ldr	r3, [r7, #20]
  40eed2:	689b      	ldr	r3, [r3, #8]
  40eed4:	b218      	sxth	r0, r3
  40eed6:	8bfb      	ldrh	r3, [r7, #30]
  40eed8:	687a      	ldr	r2, [r7, #4]
  40eeda:	4413      	add	r3, r2
  40eedc:	4619      	mov	r1, r3
  40eede:	4b6c      	ldr	r3, [pc, #432]	; (40f090 <DynProtocol_encodeSensorEvent+0xb5c>)
  40eee0:	4798      	blx	r3
		idx += 2;
  40eee2:	8bfb      	ldrh	r3, [r7, #30]
  40eee4:	3302      	adds	r3, #2
  40eee6:	83fb      	strh	r3, [r7, #30]
		break;
  40eee8:	e0f0      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_FSYNC_EVENT:
	{
		if(maxBufferSize < 2)
  40eeea:	887b      	ldrh	r3, [r7, #2]
  40eeec:	2b01      	cmp	r3, #1
  40eeee:	f240 8123 	bls.w	40f138 <DynProtocol_encodeSensorEvent+0xc04>
			goto error_size;
		// delta_ts
		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[0], &outBuffer[idx]);
  40eef2:	697b      	ldr	r3, [r7, #20]
  40eef4:	689b      	ldr	r3, [r3, #8]
  40eef6:	b218      	sxth	r0, r3
  40eef8:	8bfb      	ldrh	r3, [r7, #30]
  40eefa:	687a      	ldr	r2, [r7, #4]
  40eefc:	4413      	add	r3, r2
  40eefe:	4619      	mov	r1, r3
  40ef00:	4b63      	ldr	r3, [pc, #396]	; (40f090 <DynProtocol_encodeSensorEvent+0xb5c>)
  40ef02:	4798      	blx	r3
		idx += 2;
  40ef04:	8bfb      	ldrh	r3, [r7, #30]
  40ef06:	3302      	adds	r3, #2
  40ef08:	83fb      	strh	r3, [r7, #30]
		break;
  40ef0a:	e0df      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_EIS:
	{
		if(maxBufferSize < 14)
  40ef0c:	887b      	ldrh	r3, [r7, #2]
  40ef0e:	2b0d      	cmp	r3, #13
  40ef10:	f240 8114 	bls.w	40f13c <DynProtocol_encodeSensorEvent+0xc08>
			goto error_size;
		// uncalibrated data
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40ef14:	697b      	ldr	r3, [r7, #20]
  40ef16:	f103 0008 	add.w	r0, r3, #8
  40ef1a:	68fb      	ldr	r3, [r7, #12]
  40ef1c:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40ef20:	4619      	mov	r1, r3
  40ef22:	8bfb      	ldrh	r3, [r7, #30]
  40ef24:	687a      	ldr	r2, [r7, #4]
  40ef26:	4413      	add	r3, r2
  40ef28:	9300      	str	r3, [sp, #0]
  40ef2a:	460b      	mov	r3, r1
  40ef2c:	2210      	movs	r2, #16
  40ef2e:	2103      	movs	r1, #3
  40ef30:	4c56      	ldr	r4, [pc, #344]	; (40f08c <DynProtocol_encodeSensorEvent+0xb58>)
  40ef32:	47a0      	blx	r4
  40ef34:	4603      	mov	r3, r0
  40ef36:	b29a      	uxth	r2, r3
  40ef38:	8bfb      	ldrh	r3, [r7, #30]
  40ef3a:	4413      	add	r3, r2
  40ef3c:	83fb      	strh	r3, [r7, #30]
		// bias
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40ef3e:	697b      	ldr	r3, [r7, #20]
  40ef40:	f103 0014 	add.w	r0, r3, #20
  40ef44:	68fb      	ldr	r3, [r7, #12]
  40ef46:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
  40ef4a:	4619      	mov	r1, r3
  40ef4c:	8bfb      	ldrh	r3, [r7, #30]
  40ef4e:	687a      	ldr	r2, [r7, #4]
  40ef50:	4413      	add	r3, r2
  40ef52:	9300      	str	r3, [sp, #0]
  40ef54:	460b      	mov	r3, r1
  40ef56:	2210      	movs	r2, #16
  40ef58:	2103      	movs	r1, #3
  40ef5a:	4c4c      	ldr	r4, [pc, #304]	; (40f08c <DynProtocol_encodeSensorEvent+0xb58>)
  40ef5c:	47a0      	blx	r4
  40ef5e:	4603      	mov	r3, r0
  40ef60:	b29a      	uxth	r2, r3
  40ef62:	8bfb      	ldrh	r3, [r7, #30]
  40ef64:	4413      	add	r3, r2
  40ef66:	83fb      	strh	r3, [r7, #30]
		// delta_ts
		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[6], &outBuffer[idx]);
  40ef68:	697b      	ldr	r3, [r7, #20]
  40ef6a:	6a1b      	ldr	r3, [r3, #32]
  40ef6c:	b218      	sxth	r0, r3
  40ef6e:	8bfb      	ldrh	r3, [r7, #30]
  40ef70:	687a      	ldr	r2, [r7, #4]
  40ef72:	4413      	add	r3, r2
  40ef74:	4619      	mov	r1, r3
  40ef76:	4b46      	ldr	r3, [pc, #280]	; (40f090 <DynProtocol_encodeSensorEvent+0xb5c>)
  40ef78:	4798      	blx	r3
		idx += 2;
  40ef7a:	8bfb      	ldrh	r3, [r7, #30]
  40ef7c:	3302      	adds	r3, #2
  40ef7e:	83fb      	strh	r3, [r7, #30]
		break;
  40ef80:	e0a4      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	case DYN_PRO_SENSOR_TYPE_CUSTOM4:
	case DYN_PRO_SENSOR_TYPE_CUSTOM5:
	case DYN_PRO_SENSOR_TYPE_CUSTOM6:
	case DYN_PRO_SENSOR_TYPE_CUSTOM7:
	{
		if(maxBufferSize < 64)
  40ef82:	887b      	ldrh	r3, [r7, #2]
  40ef84:	2b3f      	cmp	r3, #63	; 0x3f
  40ef86:	f240 80db 	bls.w	40f140 <DynProtocol_encodeSensorEvent+0xc0c>
			goto error_size;
		// meta data contains size of custom sensors, it can be checked in host
		outBuffer[idx++] = vSensordata->base.meta_data;
  40ef8a:	8bfb      	ldrh	r3, [r7, #30]
  40ef8c:	1c5a      	adds	r2, r3, #1
  40ef8e:	83fa      	strh	r2, [r7, #30]
  40ef90:	461a      	mov	r2, r3
  40ef92:	687b      	ldr	r3, [r7, #4]
  40ef94:	4413      	add	r3, r2
  40ef96:	697a      	ldr	r2, [r7, #20]
  40ef98:	6852      	ldr	r2, [r2, #4]
  40ef9a:	b2d2      	uxtb	r2, r2
  40ef9c:	701a      	strb	r2, [r3, #0]
		// one byte less available in outBuffer
		maxBufferSize--;
  40ef9e:	887b      	ldrh	r3, [r7, #2]
  40efa0:	3b01      	subs	r3, #1
  40efa2:	807b      	strh	r3, [r7, #2]
		// let's make sure that size to be copied is not bigger than size left in outBuffer
		if(vSensordata->base.meta_data > maxBufferSize)
  40efa4:	697b      	ldr	r3, [r7, #20]
  40efa6:	685a      	ldr	r2, [r3, #4]
  40efa8:	887b      	ldrh	r3, [r7, #2]
  40efaa:	429a      	cmp	r2, r3
  40efac:	f200 80ca 	bhi.w	40f144 <DynProtocol_encodeSensorEvent+0xc10>
			goto error_size;

		memcpy(&outBuffer[idx], vSensordata->data.u8, vSensordata->base.meta_data);
  40efb0:	8bfb      	ldrh	r3, [r7, #30]
  40efb2:	687a      	ldr	r2, [r7, #4]
  40efb4:	18d0      	adds	r0, r2, r3
  40efb6:	697b      	ldr	r3, [r7, #20]
  40efb8:	f103 0108 	add.w	r1, r3, #8
  40efbc:	697b      	ldr	r3, [r7, #20]
  40efbe:	685b      	ldr	r3, [r3, #4]
  40efc0:	461a      	mov	r2, r3
  40efc2:	4b34      	ldr	r3, [pc, #208]	; (40f094 <DynProtocol_encodeSensorEvent+0xb60>)
  40efc4:	4798      	blx	r3
		//set hardly the payload size until payload has a fixed value for custom sensors
		idx += sizeof(vSensordata->data.u8);
  40efc6:	8bfb      	ldrh	r3, [r7, #30]
  40efc8:	3340      	adds	r3, #64	; 0x40
  40efca:	83fb      	strh	r3, [r7, #30]
		break;
  40efcc:	e07e      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
	{
		if(maxBufferSize < 16)
  40efce:	887b      	ldrh	r3, [r7, #2]
  40efd0:	2b0f      	cmp	r3, #15
  40efd2:	f240 80b9 	bls.w	40f148 <DynProtocol_encodeSensorEvent+0xc14>
			goto error_size;

		for (i=0; i<4; i++) {
  40efd6:	2300      	movs	r3, #0
  40efd8:	83bb      	strh	r3, [r7, #28]
  40efda:	e011      	b.n	40f000 <DynProtocol_encodeSensorEvent+0xacc>
			inv_dc_int32_to_little8(vSensordata->data.u32[i], &outBuffer[idx]); // raw pressure
  40efdc:	8bba      	ldrh	r2, [r7, #28]
  40efde:	697b      	ldr	r3, [r7, #20]
  40efe0:	3202      	adds	r2, #2
  40efe2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40efe6:	4618      	mov	r0, r3
  40efe8:	8bfb      	ldrh	r3, [r7, #30]
  40efea:	687a      	ldr	r2, [r7, #4]
  40efec:	4413      	add	r3, r2
  40efee:	4619      	mov	r1, r3
  40eff0:	4b25      	ldr	r3, [pc, #148]	; (40f088 <DynProtocol_encodeSensorEvent+0xb54>)
  40eff2:	4798      	blx	r3
			idx += 4;
  40eff4:	8bfb      	ldrh	r3, [r7, #30]
  40eff6:	3304      	adds	r3, #4
  40eff8:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40effa:	8bbb      	ldrh	r3, [r7, #28]
  40effc:	3301      	adds	r3, #1
  40effe:	83bb      	strh	r3, [r7, #28]
  40f000:	8bbb      	ldrh	r3, [r7, #28]
  40f002:	2b03      	cmp	r3, #3
  40f004:	d9ea      	bls.n	40efdc <DynProtocol_encodeSensorEvent+0xaa8>
		}
		break;
  40f006:	e061      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	case DYN_PRO_SENSOR_TYPE_HEART_RATE:
	{
		if(maxBufferSize < 4)
  40f008:	887b      	ldrh	r3, [r7, #2]
  40f00a:	2b03      	cmp	r3, #3
  40f00c:	f240 809e 	bls.w	40f14c <DynProtocol_encodeSensorEvent+0xc18>
			goto error_size;
                        
		// ppm
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 1, 16, PROTOCOL_HRM_PRECISION, &outBuffer[idx]);
  40f010:	697b      	ldr	r3, [r7, #20]
  40f012:	f103 0008 	add.w	r0, r3, #8
  40f016:	8bfb      	ldrh	r3, [r7, #30]
  40f018:	687a      	ldr	r2, [r7, #4]
  40f01a:	4413      	add	r3, r2
  40f01c:	9300      	str	r3, [sp, #0]
  40f01e:	2307      	movs	r3, #7
  40f020:	2210      	movs	r2, #16
  40f022:	2101      	movs	r1, #1
  40f024:	4c19      	ldr	r4, [pc, #100]	; (40f08c <DynProtocol_encodeSensorEvent+0xb58>)
  40f026:	47a0      	blx	r4
  40f028:	4603      	mov	r3, r0
  40f02a:	b29a      	uxth	r2, r3
  40f02c:	8bfb      	ldrh	r3, [r7, #30]
  40f02e:	4413      	add	r3, r2
  40f030:	83fb      	strh	r3, [r7, #30]

		// confidence
		outBuffer[idx] = vSensordata->data.u8[0]; 
  40f032:	8bfb      	ldrh	r3, [r7, #30]
  40f034:	687a      	ldr	r2, [r7, #4]
  40f036:	4413      	add	r3, r2
  40f038:	697a      	ldr	r2, [r7, #20]
  40f03a:	7a12      	ldrb	r2, [r2, #8]
  40f03c:	701a      	strb	r2, [r3, #0]
		idx++;
  40f03e:	8bfb      	ldrh	r3, [r7, #30]
  40f040:	3301      	adds	r3, #1
  40f042:	83fb      	strh	r3, [r7, #30]

		// sqi
		outBuffer[idx] = vSensordata->data.u8[1]; 
  40f044:	8bfb      	ldrh	r3, [r7, #30]
  40f046:	687a      	ldr	r2, [r7, #4]
  40f048:	4413      	add	r3, r2
  40f04a:	697a      	ldr	r2, [r7, #20]
  40f04c:	7a52      	ldrb	r2, [r2, #9]
  40f04e:	701a      	strb	r2, [r3, #0]
		idx++;                
  40f050:	8bfb      	ldrh	r3, [r7, #30]
  40f052:	3301      	adds	r3, #1
  40f054:	83fb      	strh	r3, [r7, #30]

		break;
  40f056:	e039      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}
        
	case DYN_PRO_SENSOR_TYPE_HRV:
	{
		if(maxBufferSize < 10)
  40f058:	887b      	ldrh	r3, [r7, #2]
  40f05a:	2b09      	cmp	r3, #9
  40f05c:	d978      	bls.n	40f150 <DynProtocol_encodeSensorEvent+0xc1c>
			goto error_size;
                
		// RR_count
		outBuffer[idx] = vSensordata->data.u8[1]; 
  40f05e:	8bfb      	ldrh	r3, [r7, #30]
  40f060:	687a      	ldr	r2, [r7, #4]
  40f062:	4413      	add	r3, r2
  40f064:	697a      	ldr	r2, [r7, #20]
  40f066:	7a52      	ldrb	r2, [r2, #9]
  40f068:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40f06a:	8bfb      	ldrh	r3, [r7, #30]
  40f06c:	3301      	adds	r3, #1
  40f06e:	83fb      	strh	r3, [r7, #30]

		// paddingDummy
		outBuffer[idx] = vSensordata->data.u8[0]; 
  40f070:	8bfb      	ldrh	r3, [r7, #30]
  40f072:	687a      	ldr	r2, [r7, #4]
  40f074:	4413      	add	r3, r2
  40f076:	697a      	ldr	r2, [r7, #20]
  40f078:	7a12      	ldrb	r2, [r2, #8]
  40f07a:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40f07c:	8bfb      	ldrh	r3, [r7, #30]
  40f07e:	3301      	adds	r3, #1
  40f080:	83fb      	strh	r3, [r7, #30]
                
		// RR_interval
		for (i=0; i<4; i++) {
  40f082:	2300      	movs	r3, #0
  40f084:	83bb      	strh	r3, [r7, #28]
  40f086:	e019      	b.n	40f0bc <DynProtocol_encodeSensorEvent+0xb88>
  40f088:	0040f9c9 	.word	0x0040f9c9
  40f08c:	0040d065 	.word	0x0040d065
  40f090:	0040fa0d 	.word	0x0040fa0d
  40f094:	00414235 	.word	0x00414235
			inv_dc_int16_to_little8(vSensordata->data.u16[i], &outBuffer[idx]);
  40f098:	8bba      	ldrh	r2, [r7, #28]
  40f09a:	697b      	ldr	r3, [r7, #20]
  40f09c:	3204      	adds	r2, #4
  40f09e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  40f0a2:	b218      	sxth	r0, r3
  40f0a4:	8bfb      	ldrh	r3, [r7, #30]
  40f0a6:	687a      	ldr	r2, [r7, #4]
  40f0a8:	4413      	add	r3, r2
  40f0aa:	4619      	mov	r1, r3
  40f0ac:	4b2d      	ldr	r3, [pc, #180]	; (40f164 <DynProtocol_encodeSensorEvent+0xc30>)
  40f0ae:	4798      	blx	r3
			idx += 2;
  40f0b0:	8bfb      	ldrh	r3, [r7, #30]
  40f0b2:	3302      	adds	r3, #2
  40f0b4:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40f0b6:	8bbb      	ldrh	r3, [r7, #28]
  40f0b8:	3301      	adds	r3, #1
  40f0ba:	83bb      	strh	r3, [r7, #28]
  40f0bc:	8bbb      	ldrh	r3, [r7, #28]
  40f0be:	2b03      	cmp	r3, #3
  40f0c0:	d9ea      	bls.n	40f098 <DynProtocol_encodeSensorEvent+0xb64>
		}                

		break;
  40f0c2:	e003      	b.n	40f0cc <DynProtocol_encodeSensorEvent+0xb98>
	}

	default:
		return -1;
  40f0c4:	f04f 33ff 	mov.w	r3, #4294967295
  40f0c8:	e047      	b.n	40f15a <DynProtocol_encodeSensorEvent+0xc26>
		break;
  40f0ca:	bf00      	nop
	}

	return idx;
  40f0cc:	8bfb      	ldrh	r3, [r7, #30]
  40f0ce:	e044      	b.n	40f15a <DynProtocol_encodeSensorEvent+0xc26>
		goto error_size;
  40f0d0:	bf00      	nop
  40f0d2:	e03e      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0d4:	bf00      	nop
  40f0d6:	e03c      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0d8:	bf00      	nop
  40f0da:	e03a      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0dc:	bf00      	nop
  40f0de:	e038      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0e0:	bf00      	nop
  40f0e2:	e036      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0e4:	bf00      	nop
  40f0e6:	e034      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0e8:	bf00      	nop
  40f0ea:	e032      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0ec:	bf00      	nop
  40f0ee:	e030      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0f0:	bf00      	nop
  40f0f2:	e02e      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0f4:	bf00      	nop
  40f0f6:	e02c      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0f8:	bf00      	nop
  40f0fa:	e02a      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f0fc:	bf00      	nop
  40f0fe:	e028      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f100:	bf00      	nop
  40f102:	e026      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f104:	bf00      	nop
  40f106:	e024      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f108:	bf00      	nop
  40f10a:	e022      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f10c:	bf00      	nop
  40f10e:	e020      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f110:	bf00      	nop
  40f112:	e01e      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f114:	bf00      	nop
  40f116:	e01c      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f118:	bf00      	nop
  40f11a:	e01a      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f11c:	bf00      	nop
  40f11e:	e018      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f120:	bf00      	nop
  40f122:	e016      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f124:	bf00      	nop
  40f126:	e014      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f128:	bf00      	nop
  40f12a:	e012      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f12c:	bf00      	nop
  40f12e:	e010      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f130:	bf00      	nop
  40f132:	e00e      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f134:	bf00      	nop
  40f136:	e00c      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f138:	bf00      	nop
  40f13a:	e00a      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f13c:	bf00      	nop
  40f13e:	e008      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f140:	bf00      	nop
  40f142:	e006      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f144:	bf00      	nop
  40f146:	e004      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f148:	bf00      	nop
  40f14a:	e002      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f14c:	bf00      	nop
  40f14e:	e000      	b.n	40f152 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
  40f150:	bf00      	nop

error_size:
	return maxBufferSize + idx + 1; /* +1 to indicate buffer is too small */
  40f152:	887a      	ldrh	r2, [r7, #2]
  40f154:	8bfb      	ldrh	r3, [r7, #30]
  40f156:	4413      	add	r3, r2
  40f158:	3301      	adds	r3, #1
}
  40f15a:	4618      	mov	r0, r3
  40f15c:	3724      	adds	r7, #36	; 0x24
  40f15e:	46bd      	mov	sp, r7
  40f160:	bd90      	pop	{r4, r7, pc}
  40f162:	bf00      	nop
  40f164:	0040fa0d 	.word	0x0040fa0d

0040f168 <DynProtocol_checkFrameSize>:


static int DynProtocol_checkFrameSize(DynProtocol_t * self)
{
  40f168:	b590      	push	{r4, r7, lr}
  40f16a:	b083      	sub	sp, #12
  40f16c:	af00      	add	r7, sp, #0
  40f16e:	6078      	str	r0, [r7, #4]
	if(self->decode_state_machine.expected_size == UINT16_MAX) {
  40f170:	687b      	ldr	r3, [r7, #4]
  40f172:	8a1b      	ldrh	r3, [r3, #16]
  40f174:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40f178:	4293      	cmp	r3, r2
  40f17a:	d106      	bne.n	40f18a <DynProtocol_checkFrameSize+0x22>
		/* assume frame is unknown, return error */
		INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unknown frame");
  40f17c:	4913      	ldr	r1, [pc, #76]	; (40f1cc <DynProtocol_checkFrameSize+0x64>)
  40f17e:	2001      	movs	r0, #1
  40f180:	4b13      	ldr	r3, [pc, #76]	; (40f1d0 <DynProtocol_checkFrameSize+0x68>)
  40f182:	4798      	blx	r3
		return INV_ERROR_SIZE;
  40f184:	f06f 0304 	mvn.w	r3, #4
  40f188:	e01b      	b.n	40f1c2 <DynProtocol_checkFrameSize+0x5a>
	 * expected_size is the payload expected size (not the total frame expected size).
	 * it should respect this condititon:
	 *  current_frame_size >= 1 byte (GID) + 1 byte (CID) + expected_size
	 * note : current_frame_size == UINT16_MAX means check on frame size disabled (default).
	 */
	if(self->decode_state_machine.current_frame_size != UINT16_MAX) {
  40f18a:	687b      	ldr	r3, [r7, #4]
  40f18c:	895b      	ldrh	r3, [r3, #10]
  40f18e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40f192:	4293      	cmp	r3, r2
  40f194:	d014      	beq.n	40f1c0 <DynProtocol_checkFrameSize+0x58>
		if(self->decode_state_machine.current_frame_size < (self->decode_state_machine.expected_size + 2)) {
  40f196:	687b      	ldr	r3, [r7, #4]
  40f198:	895b      	ldrh	r3, [r3, #10]
  40f19a:	461a      	mov	r2, r3
  40f19c:	687b      	ldr	r3, [r7, #4]
  40f19e:	8a1b      	ldrh	r3, [r3, #16]
  40f1a0:	3302      	adds	r3, #2
  40f1a2:	429a      	cmp	r2, r3
  40f1a4:	da0c      	bge.n	40f1c0 <DynProtocol_checkFrameSize+0x58>
			INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Frame size error. size=%dB (expected %dB)",
  40f1a6:	687b      	ldr	r3, [r7, #4]
  40f1a8:	895b      	ldrh	r3, [r3, #10]
  40f1aa:	461a      	mov	r2, r3
  40f1ac:	687b      	ldr	r3, [r7, #4]
  40f1ae:	8a1b      	ldrh	r3, [r3, #16]
  40f1b0:	3302      	adds	r3, #2
  40f1b2:	4908      	ldr	r1, [pc, #32]	; (40f1d4 <DynProtocol_checkFrameSize+0x6c>)
  40f1b4:	2001      	movs	r0, #1
  40f1b6:	4c06      	ldr	r4, [pc, #24]	; (40f1d0 <DynProtocol_checkFrameSize+0x68>)
  40f1b8:	47a0      	blx	r4
				self->decode_state_machine.current_frame_size, self->decode_state_machine.expected_size + 2);
			return INV_ERROR_SIZE;
  40f1ba:	f06f 0304 	mvn.w	r3, #4
  40f1be:	e000      	b.n	40f1c2 <DynProtocol_checkFrameSize+0x5a>
		}
	}

	return INV_ERROR_SUCCESS;
  40f1c0:	2300      	movs	r3, #0
}
  40f1c2:	4618      	mov	r0, r3
  40f1c4:	370c      	adds	r7, #12
  40f1c6:	46bd      	mov	sp, r7
  40f1c8:	bd90      	pop	{r4, r7, pc}
  40f1ca:	bf00      	nop
  40f1cc:	0041ccd4 	.word	0x0041ccd4
  40f1d0:	0040ff51 	.word	0x0040ff51
  40f1d4:	0041ccf0 	.word	0x0041ccf0

0040f1d8 <DynProtocol_init>:

void DynProtocol_init(DynProtocol_t * self,
		DynProtocolEvent_cb event_cb, void * event_cb_cookie)
{
  40f1d8:	b580      	push	{r7, lr}
  40f1da:	b084      	sub	sp, #16
  40f1dc:	af00      	add	r7, sp, #0
  40f1de:	60f8      	str	r0, [r7, #12]
  40f1e0:	60b9      	str	r1, [r7, #8]
  40f1e2:	607a      	str	r2, [r7, #4]
	memset(self, 0, sizeof(*self));
  40f1e4:	f44f 728c 	mov.w	r2, #280	; 0x118
  40f1e8:	2100      	movs	r1, #0
  40f1ea:	68f8      	ldr	r0, [r7, #12]
  40f1ec:	4b0b      	ldr	r3, [pc, #44]	; (40f21c <DynProtocol_init+0x44>)
  40f1ee:	4798      	blx	r3

	self->event_cb        = event_cb;
  40f1f0:	68fb      	ldr	r3, [r7, #12]
  40f1f2:	68ba      	ldr	r2, [r7, #8]
  40f1f4:	601a      	str	r2, [r3, #0]
	self->event_cb_cookie = event_cb_cookie;
  40f1f6:	68fb      	ldr	r3, [r7, #12]
  40f1f8:	687a      	ldr	r2, [r7, #4]
  40f1fa:	605a      	str	r2, [r3, #4]
	self->decode_state_machine.current_frame_size = UINT16_MAX;
  40f1fc:	68fb      	ldr	r3, [r7, #12]
  40f1fe:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40f202:	815a      	strh	r2, [r3, #10]
	self->precision.acc = PROTOCOL_ACCELEROMETER_PRECISION;
  40f204:	68fb      	ldr	r3, [r7, #12]
  40f206:	220b      	movs	r2, #11
  40f208:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
	self->precision.gyro = PROTOCOL_GYROSCOPE_PRECISION;
  40f20c:	68fb      	ldr	r3, [r7, #12]
  40f20e:	2204      	movs	r2, #4
  40f210:	f883 2115 	strb.w	r2, [r3, #277]	; 0x115
}
  40f214:	bf00      	nop
  40f216:	3710      	adds	r7, #16
  40f218:	46bd      	mov	sp, r7
  40f21a:	bd80      	pop	{r7, pc}
  40f21c:	00414431 	.word	0x00414431

0040f220 <DynProtocol_processPktByte>:
	}
	return rc;
}

int DynProtocol_processPktByte(DynProtocol_t * self, uint8_t rcvByte)
{
  40f220:	b580      	push	{r7, lr}
  40f222:	b084      	sub	sp, #16
  40f224:	af00      	add	r7, sp, #0
  40f226:	6078      	str	r0, [r7, #4]
  40f228:	460b      	mov	r3, r1
  40f22a:	70fb      	strb	r3, [r7, #3]
	switch(self->decode_state_machine.state) {
  40f22c:	687b      	ldr	r3, [r7, #4]
  40f22e:	7a1b      	ldrb	r3, [r3, #8]
  40f230:	2b01      	cmp	r3, #1
  40f232:	d021      	beq.n	40f278 <DynProtocol_processPktByte+0x58>
  40f234:	2b02      	cmp	r3, #2
  40f236:	d047      	beq.n	40f2c8 <DynProtocol_processPktByte+0xa8>
  40f238:	2b00      	cmp	r3, #0
  40f23a:	f040 8084 	bne.w	40f346 <DynProtocol_processPktByte+0x126>
	case PROTOCOL_STATE_GID:
	{
		self->decode_state_machine.event_type = (rcvByte & EVENT_TYPE_MASK);
  40f23e:	78fb      	ldrb	r3, [r7, #3]
  40f240:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  40f244:	b2da      	uxtb	r2, r3
  40f246:	687b      	ldr	r3, [r7, #4]
  40f248:	731a      	strb	r2, [r3, #12]
		self->decode_state_machine.group_id   = (rcvByte & ~EVENT_TYPE_MASK);
  40f24a:	78fb      	ldrb	r3, [r7, #3]
  40f24c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  40f250:	b2da      	uxtb	r2, r3
  40f252:	687b      	ldr	r3, [r7, #4]
  40f254:	735a      	strb	r2, [r3, #13]
		self->decode_state_machine.state      = PROTOCOL_STATE_CID;
  40f256:	687b      	ldr	r3, [r7, #4]
  40f258:	2201      	movs	r2, #1
  40f25a:	721a      	strb	r2, [r3, #8]

		if(self->decode_state_machine.group_id != DYN_PROTOCOL_GROUP_ID) {
  40f25c:	687b      	ldr	r3, [r7, #4]
  40f25e:	7b5b      	ldrb	r3, [r3, #13]
  40f260:	2b03      	cmp	r3, #3
  40f262:	d06b      	beq.n	40f33c <DynProtocol_processPktByte+0x11c>
			self->decode_state_machine.state  = PROTOCOL_STATE_IDLE;
  40f264:	687b      	ldr	r3, [r7, #4]
  40f266:	2200      	movs	r2, #0
  40f268:	721a      	strb	r2, [r3, #8]
			INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Invalid group ID");
  40f26a:	4939      	ldr	r1, [pc, #228]	; (40f350 <DynProtocol_processPktByte+0x130>)
  40f26c:	2001      	movs	r0, #1
  40f26e:	4b39      	ldr	r3, [pc, #228]	; (40f354 <DynProtocol_processPktByte+0x134>)
  40f270:	4798      	blx	r3
			return -1;
  40f272:	f04f 33ff 	mov.w	r3, #4294967295
  40f276:	e067      	b.n	40f348 <DynProtocol_processPktByte+0x128>

	case PROTOCOL_STATE_CID:
	{
		int rc;

		self->decode_state_machine.cmd_id     = rcvByte;
  40f278:	687b      	ldr	r3, [r7, #4]
  40f27a:	78fa      	ldrb	r2, [r7, #3]
  40f27c:	739a      	strb	r2, [r3, #14]
		self->decode_state_machine.state      = PROTOCOL_STATE_PAYLOAD;
  40f27e:	687b      	ldr	r3, [r7, #4]
  40f280:	2202      	movs	r2, #2
  40f282:	721a      	strb	r2, [r3, #8]
		self->decode_state_machine.received_size = 0;
  40f284:	687b      	ldr	r3, [r7, #4]
  40f286:	2200      	movs	r2, #0
  40f288:	825a      	strh	r2, [r3, #18]
		self->decode_state_machine.expected_size = 0;
  40f28a:	687b      	ldr	r3, [r7, #4]
  40f28c:	2200      	movs	r2, #0
  40f28e:	821a      	strh	r2, [r3, #16]
		self->decode_state_machine.expected_size = DynProtocol_getPayload(self);
  40f290:	6878      	ldr	r0, [r7, #4]
  40f292:	4b31      	ldr	r3, [pc, #196]	; (40f358 <DynProtocol_processPktByte+0x138>)
  40f294:	4798      	blx	r3
  40f296:	4603      	mov	r3, r0
  40f298:	b29a      	uxth	r2, r3
  40f29a:	687b      	ldr	r3, [r7, #4]
  40f29c:	821a      	strh	r2, [r3, #16]

		if((rc = DynProtocol_checkFrameSize(self)) != INV_ERROR_SUCCESS) {
  40f29e:	6878      	ldr	r0, [r7, #4]
  40f2a0:	4b2e      	ldr	r3, [pc, #184]	; (40f35c <DynProtocol_processPktByte+0x13c>)
  40f2a2:	4798      	blx	r3
  40f2a4:	60f8      	str	r0, [r7, #12]
  40f2a6:	68fb      	ldr	r3, [r7, #12]
  40f2a8:	2b00      	cmp	r3, #0
  40f2aa:	d004      	beq.n	40f2b6 <DynProtocol_processPktByte+0x96>
			self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
  40f2ac:	687b      	ldr	r3, [r7, #4]
  40f2ae:	2200      	movs	r2, #0
  40f2b0:	721a      	strb	r2, [r3, #8]
			return rc;
  40f2b2:	68fb      	ldr	r3, [r7, #12]
  40f2b4:	e048      	b.n	40f348 <DynProtocol_processPktByte+0x128>
		}

		if(self->decode_state_machine.expected_size == 0) {
  40f2b6:	687b      	ldr	r3, [r7, #4]
  40f2b8:	8a1b      	ldrh	r3, [r3, #16]
  40f2ba:	2b00      	cmp	r3, #0
  40f2bc:	d140      	bne.n	40f340 <DynProtocol_processPktByte+0x120>
			return DynProtocol_doProcess(self);
  40f2be:	6878      	ldr	r0, [r7, #4]
  40f2c0:	4b27      	ldr	r3, [pc, #156]	; (40f360 <DynProtocol_processPktByte+0x140>)
  40f2c2:	4798      	blx	r3
  40f2c4:	4603      	mov	r3, r0
  40f2c6:	e03f      	b.n	40f348 <DynProtocol_processPktByte+0x128>

	case PROTOCOL_STATE_PAYLOAD:
	{
		int rc;

		if(self->decode_state_machine.received_size >= MAX_EXPECTED_PAYLOAD)
  40f2c8:	687b      	ldr	r3, [r7, #4]
  40f2ca:	8a5b      	ldrh	r3, [r3, #18]
  40f2cc:	2bff      	cmp	r3, #255	; 0xff
  40f2ce:	d904      	bls.n	40f2da <DynProtocol_processPktByte+0xba>
			INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: internal buffer size full");
  40f2d0:	4924      	ldr	r1, [pc, #144]	; (40f364 <DynProtocol_processPktByte+0x144>)
  40f2d2:	2002      	movs	r0, #2
  40f2d4:	4b1f      	ldr	r3, [pc, #124]	; (40f354 <DynProtocol_processPktByte+0x134>)
  40f2d6:	4798      	blx	r3
  40f2d8:	e006      	b.n	40f2e8 <DynProtocol_processPktByte+0xc8>
		else
			self->decode_state_machine.tmp_buffer[self->decode_state_machine.received_size] = rcvByte;
  40f2da:	687b      	ldr	r3, [r7, #4]
  40f2dc:	8a5b      	ldrh	r3, [r3, #18]
  40f2de:	461a      	mov	r2, r3
  40f2e0:	687b      	ldr	r3, [r7, #4]
  40f2e2:	4413      	add	r3, r2
  40f2e4:	78fa      	ldrb	r2, [r7, #3]
  40f2e6:	751a      	strb	r2, [r3, #20]

		self->decode_state_machine.received_size++;
  40f2e8:	687b      	ldr	r3, [r7, #4]
  40f2ea:	8a5b      	ldrh	r3, [r3, #18]
  40f2ec:	3301      	adds	r3, #1
  40f2ee:	b29a      	uxth	r2, r3
  40f2f0:	687b      	ldr	r3, [r7, #4]
  40f2f2:	825a      	strh	r2, [r3, #18]
		if(self->decode_state_machine.received_size == self->decode_state_machine.expected_size)
  40f2f4:	687b      	ldr	r3, [r7, #4]
  40f2f6:	8a5a      	ldrh	r2, [r3, #18]
  40f2f8:	687b      	ldr	r3, [r7, #4]
  40f2fa:	8a1b      	ldrh	r3, [r3, #16]
  40f2fc:	429a      	cmp	r2, r3
  40f2fe:	d106      	bne.n	40f30e <DynProtocol_processPktByte+0xee>
			/* update expected payload, in case actual payload cannot be determined using only CID */
			self->decode_state_machine.expected_size = DynProtocol_getPayload(self);
  40f300:	6878      	ldr	r0, [r7, #4]
  40f302:	4b15      	ldr	r3, [pc, #84]	; (40f358 <DynProtocol_processPktByte+0x138>)
  40f304:	4798      	blx	r3
  40f306:	4603      	mov	r3, r0
  40f308:	b29a      	uxth	r2, r3
  40f30a:	687b      	ldr	r3, [r7, #4]
  40f30c:	821a      	strh	r2, [r3, #16]

		if((rc = DynProtocol_checkFrameSize(self)) != INV_ERROR_SUCCESS) {
  40f30e:	6878      	ldr	r0, [r7, #4]
  40f310:	4b12      	ldr	r3, [pc, #72]	; (40f35c <DynProtocol_processPktByte+0x13c>)
  40f312:	4798      	blx	r3
  40f314:	60b8      	str	r0, [r7, #8]
  40f316:	68bb      	ldr	r3, [r7, #8]
  40f318:	2b00      	cmp	r3, #0
  40f31a:	d004      	beq.n	40f326 <DynProtocol_processPktByte+0x106>
			self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
  40f31c:	687b      	ldr	r3, [r7, #4]
  40f31e:	2200      	movs	r2, #0
  40f320:	721a      	strb	r2, [r3, #8]
			return rc;
  40f322:	68bb      	ldr	r3, [r7, #8]
  40f324:	e010      	b.n	40f348 <DynProtocol_processPktByte+0x128>
		}

		if(self->decode_state_machine.received_size == self->decode_state_machine.expected_size)
  40f326:	687b      	ldr	r3, [r7, #4]
  40f328:	8a5a      	ldrh	r2, [r3, #18]
  40f32a:	687b      	ldr	r3, [r7, #4]
  40f32c:	8a1b      	ldrh	r3, [r3, #16]
  40f32e:	429a      	cmp	r2, r3
  40f330:	d108      	bne.n	40f344 <DynProtocol_processPktByte+0x124>
			return DynProtocol_doProcess(self);
  40f332:	6878      	ldr	r0, [r7, #4]
  40f334:	4b0a      	ldr	r3, [pc, #40]	; (40f360 <DynProtocol_processPktByte+0x140>)
  40f336:	4798      	blx	r3
  40f338:	4603      	mov	r3, r0
  40f33a:	e005      	b.n	40f348 <DynProtocol_processPktByte+0x128>
		break;
  40f33c:	bf00      	nop
  40f33e:	e002      	b.n	40f346 <DynProtocol_processPktByte+0x126>
		break;
  40f340:	bf00      	nop
  40f342:	e000      	b.n	40f346 <DynProtocol_processPktByte+0x126>

		break;
  40f344:	bf00      	nop
	}
	}

	return 0;
  40f346:	2300      	movs	r3, #0
}
  40f348:	4618      	mov	r0, r3
  40f34a:	3710      	adds	r7, #16
  40f34c:	46bd      	mov	sp, r7
  40f34e:	bd80      	pop	{r7, pc}
  40f350:	0041cd28 	.word	0x0041cd28
  40f354:	0040ff51 	.word	0x0040ff51
  40f358:	0040d251 	.word	0x0040d251
  40f35c:	0040f169 	.word	0x0040f169
  40f360:	0040e471 	.word	0x0040e471
  40f364:	0041cd48 	.word	0x0041cd48

0040f368 <DynProtocol_encodeResponse>:
}

int DynProtocol_encodeResponse(DynProtocol_t * self,
		enum DynProtocolEid eid, const DynProtocolEdata_t * edata,
		uint8_t * outBuffer, uint16_t maxBufferSize, uint16_t *outBufferSize)
{
  40f368:	b590      	push	{r4, r7, lr}
  40f36a:	b089      	sub	sp, #36	; 0x24
  40f36c:	af02      	add	r7, sp, #8
  40f36e:	60f8      	str	r0, [r7, #12]
  40f370:	607a      	str	r2, [r7, #4]
  40f372:	603b      	str	r3, [r7, #0]
  40f374:	460b      	mov	r3, r1
  40f376:	72fb      	strb	r3, [r7, #11]
	int precision;
	uint16_t idx = 0;
  40f378:	2300      	movs	r3, #0
  40f37a:	82fb      	strh	r3, [r7, #22]

	(void)self;

	*outBufferSize = 0;
  40f37c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f37e:	2200      	movs	r2, #0
  40f380:	801a      	strh	r2, [r3, #0]

	if(maxBufferSize < 2)
  40f382:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  40f384:	2b01      	cmp	r3, #1
  40f386:	f240 8167 	bls.w	40f658 <DynProtocol_encodeResponse+0x2f0>
		goto error_size;

	outBuffer[idx]  = EVENT_TYPE_RESP; // Set event type
  40f38a:	8afb      	ldrh	r3, [r7, #22]
  40f38c:	683a      	ldr	r2, [r7, #0]
  40f38e:	4413      	add	r3, r2
  40f390:	2240      	movs	r2, #64	; 0x40
  40f392:	701a      	strb	r2, [r3, #0]
	outBuffer[idx++] |= DYN_PROTOCOL_GROUP_ID & ~EVENT_TYPE_MASK; // Set group ID
  40f394:	8afb      	ldrh	r3, [r7, #22]
  40f396:	1c5a      	adds	r2, r3, #1
  40f398:	82fa      	strh	r2, [r7, #22]
  40f39a:	4619      	mov	r1, r3
  40f39c:	683a      	ldr	r2, [r7, #0]
  40f39e:	440a      	add	r2, r1
  40f3a0:	4619      	mov	r1, r3
  40f3a2:	683b      	ldr	r3, [r7, #0]
  40f3a4:	440b      	add	r3, r1
  40f3a6:	781b      	ldrb	r3, [r3, #0]
  40f3a8:	f043 0303 	orr.w	r3, r3, #3
  40f3ac:	b2db      	uxtb	r3, r3
  40f3ae:	7013      	strb	r3, [r2, #0]
	outBuffer[idx++] = (uint8_t)eid;
  40f3b0:	8afb      	ldrh	r3, [r7, #22]
  40f3b2:	1c5a      	adds	r2, r3, #1
  40f3b4:	82fa      	strh	r2, [r7, #22]
  40f3b6:	461a      	mov	r2, r3
  40f3b8:	683b      	ldr	r3, [r7, #0]
  40f3ba:	4413      	add	r3, r2
  40f3bc:	7afa      	ldrb	r2, [r7, #11]
  40f3be:	701a      	strb	r2, [r3, #0]

	switch(eid) {
  40f3c0:	7afb      	ldrb	r3, [r7, #11]
  40f3c2:	2b24      	cmp	r3, #36	; 0x24
  40f3c4:	f200 813e 	bhi.w	40f644 <DynProtocol_encodeResponse+0x2dc>
  40f3c8:	a201      	add	r2, pc, #4	; (adr r2, 40f3d0 <DynProtocol_encodeResponse+0x68>)
  40f3ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40f3ce:	bf00      	nop
  40f3d0:	0040f465 	.word	0x0040f465
  40f3d4:	0040f645 	.word	0x0040f645
  40f3d8:	0040f645 	.word	0x0040f645
  40f3dc:	0040f645 	.word	0x0040f645
  40f3e0:	0040f645 	.word	0x0040f645
  40f3e4:	0040f645 	.word	0x0040f645
  40f3e8:	0040f645 	.word	0x0040f645
  40f3ec:	0040f645 	.word	0x0040f645
  40f3f0:	0040f645 	.word	0x0040f645
  40f3f4:	0040f645 	.word	0x0040f645
  40f3f8:	0040f645 	.word	0x0040f645
  40f3fc:	0040f645 	.word	0x0040f645
  40f400:	0040f645 	.word	0x0040f645
  40f404:	0040f645 	.word	0x0040f645
  40f408:	0040f645 	.word	0x0040f645
  40f40c:	0040f645 	.word	0x0040f645
  40f410:	0040f497 	.word	0x0040f497
  40f414:	0040f497 	.word	0x0040f497
  40f418:	0040f497 	.word	0x0040f497
  40f41c:	0040f497 	.word	0x0040f497
  40f420:	0040f645 	.word	0x0040f645
  40f424:	0040f497 	.word	0x0040f497
  40f428:	0040f465 	.word	0x0040f465
  40f42c:	0040f497 	.word	0x0040f497
  40f430:	0040f645 	.word	0x0040f645
  40f434:	0040f497 	.word	0x0040f497
  40f438:	0040f497 	.word	0x0040f497
  40f43c:	0040f497 	.word	0x0040f497
  40f440:	0040f497 	.word	0x0040f497
  40f444:	0040f497 	.word	0x0040f497
  40f448:	0040f497 	.word	0x0040f497
  40f44c:	0040f5c1 	.word	0x0040f5c1
  40f450:	0040f497 	.word	0x0040f497
  40f454:	0040f4b9 	.word	0x0040f4b9
  40f458:	0040f497 	.word	0x0040f497
  40f45c:	0040f497 	.word	0x0040f497
  40f460:	0040f507 	.word	0x0040f507
	case DYN_PROTOCOL_EID_PROTOCOLVERSION:
	case DYN_PROTOCOL_EID_GET_FW_INFO:
	{
		if((maxBufferSize - idx) < 16)
  40f464:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f466:	8afb      	ldrh	r3, [r7, #22]
  40f468:	1ad3      	subs	r3, r2, r3
  40f46a:	2b0f      	cmp	r3, #15
  40f46c:	f340 80f6 	ble.w	40f65c <DynProtocol_encodeResponse+0x2f4>
			goto error_size;
		memcpy(&outBuffer[idx], edata->d.response.version, 15);
  40f470:	8afb      	ldrh	r3, [r7, #22]
  40f472:	683a      	ldr	r2, [r7, #0]
  40f474:	18d0      	adds	r0, r2, r3
  40f476:	687b      	ldr	r3, [r7, #4]
  40f478:	3304      	adds	r3, #4
  40f47a:	220f      	movs	r2, #15
  40f47c:	4619      	mov	r1, r3
  40f47e:	4b82      	ldr	r3, [pc, #520]	; (40f688 <DynProtocol_encodeResponse+0x320>)
  40f480:	4798      	blx	r3
		outBuffer[idx+15] = '\0';
  40f482:	8afb      	ldrh	r3, [r7, #22]
  40f484:	330f      	adds	r3, #15
  40f486:	683a      	ldr	r2, [r7, #0]
  40f488:	4413      	add	r3, r2
  40f48a:	2200      	movs	r2, #0
  40f48c:	701a      	strb	r2, [r3, #0]
		idx += 16;
  40f48e:	8afb      	ldrh	r3, [r7, #22]
  40f490:	3310      	adds	r3, #16
  40f492:	82fb      	strh	r3, [r7, #22]
		break;
  40f494:	e0d1      	b.n	40f63a <DynProtocol_encodeResponse+0x2d2>
	case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX:
	case DYN_PROTOCOL_EID_GET_SW_REG:
	case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
	case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:
	{
		if((maxBufferSize - idx) < 1)
  40f496:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f498:	8afb      	ldrh	r3, [r7, #22]
  40f49a:	1ad3      	subs	r3, r2, r3
  40f49c:	2b00      	cmp	r3, #0
  40f49e:	f340 80df 	ble.w	40f660 <DynProtocol_encodeResponse+0x2f8>
			goto error_size;
		outBuffer[idx++] = (uint8_t)edata->d.response.rc;
  40f4a2:	8afb      	ldrh	r3, [r7, #22]
  40f4a4:	1c5a      	adds	r2, r3, #1
  40f4a6:	82fa      	strh	r2, [r7, #22]
  40f4a8:	461a      	mov	r2, r3
  40f4aa:	683b      	ldr	r3, [r7, #0]
  40f4ac:	4413      	add	r3, r2
  40f4ae:	687a      	ldr	r2, [r7, #4]
  40f4b0:	6852      	ldr	r2, [r2, #4]
  40f4b2:	b2d2      	uxtb	r2, r2
  40f4b4:	701a      	strb	r2, [r3, #0]
		break;
  40f4b6:	e0c0      	b.n	40f63a <DynProtocol_encodeResponse+0x2d2>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_DATA:
	{
		if((maxBufferSize - idx) < (1+1+1+4+64)) // need room for rc+sensorstatus+sensorid+timestamp+data
  40f4b8:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f4ba:	8afb      	ldrh	r3, [r7, #22]
  40f4bc:	1ad3      	subs	r3, r2, r3
  40f4be:	2b46      	cmp	r3, #70	; 0x46
  40f4c0:	f340 80d0 	ble.w	40f664 <DynProtocol_encodeResponse+0x2fc>
			goto error_size;
		outBuffer[idx++] = edata->d.response.sensorData.rc;
  40f4c4:	8afb      	ldrh	r3, [r7, #22]
  40f4c6:	1c5a      	adds	r2, r3, #1
  40f4c8:	82fa      	strh	r2, [r7, #22]
  40f4ca:	461a      	mov	r2, r3
  40f4cc:	683b      	ldr	r3, [r7, #0]
  40f4ce:	4413      	add	r3, r2
  40f4d0:	687a      	ldr	r2, [r7, #4]
  40f4d2:	6852      	ldr	r2, [r2, #4]
  40f4d4:	b2d2      	uxtb	r2, r2
  40f4d6:	701a      	strb	r2, [r3, #0]
 		if(DynProtocol_encodeSensorEvent(self, edata, &outBuffer[idx], maxBufferSize - idx, DYN_PROTOCOL_ETYPE_RESP) == -1)
  40f4d8:	8afb      	ldrh	r3, [r7, #22]
  40f4da:	683a      	ldr	r2, [r7, #0]
  40f4dc:	18d1      	adds	r1, r2, r3
  40f4de:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f4e0:	8afb      	ldrh	r3, [r7, #22]
  40f4e2:	1ad3      	subs	r3, r2, r3
  40f4e4:	b29a      	uxth	r2, r3
  40f4e6:	2301      	movs	r3, #1
  40f4e8:	9300      	str	r3, [sp, #0]
  40f4ea:	4613      	mov	r3, r2
  40f4ec:	460a      	mov	r2, r1
  40f4ee:	6879      	ldr	r1, [r7, #4]
  40f4f0:	68f8      	ldr	r0, [r7, #12]
  40f4f2:	4c66      	ldr	r4, [pc, #408]	; (40f68c <DynProtocol_encodeResponse+0x324>)
  40f4f4:	47a0      	blx	r4
  40f4f6:	4603      	mov	r3, r0
  40f4f8:	f1b3 3fff 	cmp.w	r3, #4294967295
  40f4fc:	f000 80a4 	beq.w	40f648 <DynProtocol_encodeResponse+0x2e0>
			goto error_arg;

		// GET_SENSOR_DATA response frame size is fixed:
		//  EVT_TYPE + EVT_ID + RC + SENSOR_STATUS + SENSORID + TIMESTAMP[0-3] + MAX_SENSOR_EVENT_DATA_SIZE (arbitrary fixed to 64B)
		idx = 1+1+1+1+1+4+64;
  40f500:	2349      	movs	r3, #73	; 0x49
  40f502:	82fb      	strh	r3, [r7, #22]
		break;
  40f504:	e099      	b.n	40f63a <DynProtocol_encodeResponse+0x2d2>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
	{
		if((maxBufferSize - idx) < 68)
  40f506:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f508:	8afb      	ldrh	r3, [r7, #22]
  40f50a:	1ad3      	subs	r3, r2, r3
  40f50c:	2b43      	cmp	r3, #67	; 0x43
  40f50e:	f340 80ab 	ble.w	40f668 <DynProtocol_encodeResponse+0x300>
			goto error_size;
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.rc;
  40f512:	8afb      	ldrh	r3, [r7, #22]
  40f514:	1c5a      	adds	r2, r3, #1
  40f516:	82fa      	strh	r2, [r7, #22]
  40f518:	461a      	mov	r2, r3
  40f51a:	683b      	ldr	r3, [r7, #0]
  40f51c:	4413      	add	r3, r2
  40f51e:	687a      	ldr	r2, [r7, #4]
  40f520:	6852      	ldr	r2, [r2, #4]
  40f522:	b2d2      	uxtb	r2, r2
  40f524:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.type;
  40f526:	8afb      	ldrh	r3, [r7, #22]
  40f528:	1c5a      	adds	r2, r3, #1
  40f52a:	82fa      	strh	r2, [r7, #22]
  40f52c:	461a      	mov	r2, r3
  40f52e:	683b      	ldr	r3, [r7, #0]
  40f530:	4413      	add	r3, r2
  40f532:	687a      	ldr	r2, [r7, #4]
  40f534:	6892      	ldr	r2, [r2, #8]
  40f536:	b2d2      	uxtb	r2, r2
  40f538:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.size;
  40f53a:	8afb      	ldrh	r3, [r7, #22]
  40f53c:	1c5a      	adds	r2, r3, #1
  40f53e:	82fa      	strh	r2, [r7, #22]
  40f540:	461a      	mov	r2, r3
  40f542:	683b      	ldr	r3, [r7, #0]
  40f544:	4413      	add	r3, r2
  40f546:	687a      	ldr	r2, [r7, #4]
  40f548:	68d2      	ldr	r2, [r2, #12]
  40f54a:	b2d2      	uxtb	r2, r2
  40f54c:	701a      	strb	r2, [r3, #0]
		switch (edata->d.response.sensorcfg.cfg.base.type) {
  40f54e:	687b      	ldr	r3, [r7, #4]
  40f550:	689b      	ldr	r3, [r3, #8]
  40f552:	2b03      	cmp	r3, #3
  40f554:	d11d      	bne.n	40f592 <DynProtocol_encodeResponse+0x22a>
		case VSENSOR_CONFIG_TYPE_OFFSET:
			outBuffer[idx++] = (uint8_t)edata->sensor_id;
  40f556:	8afb      	ldrh	r3, [r7, #22]
  40f558:	1c5a      	adds	r2, r3, #1
  40f55a:	82fa      	strh	r2, [r7, #22]
  40f55c:	461a      	mov	r2, r3
  40f55e:	683b      	ldr	r3, [r7, #0]
  40f560:	4413      	add	r3, r2
  40f562:	687a      	ldr	r2, [r7, #4]
  40f564:	6812      	ldr	r2, [r2, #0]
  40f566:	b2d2      	uxtb	r2, r2
  40f568:	701a      	strb	r2, [r3, #0]
			precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40f56a:	687b      	ldr	r3, [r7, #4]
  40f56c:	681b      	ldr	r3, [r3, #0]
  40f56e:	4619      	mov	r1, r3
  40f570:	68f8      	ldr	r0, [r7, #12]
  40f572:	4b47      	ldr	r3, [pc, #284]	; (40f690 <DynProtocol_encodeResponse+0x328>)
  40f574:	4798      	blx	r3
  40f576:	6138      	str	r0, [r7, #16]
			DynProtocol_encodeQxToQyVect16((int32_t*)&edata->d.response.sensorcfg.cfg.buffer[0], 3, 16, precision, &outBuffer[idx]);
  40f578:	687b      	ldr	r3, [r7, #4]
  40f57a:	f103 0010 	add.w	r0, r3, #16
  40f57e:	8afb      	ldrh	r3, [r7, #22]
  40f580:	683a      	ldr	r2, [r7, #0]
  40f582:	4413      	add	r3, r2
  40f584:	9300      	str	r3, [sp, #0]
  40f586:	693b      	ldr	r3, [r7, #16]
  40f588:	2210      	movs	r2, #16
  40f58a:	2103      	movs	r1, #3
  40f58c:	4c41      	ldr	r4, [pc, #260]	; (40f694 <DynProtocol_encodeResponse+0x32c>)
  40f58e:	47a0      	blx	r4
			break;
  40f590:	e013      	b.n	40f5ba <DynProtocol_encodeResponse+0x252>
		default:
			// we don't know what is the value of cfg.size so let's make sure
			// there is enough room in outBuffer.
			if((uint32_t)(maxBufferSize - idx) < edata->d.response.sensorcfg.cfg.base.size)
  40f592:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f594:	8afb      	ldrh	r3, [r7, #22]
  40f596:	1ad3      	subs	r3, r2, r3
  40f598:	461a      	mov	r2, r3
  40f59a:	687b      	ldr	r3, [r7, #4]
  40f59c:	68db      	ldr	r3, [r3, #12]
  40f59e:	429a      	cmp	r2, r3
  40f5a0:	d364      	bcc.n	40f66c <DynProtocol_encodeResponse+0x304>
				goto error_size;
			memcpy(&outBuffer[idx], edata->d.response.sensorcfg.cfg.buffer, edata->d.response.sensorcfg.cfg.base.size);
  40f5a2:	8afb      	ldrh	r3, [r7, #22]
  40f5a4:	683a      	ldr	r2, [r7, #0]
  40f5a6:	18d0      	adds	r0, r2, r3
  40f5a8:	687b      	ldr	r3, [r7, #4]
  40f5aa:	f103 0110 	add.w	r1, r3, #16
  40f5ae:	687b      	ldr	r3, [r7, #4]
  40f5b0:	68db      	ldr	r3, [r3, #12]
  40f5b2:	461a      	mov	r2, r3
  40f5b4:	4b34      	ldr	r3, [pc, #208]	; (40f688 <DynProtocol_encodeResponse+0x320>)
  40f5b6:	4798      	blx	r3
			break;
  40f5b8:	bf00      	nop
		}
		idx = 68 + 2;
  40f5ba:	2346      	movs	r3, #70	; 0x46
  40f5bc:	82fb      	strh	r3, [r7, #22]
		break;
  40f5be:	e03c      	b.n	40f63a <DynProtocol_encodeResponse+0x2d2>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
	{
		if ((maxBufferSize - idx) < 1 + 1 + 1 + (3 * 2))
  40f5c0:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f5c2:	8afb      	ldrh	r3, [r7, #22]
  40f5c4:	1ad3      	subs	r3, r2, r3
  40f5c6:	2b08      	cmp	r3, #8
  40f5c8:	dd52      	ble.n	40f670 <DynProtocol_encodeResponse+0x308>
			goto error_size;
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.rc;
  40f5ca:	8afb      	ldrh	r3, [r7, #22]
  40f5cc:	1c5a      	adds	r2, r3, #1
  40f5ce:	82fa      	strh	r2, [r7, #22]
  40f5d0:	461a      	mov	r2, r3
  40f5d2:	683b      	ldr	r3, [r7, #0]
  40f5d4:	4413      	add	r3, r2
  40f5d6:	687a      	ldr	r2, [r7, #4]
  40f5d8:	6852      	ldr	r2, [r2, #4]
  40f5da:	b2d2      	uxtb	r2, r2
  40f5dc:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->sensor_id;
  40f5de:	8afb      	ldrh	r3, [r7, #22]
  40f5e0:	1c5a      	adds	r2, r3, #1
  40f5e2:	82fa      	strh	r2, [r7, #22]
  40f5e4:	461a      	mov	r2, r3
  40f5e6:	683b      	ldr	r3, [r7, #0]
  40f5e8:	4413      	add	r3, r2
  40f5ea:	687a      	ldr	r2, [r7, #4]
  40f5ec:	6812      	ldr	r2, [r2, #0]
  40f5ee:	b2d2      	uxtb	r2, r2
  40f5f0:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.type;
  40f5f2:	8afb      	ldrh	r3, [r7, #22]
  40f5f4:	1c5a      	adds	r2, r3, #1
  40f5f6:	82fa      	strh	r2, [r7, #22]
  40f5f8:	461a      	mov	r2, r3
  40f5fa:	683b      	ldr	r3, [r7, #0]
  40f5fc:	4413      	add	r3, r2
  40f5fe:	687a      	ldr	r2, [r7, #4]
  40f600:	6892      	ldr	r2, [r2, #8]
  40f602:	b2d2      	uxtb	r2, r2
  40f604:	701a      	strb	r2, [r3, #0]
		precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40f606:	687b      	ldr	r3, [r7, #4]
  40f608:	681b      	ldr	r3, [r3, #0]
  40f60a:	4619      	mov	r1, r3
  40f60c:	68f8      	ldr	r0, [r7, #12]
  40f60e:	4b20      	ldr	r3, [pc, #128]	; (40f690 <DynProtocol_encodeResponse+0x328>)
  40f610:	4798      	blx	r3
  40f612:	6138      	str	r0, [r7, #16]
		idx += DynProtocol_encodeQxToQyVect16(&((VSensorConfigOffset *)&edata->d.response.sensorcfg.cfg)->vect[0], 3, 16, precision, &outBuffer[idx]);
  40f614:	687b      	ldr	r3, [r7, #4]
  40f616:	3308      	adds	r3, #8
  40f618:	f103 0008 	add.w	r0, r3, #8
  40f61c:	8afb      	ldrh	r3, [r7, #22]
  40f61e:	683a      	ldr	r2, [r7, #0]
  40f620:	4413      	add	r3, r2
  40f622:	9300      	str	r3, [sp, #0]
  40f624:	693b      	ldr	r3, [r7, #16]
  40f626:	2210      	movs	r2, #16
  40f628:	2103      	movs	r1, #3
  40f62a:	4c1a      	ldr	r4, [pc, #104]	; (40f694 <DynProtocol_encodeResponse+0x32c>)
  40f62c:	47a0      	blx	r4
  40f62e:	4603      	mov	r3, r0
  40f630:	b29a      	uxth	r2, r3
  40f632:	8afb      	ldrh	r3, [r7, #22]
  40f634:	4413      	add	r3, r2
  40f636:	82fb      	strh	r3, [r7, #22]
		break;
  40f638:	bf00      	nop

	default:
		goto error_arg;
	}

	*outBufferSize = (idx);
  40f63a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f63c:	8afa      	ldrh	r2, [r7, #22]
  40f63e:	801a      	strh	r2, [r3, #0]

	return 0;
  40f640:	2300      	movs	r3, #0
  40f642:	e01c      	b.n	40f67e <DynProtocol_encodeResponse+0x316>
		goto error_arg;
  40f644:	bf00      	nop
  40f646:	e000      	b.n	40f64a <DynProtocol_encodeResponse+0x2e2>
			goto error_arg;
  40f648:	bf00      	nop

error_arg:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected argument for DynProtocol_encodeResponse()");
  40f64a:	4913      	ldr	r1, [pc, #76]	; (40f698 <DynProtocol_encodeResponse+0x330>)
  40f64c:	2001      	movs	r0, #1
  40f64e:	4b13      	ldr	r3, [pc, #76]	; (40f69c <DynProtocol_encodeResponse+0x334>)
  40f650:	4798      	blx	r3
	return -1;
  40f652:	f04f 33ff 	mov.w	r3, #4294967295
  40f656:	e012      	b.n	40f67e <DynProtocol_encodeResponse+0x316>
		goto error_size;
  40f658:	bf00      	nop
  40f65a:	e00a      	b.n	40f672 <DynProtocol_encodeResponse+0x30a>
			goto error_size;
  40f65c:	bf00      	nop
  40f65e:	e008      	b.n	40f672 <DynProtocol_encodeResponse+0x30a>
			goto error_size;
  40f660:	bf00      	nop
  40f662:	e006      	b.n	40f672 <DynProtocol_encodeResponse+0x30a>
			goto error_size;
  40f664:	bf00      	nop
  40f666:	e004      	b.n	40f672 <DynProtocol_encodeResponse+0x30a>
			goto error_size;
  40f668:	bf00      	nop
  40f66a:	e002      	b.n	40f672 <DynProtocol_encodeResponse+0x30a>
				goto error_size;
  40f66c:	bf00      	nop
  40f66e:	e000      	b.n	40f672 <DynProtocol_encodeResponse+0x30a>
			goto error_size;
  40f670:	bf00      	nop

error_size:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: output buffer size too small");
  40f672:	490b      	ldr	r1, [pc, #44]	; (40f6a0 <DynProtocol_encodeResponse+0x338>)
  40f674:	2001      	movs	r0, #1
  40f676:	4b09      	ldr	r3, [pc, #36]	; (40f69c <DynProtocol_encodeResponse+0x334>)
  40f678:	4798      	blx	r3
	return -1;
  40f67a:	f04f 33ff 	mov.w	r3, #4294967295
}
  40f67e:	4618      	mov	r0, r3
  40f680:	371c      	adds	r7, #28
  40f682:	46bd      	mov	sp, r7
  40f684:	bd90      	pop	{r4, r7, pc}
  40f686:	bf00      	nop
  40f688:	00414235 	.word	0x00414235
  40f68c:	0040e535 	.word	0x0040e535
  40f690:	0040d0f1 	.word	0x0040d0f1
  40f694:	0040d065 	.word	0x0040d065
  40f698:	0041cdd4 	.word	0x0041cdd4
  40f69c:	0040ff51 	.word	0x0040ff51
  40f6a0:	0041cda8 	.word	0x0041cda8

0040f6a4 <DynProtocol_encodeAsync>:

int DynProtocol_encodeAsync(DynProtocol_t * self,
		enum DynProtocolEid eid, const DynProtocolEdata_t * edata,
		uint8_t * outBuffer, uint16_t maxBufferSize, uint16_t *outBufferSize)
{
  40f6a4:	b590      	push	{r4, r7, lr}
  40f6a6:	b089      	sub	sp, #36	; 0x24
  40f6a8:	af02      	add	r7, sp, #8
  40f6aa:	60f8      	str	r0, [r7, #12]
  40f6ac:	607a      	str	r2, [r7, #4]
  40f6ae:	603b      	str	r3, [r7, #0]
  40f6b0:	460b      	mov	r3, r1
  40f6b2:	72fb      	strb	r3, [r7, #11]
	uint16_t idx = 0;
  40f6b4:	2300      	movs	r3, #0
  40f6b6:	82fb      	strh	r3, [r7, #22]
	int len;

	(void)self;

	*outBufferSize = 0;
  40f6b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f6ba:	2200      	movs	r2, #0
  40f6bc:	801a      	strh	r2, [r3, #0]

	if(maxBufferSize < 2)
  40f6be:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  40f6c0:	2b01      	cmp	r3, #1
  40f6c2:	d94b      	bls.n	40f75c <DynProtocol_encodeAsync+0xb8>
		goto error_size;

	outBuffer[idx]  = EVENT_TYPE_ASYNC; // Set event type
  40f6c4:	8afb      	ldrh	r3, [r7, #22]
  40f6c6:	683a      	ldr	r2, [r7, #0]
  40f6c8:	4413      	add	r3, r2
  40f6ca:	2280      	movs	r2, #128	; 0x80
  40f6cc:	701a      	strb	r2, [r3, #0]
	outBuffer[idx++] |= DYN_PROTOCOL_GROUP_ID & ~EVENT_TYPE_MASK; // Set group ID
  40f6ce:	8afb      	ldrh	r3, [r7, #22]
  40f6d0:	1c5a      	adds	r2, r3, #1
  40f6d2:	82fa      	strh	r2, [r7, #22]
  40f6d4:	4619      	mov	r1, r3
  40f6d6:	683a      	ldr	r2, [r7, #0]
  40f6d8:	440a      	add	r2, r1
  40f6da:	4619      	mov	r1, r3
  40f6dc:	683b      	ldr	r3, [r7, #0]
  40f6de:	440b      	add	r3, r1
  40f6e0:	781b      	ldrb	r3, [r3, #0]
  40f6e2:	f043 0303 	orr.w	r3, r3, #3
  40f6e6:	b2db      	uxtb	r3, r3
  40f6e8:	7013      	strb	r3, [r2, #0]
	outBuffer[idx++] = (uint8_t)eid;
  40f6ea:	8afb      	ldrh	r3, [r7, #22]
  40f6ec:	1c5a      	adds	r2, r3, #1
  40f6ee:	82fa      	strh	r2, [r7, #22]
  40f6f0:	461a      	mov	r2, r3
  40f6f2:	683b      	ldr	r3, [r7, #0]
  40f6f4:	4413      	add	r3, r2
  40f6f6:	7afa      	ldrb	r2, [r7, #11]
  40f6f8:	701a      	strb	r2, [r3, #0]

	switch(eid) {
  40f6fa:	7afb      	ldrb	r3, [r7, #11]
  40f6fc:	2b30      	cmp	r3, #48	; 0x30
  40f6fe:	d000      	beq.n	40f702 <DynProtocol_encodeAsync+0x5e>
		idx += len;
		break;
	}

	default:
		goto error_arg;
  40f700:	e025      	b.n	40f74e <DynProtocol_encodeAsync+0xaa>
		len = DynProtocol_encodeSensorEvent(self, edata, &outBuffer[idx], maxBufferSize - idx, DYN_PROTOCOL_ETYPE_ASYNC);
  40f702:	8afb      	ldrh	r3, [r7, #22]
  40f704:	683a      	ldr	r2, [r7, #0]
  40f706:	18d1      	adds	r1, r2, r3
  40f708:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f70a:	8afb      	ldrh	r3, [r7, #22]
  40f70c:	1ad3      	subs	r3, r2, r3
  40f70e:	b29a      	uxth	r2, r3
  40f710:	2302      	movs	r3, #2
  40f712:	9300      	str	r3, [sp, #0]
  40f714:	4613      	mov	r3, r2
  40f716:	460a      	mov	r2, r1
  40f718:	6879      	ldr	r1, [r7, #4]
  40f71a:	68f8      	ldr	r0, [r7, #12]
  40f71c:	4c16      	ldr	r4, [pc, #88]	; (40f778 <DynProtocol_encodeAsync+0xd4>)
  40f71e:	47a0      	blx	r4
  40f720:	6138      	str	r0, [r7, #16]
		if(len == -1)
  40f722:	693b      	ldr	r3, [r7, #16]
  40f724:	f1b3 3fff 	cmp.w	r3, #4294967295
  40f728:	d010      	beq.n	40f74c <DynProtocol_encodeAsync+0xa8>
		else if(len > maxBufferSize - idx)
  40f72a:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f72c:	8afb      	ldrh	r3, [r7, #22]
  40f72e:	1ad2      	subs	r2, r2, r3
  40f730:	693b      	ldr	r3, [r7, #16]
  40f732:	429a      	cmp	r2, r3
  40f734:	db14      	blt.n	40f760 <DynProtocol_encodeAsync+0xbc>
		idx += len;
  40f736:	693b      	ldr	r3, [r7, #16]
  40f738:	b29a      	uxth	r2, r3
  40f73a:	8afb      	ldrh	r3, [r7, #22]
  40f73c:	4413      	add	r3, r2
  40f73e:	82fb      	strh	r3, [r7, #22]
		break;
  40f740:	bf00      	nop
	}

	*outBufferSize = (idx);
  40f742:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f744:	8afa      	ldrh	r2, [r7, #22]
  40f746:	801a      	strh	r2, [r3, #0]

	return 0;
  40f748:	2300      	movs	r3, #0
  40f74a:	e010      	b.n	40f76e <DynProtocol_encodeAsync+0xca>
			goto error_arg;
  40f74c:	bf00      	nop

error_arg:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected argument for encode_async()");
  40f74e:	490b      	ldr	r1, [pc, #44]	; (40f77c <DynProtocol_encodeAsync+0xd8>)
  40f750:	2001      	movs	r0, #1
  40f752:	4b0b      	ldr	r3, [pc, #44]	; (40f780 <DynProtocol_encodeAsync+0xdc>)
  40f754:	4798      	blx	r3
	return -1;
  40f756:	f04f 33ff 	mov.w	r3, #4294967295
  40f75a:	e008      	b.n	40f76e <DynProtocol_encodeAsync+0xca>
		goto error_size;
  40f75c:	bf00      	nop
  40f75e:	e000      	b.n	40f762 <DynProtocol_encodeAsync+0xbe>
			goto error_size;
  40f760:	bf00      	nop

error_size:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: output buffer size too small");
  40f762:	4908      	ldr	r1, [pc, #32]	; (40f784 <DynProtocol_encodeAsync+0xe0>)
  40f764:	2001      	movs	r0, #1
  40f766:	4b06      	ldr	r3, [pc, #24]	; (40f780 <DynProtocol_encodeAsync+0xdc>)
  40f768:	4798      	blx	r3
	return -1;
  40f76a:	f04f 33ff 	mov.w	r3, #4294967295
}
  40f76e:	4618      	mov	r0, r3
  40f770:	371c      	adds	r7, #28
  40f772:	46bd      	mov	sp, r7
  40f774:	bd90      	pop	{r4, r7, pc}
  40f776:	bf00      	nop
  40f778:	0040e535 	.word	0x0040e535
  40f77c:	0041ce18 	.word	0x0041ce18
  40f780:	0040ff51 	.word	0x0040ff51
  40f784:	0041cda8 	.word	0x0041cda8

0040f788 <DynProTransportUart_callEventCB>:
#define DYN_PRO_TRANSPORT_UART_OVERHEAD     4

static inline void DynProTransportUart_callEventCB(DynProTransportUart_t * self, 
		enum DynProTransportEvent event,
		union DynProTransportEventData data)
{
  40f788:	b580      	push	{r7, lr}
  40f78a:	b084      	sub	sp, #16
  40f78c:	af00      	add	r7, sp, #0
  40f78e:	60f8      	str	r0, [r7, #12]
  40f790:	460b      	mov	r3, r1
  40f792:	607a      	str	r2, [r7, #4]
  40f794:	72fb      	strb	r3, [r7, #11]
	if(self->event_cb) {
  40f796:	68fb      	ldr	r3, [r7, #12]
  40f798:	681b      	ldr	r3, [r3, #0]
  40f79a:	2b00      	cmp	r3, #0
  40f79c:	d006      	beq.n	40f7ac <DynProTransportUart_callEventCB+0x24>
		self->event_cb(event, data, self->event_cb_cookie);
  40f79e:	68fb      	ldr	r3, [r7, #12]
  40f7a0:	681b      	ldr	r3, [r3, #0]
  40f7a2:	68fa      	ldr	r2, [r7, #12]
  40f7a4:	6852      	ldr	r2, [r2, #4]
  40f7a6:	7af8      	ldrb	r0, [r7, #11]
  40f7a8:	6879      	ldr	r1, [r7, #4]
  40f7aa:	4798      	blx	r3
	}
}
  40f7ac:	bf00      	nop
  40f7ae:	3710      	adds	r7, #16
  40f7b0:	46bd      	mov	sp, r7
  40f7b2:	bd80      	pop	{r7, pc}

0040f7b4 <DynProTransportUart_init>:

void DynProTransportUart_init(DynProTransportUart_t * self,
		DynProTransportEvent_cb event_cb, void * cookie)
{
  40f7b4:	b480      	push	{r7}
  40f7b6:	b085      	sub	sp, #20
  40f7b8:	af00      	add	r7, sp, #0
  40f7ba:	60f8      	str	r0, [r7, #12]
  40f7bc:	60b9      	str	r1, [r7, #8]
  40f7be:	607a      	str	r2, [r7, #4]
	self->event_cb        = event_cb;
  40f7c0:	68fb      	ldr	r3, [r7, #12]
  40f7c2:	68ba      	ldr	r2, [r7, #8]
  40f7c4:	601a      	str	r2, [r3, #0]
	self->event_cb_cookie = cookie;
  40f7c6:	68fb      	ldr	r3, [r7, #12]
  40f7c8:	687a      	ldr	r2, [r7, #4]
  40f7ca:	605a      	str	r2, [r3, #4]
	self->rx_sm_state     = RECEIVER_STATE_IDLE;
  40f7cc:	68fb      	ldr	r3, [r7, #12]
  40f7ce:	2200      	movs	r2, #0
  40f7d0:	721a      	strb	r2, [r3, #8]
	self->use_tx_dma        = 0;
  40f7d2:	68fb      	ldr	r3, [r7, #12]
  40f7d4:	2200      	movs	r2, #0
  40f7d6:	739a      	strb	r2, [r3, #14]
}
  40f7d8:	bf00      	nop
  40f7da:	3714      	adds	r7, #20
  40f7dc:	46bd      	mov	sp, r7
  40f7de:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f7e2:	4770      	bx	lr

0040f7e4 <DynProTransportUart_rxProcessByte>:
		return expected_size;
		
}

int DynProTransportUart_rxProcessByte(DynProTransportUart_t * self, uint8_t rcv_byte)
{
  40f7e4:	b580      	push	{r7, lr}
  40f7e6:	b084      	sub	sp, #16
  40f7e8:	af00      	add	r7, sp, #0
  40f7ea:	6078      	str	r0, [r7, #4]
  40f7ec:	460b      	mov	r3, r1
  40f7ee:	70fb      	strb	r3, [r7, #3]
	union DynProTransportEventData udata;

	switch(self->rx_sm_state) {
  40f7f0:	687b      	ldr	r3, [r7, #4]
  40f7f2:	7a1b      	ldrb	r3, [r3, #8]
  40f7f4:	2b04      	cmp	r3, #4
  40f7f6:	f200 8087 	bhi.w	40f908 <DynProTransportUart_rxProcessByte+0x124>
  40f7fa:	a201      	add	r2, pc, #4	; (adr r2, 40f800 <DynProTransportUart_rxProcessByte+0x1c>)
  40f7fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40f800:	0040f815 	.word	0x0040f815
  40f804:	0040f84b 	.word	0x0040f84b
  40f808:	0040f881 	.word	0x0040f881
  40f80c:	0040f891 	.word	0x0040f891
  40f810:	0040f8c7 	.word	0x0040f8c7
	case RECEIVER_STATE_IDLE:
		if(rcv_byte == SYNC_BYTE_0) {
  40f814:	78fb      	ldrb	r3, [r7, #3]
  40f816:	2b55      	cmp	r3, #85	; 0x55
  40f818:	d103      	bne.n	40f822 <DynProTransportUart_rxProcessByte+0x3e>
			self->rx_sm_state = RECEIVER_STATE_SYNC_1;
  40f81a:	687b      	ldr	r3, [r7, #4]
  40f81c:	2201      	movs	r2, #1
  40f81e:	721a      	strb	r2, [r3, #8]
			self->rx_sm_state = RECEIVER_STATE_IDLE;
			udata.error = -1;
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
			return -1;
		}
		break;
  40f820:	e072      	b.n	40f908 <DynProTransportUart_rxProcessByte+0x124>
			INV_MSG(INV_MSG_LEVEL_VERBOSE, "DynProTransportUart: unexpected SYNC0 byte %x recevied", rcv_byte);
  40f822:	78fb      	ldrb	r3, [r7, #3]
  40f824:	461a      	mov	r2, r3
  40f826:	493b      	ldr	r1, [pc, #236]	; (40f914 <DynProTransportUart_rxProcessByte+0x130>)
  40f828:	2004      	movs	r0, #4
  40f82a:	4b3b      	ldr	r3, [pc, #236]	; (40f918 <DynProTransportUart_rxProcessByte+0x134>)
  40f82c:	4798      	blx	r3
			self->rx_sm_state = RECEIVER_STATE_IDLE;
  40f82e:	687b      	ldr	r3, [r7, #4]
  40f830:	2200      	movs	r2, #0
  40f832:	721a      	strb	r2, [r3, #8]
			udata.error = -1;
  40f834:	f04f 33ff 	mov.w	r3, #4294967295
  40f838:	60fb      	str	r3, [r7, #12]
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
  40f83a:	68fa      	ldr	r2, [r7, #12]
  40f83c:	2100      	movs	r1, #0
  40f83e:	6878      	ldr	r0, [r7, #4]
  40f840:	4b36      	ldr	r3, [pc, #216]	; (40f91c <DynProTransportUart_rxProcessByte+0x138>)
  40f842:	4798      	blx	r3
			return -1;
  40f844:	f04f 33ff 	mov.w	r3, #4294967295
  40f848:	e05f      	b.n	40f90a <DynProTransportUart_rxProcessByte+0x126>

	case RECEIVER_STATE_SYNC_1:
		if(rcv_byte == SYNC_BYTE_1) {
  40f84a:	78fb      	ldrb	r3, [r7, #3]
  40f84c:	2baa      	cmp	r3, #170	; 0xaa
  40f84e:	d103      	bne.n	40f858 <DynProTransportUart_rxProcessByte+0x74>
			self->rx_sm_state = RECEIVER_STATE_SIZE_BYTE_0;
  40f850:	687b      	ldr	r3, [r7, #4]
  40f852:	2202      	movs	r2, #2
  40f854:	721a      	strb	r2, [r3, #8]
			self->rx_sm_state = RECEIVER_STATE_IDLE;
			udata.error = -1;
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
			return -1;
		}
		break;
  40f856:	e057      	b.n	40f908 <DynProTransportUart_rxProcessByte+0x124>
			INV_MSG(INV_MSG_LEVEL_VERBOSE, "DynProTransportUart: unexpected SYNC1 byte %x recevied", rcv_byte);
  40f858:	78fb      	ldrb	r3, [r7, #3]
  40f85a:	461a      	mov	r2, r3
  40f85c:	4930      	ldr	r1, [pc, #192]	; (40f920 <DynProTransportUart_rxProcessByte+0x13c>)
  40f85e:	2004      	movs	r0, #4
  40f860:	4b2d      	ldr	r3, [pc, #180]	; (40f918 <DynProTransportUart_rxProcessByte+0x134>)
  40f862:	4798      	blx	r3
			self->rx_sm_state = RECEIVER_STATE_IDLE;
  40f864:	687b      	ldr	r3, [r7, #4]
  40f866:	2200      	movs	r2, #0
  40f868:	721a      	strb	r2, [r3, #8]
			udata.error = -1;
  40f86a:	f04f 33ff 	mov.w	r3, #4294967295
  40f86e:	60fb      	str	r3, [r7, #12]
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
  40f870:	68fa      	ldr	r2, [r7, #12]
  40f872:	2100      	movs	r1, #0
  40f874:	6878      	ldr	r0, [r7, #4]
  40f876:	4b29      	ldr	r3, [pc, #164]	; (40f91c <DynProTransportUart_rxProcessByte+0x138>)
  40f878:	4798      	blx	r3
			return -1;
  40f87a:	f04f 33ff 	mov.w	r3, #4294967295
  40f87e:	e044      	b.n	40f90a <DynProTransportUart_rxProcessByte+0x126>

	case RECEIVER_STATE_SIZE_BYTE_0:
		self->rx_expected_bytes = (uint16_t)rcv_byte;
  40f880:	78fb      	ldrb	r3, [r7, #3]
  40f882:	b29a      	uxth	r2, r3
  40f884:	687b      	ldr	r3, [r7, #4]
  40f886:	815a      	strh	r2, [r3, #10]
		self->rx_sm_state = RECEIVER_STATE_SIZE_BYTE_1;
  40f888:	687b      	ldr	r3, [r7, #4]
  40f88a:	2203      	movs	r2, #3
  40f88c:	721a      	strb	r2, [r3, #8]
		break;
  40f88e:	e03b      	b.n	40f908 <DynProTransportUart_rxProcessByte+0x124>

	case RECEIVER_STATE_SIZE_BYTE_1:
		self->rx_expected_bytes |= ((uint16_t)rcv_byte << 8U);
  40f890:	687b      	ldr	r3, [r7, #4]
  40f892:	895b      	ldrh	r3, [r3, #10]
  40f894:	b21a      	sxth	r2, r3
  40f896:	78fb      	ldrb	r3, [r7, #3]
  40f898:	021b      	lsls	r3, r3, #8
  40f89a:	b21b      	sxth	r3, r3
  40f89c:	4313      	orrs	r3, r2
  40f89e:	b21b      	sxth	r3, r3
  40f8a0:	b29a      	uxth	r2, r3
  40f8a2:	687b      	ldr	r3, [r7, #4]
  40f8a4:	815a      	strh	r2, [r3, #10]
		self->rx_received_bytes = 0;
  40f8a6:	687b      	ldr	r3, [r7, #4]
  40f8a8:	2200      	movs	r2, #0
  40f8aa:	819a      	strh	r2, [r3, #12]
		self->rx_sm_state = RECEIVER_STATE_PACKET_DATA;
  40f8ac:	687b      	ldr	r3, [r7, #4]
  40f8ae:	2204      	movs	r2, #4
  40f8b0:	721a      	strb	r2, [r3, #8]
		udata.pkt_size = self->rx_expected_bytes;
  40f8b2:	687b      	ldr	r3, [r7, #4]
  40f8b4:	895b      	ldrh	r3, [r3, #10]
  40f8b6:	81bb      	strh	r3, [r7, #12]
		DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_PKT_SIZE, udata);
  40f8b8:	68fa      	ldr	r2, [r7, #12]
  40f8ba:	2101      	movs	r1, #1
  40f8bc:	6878      	ldr	r0, [r7, #4]
  40f8be:	4b17      	ldr	r3, [pc, #92]	; (40f91c <DynProTransportUart_rxProcessByte+0x138>)
  40f8c0:	4798      	blx	r3
		return 1;
  40f8c2:	2301      	movs	r3, #1
  40f8c4:	e021      	b.n	40f90a <DynProTransportUart_rxProcessByte+0x126>

	case RECEIVER_STATE_PACKET_DATA:
		self->rx_received_bytes++;
  40f8c6:	687b      	ldr	r3, [r7, #4]
  40f8c8:	899b      	ldrh	r3, [r3, #12]
  40f8ca:	3301      	adds	r3, #1
  40f8cc:	b29a      	uxth	r2, r3
  40f8ce:	687b      	ldr	r3, [r7, #4]
  40f8d0:	819a      	strh	r2, [r3, #12]
		udata.pkt_size = rcv_byte;
  40f8d2:	78fb      	ldrb	r3, [r7, #3]
  40f8d4:	b29b      	uxth	r3, r3
  40f8d6:	81bb      	strh	r3, [r7, #12]
		DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_PKT_BYTE, udata);
  40f8d8:	68fa      	ldr	r2, [r7, #12]
  40f8da:	2102      	movs	r1, #2
  40f8dc:	6878      	ldr	r0, [r7, #4]
  40f8de:	4b0f      	ldr	r3, [pc, #60]	; (40f91c <DynProTransportUart_rxProcessByte+0x138>)
  40f8e0:	4798      	blx	r3
		if(self->rx_received_bytes == self->rx_expected_bytes) {
  40f8e2:	687b      	ldr	r3, [r7, #4]
  40f8e4:	899a      	ldrh	r2, [r3, #12]
  40f8e6:	687b      	ldr	r3, [r7, #4]
  40f8e8:	895b      	ldrh	r3, [r3, #10]
  40f8ea:	429a      	cmp	r2, r3
  40f8ec:	d10a      	bne.n	40f904 <DynProTransportUart_rxProcessByte+0x120>
			self->rx_sm_state = RECEIVER_STATE_IDLE;
  40f8ee:	687b      	ldr	r3, [r7, #4]
  40f8f0:	2200      	movs	r2, #0
  40f8f2:	721a      	strb	r2, [r3, #8]
			udata.pkt_size = self->rx_received_bytes;
  40f8f4:	687b      	ldr	r3, [r7, #4]
  40f8f6:	899b      	ldrh	r3, [r3, #12]
  40f8f8:	81bb      	strh	r3, [r7, #12]
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_PKT_END, udata);
  40f8fa:	68fa      	ldr	r2, [r7, #12]
  40f8fc:	2103      	movs	r1, #3
  40f8fe:	6878      	ldr	r0, [r7, #4]
  40f900:	4b06      	ldr	r3, [pc, #24]	; (40f91c <DynProTransportUart_rxProcessByte+0x138>)
  40f902:	4798      	blx	r3
		}
		return 1;
  40f904:	2301      	movs	r3, #1
  40f906:	e000      	b.n	40f90a <DynProTransportUart_rxProcessByte+0x126>
	}

	return 0;
  40f908:	2300      	movs	r3, #0
}
  40f90a:	4618      	mov	r0, r3
  40f90c:	3710      	adds	r7, #16
  40f90e:	46bd      	mov	sp, r7
  40f910:	bd80      	pop	{r7, pc}
  40f912:	bf00      	nop
  40f914:	0041d150 	.word	0x0041d150
  40f918:	0040ff51 	.word	0x0040ff51
  40f91c:	0040f789 	.word	0x0040f789
  40f920:	0041d188 	.word	0x0041d188

0040f924 <DynProTransportUart_tx>:
 *
 * @return      0 on sucess, negative value on error
 */
int DynProTransportUart_tx(DynProTransportUart_t * self,
	const uint8_t * buffer, uint16_t size)
{
  40f924:	b580      	push	{r7, lr}
  40f926:	b088      	sub	sp, #32
  40f928:	af00      	add	r7, sp, #0
  40f92a:	60f8      	str	r0, [r7, #12]
  40f92c:	60b9      	str	r1, [r7, #8]
  40f92e:	4613      	mov	r3, r2
  40f930:	80fb      	strh	r3, [r7, #6]
	union DynProTransportEventData udata;
	const uint32_t total_bytes = DYN_PRO_TRANSPORT_UART_OVERHEAD + size;
  40f932:	88fb      	ldrh	r3, [r7, #6]
  40f934:	3304      	adds	r3, #4
  40f936:	61bb      	str	r3, [r7, #24]
	uint16_t i;

	udata.tx_start = total_bytes;
  40f938:	69bb      	ldr	r3, [r7, #24]
  40f93a:	617b      	str	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_START, udata);
  40f93c:	697a      	ldr	r2, [r7, #20]
  40f93e:	2104      	movs	r1, #4
  40f940:	68f8      	ldr	r0, [r7, #12]
  40f942:	4b20      	ldr	r3, [pc, #128]	; (40f9c4 <DynProTransportUart_tx+0xa0>)
  40f944:	4798      	blx	r3
	udata.tx_byte = SYNC_BYTE_0;
  40f946:	2355      	movs	r3, #85	; 0x55
  40f948:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f94a:	697a      	ldr	r2, [r7, #20]
  40f94c:	2105      	movs	r1, #5
  40f94e:	68f8      	ldr	r0, [r7, #12]
  40f950:	4b1c      	ldr	r3, [pc, #112]	; (40f9c4 <DynProTransportUart_tx+0xa0>)
  40f952:	4798      	blx	r3
	udata.tx_byte = SYNC_BYTE_1;
  40f954:	23aa      	movs	r3, #170	; 0xaa
  40f956:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f958:	697a      	ldr	r2, [r7, #20]
  40f95a:	2105      	movs	r1, #5
  40f95c:	68f8      	ldr	r0, [r7, #12]
  40f95e:	4b19      	ldr	r3, [pc, #100]	; (40f9c4 <DynProTransportUart_tx+0xa0>)
  40f960:	4798      	blx	r3
	udata.tx_byte = (size & 0x00FF);
  40f962:	88fb      	ldrh	r3, [r7, #6]
  40f964:	b2db      	uxtb	r3, r3
  40f966:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f968:	697a      	ldr	r2, [r7, #20]
  40f96a:	2105      	movs	r1, #5
  40f96c:	68f8      	ldr	r0, [r7, #12]
  40f96e:	4b15      	ldr	r3, [pc, #84]	; (40f9c4 <DynProTransportUart_tx+0xa0>)
  40f970:	4798      	blx	r3
	udata.tx_byte = (size & 0xFF00) >> 8;
  40f972:	88fb      	ldrh	r3, [r7, #6]
  40f974:	0a1b      	lsrs	r3, r3, #8
  40f976:	b29b      	uxth	r3, r3
  40f978:	b2db      	uxtb	r3, r3
  40f97a:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f97c:	697a      	ldr	r2, [r7, #20]
  40f97e:	2105      	movs	r1, #5
  40f980:	68f8      	ldr	r0, [r7, #12]
  40f982:	4b10      	ldr	r3, [pc, #64]	; (40f9c4 <DynProTransportUart_tx+0xa0>)
  40f984:	4798      	blx	r3

	for(i = 0; i < size; ++i) {
  40f986:	2300      	movs	r3, #0
  40f988:	83fb      	strh	r3, [r7, #30]
  40f98a:	e00c      	b.n	40f9a6 <DynProTransportUart_tx+0x82>
		udata.tx_byte = buffer[i];
  40f98c:	8bfb      	ldrh	r3, [r7, #30]
  40f98e:	68ba      	ldr	r2, [r7, #8]
  40f990:	4413      	add	r3, r2
  40f992:	781b      	ldrb	r3, [r3, #0]
  40f994:	753b      	strb	r3, [r7, #20]
		DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f996:	697a      	ldr	r2, [r7, #20]
  40f998:	2105      	movs	r1, #5
  40f99a:	68f8      	ldr	r0, [r7, #12]
  40f99c:	4b09      	ldr	r3, [pc, #36]	; (40f9c4 <DynProTransportUart_tx+0xa0>)
  40f99e:	4798      	blx	r3
	for(i = 0; i < size; ++i) {
  40f9a0:	8bfb      	ldrh	r3, [r7, #30]
  40f9a2:	3301      	adds	r3, #1
  40f9a4:	83fb      	strh	r3, [r7, #30]
  40f9a6:	8bfa      	ldrh	r2, [r7, #30]
  40f9a8:	88fb      	ldrh	r3, [r7, #6]
  40f9aa:	429a      	cmp	r2, r3
  40f9ac:	d3ee      	bcc.n	40f98c <DynProTransportUart_tx+0x68>
	}

	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_END, udata);
  40f9ae:	697a      	ldr	r2, [r7, #20]
  40f9b0:	2106      	movs	r1, #6
  40f9b2:	68f8      	ldr	r0, [r7, #12]
  40f9b4:	4b03      	ldr	r3, [pc, #12]	; (40f9c4 <DynProTransportUart_tx+0xa0>)
  40f9b6:	4798      	blx	r3

	return 0;
  40f9b8:	2300      	movs	r3, #0
}
  40f9ba:	4618      	mov	r0, r3
  40f9bc:	3720      	adds	r7, #32
  40f9be:	46bd      	mov	sp, r7
  40f9c0:	bd80      	pop	{r7, pc}
  40f9c2:	bf00      	nop
  40f9c4:	0040f789 	.word	0x0040f789

0040f9c8 <inv_dc_int32_to_little8>:
 */

#include "DataConverter.h"

uint8_t * inv_dc_int32_to_little8(int32_t x, uint8_t * little8)
{
  40f9c8:	b480      	push	{r7}
  40f9ca:	b083      	sub	sp, #12
  40f9cc:	af00      	add	r7, sp, #0
  40f9ce:	6078      	str	r0, [r7, #4]
  40f9d0:	6039      	str	r1, [r7, #0]
	little8[3] = (uint8_t)((x >> 24) & 0xff);
  40f9d2:	683b      	ldr	r3, [r7, #0]
  40f9d4:	3303      	adds	r3, #3
  40f9d6:	687a      	ldr	r2, [r7, #4]
  40f9d8:	1612      	asrs	r2, r2, #24
  40f9da:	b2d2      	uxtb	r2, r2
  40f9dc:	701a      	strb	r2, [r3, #0]
	little8[2] = (uint8_t)((x >> 16) & 0xff);
  40f9de:	683b      	ldr	r3, [r7, #0]
  40f9e0:	3302      	adds	r3, #2
  40f9e2:	687a      	ldr	r2, [r7, #4]
  40f9e4:	1412      	asrs	r2, r2, #16
  40f9e6:	b2d2      	uxtb	r2, r2
  40f9e8:	701a      	strb	r2, [r3, #0]
	little8[1] = (uint8_t)((x >> 8) & 0xff);
  40f9ea:	683b      	ldr	r3, [r7, #0]
  40f9ec:	3301      	adds	r3, #1
  40f9ee:	687a      	ldr	r2, [r7, #4]
  40f9f0:	1212      	asrs	r2, r2, #8
  40f9f2:	b2d2      	uxtb	r2, r2
  40f9f4:	701a      	strb	r2, [r3, #0]
	little8[0] = (uint8_t)(x & 0xff);
  40f9f6:	687b      	ldr	r3, [r7, #4]
  40f9f8:	b2da      	uxtb	r2, r3
  40f9fa:	683b      	ldr	r3, [r7, #0]
  40f9fc:	701a      	strb	r2, [r3, #0]

	return little8;
  40f9fe:	683b      	ldr	r3, [r7, #0]
}
  40fa00:	4618      	mov	r0, r3
  40fa02:	370c      	adds	r7, #12
  40fa04:	46bd      	mov	sp, r7
  40fa06:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fa0a:	4770      	bx	lr

0040fa0c <inv_dc_int16_to_little8>:

uint8_t * inv_dc_int16_to_little8(int16_t x, uint8_t * little8)
{
  40fa0c:	b480      	push	{r7}
  40fa0e:	b083      	sub	sp, #12
  40fa10:	af00      	add	r7, sp, #0
  40fa12:	4603      	mov	r3, r0
  40fa14:	6039      	str	r1, [r7, #0]
  40fa16:	80fb      	strh	r3, [r7, #6]
	little8[0] = (uint8_t)(x & 0xff);
  40fa18:	88fb      	ldrh	r3, [r7, #6]
  40fa1a:	b2da      	uxtb	r2, r3
  40fa1c:	683b      	ldr	r3, [r7, #0]
  40fa1e:	701a      	strb	r2, [r3, #0]
	little8[1] = (uint8_t)((x >> 8) & 0xff);
  40fa20:	683b      	ldr	r3, [r7, #0]
  40fa22:	3301      	adds	r3, #1
  40fa24:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
  40fa28:	1212      	asrs	r2, r2, #8
  40fa2a:	b212      	sxth	r2, r2
  40fa2c:	b2d2      	uxtb	r2, r2
  40fa2e:	701a      	strb	r2, [r3, #0]

	return little8;
  40fa30:	683b      	ldr	r3, [r7, #0]
}
  40fa32:	4618      	mov	r0, r3
  40fa34:	370c      	adds	r7, #12
  40fa36:	46bd      	mov	sp, r7
  40fa38:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fa3c:	4770      	bx	lr

0040fa3e <inv_dc_little8_to_int32>:

	return big8;
}

int32_t inv_dc_little8_to_int32(const uint8_t * little8)
{
  40fa3e:	b480      	push	{r7}
  40fa40:	b085      	sub	sp, #20
  40fa42:	af00      	add	r7, sp, #0
  40fa44:	6078      	str	r0, [r7, #4]
	int32_t x = 0;
  40fa46:	2300      	movs	r3, #0
  40fa48:	60fb      	str	r3, [r7, #12]

	x |= ((int32_t)little8[3] << 24);
  40fa4a:	687b      	ldr	r3, [r7, #4]
  40fa4c:	3303      	adds	r3, #3
  40fa4e:	781b      	ldrb	r3, [r3, #0]
  40fa50:	061b      	lsls	r3, r3, #24
  40fa52:	68fa      	ldr	r2, [r7, #12]
  40fa54:	4313      	orrs	r3, r2
  40fa56:	60fb      	str	r3, [r7, #12]
	x |= ((int32_t)little8[2] << 16);
  40fa58:	687b      	ldr	r3, [r7, #4]
  40fa5a:	3302      	adds	r3, #2
  40fa5c:	781b      	ldrb	r3, [r3, #0]
  40fa5e:	041b      	lsls	r3, r3, #16
  40fa60:	68fa      	ldr	r2, [r7, #12]
  40fa62:	4313      	orrs	r3, r2
  40fa64:	60fb      	str	r3, [r7, #12]
	x |= ((int32_t)little8[1] << 8);
  40fa66:	687b      	ldr	r3, [r7, #4]
  40fa68:	3301      	adds	r3, #1
  40fa6a:	781b      	ldrb	r3, [r3, #0]
  40fa6c:	021b      	lsls	r3, r3, #8
  40fa6e:	68fa      	ldr	r2, [r7, #12]
  40fa70:	4313      	orrs	r3, r2
  40fa72:	60fb      	str	r3, [r7, #12]
	x |= ((int32_t)little8[0]);
  40fa74:	687b      	ldr	r3, [r7, #4]
  40fa76:	781b      	ldrb	r3, [r3, #0]
  40fa78:	461a      	mov	r2, r3
  40fa7a:	68fb      	ldr	r3, [r7, #12]
  40fa7c:	4313      	orrs	r3, r2
  40fa7e:	60fb      	str	r3, [r7, #12]

	return x;
  40fa80:	68fb      	ldr	r3, [r7, #12]
}
  40fa82:	4618      	mov	r0, r3
  40fa84:	3714      	adds	r7, #20
  40fa86:	46bd      	mov	sp, r7
  40fa88:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fa8c:	4770      	bx	lr

0040fa8e <inv_dc_le_to_int16>:

	return result;
}

int16_t inv_dc_le_to_int16(const uint8_t * little8)
{
  40fa8e:	b480      	push	{r7}
  40fa90:	b085      	sub	sp, #20
  40fa92:	af00      	add	r7, sp, #0
  40fa94:	6078      	str	r0, [r7, #4]
	uint16_t x = 0;
  40fa96:	2300      	movs	r3, #0
  40fa98:	81fb      	strh	r3, [r7, #14]

	x |= ((uint16_t)little8[0]);
  40fa9a:	687b      	ldr	r3, [r7, #4]
  40fa9c:	781b      	ldrb	r3, [r3, #0]
  40fa9e:	b29a      	uxth	r2, r3
  40faa0:	89fb      	ldrh	r3, [r7, #14]
  40faa2:	4313      	orrs	r3, r2
  40faa4:	81fb      	strh	r3, [r7, #14]
	x |= ((uint16_t)little8[1] << 8);
  40faa6:	687b      	ldr	r3, [r7, #4]
  40faa8:	3301      	adds	r3, #1
  40faaa:	781b      	ldrb	r3, [r3, #0]
  40faac:	021b      	lsls	r3, r3, #8
  40faae:	b21a      	sxth	r2, r3
  40fab0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
  40fab4:	4313      	orrs	r3, r2
  40fab6:	b21b      	sxth	r3, r3
  40fab8:	81fb      	strh	r3, [r7, #14]

	return (int16_t)x;
  40faba:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
  40fabe:	4618      	mov	r0, r3
  40fac0:	3714      	adds	r7, #20
  40fac2:	46bd      	mov	sp, r7
  40fac4:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fac8:	4770      	bx	lr

0040faca <inv_dc_float_to_sfix32>:
		out[i] = (float)in[i] / (1 << qx);
	}
}

void inv_dc_float_to_sfix32(const float * in, uint32_t len, uint8_t qx, int32_t * out)
{
  40faca:	b480      	push	{r7}
  40facc:	b087      	sub	sp, #28
  40face:	af00      	add	r7, sp, #0
  40fad0:	60f8      	str	r0, [r7, #12]
  40fad2:	60b9      	str	r1, [r7, #8]
  40fad4:	603b      	str	r3, [r7, #0]
  40fad6:	4613      	mov	r3, r2
  40fad8:	71fb      	strb	r3, [r7, #7]
	uint8_t i;

	for(i = 0; i < len; ++i) {
  40fada:	2300      	movs	r3, #0
  40fadc:	75fb      	strb	r3, [r7, #23]
  40fade:	e02d      	b.n	40fb3c <inv_dc_float_to_sfix32+0x72>
		out[i] = (int32_t)((in[i] * (1 << qx)) + ((in[i] >= 0) - 0.5f));
  40fae0:	7dfb      	ldrb	r3, [r7, #23]
  40fae2:	009b      	lsls	r3, r3, #2
  40fae4:	683a      	ldr	r2, [r7, #0]
  40fae6:	4413      	add	r3, r2
  40fae8:	7dfa      	ldrb	r2, [r7, #23]
  40faea:	0092      	lsls	r2, r2, #2
  40faec:	68f9      	ldr	r1, [r7, #12]
  40faee:	440a      	add	r2, r1
  40faf0:	ed92 7a00 	vldr	s14, [r2]
  40faf4:	79fa      	ldrb	r2, [r7, #7]
  40faf6:	2101      	movs	r1, #1
  40faf8:	fa01 f202 	lsl.w	r2, r1, r2
  40fafc:	ee07 2a90 	vmov	s15, r2
  40fb00:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40fb04:	ee27 7a27 	vmul.f32	s14, s14, s15
  40fb08:	7dfa      	ldrb	r2, [r7, #23]
  40fb0a:	0092      	lsls	r2, r2, #2
  40fb0c:	68f9      	ldr	r1, [r7, #12]
  40fb0e:	440a      	add	r2, r1
  40fb10:	edd2 7a00 	vldr	s15, [r2]
  40fb14:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40fb18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40fb1c:	db02      	blt.n	40fb24 <inv_dc_float_to_sfix32+0x5a>
  40fb1e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40fb22:	e001      	b.n	40fb28 <inv_dc_float_to_sfix32+0x5e>
  40fb24:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40fb28:	ee77 7a27 	vadd.f32	s15, s14, s15
  40fb2c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40fb30:	ee17 2a90 	vmov	r2, s15
  40fb34:	601a      	str	r2, [r3, #0]
	for(i = 0; i < len; ++i) {
  40fb36:	7dfb      	ldrb	r3, [r7, #23]
  40fb38:	3301      	adds	r3, #1
  40fb3a:	75fb      	strb	r3, [r7, #23]
  40fb3c:	7dfa      	ldrb	r2, [r7, #23]
  40fb3e:	68bb      	ldr	r3, [r7, #8]
  40fb40:	429a      	cmp	r2, r3
  40fb42:	d3cd      	bcc.n	40fae0 <inv_dc_float_to_sfix32+0x16>
	}
}
  40fb44:	bf00      	nop
  40fb46:	371c      	adds	r7, #28
  40fb48:	46bd      	mov	sp, r7
  40fb4a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fb4e:	4770      	bx	lr

0040fb50 <inv_error_str>:
 */

#include "ErrorHelper.h"

const char * inv_error_str(int error)
{
  40fb50:	b480      	push	{r7}
  40fb52:	b083      	sub	sp, #12
  40fb54:	af00      	add	r7, sp, #0
  40fb56:	6078      	str	r0, [r7, #4]
	switch(error) {
  40fb58:	687b      	ldr	r3, [r7, #4]
  40fb5a:	3311      	adds	r3, #17
  40fb5c:	2b11      	cmp	r3, #17
  40fb5e:	d849      	bhi.n	40fbf4 <inv_error_str+0xa4>
  40fb60:	a201      	add	r2, pc, #4	; (adr r2, 40fb68 <inv_error_str+0x18>)
  40fb62:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40fb66:	bf00      	nop
  40fb68:	0040fbf1 	.word	0x0040fbf1
  40fb6c:	0040fbed 	.word	0x0040fbed
  40fb70:	0040fbe9 	.word	0x0040fbe9
  40fb74:	0040fbe5 	.word	0x0040fbe5
  40fb78:	0040fbe1 	.word	0x0040fbe1
  40fb7c:	0040fbdd 	.word	0x0040fbdd
  40fb80:	0040fbd9 	.word	0x0040fbd9
  40fb84:	0040fbd5 	.word	0x0040fbd5
  40fb88:	0040fbd1 	.word	0x0040fbd1
  40fb8c:	0040fbf5 	.word	0x0040fbf5
  40fb90:	0040fbcd 	.word	0x0040fbcd
  40fb94:	0040fbc9 	.word	0x0040fbc9
  40fb98:	0040fbc5 	.word	0x0040fbc5
  40fb9c:	0040fbc1 	.word	0x0040fbc1
  40fba0:	0040fbbd 	.word	0x0040fbbd
  40fba4:	0040fbb9 	.word	0x0040fbb9
  40fba8:	0040fbb5 	.word	0x0040fbb5
  40fbac:	0040fbb1 	.word	0x0040fbb1
	case INV_ERROR_SUCCESS:      return "Success";
  40fbb0:	4b14      	ldr	r3, [pc, #80]	; (40fc04 <inv_error_str+0xb4>)
  40fbb2:	e020      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR:              return "Unspecified error";
  40fbb4:	4b14      	ldr	r3, [pc, #80]	; (40fc08 <inv_error_str+0xb8>)
  40fbb6:	e01e      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_NIMPL:        return "Not implemented";
  40fbb8:	4b14      	ldr	r3, [pc, #80]	; (40fc0c <inv_error_str+0xbc>)
  40fbba:	e01c      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_TRANSPORT:    return "Transport error";
  40fbbc:	4b14      	ldr	r3, [pc, #80]	; (40fc10 <inv_error_str+0xc0>)
  40fbbe:	e01a      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_TIMEOUT:      return "Timeout, action did not complete in time";
  40fbc0:	4b14      	ldr	r3, [pc, #80]	; (40fc14 <inv_error_str+0xc4>)
  40fbc2:	e018      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_SIZE:         return "Wrong size error";
  40fbc4:	4b14      	ldr	r3, [pc, #80]	; (40fc18 <inv_error_str+0xc8>)
  40fbc6:	e016      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_OS:           return "Operating system failure";
  40fbc8:	4b14      	ldr	r3, [pc, #80]	; (40fc1c <inv_error_str+0xcc>)
  40fbca:	e014      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_IO:           return "Input/Output error";
  40fbcc:	4b14      	ldr	r3, [pc, #80]	; (40fc20 <inv_error_str+0xd0>)
  40fbce:	e012      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_MEM: 		 return "Bad allocation";
  40fbd0:	4b14      	ldr	r3, [pc, #80]	; (40fc24 <inv_error_str+0xd4>)
  40fbd2:	e010      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_HW:           return "Hardware error";
  40fbd4:	4b14      	ldr	r3, [pc, #80]	; (40fc28 <inv_error_str+0xd8>)
  40fbd6:	e00e      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_BAD_ARG:      return "Invalid arguments";
  40fbd8:	4b14      	ldr	r3, [pc, #80]	; (40fc2c <inv_error_str+0xdc>)
  40fbda:	e00c      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_UNEXPECTED:   return "Unexpected error";
  40fbdc:	4b14      	ldr	r3, [pc, #80]	; (40fc30 <inv_error_str+0xe0>)
  40fbde:	e00a      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_FILE:         return "Invalid file format";
  40fbe0:	4b14      	ldr	r3, [pc, #80]	; (40fc34 <inv_error_str+0xe4>)
  40fbe2:	e008      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_PATH:         return "Invalid file path";
  40fbe4:	4b14      	ldr	r3, [pc, #80]	; (40fc38 <inv_error_str+0xe8>)
  40fbe6:	e006      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_IMAGE_TYPE:   return "Unknown image type";
  40fbe8:	4b14      	ldr	r3, [pc, #80]	; (40fc3c <inv_error_str+0xec>)
  40fbea:	e004      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_WATCHDOG:     return "Watchdog error";
  40fbec:	4b14      	ldr	r3, [pc, #80]	; (40fc40 <inv_error_str+0xf0>)
  40fbee:	e002      	b.n	40fbf6 <inv_error_str+0xa6>
	case INV_ERROR_FIFO_OVERFLOW: return "FIFO overflow error";
  40fbf0:	4b14      	ldr	r3, [pc, #80]	; (40fc44 <inv_error_str+0xf4>)
  40fbf2:	e000      	b.n	40fbf6 <inv_error_str+0xa6>
	default:                     return "Unknown error";
  40fbf4:	4b14      	ldr	r3, [pc, #80]	; (40fc48 <inv_error_str+0xf8>)
	}
  40fbf6:	4618      	mov	r0, r3
  40fbf8:	370c      	adds	r7, #12
  40fbfa:	46bd      	mov	sp, r7
  40fbfc:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fc00:	4770      	bx	lr
  40fc02:	bf00      	nop
  40fc04:	0041d1c0 	.word	0x0041d1c0
  40fc08:	0041d1c8 	.word	0x0041d1c8
  40fc0c:	0041d1dc 	.word	0x0041d1dc
  40fc10:	0041d1ec 	.word	0x0041d1ec
  40fc14:	0041d1fc 	.word	0x0041d1fc
  40fc18:	0041d228 	.word	0x0041d228
  40fc1c:	0041d23c 	.word	0x0041d23c
  40fc20:	0041d258 	.word	0x0041d258
  40fc24:	0041d26c 	.word	0x0041d26c
  40fc28:	0041d27c 	.word	0x0041d27c
  40fc2c:	0041d28c 	.word	0x0041d28c
  40fc30:	0041d2a0 	.word	0x0041d2a0
  40fc34:	0041d2b4 	.word	0x0041d2b4
  40fc38:	0041d2c8 	.word	0x0041d2c8
  40fc3c:	0041d2dc 	.word	0x0041d2dc
  40fc40:	0041d2f0 	.word	0x0041d2f0
  40fc44:	0041d300 	.word	0x0041d300
  40fc48:	0041d314 	.word	0x0041d314

0040fc4c <InvScheduler_insertTask>:

#include "InvScheduler.h"

static void InvScheduler_insertTask(InvScheduler * scheduler,
		InvSchedulerTask *task)
{
  40fc4c:	b480      	push	{r7}
  40fc4e:	b083      	sub	sp, #12
  40fc50:	af00      	add	r7, sp, #0
  40fc52:	6078      	str	r0, [r7, #4]
  40fc54:	6039      	str	r1, [r7, #0]
	if(scheduler->queue == 0) {
  40fc56:	687b      	ldr	r3, [r7, #4]
  40fc58:	685b      	ldr	r3, [r3, #4]
  40fc5a:	2b00      	cmp	r3, #0
  40fc5c:	d109      	bne.n	40fc72 <InvScheduler_insertTask+0x26>
		task->prev = task;
  40fc5e:	683b      	ldr	r3, [r7, #0]
  40fc60:	683a      	ldr	r2, [r7, #0]
  40fc62:	621a      	str	r2, [r3, #32]
		task->next = 0;
  40fc64:	683b      	ldr	r3, [r7, #0]
  40fc66:	2200      	movs	r2, #0
  40fc68:	61da      	str	r2, [r3, #28]
		scheduler->queue = task;
  40fc6a:	687b      	ldr	r3, [r7, #4]
  40fc6c:	683a      	ldr	r2, [r7, #0]
  40fc6e:	605a      	str	r2, [r3, #4]
		task->prev = scheduler->queue->prev;
		task->next = 0;
		scheduler->queue->prev->next = task;
		scheduler->queue->prev       = task;
	}
}
  40fc70:	e010      	b.n	40fc94 <InvScheduler_insertTask+0x48>
		task->prev = scheduler->queue->prev;
  40fc72:	687b      	ldr	r3, [r7, #4]
  40fc74:	685b      	ldr	r3, [r3, #4]
  40fc76:	6a1a      	ldr	r2, [r3, #32]
  40fc78:	683b      	ldr	r3, [r7, #0]
  40fc7a:	621a      	str	r2, [r3, #32]
		task->next = 0;
  40fc7c:	683b      	ldr	r3, [r7, #0]
  40fc7e:	2200      	movs	r2, #0
  40fc80:	61da      	str	r2, [r3, #28]
		scheduler->queue->prev->next = task;
  40fc82:	687b      	ldr	r3, [r7, #4]
  40fc84:	685b      	ldr	r3, [r3, #4]
  40fc86:	6a1b      	ldr	r3, [r3, #32]
  40fc88:	683a      	ldr	r2, [r7, #0]
  40fc8a:	61da      	str	r2, [r3, #28]
		scheduler->queue->prev       = task;
  40fc8c:	687b      	ldr	r3, [r7, #4]
  40fc8e:	685b      	ldr	r3, [r3, #4]
  40fc90:	683a      	ldr	r2, [r7, #0]
  40fc92:	621a      	str	r2, [r3, #32]
}
  40fc94:	bf00      	nop
  40fc96:	370c      	adds	r7, #12
  40fc98:	46bd      	mov	sp, r7
  40fc9a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fc9e:	4770      	bx	lr

0040fca0 <InvScheduler_removeTask>:

static inline void InvScheduler_removeTask(InvScheduler * scheduler,
		InvSchedulerTask *task)
{
  40fca0:	b480      	push	{r7}
  40fca2:	b083      	sub	sp, #12
  40fca4:	af00      	add	r7, sp, #0
  40fca6:	6078      	str	r0, [r7, #4]
  40fca8:	6039      	str	r1, [r7, #0]
	if(scheduler->queue == task) {
  40fcaa:	687b      	ldr	r3, [r7, #4]
  40fcac:	685a      	ldr	r2, [r3, #4]
  40fcae:	683b      	ldr	r3, [r7, #0]
  40fcb0:	429a      	cmp	r2, r3
  40fcb2:	d104      	bne.n	40fcbe <InvScheduler_removeTask+0x1e>
		scheduler->queue = task->next;
  40fcb4:	683b      	ldr	r3, [r7, #0]
  40fcb6:	69da      	ldr	r2, [r3, #28]
  40fcb8:	687b      	ldr	r3, [r7, #4]
  40fcba:	605a      	str	r2, [r3, #4]
  40fcbc:	e00f      	b.n	40fcde <InvScheduler_removeTask+0x3e>
	} else {
		if(scheduler->queue->prev == task)
  40fcbe:	687b      	ldr	r3, [r7, #4]
  40fcc0:	685b      	ldr	r3, [r3, #4]
  40fcc2:	6a1a      	ldr	r2, [r3, #32]
  40fcc4:	683b      	ldr	r3, [r7, #0]
  40fcc6:	429a      	cmp	r2, r3
  40fcc8:	d104      	bne.n	40fcd4 <InvScheduler_removeTask+0x34>
			scheduler->queue->prev = task->prev;
  40fcca:	687b      	ldr	r3, [r7, #4]
  40fccc:	685b      	ldr	r3, [r3, #4]
  40fcce:	683a      	ldr	r2, [r7, #0]
  40fcd0:	6a12      	ldr	r2, [r2, #32]
  40fcd2:	621a      	str	r2, [r3, #32]
		task->prev->next = task->next;
  40fcd4:	683b      	ldr	r3, [r7, #0]
  40fcd6:	6a1b      	ldr	r3, [r3, #32]
  40fcd8:	683a      	ldr	r2, [r7, #0]
  40fcda:	69d2      	ldr	r2, [r2, #28]
  40fcdc:	61da      	str	r2, [r3, #28]
	}
	if(task->next)
  40fcde:	683b      	ldr	r3, [r7, #0]
  40fce0:	69db      	ldr	r3, [r3, #28]
  40fce2:	2b00      	cmp	r3, #0
  40fce4:	d004      	beq.n	40fcf0 <InvScheduler_removeTask+0x50>
		task->next->prev = task->prev;
  40fce6:	683b      	ldr	r3, [r7, #0]
  40fce8:	69db      	ldr	r3, [r3, #28]
  40fcea:	683a      	ldr	r2, [r7, #0]
  40fcec:	6a12      	ldr	r2, [r2, #32]
  40fcee:	621a      	str	r2, [r3, #32]
}
  40fcf0:	bf00      	nop
  40fcf2:	370c      	adds	r7, #12
  40fcf4:	46bd      	mov	sp, r7
  40fcf6:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fcfa:	4770      	bx	lr

0040fcfc <InvScheduler_getTaskToSchedule>:

static InvSchedulerTask * InvScheduler_getTaskToSchedule(InvScheduler * scheduler,
		uint32_t now)
{
  40fcfc:	b480      	push	{r7}
  40fcfe:	b089      	sub	sp, #36	; 0x24
  40fd00:	af00      	add	r7, sp, #0
  40fd02:	6078      	str	r0, [r7, #4]
  40fd04:	6039      	str	r1, [r7, #0]
	InvSchedulerTask * cur  = scheduler->queue;
  40fd06:	687b      	ldr	r3, [r7, #4]
  40fd08:	685b      	ldr	r3, [r3, #4]
  40fd0a:	61fb      	str	r3, [r7, #28]
	InvSchedulerTask * task = 0;
  40fd0c:	2300      	movs	r3, #0
  40fd0e:	61bb      	str	r3, [r7, #24]
	uint32_t           max_diff = 0;
  40fd10:	2300      	movs	r3, #0
  40fd12:	617b      	str	r3, [r7, #20]

	while(cur) {
  40fd14:	e043      	b.n	40fd9e <InvScheduler_getTaskToSchedule+0xa2>
		const uint32_t timeout = (cur->delay != 0) ? cur->delay : cur->period;
  40fd16:	69fb      	ldr	r3, [r7, #28]
  40fd18:	695b      	ldr	r3, [r3, #20]
  40fd1a:	2b00      	cmp	r3, #0
  40fd1c:	d002      	beq.n	40fd24 <InvScheduler_getTaskToSchedule+0x28>
  40fd1e:	69fb      	ldr	r3, [r7, #28]
  40fd20:	695b      	ldr	r3, [r3, #20]
  40fd22:	e001      	b.n	40fd28 <InvScheduler_getTaskToSchedule+0x2c>
  40fd24:	69fb      	ldr	r3, [r7, #28]
  40fd26:	691b      	ldr	r3, [r3, #16]
  40fd28:	613b      	str	r3, [r7, #16]
		uint32_t elpased;

		/* initalize task states after it was started */
		if(cur->state == INVSCHEDULER_TASK_STATE_STARTED) {
  40fd2a:	69fb      	ldr	r3, [r7, #28]
  40fd2c:	7a5b      	ldrb	r3, [r3, #9]
  40fd2e:	2b01      	cmp	r3, #1
  40fd30:	d110      	bne.n	40fd54 <InvScheduler_getTaskToSchedule+0x58>
			cur->state    = INVSCHEDULER_TASK_STATE_READY;
  40fd32:	69fb      	ldr	r3, [r7, #28]
  40fd34:	2202      	movs	r2, #2
  40fd36:	725a      	strb	r2, [r3, #9]
			cur->lasttime = now;
  40fd38:	69fb      	ldr	r3, [r7, #28]
  40fd3a:	683a      	ldr	r2, [r7, #0]
  40fd3c:	60da      	str	r2, [r3, #12]

			if(cur->delay == 0) {
  40fd3e:	69fb      	ldr	r3, [r7, #28]
  40fd40:	695b      	ldr	r3, [r3, #20]
  40fd42:	2b00      	cmp	r3, #0
  40fd44:	d106      	bne.n	40fd54 <InvScheduler_getTaskToSchedule+0x58>
				cur->lasttime -= cur->period; /* ensure task is run ASAP */
  40fd46:	69fb      	ldr	r3, [r7, #28]
  40fd48:	68da      	ldr	r2, [r3, #12]
  40fd4a:	69fb      	ldr	r3, [r7, #28]
  40fd4c:	691b      	ldr	r3, [r3, #16]
  40fd4e:	1ad2      	subs	r2, r2, r3
  40fd50:	69fb      	ldr	r3, [r7, #28]
  40fd52:	60da      	str	r2, [r3, #12]
			}
		}

		elpased = (now - cur->lasttime);
  40fd54:	69fb      	ldr	r3, [r7, #28]
  40fd56:	68db      	ldr	r3, [r3, #12]
  40fd58:	683a      	ldr	r2, [r7, #0]
  40fd5a:	1ad3      	subs	r3, r2, r3
  40fd5c:	60fb      	str	r3, [r7, #12]

		/* check timeout against elpased time */
		if(elpased >= timeout) {
  40fd5e:	68fa      	ldr	r2, [r7, #12]
  40fd60:	693b      	ldr	r3, [r7, #16]
  40fd62:	429a      	cmp	r2, r3
  40fd64:	d318      	bcc.n	40fd98 <InvScheduler_getTaskToSchedule+0x9c>
			const uint32_t diff = (elpased - timeout);
  40fd66:	68fa      	ldr	r2, [r7, #12]
  40fd68:	693b      	ldr	r3, [r7, #16]
  40fd6a:	1ad3      	subs	r3, r2, r3
  40fd6c:	60bb      	str	r3, [r7, #8]

			if(task == 0 || diff > max_diff ||
  40fd6e:	69bb      	ldr	r3, [r7, #24]
  40fd70:	2b00      	cmp	r3, #0
  40fd72:	d00d      	beq.n	40fd90 <InvScheduler_getTaskToSchedule+0x94>
  40fd74:	68ba      	ldr	r2, [r7, #8]
  40fd76:	697b      	ldr	r3, [r7, #20]
  40fd78:	429a      	cmp	r2, r3
  40fd7a:	d809      	bhi.n	40fd90 <InvScheduler_getTaskToSchedule+0x94>
  40fd7c:	68ba      	ldr	r2, [r7, #8]
  40fd7e:	697b      	ldr	r3, [r7, #20]
  40fd80:	429a      	cmp	r2, r3
  40fd82:	d109      	bne.n	40fd98 <InvScheduler_getTaskToSchedule+0x9c>
					(diff == max_diff && cur->priority > task->priority)) {
  40fd84:	69fb      	ldr	r3, [r7, #28]
  40fd86:	7a1a      	ldrb	r2, [r3, #8]
  40fd88:	69bb      	ldr	r3, [r7, #24]
  40fd8a:	7a1b      	ldrb	r3, [r3, #8]
  40fd8c:	429a      	cmp	r2, r3
  40fd8e:	d903      	bls.n	40fd98 <InvScheduler_getTaskToSchedule+0x9c>
				task = cur;
  40fd90:	69fb      	ldr	r3, [r7, #28]
  40fd92:	61bb      	str	r3, [r7, #24]
				max_diff = diff;
  40fd94:	68bb      	ldr	r3, [r7, #8]
  40fd96:	617b      	str	r3, [r7, #20]
			}
		}

		cur = cur->next;
  40fd98:	69fb      	ldr	r3, [r7, #28]
  40fd9a:	69db      	ldr	r3, [r3, #28]
  40fd9c:	61fb      	str	r3, [r7, #28]
	while(cur) {
  40fd9e:	69fb      	ldr	r3, [r7, #28]
  40fda0:	2b00      	cmp	r3, #0
  40fda2:	d1b8      	bne.n	40fd16 <InvScheduler_getTaskToSchedule+0x1a>
	}

	return task;
  40fda4:	69bb      	ldr	r3, [r7, #24]
}
  40fda6:	4618      	mov	r0, r3
  40fda8:	3724      	adds	r7, #36	; 0x24
  40fdaa:	46bd      	mov	sp, r7
  40fdac:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fdb0:	4770      	bx	lr
	...

0040fdb4 <InvScheduler_dispatchOneTask>:

	return UINT32_MAX;
}

int InvScheduler_dispatchOneTask(InvScheduler *scheduler)
{
  40fdb4:	b580      	push	{r7, lr}
  40fdb6:	b086      	sub	sp, #24
  40fdb8:	af00      	add	r7, sp, #0
  40fdba:	6078      	str	r0, [r7, #4]
	int run = 0;
  40fdbc:	2300      	movs	r3, #0
  40fdbe:	617b      	str	r3, [r7, #20]
	const uint32_t now = scheduler->currentTime;
  40fdc0:	687b      	ldr	r3, [r7, #4]
  40fdc2:	681b      	ldr	r3, [r3, #0]
  40fdc4:	613b      	str	r3, [r7, #16]
	InvSchedulerTask * task;

	InvScheduler_lock(scheduler->contextLock);

	task = InvScheduler_getTaskToSchedule(scheduler, now);
  40fdc6:	6939      	ldr	r1, [r7, #16]
  40fdc8:	6878      	ldr	r0, [r7, #4]
  40fdca:	4b15      	ldr	r3, [pc, #84]	; (40fe20 <InvScheduler_dispatchOneTask+0x6c>)
  40fdcc:	4798      	blx	r3
  40fdce:	60f8      	str	r0, [r7, #12]

	if(task) {
  40fdd0:	68fb      	ldr	r3, [r7, #12]
  40fdd2:	2b00      	cmp	r3, #0
  40fdd4:	d01f      	beq.n	40fe16 <InvScheduler_dispatchOneTask+0x62>
		/* update lastime and task state */
		task->delay    = 0; /* clear delay */
  40fdd6:	68fb      	ldr	r3, [r7, #12]
  40fdd8:	2200      	movs	r2, #0
  40fdda:	615a      	str	r2, [r3, #20]
		task->lasttime = now;
  40fddc:	68fb      	ldr	r3, [r7, #12]
  40fdde:	693a      	ldr	r2, [r7, #16]
  40fde0:	60da      	str	r2, [r3, #12]
		task->state    = INVSCHEDULER_TASK_STATE_RUNNING;
  40fde2:	68fb      	ldr	r3, [r7, #12]
  40fde4:	2203      	movs	r2, #3
  40fde6:	725a      	strb	r2, [r3, #9]

		InvScheduler_removeTask(scheduler, task);
  40fde8:	68f9      	ldr	r1, [r7, #12]
  40fdea:	6878      	ldr	r0, [r7, #4]
  40fdec:	4b0d      	ldr	r3, [pc, #52]	; (40fe24 <InvScheduler_dispatchOneTask+0x70>)
  40fdee:	4798      	blx	r3

		InvScheduler_unlock(scheduler->contextLock);
		InvScheduler_onTaskEnterHook(task, scheduler->currentTime);
		task->func(task->arg); /* execute the task */
  40fdf0:	68fb      	ldr	r3, [r7, #12]
  40fdf2:	681b      	ldr	r3, [r3, #0]
  40fdf4:	68fa      	ldr	r2, [r7, #12]
  40fdf6:	6852      	ldr	r2, [r2, #4]
  40fdf8:	4610      	mov	r0, r2
  40fdfa:	4798      	blx	r3
		InvScheduler_onTaskExitHook(task, scheduler->currentTime);
		InvScheduler_lock(scheduler->contextLock);

		/* schedule task for next period */
		if(task->state == INVSCHEDULER_TASK_STATE_RUNNING) {
  40fdfc:	68fb      	ldr	r3, [r7, #12]
  40fdfe:	7a5b      	ldrb	r3, [r3, #9]
  40fe00:	2b03      	cmp	r3, #3
  40fe02:	d106      	bne.n	40fe12 <InvScheduler_dispatchOneTask+0x5e>
			task->state = INVSCHEDULER_TASK_STATE_READY;
  40fe04:	68fb      	ldr	r3, [r7, #12]
  40fe06:	2202      	movs	r2, #2
  40fe08:	725a      	strb	r2, [r3, #9]
			InvScheduler_insertTask(scheduler, task);
  40fe0a:	68f9      	ldr	r1, [r7, #12]
  40fe0c:	6878      	ldr	r0, [r7, #4]
  40fe0e:	4b06      	ldr	r3, [pc, #24]	; (40fe28 <InvScheduler_dispatchOneTask+0x74>)
  40fe10:	4798      	blx	r3
		}

		run = 1;
  40fe12:	2301      	movs	r3, #1
  40fe14:	617b      	str	r3, [r7, #20]
	}

	InvScheduler_unlock(scheduler->contextLock);

	return run;
  40fe16:	697b      	ldr	r3, [r7, #20]
}
  40fe18:	4618      	mov	r0, r3
  40fe1a:	3718      	adds	r7, #24
  40fe1c:	46bd      	mov	sp, r7
  40fe1e:	bd80      	pop	{r7, pc}
  40fe20:	0040fcfd 	.word	0x0040fcfd
  40fe24:	0040fca1 	.word	0x0040fca1
  40fe28:	0040fc4d 	.word	0x0040fc4d

0040fe2c <InvScheduler_dispatchTasks>:

int InvScheduler_dispatchTasks(InvScheduler *scheduler)
{
  40fe2c:	b580      	push	{r7, lr}
  40fe2e:	b084      	sub	sp, #16
  40fe30:	af00      	add	r7, sp, #0
  40fe32:	6078      	str	r0, [r7, #4]
	int count = 0;
  40fe34:	2300      	movs	r3, #0
  40fe36:	60fb      	str	r3, [r7, #12]

	while(InvScheduler_dispatchOneTask(scheduler))
  40fe38:	e002      	b.n	40fe40 <InvScheduler_dispatchTasks+0x14>
		++count;
  40fe3a:	68fb      	ldr	r3, [r7, #12]
  40fe3c:	3301      	adds	r3, #1
  40fe3e:	60fb      	str	r3, [r7, #12]
	while(InvScheduler_dispatchOneTask(scheduler))
  40fe40:	6878      	ldr	r0, [r7, #4]
  40fe42:	4b05      	ldr	r3, [pc, #20]	; (40fe58 <InvScheduler_dispatchTasks+0x2c>)
  40fe44:	4798      	blx	r3
  40fe46:	4603      	mov	r3, r0
  40fe48:	2b00      	cmp	r3, #0
  40fe4a:	d1f6      	bne.n	40fe3a <InvScheduler_dispatchTasks+0xe>

	return count;
  40fe4c:	68fb      	ldr	r3, [r7, #12]
}
  40fe4e:	4618      	mov	r0, r3
  40fe50:	3710      	adds	r7, #16
  40fe52:	46bd      	mov	sp, r7
  40fe54:	bd80      	pop	{r7, pc}
  40fe56:	bf00      	nop
  40fe58:	0040fdb5 	.word	0x0040fdb5

0040fe5c <InvScheduler_initTaskDo>:

void InvScheduler_initTaskDo(InvScheduler *scheduler, InvSchedulerTask *task,
		void (*func)(void *), void *arg, uint8_t prio, uint32_t period)
{
  40fe5c:	b480      	push	{r7}
  40fe5e:	b085      	sub	sp, #20
  40fe60:	af00      	add	r7, sp, #0
  40fe62:	60f8      	str	r0, [r7, #12]
  40fe64:	60b9      	str	r1, [r7, #8]
  40fe66:	607a      	str	r2, [r7, #4]
  40fe68:	603b      	str	r3, [r7, #0]
	task->scheduler = scheduler;
  40fe6a:	68bb      	ldr	r3, [r7, #8]
  40fe6c:	68fa      	ldr	r2, [r7, #12]
  40fe6e:	619a      	str	r2, [r3, #24]
	task->func 		= func;
  40fe70:	68bb      	ldr	r3, [r7, #8]
  40fe72:	687a      	ldr	r2, [r7, #4]
  40fe74:	601a      	str	r2, [r3, #0]
	task->arg 		= arg;
  40fe76:	68bb      	ldr	r3, [r7, #8]
  40fe78:	683a      	ldr	r2, [r7, #0]
  40fe7a:	605a      	str	r2, [r3, #4]
	task->priority 	= prio;
  40fe7c:	68bb      	ldr	r3, [r7, #8]
  40fe7e:	7e3a      	ldrb	r2, [r7, #24]
  40fe80:	721a      	strb	r2, [r3, #8]
	task->period 	= period;
  40fe82:	68bb      	ldr	r3, [r7, #8]
  40fe84:	69fa      	ldr	r2, [r7, #28]
  40fe86:	611a      	str	r2, [r3, #16]
	task->state		= INVSCHEDULER_TASK_STATE_STOP;
  40fe88:	68bb      	ldr	r3, [r7, #8]
  40fe8a:	2200      	movs	r2, #0
  40fe8c:	725a      	strb	r2, [r3, #9]
#ifdef INVSCHEDULER_TASK_NAME
	task->name 		= "";
#endif
}
  40fe8e:	bf00      	nop
  40fe90:	3714      	adds	r7, #20
  40fe92:	46bd      	mov	sp, r7
  40fe94:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fe98:	4770      	bx	lr
	...

0040fe9c <InvScheduler_startTaskU>:

void InvScheduler_startTaskU(InvSchedulerTask *task, uint32_t delay)
{
  40fe9c:	b580      	push	{r7, lr}
  40fe9e:	b082      	sub	sp, #8
  40fea0:	af00      	add	r7, sp, #0
  40fea2:	6078      	str	r0, [r7, #4]
  40fea4:	6039      	str	r1, [r7, #0]
	if(task->state == INVSCHEDULER_TASK_STATE_STARTED ||
  40fea6:	687b      	ldr	r3, [r7, #4]
  40fea8:	7a5b      	ldrb	r3, [r3, #9]
  40feaa:	2b01      	cmp	r3, #1
  40feac:	d003      	beq.n	40feb6 <InvScheduler_startTaskU+0x1a>
			task->state == INVSCHEDULER_TASK_STATE_READY) {
  40feae:	687b      	ldr	r3, [r7, #4]
  40feb0:	7a5b      	ldrb	r3, [r3, #9]
	if(task->state == INVSCHEDULER_TASK_STATE_STARTED ||
  40feb2:	2b02      	cmp	r3, #2
  40feb4:	d105      	bne.n	40fec2 <InvScheduler_startTaskU+0x26>
		InvScheduler_removeTask(task->scheduler, task);
  40feb6:	687b      	ldr	r3, [r7, #4]
  40feb8:	699b      	ldr	r3, [r3, #24]
  40feba:	6879      	ldr	r1, [r7, #4]
  40febc:	4618      	mov	r0, r3
  40febe:	4b09      	ldr	r3, [pc, #36]	; (40fee4 <InvScheduler_startTaskU+0x48>)
  40fec0:	4798      	blx	r3
	}
	InvScheduler_insertTask(task->scheduler, task);
  40fec2:	687b      	ldr	r3, [r7, #4]
  40fec4:	699b      	ldr	r3, [r3, #24]
  40fec6:	6879      	ldr	r1, [r7, #4]
  40fec8:	4618      	mov	r0, r3
  40feca:	4b07      	ldr	r3, [pc, #28]	; (40fee8 <InvScheduler_startTaskU+0x4c>)
  40fecc:	4798      	blx	r3
	task->delay = delay;
  40fece:	687b      	ldr	r3, [r7, #4]
  40fed0:	683a      	ldr	r2, [r7, #0]
  40fed2:	615a      	str	r2, [r3, #20]
	task->state = INVSCHEDULER_TASK_STATE_STARTED;
  40fed4:	687b      	ldr	r3, [r7, #4]
  40fed6:	2201      	movs	r2, #1
  40fed8:	725a      	strb	r2, [r3, #9]
}
  40feda:	bf00      	nop
  40fedc:	3708      	adds	r7, #8
  40fede:	46bd      	mov	sp, r7
  40fee0:	bd80      	pop	{r7, pc}
  40fee2:	bf00      	nop
  40fee4:	0040fca1 	.word	0x0040fca1
  40fee8:	0040fc4d 	.word	0x0040fc4d

0040feec <InvScheduler_startTask>:

void InvScheduler_startTask(InvSchedulerTask *task, uint32_t delay)
{
  40feec:	b580      	push	{r7, lr}
  40feee:	b082      	sub	sp, #8
  40fef0:	af00      	add	r7, sp, #0
  40fef2:	6078      	str	r0, [r7, #4]
  40fef4:	6039      	str	r1, [r7, #0]
	InvScheduler_lock(task->scheduler->contextLock);
	InvScheduler_startTaskU(task, delay);
  40fef6:	6839      	ldr	r1, [r7, #0]
  40fef8:	6878      	ldr	r0, [r7, #4]
  40fefa:	4b03      	ldr	r3, [pc, #12]	; (40ff08 <InvScheduler_startTask+0x1c>)
  40fefc:	4798      	blx	r3
	InvScheduler_unlock(task->scheduler->contextLock);
}
  40fefe:	bf00      	nop
  40ff00:	3708      	adds	r7, #8
  40ff02:	46bd      	mov	sp, r7
  40ff04:	bd80      	pop	{r7, pc}
  40ff06:	bf00      	nop
  40ff08:	0040fe9d 	.word	0x0040fe9d

0040ff0c <inv_msg_setup>:
{
	(void)level, (void)str, (void)ap;
}

void inv_msg_setup(int level, inv_msg_printer_t printer)
{
  40ff0c:	b480      	push	{r7}
  40ff0e:	b083      	sub	sp, #12
  40ff10:	af00      	add	r7, sp, #0
  40ff12:	6078      	str	r0, [r7, #4]
  40ff14:	6039      	str	r1, [r7, #0]
	msg_level   = level;
  40ff16:	4a0c      	ldr	r2, [pc, #48]	; (40ff48 <inv_msg_setup+0x3c>)
  40ff18:	687b      	ldr	r3, [r7, #4]
  40ff1a:	6013      	str	r3, [r2, #0]
	if (level < INV_MSG_LEVEL_OFF)
  40ff1c:	687b      	ldr	r3, [r7, #4]
  40ff1e:	2b00      	cmp	r3, #0
  40ff20:	da03      	bge.n	40ff2a <inv_msg_setup+0x1e>
		msg_level = INV_MSG_LEVEL_OFF;
  40ff22:	4b09      	ldr	r3, [pc, #36]	; (40ff48 <inv_msg_setup+0x3c>)
  40ff24:	2200      	movs	r2, #0
  40ff26:	601a      	str	r2, [r3, #0]
  40ff28:	e005      	b.n	40ff36 <inv_msg_setup+0x2a>
	else if (level > INV_MSG_LEVEL_MAX)
  40ff2a:	687b      	ldr	r3, [r7, #4]
  40ff2c:	2b06      	cmp	r3, #6
  40ff2e:	dd02      	ble.n	40ff36 <inv_msg_setup+0x2a>
		msg_level = INV_MSG_LEVEL_MAX;
  40ff30:	4b05      	ldr	r3, [pc, #20]	; (40ff48 <inv_msg_setup+0x3c>)
  40ff32:	2206      	movs	r2, #6
  40ff34:	601a      	str	r2, [r3, #0]
	msg_printer = printer;
  40ff36:	4a05      	ldr	r2, [pc, #20]	; (40ff4c <inv_msg_setup+0x40>)
  40ff38:	683b      	ldr	r3, [r7, #0]
  40ff3a:	6013      	str	r3, [r2, #0]
}
  40ff3c:	bf00      	nop
  40ff3e:	370c      	adds	r7, #12
  40ff40:	46bd      	mov	sp, r7
  40ff42:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ff46:	4770      	bx	lr
  40ff48:	2000182c 	.word	0x2000182c
  40ff4c:	20001830 	.word	0x20001830

0040ff50 <inv_msg>:

void inv_msg(int level, const char * str, ...)
{
  40ff50:	b40e      	push	{r1, r2, r3}
  40ff52:	b580      	push	{r7, lr}
  40ff54:	b085      	sub	sp, #20
  40ff56:	af00      	add	r7, sp, #0
  40ff58:	6078      	str	r0, [r7, #4]
	if(level && level <= msg_level && msg_printer) {
  40ff5a:	687b      	ldr	r3, [r7, #4]
  40ff5c:	2b00      	cmp	r3, #0
  40ff5e:	d011      	beq.n	40ff84 <inv_msg+0x34>
  40ff60:	4b0c      	ldr	r3, [pc, #48]	; (40ff94 <inv_msg+0x44>)
  40ff62:	681b      	ldr	r3, [r3, #0]
  40ff64:	687a      	ldr	r2, [r7, #4]
  40ff66:	429a      	cmp	r2, r3
  40ff68:	dc0c      	bgt.n	40ff84 <inv_msg+0x34>
  40ff6a:	4b0b      	ldr	r3, [pc, #44]	; (40ff98 <inv_msg+0x48>)
  40ff6c:	681b      	ldr	r3, [r3, #0]
  40ff6e:	2b00      	cmp	r3, #0
  40ff70:	d008      	beq.n	40ff84 <inv_msg+0x34>
		va_list ap;
		va_start(ap, str);
  40ff72:	f107 0320 	add.w	r3, r7, #32
  40ff76:	60fb      	str	r3, [r7, #12]
		msg_printer(level, str, ap);
  40ff78:	4b07      	ldr	r3, [pc, #28]	; (40ff98 <inv_msg+0x48>)
  40ff7a:	681b      	ldr	r3, [r3, #0]
  40ff7c:	68fa      	ldr	r2, [r7, #12]
  40ff7e:	69f9      	ldr	r1, [r7, #28]
  40ff80:	6878      	ldr	r0, [r7, #4]
  40ff82:	4798      	blx	r3
		va_end(ap);
	}
}
  40ff84:	bf00      	nop
  40ff86:	3714      	adds	r7, #20
  40ff88:	46bd      	mov	sp, r7
  40ff8a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
  40ff8e:	b003      	add	sp, #12
  40ff90:	4770      	bx	lr
  40ff92:	bf00      	nop
  40ff94:	2000182c 	.word	0x2000182c
  40ff98:	20001830 	.word	0x20001830

0040ff9c <RingByteBuffer_init>:

#include "RingByteBuffer.h"

void RingByteBuffer_init(RingByteBuffer *self, uint8_t *pBuffer,
                         uint16_t sizeBuffer)
{
  40ff9c:	b580      	push	{r7, lr}
  40ff9e:	b084      	sub	sp, #16
  40ffa0:	af00      	add	r7, sp, #0
  40ffa2:	60f8      	str	r0, [r7, #12]
  40ffa4:	60b9      	str	r1, [r7, #8]
  40ffa6:	4613      	mov	r3, r2
  40ffa8:	80fb      	strh	r3, [r7, #6]
	ASSERT(self);
	ASSERT(pBuffer);

	self->buffer 	= pBuffer;
  40ffaa:	68fb      	ldr	r3, [r7, #12]
  40ffac:	68ba      	ldr	r2, [r7, #8]
  40ffae:	601a      	str	r2, [r3, #0]
	self->size 		= sizeBuffer;
  40ffb0:	68fb      	ldr	r3, [r7, #12]
  40ffb2:	88fa      	ldrh	r2, [r7, #6]
  40ffb4:	809a      	strh	r2, [r3, #4]

	RingByteBuffer_clear(self);
  40ffb6:	68f8      	ldr	r0, [r7, #12]
  40ffb8:	4b02      	ldr	r3, [pc, #8]	; (40ffc4 <RingByteBuffer_init+0x28>)
  40ffba:	4798      	blx	r3
}
  40ffbc:	bf00      	nop
  40ffbe:	3710      	adds	r7, #16
  40ffc0:	46bd      	mov	sp, r7
  40ffc2:	bd80      	pop	{r7, pc}
  40ffc4:	0040ffc9 	.word	0x0040ffc9

0040ffc8 <RingByteBuffer_clear>:

void RingByteBuffer_clear(RingByteBuffer *self)
{
  40ffc8:	b480      	push	{r7}
  40ffca:	b083      	sub	sp, #12
  40ffcc:	af00      	add	r7, sp, #0
  40ffce:	6078      	str	r0, [r7, #4]
	ASSERT(self);

	self->start		= 0;
  40ffd0:	687b      	ldr	r3, [r7, #4]
  40ffd2:	2200      	movs	r2, #0
  40ffd4:	80da      	strh	r2, [r3, #6]
	self->end		= 0;
  40ffd6:	687b      	ldr	r3, [r7, #4]
  40ffd8:	2200      	movs	r2, #0
  40ffda:	811a      	strh	r2, [r3, #8]
	self->msbStart	= 0;
  40ffdc:	687b      	ldr	r3, [r7, #4]
  40ffde:	2200      	movs	r2, #0
  40ffe0:	729a      	strb	r2, [r3, #10]
	self->msbEnd	= 0;
  40ffe2:	687b      	ldr	r3, [r7, #4]
  40ffe4:	2200      	movs	r2, #0
  40ffe6:	72da      	strb	r2, [r3, #11]
}
  40ffe8:	bf00      	nop
  40ffea:	370c      	adds	r7, #12
  40ffec:	46bd      	mov	sp, r7
  40ffee:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fff2:	4770      	bx	lr

0040fff4 <RingByteBuffer_pushByte>:
		return 0;
	}
}

void RingByteBuffer_pushByte(RingByteBuffer *self, uint8_t byte)
{
  40fff4:	b480      	push	{r7}
  40fff6:	b083      	sub	sp, #12
  40fff8:	af00      	add	r7, sp, #0
  40fffa:	6078      	str	r0, [r7, #4]
  40fffc:	460b      	mov	r3, r1
  40fffe:	70fb      	strb	r3, [r7, #3]
	ASSERT(self);

	self->buffer[self->end] = byte;
  410000:	687b      	ldr	r3, [r7, #4]
  410002:	681b      	ldr	r3, [r3, #0]
  410004:	687a      	ldr	r2, [r7, #4]
  410006:	8912      	ldrh	r2, [r2, #8]
  410008:	4413      	add	r3, r2
  41000a:	78fa      	ldrb	r2, [r7, #3]
  41000c:	701a      	strb	r2, [r3, #0]

	if (++self->end == self->size) {
  41000e:	687b      	ldr	r3, [r7, #4]
  410010:	891b      	ldrh	r3, [r3, #8]
  410012:	3301      	adds	r3, #1
  410014:	b29a      	uxth	r2, r3
  410016:	687b      	ldr	r3, [r7, #4]
  410018:	811a      	strh	r2, [r3, #8]
  41001a:	687b      	ldr	r3, [r7, #4]
  41001c:	891a      	ldrh	r2, [r3, #8]
  41001e:	687b      	ldr	r3, [r7, #4]
  410020:	889b      	ldrh	r3, [r3, #4]
  410022:	429a      	cmp	r2, r3
  410024:	d109      	bne.n	41003a <RingByteBuffer_pushByte+0x46>
		self->msbEnd ^= 1;
  410026:	687b      	ldr	r3, [r7, #4]
  410028:	7adb      	ldrb	r3, [r3, #11]
  41002a:	f083 0301 	eor.w	r3, r3, #1
  41002e:	b2da      	uxtb	r2, r3
  410030:	687b      	ldr	r3, [r7, #4]
  410032:	72da      	strb	r2, [r3, #11]
		self->end 	  = 0;
  410034:	687b      	ldr	r3, [r7, #4]
  410036:	2200      	movs	r2, #0
  410038:	811a      	strh	r2, [r3, #8]
	}
}
  41003a:	bf00      	nop
  41003c:	370c      	adds	r7, #12
  41003e:	46bd      	mov	sp, r7
  410040:	f85d 7b04 	ldr.w	r7, [sp], #4
  410044:	4770      	bx	lr

00410046 <RingByteBuffer_popByte>:

uint8_t RingByteBuffer_popByte(RingByteBuffer *self)
{
  410046:	b480      	push	{r7}
  410048:	b085      	sub	sp, #20
  41004a:	af00      	add	r7, sp, #0
  41004c:	6078      	str	r0, [r7, #4]
	uint8_t byte;

	ASSERT(self);

	byte = self->buffer[self->start];
  41004e:	687b      	ldr	r3, [r7, #4]
  410050:	681b      	ldr	r3, [r3, #0]
  410052:	687a      	ldr	r2, [r7, #4]
  410054:	88d2      	ldrh	r2, [r2, #6]
  410056:	4413      	add	r3, r2
  410058:	781b      	ldrb	r3, [r3, #0]
  41005a:	73fb      	strb	r3, [r7, #15]

	if (++self->start == self->size) {
  41005c:	687b      	ldr	r3, [r7, #4]
  41005e:	88db      	ldrh	r3, [r3, #6]
  410060:	3301      	adds	r3, #1
  410062:	b29a      	uxth	r2, r3
  410064:	687b      	ldr	r3, [r7, #4]
  410066:	80da      	strh	r2, [r3, #6]
  410068:	687b      	ldr	r3, [r7, #4]
  41006a:	88da      	ldrh	r2, [r3, #6]
  41006c:	687b      	ldr	r3, [r7, #4]
  41006e:	889b      	ldrh	r3, [r3, #4]
  410070:	429a      	cmp	r2, r3
  410072:	d109      	bne.n	410088 <RingByteBuffer_popByte+0x42>
		self->msbStart ^= 1;
  410074:	687b      	ldr	r3, [r7, #4]
  410076:	7a9b      	ldrb	r3, [r3, #10]
  410078:	f083 0301 	eor.w	r3, r3, #1
  41007c:	b2da      	uxtb	r2, r3
  41007e:	687b      	ldr	r3, [r7, #4]
  410080:	729a      	strb	r2, [r3, #10]
		self->start     = 0;
  410082:	687b      	ldr	r3, [r7, #4]
  410084:	2200      	movs	r2, #0
  410086:	80da      	strh	r2, [r3, #6]
	}

	return byte;
  410088:	7bfb      	ldrb	r3, [r7, #15]
}
  41008a:	4618      	mov	r0, r3
  41008c:	3714      	adds	r7, #20
  41008e:	46bd      	mov	sp, r7
  410090:	f85d 7b04 	ldr.w	r7, [sp], #4
  410094:	4770      	bx	lr

00410096 <inv_icm20648_augmented_init>:
		newOdr = MIN(s->sOriWuOdrMs,newOdr); \
	if	(inv_icm20648_ctrl_androidSensor_enabled	(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR)) \
		newOdr = MIN(s->sRvWuOdrMs,newOdr);

int inv_icm20648_augmented_init(struct inv_icm20648 * s)
{
  410096:	b480      	push	{r7}
  410098:	b083      	sub	sp, #12
  41009a:	af00      	add	r7, sp, #0
  41009c:	6078      	str	r0, [r7, #4]
	// ODR expected for gravity-based sensors
	s->sGravityOdrMs = 0xFFFF;
  41009e:	687b      	ldr	r3, [r7, #4]
  4100a0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100a4:	f8a3 24de 	strh.w	r2, [r3, #1246]	; 0x4de
	s->sGrvOdrMs = 0xFFFF;
  4100a8:	687b      	ldr	r3, [r7, #4]
  4100aa:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100ae:	f8a3 24e0 	strh.w	r2, [r3, #1248]	; 0x4e0
	s->sLinAccOdrMs = 0xFFFF;
  4100b2:	687b      	ldr	r3, [r7, #4]
  4100b4:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100b8:	f8a3 24e2 	strh.w	r2, [r3, #1250]	; 0x4e2
	s->sGravityWuOdrMs = 0xFFFF;
  4100bc:	687b      	ldr	r3, [r7, #4]
  4100be:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100c2:	f8a3 24e4 	strh.w	r2, [r3, #1252]	; 0x4e4
	s->sGrvWuOdrMs = 0xFFFF;
  4100c6:	687b      	ldr	r3, [r7, #4]
  4100c8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100cc:	f8a3 24e6 	strh.w	r2, [r3, #1254]	; 0x4e6
	s->sLinAccWuOdrMs = 0xFFFF;
  4100d0:	687b      	ldr	r3, [r7, #4]
  4100d2:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100d6:	f8a3 24e8 	strh.w	r2, [r3, #1256]	; 0x4e8
	// ODR expected for rotation vector-based sensors
	s->sRvOdrMs = 0xFFFF;
  4100da:	687b      	ldr	r3, [r7, #4]
  4100dc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100e0:	f8a3 24ea 	strh.w	r2, [r3, #1258]	; 0x4ea
	s->sOriOdrMs = 0xFFFF;
  4100e4:	687b      	ldr	r3, [r7, #4]
  4100e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100ea:	f8a3 24ec 	strh.w	r2, [r3, #1260]	; 0x4ec
	s->sRvWuOdrMs = 0xFFFF;
  4100ee:	687b      	ldr	r3, [r7, #4]
  4100f0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100f4:	f8a3 24ee 	strh.w	r2, [r3, #1262]	; 0x4ee
	s->sOriWuOdrMs = 0xFFFF;
  4100f8:	687b      	ldr	r3, [r7, #4]
  4100fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4100fe:	f8a3 24f0 	strh.w	r2, [r3, #1264]	; 0x4f0
	
	return 0;
  410102:	2300      	movs	r3, #0
}
  410104:	4618      	mov	r0, r3
  410106:	370c      	adds	r7, #12
  410108:	46bd      	mov	sp, r7
  41010a:	f85d 7b04 	ldr.w	r7, [sp], #4
  41010e:	4770      	bx	lr

00410110 <inv_icm20648_augmented_sensors_get_gravity>:

int inv_icm20648_augmented_sensors_get_gravity(struct inv_icm20648 * s, long gravity[3], const long quat6axis_3e[3])
{
  410110:	b5b0      	push	{r4, r5, r7, lr}
  410112:	b08c      	sub	sp, #48	; 0x30
  410114:	af00      	add	r7, sp, #0
  410116:	60f8      	str	r0, [r7, #12]
  410118:	60b9      	str	r1, [r7, #8]
  41011a:	607a      	str	r2, [r7, #4]
	long quat6axis_4e[4];
	long quat6axis_4e_body_to_world[4];

	if(!gravity) return -1;
  41011c:	68bb      	ldr	r3, [r7, #8]
  41011e:	2b00      	cmp	r3, #0
  410120:	d102      	bne.n	410128 <inv_icm20648_augmented_sensors_get_gravity+0x18>
  410122:	f04f 33ff 	mov.w	r3, #4294967295
  410126:	e054      	b.n	4101d2 <inv_icm20648_augmented_sensors_get_gravity+0xc2>
	if(!quat6axis_3e) return -1;
  410128:	687b      	ldr	r3, [r7, #4]
  41012a:	2b00      	cmp	r3, #0
  41012c:	d102      	bne.n	410134 <inv_icm20648_augmented_sensors_get_gravity+0x24>
  41012e:	f04f 33ff 	mov.w	r3, #4294967295
  410132:	e04e      	b.n	4101d2 <inv_icm20648_augmented_sensors_get_gravity+0xc2>

	// compute w element
	inv_icm20648_convert_compute_scalar_part_fxp(quat6axis_3e, quat6axis_4e);
  410134:	f107 0320 	add.w	r3, r7, #32
  410138:	4619      	mov	r1, r3
  41013a:	6878      	ldr	r0, [r7, #4]
  41013c:	4b27      	ldr	r3, [pc, #156]	; (4101dc <inv_icm20648_augmented_sensors_get_gravity+0xcc>)
  41013e:	4798      	blx	r3
	// apply mounting matrix
	inv_icm20648_q_mult_q_qi(quat6axis_4e, s->s_quat_chip_to_body, quat6axis_4e_body_to_world);
  410140:	68fb      	ldr	r3, [r7, #12]
  410142:	f103 01a8 	add.w	r1, r3, #168	; 0xa8
  410146:	f107 0210 	add.w	r2, r7, #16
  41014a:	f107 0320 	add.w	r3, r7, #32
  41014e:	4618      	mov	r0, r3
  410150:	4b23      	ldr	r3, [pc, #140]	; (4101e0 <inv_icm20648_augmented_sensors_get_gravity+0xd0>)
  410152:	4798      	blx	r3

	gravity[0] = ( 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[3], 30) - 
  410154:	697b      	ldr	r3, [r7, #20]
  410156:	69f9      	ldr	r1, [r7, #28]
  410158:	221e      	movs	r2, #30
  41015a:	4618      	mov	r0, r3
  41015c:	4b21      	ldr	r3, [pc, #132]	; (4101e4 <inv_icm20648_augmented_sensors_get_gravity+0xd4>)
  41015e:	4798      	blx	r3
  410160:	4604      	mov	r4, r0
	               2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  410162:	693b      	ldr	r3, [r7, #16]
  410164:	69b9      	ldr	r1, [r7, #24]
  410166:	221e      	movs	r2, #30
  410168:	4618      	mov	r0, r3
  41016a:	4b1e      	ldr	r3, [pc, #120]	; (4101e4 <inv_icm20648_augmented_sensors_get_gravity+0xd4>)
  41016c:	4798      	blx	r3
  41016e:	4603      	mov	r3, r0
	gravity[0] = ( 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[3], 30) - 
  410170:	1ae3      	subs	r3, r4, r3
  410172:	005b      	lsls	r3, r3, #1
	               2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  410174:	139a      	asrs	r2, r3, #14
	gravity[0] = ( 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[3], 30) - 
  410176:	68bb      	ldr	r3, [r7, #8]
  410178:	601a      	str	r2, [r3, #0]
	gravity[1] = ( 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[3], 30) + 
  41017a:	68bb      	ldr	r3, [r7, #8]
  41017c:	1d1c      	adds	r4, r3, #4
  41017e:	69bb      	ldr	r3, [r7, #24]
  410180:	69f9      	ldr	r1, [r7, #28]
  410182:	221e      	movs	r2, #30
  410184:	4618      	mov	r0, r3
  410186:	4b17      	ldr	r3, [pc, #92]	; (4101e4 <inv_icm20648_augmented_sensors_get_gravity+0xd4>)
  410188:	4798      	blx	r3
  41018a:	4605      	mov	r5, r0
	               2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[1], 30) ) >> (30 - 16);
  41018c:	693b      	ldr	r3, [r7, #16]
  41018e:	6979      	ldr	r1, [r7, #20]
  410190:	221e      	movs	r2, #30
  410192:	4618      	mov	r0, r3
  410194:	4b13      	ldr	r3, [pc, #76]	; (4101e4 <inv_icm20648_augmented_sensors_get_gravity+0xd4>)
  410196:	4798      	blx	r3
  410198:	4603      	mov	r3, r0
	gravity[1] = ( 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[3], 30) + 
  41019a:	442b      	add	r3, r5
  41019c:	005b      	lsls	r3, r3, #1
	               2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[1], 30) ) >> (30 - 16);
  41019e:	139b      	asrs	r3, r3, #14
	gravity[1] = ( 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[3], 30) + 
  4101a0:	6023      	str	r3, [r4, #0]
	gravity[2] = ( (1 << 30) - 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[1], 30) - 
  4101a2:	68bb      	ldr	r3, [r7, #8]
  4101a4:	f103 0408 	add.w	r4, r3, #8
  4101a8:	697b      	ldr	r3, [r7, #20]
  4101aa:	6979      	ldr	r1, [r7, #20]
  4101ac:	221e      	movs	r2, #30
  4101ae:	4618      	mov	r0, r3
  4101b0:	4b0c      	ldr	r3, [pc, #48]	; (4101e4 <inv_icm20648_augmented_sensors_get_gravity+0xd4>)
  4101b2:	4798      	blx	r3
  4101b4:	4603      	mov	r3, r0
  4101b6:	f1c3 5500 	rsb	r5, r3, #536870912	; 0x20000000
	                2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  4101ba:	69bb      	ldr	r3, [r7, #24]
  4101bc:	69b9      	ldr	r1, [r7, #24]
  4101be:	221e      	movs	r2, #30
  4101c0:	4618      	mov	r0, r3
  4101c2:	4b08      	ldr	r3, [pc, #32]	; (4101e4 <inv_icm20648_augmented_sensors_get_gravity+0xd4>)
  4101c4:	4798      	blx	r3
  4101c6:	4603      	mov	r3, r0
	gravity[2] = ( (1 << 30) - 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[1], 30) - 
  4101c8:	1aeb      	subs	r3, r5, r3
  4101ca:	005b      	lsls	r3, r3, #1
	                2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  4101cc:	139b      	asrs	r3, r3, #14
	gravity[2] = ( (1 << 30) - 2 * inv_icm20648_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[1], 30) - 
  4101ce:	6023      	str	r3, [r4, #0]

	return MPU_SUCCESS;
  4101d0:	2300      	movs	r3, #0
}
  4101d2:	4618      	mov	r0, r3
  4101d4:	3730      	adds	r7, #48	; 0x30
  4101d6:	46bd      	mov	sp, r7
  4101d8:	bdb0      	pop	{r4, r5, r7, pc}
  4101da:	bf00      	nop
  4101dc:	0040711d 	.word	0x0040711d
  4101e0:	00406b4d 	.word	0x00406b4d
  4101e4:	00407971 	.word	0x00407971

004101e8 <inv_icm20648_augmented_sensors_get_linearacceleration>:

int inv_icm20648_augmented_sensors_get_linearacceleration(long linacc[3], const long gravity[3], const long accel[3])
{
  4101e8:	b480      	push	{r7}
  4101ea:	b085      	sub	sp, #20
  4101ec:	af00      	add	r7, sp, #0
  4101ee:	60f8      	str	r0, [r7, #12]
  4101f0:	60b9      	str	r1, [r7, #8]
  4101f2:	607a      	str	r2, [r7, #4]
    if(!linacc) return -1;
  4101f4:	68fb      	ldr	r3, [r7, #12]
  4101f6:	2b00      	cmp	r3, #0
  4101f8:	d102      	bne.n	410200 <inv_icm20648_augmented_sensors_get_linearacceleration+0x18>
  4101fa:	f04f 33ff 	mov.w	r3, #4294967295
  4101fe:	e027      	b.n	410250 <inv_icm20648_augmented_sensors_get_linearacceleration+0x68>
    if(!gravity) return -1;
  410200:	68bb      	ldr	r3, [r7, #8]
  410202:	2b00      	cmp	r3, #0
  410204:	d102      	bne.n	41020c <inv_icm20648_augmented_sensors_get_linearacceleration+0x24>
  410206:	f04f 33ff 	mov.w	r3, #4294967295
  41020a:	e021      	b.n	410250 <inv_icm20648_augmented_sensors_get_linearacceleration+0x68>
    if(!accel) return -1;
  41020c:	687b      	ldr	r3, [r7, #4]
  41020e:	2b00      	cmp	r3, #0
  410210:	d102      	bne.n	410218 <inv_icm20648_augmented_sensors_get_linearacceleration+0x30>
  410212:	f04f 33ff 	mov.w	r3, #4294967295
  410216:	e01b      	b.n	410250 <inv_icm20648_augmented_sensors_get_linearacceleration+0x68>
    
    linacc[0] = accel[0] - gravity[0];
  410218:	687b      	ldr	r3, [r7, #4]
  41021a:	681a      	ldr	r2, [r3, #0]
  41021c:	68bb      	ldr	r3, [r7, #8]
  41021e:	681b      	ldr	r3, [r3, #0]
  410220:	1ad2      	subs	r2, r2, r3
  410222:	68fb      	ldr	r3, [r7, #12]
  410224:	601a      	str	r2, [r3, #0]
    linacc[1] = accel[1] - gravity[1];
  410226:	68fb      	ldr	r3, [r7, #12]
  410228:	3304      	adds	r3, #4
  41022a:	687a      	ldr	r2, [r7, #4]
  41022c:	3204      	adds	r2, #4
  41022e:	6811      	ldr	r1, [r2, #0]
  410230:	68ba      	ldr	r2, [r7, #8]
  410232:	3204      	adds	r2, #4
  410234:	6812      	ldr	r2, [r2, #0]
  410236:	1a8a      	subs	r2, r1, r2
  410238:	601a      	str	r2, [r3, #0]
    linacc[2] = accel[2] - gravity[2];
  41023a:	68fb      	ldr	r3, [r7, #12]
  41023c:	3308      	adds	r3, #8
  41023e:	687a      	ldr	r2, [r7, #4]
  410240:	3208      	adds	r2, #8
  410242:	6811      	ldr	r1, [r2, #0]
  410244:	68ba      	ldr	r2, [r7, #8]
  410246:	3208      	adds	r2, #8
  410248:	6812      	ldr	r2, [r2, #0]
  41024a:	1a8a      	subs	r2, r1, r2
  41024c:	601a      	str	r2, [r3, #0]
                    
    return MPU_SUCCESS;
  41024e:	2300      	movs	r3, #0
}
  410250:	4618      	mov	r0, r3
  410252:	3714      	adds	r7, #20
  410254:	46bd      	mov	sp, r7
  410256:	f85d 7b04 	ldr.w	r7, [sp], #4
  41025a:	4770      	bx	lr

0041025c <inv_icm20648_augmented_sensors_get_orientation>:


int inv_icm20648_augmented_sensors_get_orientation(long orientation[3], const long quat9axis_3e[4])
{
  41025c:	b590      	push	{r4, r7, lr}
  41025e:	b093      	sub	sp, #76	; 0x4c
  410260:	af00      	add	r7, sp, #0
  410262:	6078      	str	r0, [r7, #4]
  410264:	6039      	str	r1, [r7, #0]
    long lQuat9axis4e[4];
	long lMatrixQ30[9];       
	long lMatrixQ30Square; 
	long lRad2degQ16 = 0x394BB8; // (float)(180.0 / 3.14159265358979) in Q16
  410266:	4b43      	ldr	r3, [pc, #268]	; (410374 <inv_icm20648_augmented_sensors_get_orientation+0x118>)
  410268:	647b      	str	r3, [r7, #68]	; 0x44
    
    if(!orientation) return -1;
  41026a:	687b      	ldr	r3, [r7, #4]
  41026c:	2b00      	cmp	r3, #0
  41026e:	d102      	bne.n	410276 <inv_icm20648_augmented_sensors_get_orientation+0x1a>
  410270:	f04f 33ff 	mov.w	r3, #4294967295
  410274:	e07a      	b.n	41036c <inv_icm20648_augmented_sensors_get_orientation+0x110>
    if(!quat9axis_3e) return -1;
  410276:	683b      	ldr	r3, [r7, #0]
  410278:	2b00      	cmp	r3, #0
  41027a:	d102      	bne.n	410282 <inv_icm20648_augmented_sensors_get_orientation+0x26>
  41027c:	f04f 33ff 	mov.w	r3, #4294967295
  410280:	e074      	b.n	41036c <inv_icm20648_augmented_sensors_get_orientation+0x110>
    
    // compute w element
	inv_icm20648_convert_compute_scalar_part_fxp(quat9axis_3e, lQuat9axis4e);
  410282:	f107 0330 	add.w	r3, r7, #48	; 0x30
  410286:	4619      	mov	r1, r3
  410288:	6838      	ldr	r0, [r7, #0]
  41028a:	4b3b      	ldr	r3, [pc, #236]	; (410378 <inv_icm20648_augmented_sensors_get_orientation+0x11c>)
  41028c:	4798      	blx	r3
    
	// quaternion to a rotation matrix, q30 to q30
	inv_icm20648_convert_quat_to_col_major_matrix_fxp((const long *)lQuat9axis4e, (long *)lMatrixQ30);
  41028e:	f107 020c 	add.w	r2, r7, #12
  410292:	f107 0330 	add.w	r3, r7, #48	; 0x30
  410296:	4611      	mov	r1, r2
  410298:	4618      	mov	r0, r3
  41029a:	4b38      	ldr	r3, [pc, #224]	; (41037c <inv_icm20648_augmented_sensors_get_orientation+0x120>)
  41029c:	4798      	blx	r3

	// compute orientation in q16
	// orientationFlt[0] = atan2f(-matrixFlt[1][0], matrixFlt[0][0]) * rad2deg;
	orientation[0] = inv_icm20648_math_atan2_q15_fxp(-lMatrixQ30[3] >> 15, lMatrixQ30[0] >> 15) << 1;
  41029e:	69bb      	ldr	r3, [r7, #24]
  4102a0:	425b      	negs	r3, r3
  4102a2:	13da      	asrs	r2, r3, #15
  4102a4:	68fb      	ldr	r3, [r7, #12]
  4102a6:	13db      	asrs	r3, r3, #15
  4102a8:	4619      	mov	r1, r3
  4102aa:	4610      	mov	r0, r2
  4102ac:	4b34      	ldr	r3, [pc, #208]	; (410380 <inv_icm20648_augmented_sensors_get_orientation+0x124>)
  4102ae:	4798      	blx	r3
  4102b0:	4603      	mov	r3, r0
  4102b2:	005a      	lsls	r2, r3, #1
  4102b4:	687b      	ldr	r3, [r7, #4]
  4102b6:	601a      	str	r2, [r3, #0]
	orientation[0] = inv_icm20648_convert_mult_qfix_fxp(orientation[0], lRad2degQ16, 16);
  4102b8:	687b      	ldr	r3, [r7, #4]
  4102ba:	681b      	ldr	r3, [r3, #0]
  4102bc:	2210      	movs	r2, #16
  4102be:	6c79      	ldr	r1, [r7, #68]	; 0x44
  4102c0:	4618      	mov	r0, r3
  4102c2:	4b30      	ldr	r3, [pc, #192]	; (410384 <inv_icm20648_augmented_sensors_get_orientation+0x128>)
  4102c4:	4798      	blx	r3
  4102c6:	4602      	mov	r2, r0
  4102c8:	687b      	ldr	r3, [r7, #4]
  4102ca:	601a      	str	r2, [r3, #0]

	// orientationFlt[1] = atan2f(-matrixFlt[2][1], matrixFlt[2][2]) * rad2deg;
	orientation[1] = inv_icm20648_math_atan2_q15_fxp(-lMatrixQ30[7] >> 15, lMatrixQ30[8] >> 15) << 1;
  4102cc:	687b      	ldr	r3, [r7, #4]
  4102ce:	1d1c      	adds	r4, r3, #4
  4102d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4102d2:	425b      	negs	r3, r3
  4102d4:	13da      	asrs	r2, r3, #15
  4102d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4102d8:	13db      	asrs	r3, r3, #15
  4102da:	4619      	mov	r1, r3
  4102dc:	4610      	mov	r0, r2
  4102de:	4b28      	ldr	r3, [pc, #160]	; (410380 <inv_icm20648_augmented_sensors_get_orientation+0x124>)
  4102e0:	4798      	blx	r3
  4102e2:	4603      	mov	r3, r0
  4102e4:	005b      	lsls	r3, r3, #1
  4102e6:	6023      	str	r3, [r4, #0]
	orientation[1] = inv_icm20648_convert_mult_qfix_fxp(orientation[1], lRad2degQ16, 16);
  4102e8:	687b      	ldr	r3, [r7, #4]
  4102ea:	1d1c      	adds	r4, r3, #4
  4102ec:	687b      	ldr	r3, [r7, #4]
  4102ee:	3304      	adds	r3, #4
  4102f0:	681b      	ldr	r3, [r3, #0]
  4102f2:	2210      	movs	r2, #16
  4102f4:	6c79      	ldr	r1, [r7, #68]	; 0x44
  4102f6:	4618      	mov	r0, r3
  4102f8:	4b22      	ldr	r3, [pc, #136]	; (410384 <inv_icm20648_augmented_sensors_get_orientation+0x128>)
  4102fa:	4798      	blx	r3
  4102fc:	4603      	mov	r3, r0
  4102fe:	6023      	str	r3, [r4, #0]

	// orientationFlt[2] = asinf ( matrixFlt[2][0]) * rad2deg;
	// asin(x) = atan (x/sqrt(1-x))
	// atan2(y,x) = atan(y/x)
	// asin(x) = atan2(x, sqrt(1-x))
	lMatrixQ30Square = inv_icm20648_convert_mult_qfix_fxp(lMatrixQ30[6], lMatrixQ30[6], 30); // x
  410300:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  410302:	6a79      	ldr	r1, [r7, #36]	; 0x24
  410304:	221e      	movs	r2, #30
  410306:	4618      	mov	r0, r3
  410308:	4b1e      	ldr	r3, [pc, #120]	; (410384 <inv_icm20648_augmented_sensors_get_orientation+0x128>)
  41030a:	4798      	blx	r3
  41030c:	6438      	str	r0, [r7, #64]	; 0x40
	lMatrixQ30Square = (1UL << 30) - lMatrixQ30Square; // 1-x
  41030e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  410310:	f1c3 4380 	rsb	r3, r3, #1073741824	; 0x40000000
  410314:	643b      	str	r3, [r7, #64]	; 0x40
	lMatrixQ30Square = inv_icm20648_convert_fast_sqrt_fxp(lMatrixQ30Square); // sqrt(1-x)
  410316:	6c38      	ldr	r0, [r7, #64]	; 0x40
  410318:	4b1b      	ldr	r3, [pc, #108]	; (410388 <inv_icm20648_augmented_sensors_get_orientation+0x12c>)
  41031a:	4798      	blx	r3
  41031c:	6438      	str	r0, [r7, #64]	; 0x40
	orientation[2] = inv_icm20648_math_atan2_q15_fxp(lMatrixQ30[6] >> 15,  lMatrixQ30Square >> 15) << 1; // atan2(x, sqrt(1-x))
  41031e:	687b      	ldr	r3, [r7, #4]
  410320:	f103 0408 	add.w	r4, r3, #8
  410324:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  410326:	13da      	asrs	r2, r3, #15
  410328:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  41032a:	13db      	asrs	r3, r3, #15
  41032c:	4619      	mov	r1, r3
  41032e:	4610      	mov	r0, r2
  410330:	4b13      	ldr	r3, [pc, #76]	; (410380 <inv_icm20648_augmented_sensors_get_orientation+0x124>)
  410332:	4798      	blx	r3
  410334:	4603      	mov	r3, r0
  410336:	005b      	lsls	r3, r3, #1
  410338:	6023      	str	r3, [r4, #0]
	orientation[2] = inv_icm20648_convert_mult_qfix_fxp(orientation[2], lRad2degQ16, 16); // * rad2deg
  41033a:	687b      	ldr	r3, [r7, #4]
  41033c:	f103 0408 	add.w	r4, r3, #8
  410340:	687b      	ldr	r3, [r7, #4]
  410342:	3308      	adds	r3, #8
  410344:	681b      	ldr	r3, [r3, #0]
  410346:	2210      	movs	r2, #16
  410348:	6c79      	ldr	r1, [r7, #68]	; 0x44
  41034a:	4618      	mov	r0, r3
  41034c:	4b0d      	ldr	r3, [pc, #52]	; (410384 <inv_icm20648_augmented_sensors_get_orientation+0x128>)
  41034e:	4798      	blx	r3
  410350:	4603      	mov	r3, r0
  410352:	6023      	str	r3, [r4, #0]

	if (orientation[0] < 0)
  410354:	687b      	ldr	r3, [r7, #4]
  410356:	681b      	ldr	r3, [r3, #0]
  410358:	2b00      	cmp	r3, #0
  41035a:	da06      	bge.n	41036a <inv_icm20648_augmented_sensors_get_orientation+0x10e>
		orientation[0] += 360UL << 16;
  41035c:	687b      	ldr	r3, [r7, #4]
  41035e:	681b      	ldr	r3, [r3, #0]
  410360:	f103 73b4 	add.w	r3, r3, #23592960	; 0x1680000
  410364:	461a      	mov	r2, r3
  410366:	687b      	ldr	r3, [r7, #4]
  410368:	601a      	str	r2, [r3, #0]

    return MPU_SUCCESS;
  41036a:	2300      	movs	r3, #0
}
  41036c:	4618      	mov	r0, r3
  41036e:	374c      	adds	r7, #76	; 0x4c
  410370:	46bd      	mov	sp, r7
  410372:	bd90      	pop	{r4, r7, pc}
  410374:	00394bb8 	.word	0x00394bb8
  410378:	0040711d 	.word	0x0040711d
  41037c:	00407a25 	.word	0x00407a25
  410380:	00407df1 	.word	0x00407df1
  410384:	00407971 	.word	0x00407971
  410388:	004071b1 	.word	0x004071b1

0041038c <inv_icm20648_augmented_sensors_set_odr>:

unsigned short inv_icm20648_augmented_sensors_set_odr(struct inv_icm20648 * s, unsigned char androidSensor, unsigned short delayInMs)
{
  41038c:	b580      	push	{r7, lr}
  41038e:	b082      	sub	sp, #8
  410390:	af00      	add	r7, sp, #0
  410392:	6078      	str	r0, [r7, #4]
  410394:	460b      	mov	r3, r1
  410396:	70fb      	strb	r3, [r7, #3]
  410398:	4613      	mov	r3, r2
  41039a:	803b      	strh	r3, [r7, #0]
	switch(androidSensor)
  41039c:	78fb      	ldrb	r3, [r7, #3]
  41039e:	3b03      	subs	r3, #3
  4103a0:	2b20      	cmp	r3, #32
  4103a2:	f200 8207 	bhi.w	4107b4 <inv_icm20648_augmented_sensors_set_odr+0x428>
  4103a6:	a201      	add	r2, pc, #4	; (adr r2, 4103ac <inv_icm20648_augmented_sensors_set_odr+0x20>)
  4103a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4103ac:	00410563 	.word	0x00410563
  4103b0:	004107b5 	.word	0x004107b5
  4103b4:	004107b5 	.word	0x004107b5
  4103b8:	004107b5 	.word	0x004107b5
  4103bc:	004107b5 	.word	0x004107b5
  4103c0:	004107b5 	.word	0x004107b5
  4103c4:	00410431 	.word	0x00410431
  4103c8:	004104fd 	.word	0x004104fd
  4103cc:	004105ab 	.word	0x004105ab
  4103d0:	004107b5 	.word	0x004107b5
  4103d4:	004107b5 	.word	0x004107b5
  4103d8:	004107b5 	.word	0x004107b5
  4103dc:	00410497 	.word	0x00410497
  4103e0:	004107b5 	.word	0x004107b5
  4103e4:	004107b5 	.word	0x004107b5
  4103e8:	004107b5 	.word	0x004107b5
  4103ec:	004107b5 	.word	0x004107b5
  4103f0:	004107b5 	.word	0x004107b5
  4103f4:	004107b5 	.word	0x004107b5
  4103f8:	004107b5 	.word	0x004107b5
  4103fc:	004107b5 	.word	0x004107b5
  410400:	004107b5 	.word	0x004107b5
  410404:	00410729 	.word	0x00410729
  410408:	004107b5 	.word	0x004107b5
  41040c:	004107b5 	.word	0x004107b5
  410410:	004107b5 	.word	0x004107b5
  410414:	004105f3 	.word	0x004105f3
  410418:	004106c5 	.word	0x004106c5
  41041c:	0041076f 	.word	0x0041076f
  410420:	004107b5 	.word	0x004107b5
  410424:	004107b5 	.word	0x004107b5
  410428:	004107b5 	.word	0x004107b5
  41042c:	00410659 	.word	0x00410659
	{
		case ANDROID_SENSOR_GRAVITY:
			s->sGravityOdrMs = delayInMs;
  410430:	687b      	ldr	r3, [r7, #4]
  410432:	883a      	ldrh	r2, [r7, #0]
  410434:	f8a3 24de 	strh.w	r2, [r3, #1246]	; 0x4de
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, delayInMs);
  410438:	2109      	movs	r1, #9
  41043a:	6878      	ldr	r0, [r7, #4]
  41043c:	4ba0      	ldr	r3, [pc, #640]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  41043e:	4798      	blx	r3
  410440:	4603      	mov	r3, r0
  410442:	2b00      	cmp	r3, #0
  410444:	d007      	beq.n	410456 <inv_icm20648_augmented_sensors_set_odr+0xca>
  410446:	687b      	ldr	r3, [r7, #4]
  410448:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  41044c:	883b      	ldrh	r3, [r7, #0]
  41044e:	4293      	cmp	r3, r2
  410450:	bf28      	it	cs
  410452:	4613      	movcs	r3, r2
  410454:	803b      	strh	r3, [r7, #0]
  410456:	210f      	movs	r1, #15
  410458:	6878      	ldr	r0, [r7, #4]
  41045a:	4b99      	ldr	r3, [pc, #612]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  41045c:	4798      	blx	r3
  41045e:	4603      	mov	r3, r0
  410460:	2b00      	cmp	r3, #0
  410462:	d007      	beq.n	410474 <inv_icm20648_augmented_sensors_set_odr+0xe8>
  410464:	687b      	ldr	r3, [r7, #4]
  410466:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  41046a:	883b      	ldrh	r3, [r7, #0]
  41046c:	4293      	cmp	r3, r2
  41046e:	bf28      	it	cs
  410470:	4613      	movcs	r3, r2
  410472:	803b      	strh	r3, [r7, #0]
  410474:	210a      	movs	r1, #10
  410476:	6878      	ldr	r0, [r7, #4]
  410478:	4b91      	ldr	r3, [pc, #580]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  41047a:	4798      	blx	r3
  41047c:	4603      	mov	r3, r0
  41047e:	2b00      	cmp	r3, #0
  410480:	f000 819a 	beq.w	4107b8 <inv_icm20648_augmented_sensors_set_odr+0x42c>
  410484:	687b      	ldr	r3, [r7, #4]
  410486:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  41048a:	883b      	ldrh	r3, [r7, #0]
  41048c:	4293      	cmp	r3, r2
  41048e:	bf28      	it	cs
  410490:	4613      	movcs	r3, r2
  410492:	803b      	strh	r3, [r7, #0]
			break;
  410494:	e190      	b.n	4107b8 <inv_icm20648_augmented_sensors_set_odr+0x42c>
        case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
			s->sGrvOdrMs = delayInMs;
  410496:	687b      	ldr	r3, [r7, #4]
  410498:	883a      	ldrh	r2, [r7, #0]
  41049a:	f8a3 24e0 	strh.w	r2, [r3, #1248]	; 0x4e0
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, delayInMs);
  41049e:	2109      	movs	r1, #9
  4104a0:	6878      	ldr	r0, [r7, #4]
  4104a2:	4b87      	ldr	r3, [pc, #540]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  4104a4:	4798      	blx	r3
  4104a6:	4603      	mov	r3, r0
  4104a8:	2b00      	cmp	r3, #0
  4104aa:	d007      	beq.n	4104bc <inv_icm20648_augmented_sensors_set_odr+0x130>
  4104ac:	687b      	ldr	r3, [r7, #4]
  4104ae:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  4104b2:	883b      	ldrh	r3, [r7, #0]
  4104b4:	4293      	cmp	r3, r2
  4104b6:	bf28      	it	cs
  4104b8:	4613      	movcs	r3, r2
  4104ba:	803b      	strh	r3, [r7, #0]
  4104bc:	210f      	movs	r1, #15
  4104be:	6878      	ldr	r0, [r7, #4]
  4104c0:	4b7f      	ldr	r3, [pc, #508]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  4104c2:	4798      	blx	r3
  4104c4:	4603      	mov	r3, r0
  4104c6:	2b00      	cmp	r3, #0
  4104c8:	d007      	beq.n	4104da <inv_icm20648_augmented_sensors_set_odr+0x14e>
  4104ca:	687b      	ldr	r3, [r7, #4]
  4104cc:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  4104d0:	883b      	ldrh	r3, [r7, #0]
  4104d2:	4293      	cmp	r3, r2
  4104d4:	bf28      	it	cs
  4104d6:	4613      	movcs	r3, r2
  4104d8:	803b      	strh	r3, [r7, #0]
  4104da:	210a      	movs	r1, #10
  4104dc:	6878      	ldr	r0, [r7, #4]
  4104de:	4b78      	ldr	r3, [pc, #480]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  4104e0:	4798      	blx	r3
  4104e2:	4603      	mov	r3, r0
  4104e4:	2b00      	cmp	r3, #0
  4104e6:	f000 8169 	beq.w	4107bc <inv_icm20648_augmented_sensors_set_odr+0x430>
  4104ea:	687b      	ldr	r3, [r7, #4]
  4104ec:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  4104f0:	883b      	ldrh	r3, [r7, #0]
  4104f2:	4293      	cmp	r3, r2
  4104f4:	bf28      	it	cs
  4104f6:	4613      	movcs	r3, r2
  4104f8:	803b      	strh	r3, [r7, #0]
			break;
  4104fa:	e15f      	b.n	4107bc <inv_icm20648_augmented_sensors_set_odr+0x430>
        case ANDROID_SENSOR_LINEAR_ACCELERATION:
			s->sLinAccOdrMs = delayInMs;
  4104fc:	687b      	ldr	r3, [r7, #4]
  4104fe:	883a      	ldrh	r2, [r7, #0]
  410500:	f8a3 24e2 	strh.w	r2, [r3, #1250]	; 0x4e2
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, delayInMs);
  410504:	2109      	movs	r1, #9
  410506:	6878      	ldr	r0, [r7, #4]
  410508:	4b6d      	ldr	r3, [pc, #436]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  41050a:	4798      	blx	r3
  41050c:	4603      	mov	r3, r0
  41050e:	2b00      	cmp	r3, #0
  410510:	d007      	beq.n	410522 <inv_icm20648_augmented_sensors_set_odr+0x196>
  410512:	687b      	ldr	r3, [r7, #4]
  410514:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  410518:	883b      	ldrh	r3, [r7, #0]
  41051a:	4293      	cmp	r3, r2
  41051c:	bf28      	it	cs
  41051e:	4613      	movcs	r3, r2
  410520:	803b      	strh	r3, [r7, #0]
  410522:	210f      	movs	r1, #15
  410524:	6878      	ldr	r0, [r7, #4]
  410526:	4b66      	ldr	r3, [pc, #408]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  410528:	4798      	blx	r3
  41052a:	4603      	mov	r3, r0
  41052c:	2b00      	cmp	r3, #0
  41052e:	d007      	beq.n	410540 <inv_icm20648_augmented_sensors_set_odr+0x1b4>
  410530:	687b      	ldr	r3, [r7, #4]
  410532:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  410536:	883b      	ldrh	r3, [r7, #0]
  410538:	4293      	cmp	r3, r2
  41053a:	bf28      	it	cs
  41053c:	4613      	movcs	r3, r2
  41053e:	803b      	strh	r3, [r7, #0]
  410540:	210a      	movs	r1, #10
  410542:	6878      	ldr	r0, [r7, #4]
  410544:	4b5e      	ldr	r3, [pc, #376]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  410546:	4798      	blx	r3
  410548:	4603      	mov	r3, r0
  41054a:	2b00      	cmp	r3, #0
  41054c:	f000 8138 	beq.w	4107c0 <inv_icm20648_augmented_sensors_set_odr+0x434>
  410550:	687b      	ldr	r3, [r7, #4]
  410552:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  410556:	883b      	ldrh	r3, [r7, #0]
  410558:	4293      	cmp	r3, r2
  41055a:	bf28      	it	cs
  41055c:	4613      	movcs	r3, r2
  41055e:	803b      	strh	r3, [r7, #0]
			break;
  410560:	e12e      	b.n	4107c0 <inv_icm20648_augmented_sensors_set_odr+0x434>
        case ANDROID_SENSOR_ORIENTATION:
			s->sOriOdrMs = delayInMs;
  410562:	687b      	ldr	r3, [r7, #4]
  410564:	883a      	ldrh	r2, [r7, #0]
  410566:	f8a3 24ec 	strh.w	r2, [r3, #1260]	; 0x4ec
			AUGMENTED_SENSOR_GET_9QUAT_MIN_ODR(s, delayInMs);
  41056a:	2103      	movs	r1, #3
  41056c:	6878      	ldr	r0, [r7, #4]
  41056e:	4b54      	ldr	r3, [pc, #336]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  410570:	4798      	blx	r3
  410572:	4603      	mov	r3, r0
  410574:	2b00      	cmp	r3, #0
  410576:	d007      	beq.n	410588 <inv_icm20648_augmented_sensors_set_odr+0x1fc>
  410578:	687b      	ldr	r3, [r7, #4]
  41057a:	f8b3 24ec 	ldrh.w	r2, [r3, #1260]	; 0x4ec
  41057e:	883b      	ldrh	r3, [r7, #0]
  410580:	4293      	cmp	r3, r2
  410582:	bf28      	it	cs
  410584:	4613      	movcs	r3, r2
  410586:	803b      	strh	r3, [r7, #0]
  410588:	210b      	movs	r1, #11
  41058a:	6878      	ldr	r0, [r7, #4]
  41058c:	4b4c      	ldr	r3, [pc, #304]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  41058e:	4798      	blx	r3
  410590:	4603      	mov	r3, r0
  410592:	2b00      	cmp	r3, #0
  410594:	f000 8116 	beq.w	4107c4 <inv_icm20648_augmented_sensors_set_odr+0x438>
  410598:	687b      	ldr	r3, [r7, #4]
  41059a:	f8b3 24ea 	ldrh.w	r2, [r3, #1258]	; 0x4ea
  41059e:	883b      	ldrh	r3, [r7, #0]
  4105a0:	4293      	cmp	r3, r2
  4105a2:	bf28      	it	cs
  4105a4:	4613      	movcs	r3, r2
  4105a6:	803b      	strh	r3, [r7, #0]
			break;
  4105a8:	e10c      	b.n	4107c4 <inv_icm20648_augmented_sensors_set_odr+0x438>
        case ANDROID_SENSOR_ROTATION_VECTOR:
			s->sRvOdrMs = delayInMs;
  4105aa:	687b      	ldr	r3, [r7, #4]
  4105ac:	883a      	ldrh	r2, [r7, #0]
  4105ae:	f8a3 24ea 	strh.w	r2, [r3, #1258]	; 0x4ea
			AUGMENTED_SENSOR_GET_9QUAT_MIN_ODR(s, delayInMs);
  4105b2:	2103      	movs	r1, #3
  4105b4:	6878      	ldr	r0, [r7, #4]
  4105b6:	4b42      	ldr	r3, [pc, #264]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  4105b8:	4798      	blx	r3
  4105ba:	4603      	mov	r3, r0
  4105bc:	2b00      	cmp	r3, #0
  4105be:	d007      	beq.n	4105d0 <inv_icm20648_augmented_sensors_set_odr+0x244>
  4105c0:	687b      	ldr	r3, [r7, #4]
  4105c2:	f8b3 24ec 	ldrh.w	r2, [r3, #1260]	; 0x4ec
  4105c6:	883b      	ldrh	r3, [r7, #0]
  4105c8:	4293      	cmp	r3, r2
  4105ca:	bf28      	it	cs
  4105cc:	4613      	movcs	r3, r2
  4105ce:	803b      	strh	r3, [r7, #0]
  4105d0:	210b      	movs	r1, #11
  4105d2:	6878      	ldr	r0, [r7, #4]
  4105d4:	4b3a      	ldr	r3, [pc, #232]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  4105d6:	4798      	blx	r3
  4105d8:	4603      	mov	r3, r0
  4105da:	2b00      	cmp	r3, #0
  4105dc:	f000 80f4 	beq.w	4107c8 <inv_icm20648_augmented_sensors_set_odr+0x43c>
  4105e0:	687b      	ldr	r3, [r7, #4]
  4105e2:	f8b3 24ea 	ldrh.w	r2, [r3, #1258]	; 0x4ea
  4105e6:	883b      	ldrh	r3, [r7, #0]
  4105e8:	4293      	cmp	r3, r2
  4105ea:	bf28      	it	cs
  4105ec:	4613      	movcs	r3, r2
  4105ee:	803b      	strh	r3, [r7, #0]
			break;
  4105f0:	e0ea      	b.n	4107c8 <inv_icm20648_augmented_sensors_set_odr+0x43c>
		case ANDROID_SENSOR_WAKEUP_GRAVITY:
			s->sGravityWuOdrMs = delayInMs;
  4105f2:	687b      	ldr	r3, [r7, #4]
  4105f4:	883a      	ldrh	r2, [r7, #0]
  4105f6:	f8a3 24e4 	strh.w	r2, [r3, #1252]	; 0x4e4
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, delayInMs);
  4105fa:	211d      	movs	r1, #29
  4105fc:	6878      	ldr	r0, [r7, #4]
  4105fe:	4b30      	ldr	r3, [pc, #192]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  410600:	4798      	blx	r3
  410602:	4603      	mov	r3, r0
  410604:	2b00      	cmp	r3, #0
  410606:	d007      	beq.n	410618 <inv_icm20648_augmented_sensors_set_odr+0x28c>
  410608:	687b      	ldr	r3, [r7, #4]
  41060a:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  41060e:	883b      	ldrh	r3, [r7, #0]
  410610:	4293      	cmp	r3, r2
  410612:	bf28      	it	cs
  410614:	4613      	movcs	r3, r2
  410616:	803b      	strh	r3, [r7, #0]
  410618:	2123      	movs	r1, #35	; 0x23
  41061a:	6878      	ldr	r0, [r7, #4]
  41061c:	4b28      	ldr	r3, [pc, #160]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  41061e:	4798      	blx	r3
  410620:	4603      	mov	r3, r0
  410622:	2b00      	cmp	r3, #0
  410624:	d007      	beq.n	410636 <inv_icm20648_augmented_sensors_set_odr+0x2aa>
  410626:	687b      	ldr	r3, [r7, #4]
  410628:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  41062c:	883b      	ldrh	r3, [r7, #0]
  41062e:	4293      	cmp	r3, r2
  410630:	bf28      	it	cs
  410632:	4613      	movcs	r3, r2
  410634:	803b      	strh	r3, [r7, #0]
  410636:	211e      	movs	r1, #30
  410638:	6878      	ldr	r0, [r7, #4]
  41063a:	4b21      	ldr	r3, [pc, #132]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  41063c:	4798      	blx	r3
  41063e:	4603      	mov	r3, r0
  410640:	2b00      	cmp	r3, #0
  410642:	f000 80c3 	beq.w	4107cc <inv_icm20648_augmented_sensors_set_odr+0x440>
  410646:	687b      	ldr	r3, [r7, #4]
  410648:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  41064c:	883b      	ldrh	r3, [r7, #0]
  41064e:	4293      	cmp	r3, r2
  410650:	bf28      	it	cs
  410652:	4613      	movcs	r3, r2
  410654:	803b      	strh	r3, [r7, #0]
			break;
  410656:	e0b9      	b.n	4107cc <inv_icm20648_augmented_sensors_set_odr+0x440>
        case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
			s->sGrvWuOdrMs = delayInMs;
  410658:	687b      	ldr	r3, [r7, #4]
  41065a:	883a      	ldrh	r2, [r7, #0]
  41065c:	f8a3 24e6 	strh.w	r2, [r3, #1254]	; 0x4e6
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, delayInMs);
  410660:	211d      	movs	r1, #29
  410662:	6878      	ldr	r0, [r7, #4]
  410664:	4b16      	ldr	r3, [pc, #88]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  410666:	4798      	blx	r3
  410668:	4603      	mov	r3, r0
  41066a:	2b00      	cmp	r3, #0
  41066c:	d007      	beq.n	41067e <inv_icm20648_augmented_sensors_set_odr+0x2f2>
  41066e:	687b      	ldr	r3, [r7, #4]
  410670:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  410674:	883b      	ldrh	r3, [r7, #0]
  410676:	4293      	cmp	r3, r2
  410678:	bf28      	it	cs
  41067a:	4613      	movcs	r3, r2
  41067c:	803b      	strh	r3, [r7, #0]
  41067e:	2123      	movs	r1, #35	; 0x23
  410680:	6878      	ldr	r0, [r7, #4]
  410682:	4b0f      	ldr	r3, [pc, #60]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  410684:	4798      	blx	r3
  410686:	4603      	mov	r3, r0
  410688:	2b00      	cmp	r3, #0
  41068a:	d007      	beq.n	41069c <inv_icm20648_augmented_sensors_set_odr+0x310>
  41068c:	687b      	ldr	r3, [r7, #4]
  41068e:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  410692:	883b      	ldrh	r3, [r7, #0]
  410694:	4293      	cmp	r3, r2
  410696:	bf28      	it	cs
  410698:	4613      	movcs	r3, r2
  41069a:	803b      	strh	r3, [r7, #0]
  41069c:	211e      	movs	r1, #30
  41069e:	6878      	ldr	r0, [r7, #4]
  4106a0:	4b07      	ldr	r3, [pc, #28]	; (4106c0 <inv_icm20648_augmented_sensors_set_odr+0x334>)
  4106a2:	4798      	blx	r3
  4106a4:	4603      	mov	r3, r0
  4106a6:	2b00      	cmp	r3, #0
  4106a8:	f000 8092 	beq.w	4107d0 <inv_icm20648_augmented_sensors_set_odr+0x444>
  4106ac:	687b      	ldr	r3, [r7, #4]
  4106ae:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  4106b2:	883b      	ldrh	r3, [r7, #0]
  4106b4:	4293      	cmp	r3, r2
  4106b6:	bf28      	it	cs
  4106b8:	4613      	movcs	r3, r2
  4106ba:	803b      	strh	r3, [r7, #0]
			break;
  4106bc:	e088      	b.n	4107d0 <inv_icm20648_augmented_sensors_set_odr+0x444>
  4106be:	bf00      	nop
  4106c0:	004109f1 	.word	0x004109f1
        case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
			s->sLinAccWuOdrMs = delayInMs;
  4106c4:	687b      	ldr	r3, [r7, #4]
  4106c6:	883a      	ldrh	r2, [r7, #0]
  4106c8:	f8a3 24e8 	strh.w	r2, [r3, #1256]	; 0x4e8
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, delayInMs);
  4106cc:	211d      	movs	r1, #29
  4106ce:	6878      	ldr	r0, [r7, #4]
  4106d0:	4b45      	ldr	r3, [pc, #276]	; (4107e8 <inv_icm20648_augmented_sensors_set_odr+0x45c>)
  4106d2:	4798      	blx	r3
  4106d4:	4603      	mov	r3, r0
  4106d6:	2b00      	cmp	r3, #0
  4106d8:	d007      	beq.n	4106ea <inv_icm20648_augmented_sensors_set_odr+0x35e>
  4106da:	687b      	ldr	r3, [r7, #4]
  4106dc:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  4106e0:	883b      	ldrh	r3, [r7, #0]
  4106e2:	4293      	cmp	r3, r2
  4106e4:	bf28      	it	cs
  4106e6:	4613      	movcs	r3, r2
  4106e8:	803b      	strh	r3, [r7, #0]
  4106ea:	2123      	movs	r1, #35	; 0x23
  4106ec:	6878      	ldr	r0, [r7, #4]
  4106ee:	4b3e      	ldr	r3, [pc, #248]	; (4107e8 <inv_icm20648_augmented_sensors_set_odr+0x45c>)
  4106f0:	4798      	blx	r3
  4106f2:	4603      	mov	r3, r0
  4106f4:	2b00      	cmp	r3, #0
  4106f6:	d007      	beq.n	410708 <inv_icm20648_augmented_sensors_set_odr+0x37c>
  4106f8:	687b      	ldr	r3, [r7, #4]
  4106fa:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  4106fe:	883b      	ldrh	r3, [r7, #0]
  410700:	4293      	cmp	r3, r2
  410702:	bf28      	it	cs
  410704:	4613      	movcs	r3, r2
  410706:	803b      	strh	r3, [r7, #0]
  410708:	211e      	movs	r1, #30
  41070a:	6878      	ldr	r0, [r7, #4]
  41070c:	4b36      	ldr	r3, [pc, #216]	; (4107e8 <inv_icm20648_augmented_sensors_set_odr+0x45c>)
  41070e:	4798      	blx	r3
  410710:	4603      	mov	r3, r0
  410712:	2b00      	cmp	r3, #0
  410714:	d05e      	beq.n	4107d4 <inv_icm20648_augmented_sensors_set_odr+0x448>
  410716:	687b      	ldr	r3, [r7, #4]
  410718:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  41071c:	883b      	ldrh	r3, [r7, #0]
  41071e:	4293      	cmp	r3, r2
  410720:	bf28      	it	cs
  410722:	4613      	movcs	r3, r2
  410724:	803b      	strh	r3, [r7, #0]
			break;
  410726:	e055      	b.n	4107d4 <inv_icm20648_augmented_sensors_set_odr+0x448>
        case ANDROID_SENSOR_WAKEUP_ORIENTATION:
			s->sOriWuOdrMs = delayInMs;
  410728:	687b      	ldr	r3, [r7, #4]
  41072a:	883a      	ldrh	r2, [r7, #0]
  41072c:	f8a3 24f0 	strh.w	r2, [r3, #1264]	; 0x4f0
			AUGMENTED_SENSOR_GET_9QUATWU_MIN_ODR(s, delayInMs);
  410730:	2119      	movs	r1, #25
  410732:	6878      	ldr	r0, [r7, #4]
  410734:	4b2c      	ldr	r3, [pc, #176]	; (4107e8 <inv_icm20648_augmented_sensors_set_odr+0x45c>)
  410736:	4798      	blx	r3
  410738:	4603      	mov	r3, r0
  41073a:	2b00      	cmp	r3, #0
  41073c:	d007      	beq.n	41074e <inv_icm20648_augmented_sensors_set_odr+0x3c2>
  41073e:	687b      	ldr	r3, [r7, #4]
  410740:	f8b3 24f0 	ldrh.w	r2, [r3, #1264]	; 0x4f0
  410744:	883b      	ldrh	r3, [r7, #0]
  410746:	4293      	cmp	r3, r2
  410748:	bf28      	it	cs
  41074a:	4613      	movcs	r3, r2
  41074c:	803b      	strh	r3, [r7, #0]
  41074e:	211f      	movs	r1, #31
  410750:	6878      	ldr	r0, [r7, #4]
  410752:	4b25      	ldr	r3, [pc, #148]	; (4107e8 <inv_icm20648_augmented_sensors_set_odr+0x45c>)
  410754:	4798      	blx	r3
  410756:	4603      	mov	r3, r0
  410758:	2b00      	cmp	r3, #0
  41075a:	d03d      	beq.n	4107d8 <inv_icm20648_augmented_sensors_set_odr+0x44c>
  41075c:	687b      	ldr	r3, [r7, #4]
  41075e:	f8b3 24ee 	ldrh.w	r2, [r3, #1262]	; 0x4ee
  410762:	883b      	ldrh	r3, [r7, #0]
  410764:	4293      	cmp	r3, r2
  410766:	bf28      	it	cs
  410768:	4613      	movcs	r3, r2
  41076a:	803b      	strh	r3, [r7, #0]
			break;
  41076c:	e034      	b.n	4107d8 <inv_icm20648_augmented_sensors_set_odr+0x44c>
        case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
			s->sRvWuOdrMs = delayInMs;
  41076e:	687b      	ldr	r3, [r7, #4]
  410770:	883a      	ldrh	r2, [r7, #0]
  410772:	f8a3 24ee 	strh.w	r2, [r3, #1262]	; 0x4ee
			AUGMENTED_SENSOR_GET_9QUATWU_MIN_ODR(s, delayInMs);
  410776:	2119      	movs	r1, #25
  410778:	6878      	ldr	r0, [r7, #4]
  41077a:	4b1b      	ldr	r3, [pc, #108]	; (4107e8 <inv_icm20648_augmented_sensors_set_odr+0x45c>)
  41077c:	4798      	blx	r3
  41077e:	4603      	mov	r3, r0
  410780:	2b00      	cmp	r3, #0
  410782:	d007      	beq.n	410794 <inv_icm20648_augmented_sensors_set_odr+0x408>
  410784:	687b      	ldr	r3, [r7, #4]
  410786:	f8b3 24f0 	ldrh.w	r2, [r3, #1264]	; 0x4f0
  41078a:	883b      	ldrh	r3, [r7, #0]
  41078c:	4293      	cmp	r3, r2
  41078e:	bf28      	it	cs
  410790:	4613      	movcs	r3, r2
  410792:	803b      	strh	r3, [r7, #0]
  410794:	211f      	movs	r1, #31
  410796:	6878      	ldr	r0, [r7, #4]
  410798:	4b13      	ldr	r3, [pc, #76]	; (4107e8 <inv_icm20648_augmented_sensors_set_odr+0x45c>)
  41079a:	4798      	blx	r3
  41079c:	4603      	mov	r3, r0
  41079e:	2b00      	cmp	r3, #0
  4107a0:	d01c      	beq.n	4107dc <inv_icm20648_augmented_sensors_set_odr+0x450>
  4107a2:	687b      	ldr	r3, [r7, #4]
  4107a4:	f8b3 24ee 	ldrh.w	r2, [r3, #1262]	; 0x4ee
  4107a8:	883b      	ldrh	r3, [r7, #0]
  4107aa:	4293      	cmp	r3, r2
  4107ac:	bf28      	it	cs
  4107ae:	4613      	movcs	r3, r2
  4107b0:	803b      	strh	r3, [r7, #0]
			break;
  4107b2:	e013      	b.n	4107dc <inv_icm20648_augmented_sensors_set_odr+0x450>
		default :
			break;
  4107b4:	bf00      	nop
  4107b6:	e012      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107b8:	bf00      	nop
  4107ba:	e010      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107bc:	bf00      	nop
  4107be:	e00e      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107c0:	bf00      	nop
  4107c2:	e00c      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107c4:	bf00      	nop
  4107c6:	e00a      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107c8:	bf00      	nop
  4107ca:	e008      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107cc:	bf00      	nop
  4107ce:	e006      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107d0:	bf00      	nop
  4107d2:	e004      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107d4:	bf00      	nop
  4107d6:	e002      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107d8:	bf00      	nop
  4107da:	e000      	b.n	4107de <inv_icm20648_augmented_sensors_set_odr+0x452>
			break;
  4107dc:	bf00      	nop
	}

	return delayInMs;
  4107de:	883b      	ldrh	r3, [r7, #0]
}
  4107e0:	4618      	mov	r0, r3
  4107e2:	3708      	adds	r7, #8
  4107e4:	46bd      	mov	sp, r7
  4107e6:	bd80      	pop	{r7, pc}
  4107e8:	004109f1 	.word	0x004109f1

004107ec <inv_icm20648_augmented_sensors_update_odr>:


void inv_icm20648_augmented_sensors_update_odr(struct inv_icm20648 * s, unsigned char androidSensor, unsigned short * updatedDelayPtr)
{
  4107ec:	b580      	push	{r7, lr}
  4107ee:	b086      	sub	sp, #24
  4107f0:	af00      	add	r7, sp, #0
  4107f2:	60f8      	str	r0, [r7, #12]
  4107f4:	460b      	mov	r3, r1
  4107f6:	607a      	str	r2, [r7, #4]
  4107f8:	72fb      	strb	r3, [r7, #11]
	unsigned short lDelayInMs = 0xFFFF; // max value of uint16_t, so that we can get min value of all enabled sensors
  4107fa:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4107fe:	82fb      	strh	r3, [r7, #22]
	switch(androidSensor)
  410800:	7afb      	ldrb	r3, [r7, #11]
  410802:	3b03      	subs	r3, #3
  410804:	2b20      	cmp	r3, #32
  410806:	f200 80eb 	bhi.w	4109e0 <inv_icm20648_augmented_sensors_update_odr+0x1f4>
  41080a:	a201      	add	r2, pc, #4	; (adr r2, 410810 <inv_icm20648_augmented_sensors_update_odr+0x24>)
  41080c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  410810:	00410959 	.word	0x00410959
  410814:	004109e1 	.word	0x004109e1
  410818:	004109e1 	.word	0x004109e1
  41081c:	004109e1 	.word	0x004109e1
  410820:	004109e1 	.word	0x004109e1
  410824:	004109e1 	.word	0x004109e1
  410828:	00410895 	.word	0x00410895
  41082c:	00410895 	.word	0x00410895
  410830:	00410959 	.word	0x00410959
  410834:	004109e1 	.word	0x004109e1
  410838:	004109e1 	.word	0x004109e1
  41083c:	004109e1 	.word	0x004109e1
  410840:	00410895 	.word	0x00410895
  410844:	004109e1 	.word	0x004109e1
  410848:	004109e1 	.word	0x004109e1
  41084c:	004109e1 	.word	0x004109e1
  410850:	004109e1 	.word	0x004109e1
  410854:	004109e1 	.word	0x004109e1
  410858:	004109e1 	.word	0x004109e1
  41085c:	004109e1 	.word	0x004109e1
  410860:	004109e1 	.word	0x004109e1
  410864:	004109e1 	.word	0x004109e1
  410868:	0041099d 	.word	0x0041099d
  41086c:	004109e1 	.word	0x004109e1
  410870:	004109e1 	.word	0x004109e1
  410874:	004109e1 	.word	0x004109e1
  410878:	004108f7 	.word	0x004108f7
  41087c:	004108f7 	.word	0x004108f7
  410880:	0041099d 	.word	0x0041099d
  410884:	004109e1 	.word	0x004109e1
  410888:	004109e1 	.word	0x004109e1
  41088c:	004109e1 	.word	0x004109e1
  410890:	004108f7 	.word	0x004108f7
	{
		case ANDROID_SENSOR_GRAVITY:
        case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
        case ANDROID_SENSOR_LINEAR_ACCELERATION:
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, lDelayInMs);
  410894:	2109      	movs	r1, #9
  410896:	68f8      	ldr	r0, [r7, #12]
  410898:	4b54      	ldr	r3, [pc, #336]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  41089a:	4798      	blx	r3
  41089c:	4603      	mov	r3, r0
  41089e:	2b00      	cmp	r3, #0
  4108a0:	d007      	beq.n	4108b2 <inv_icm20648_augmented_sensors_update_odr+0xc6>
  4108a2:	68fb      	ldr	r3, [r7, #12]
  4108a4:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  4108a8:	8afb      	ldrh	r3, [r7, #22]
  4108aa:	4293      	cmp	r3, r2
  4108ac:	bf28      	it	cs
  4108ae:	4613      	movcs	r3, r2
  4108b0:	82fb      	strh	r3, [r7, #22]
  4108b2:	210f      	movs	r1, #15
  4108b4:	68f8      	ldr	r0, [r7, #12]
  4108b6:	4b4d      	ldr	r3, [pc, #308]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  4108b8:	4798      	blx	r3
  4108ba:	4603      	mov	r3, r0
  4108bc:	2b00      	cmp	r3, #0
  4108be:	d007      	beq.n	4108d0 <inv_icm20648_augmented_sensors_update_odr+0xe4>
  4108c0:	68fb      	ldr	r3, [r7, #12]
  4108c2:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  4108c6:	8afb      	ldrh	r3, [r7, #22]
  4108c8:	4293      	cmp	r3, r2
  4108ca:	bf28      	it	cs
  4108cc:	4613      	movcs	r3, r2
  4108ce:	82fb      	strh	r3, [r7, #22]
  4108d0:	210a      	movs	r1, #10
  4108d2:	68f8      	ldr	r0, [r7, #12]
  4108d4:	4b45      	ldr	r3, [pc, #276]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  4108d6:	4798      	blx	r3
  4108d8:	4603      	mov	r3, r0
  4108da:	2b00      	cmp	r3, #0
  4108dc:	d007      	beq.n	4108ee <inv_icm20648_augmented_sensors_update_odr+0x102>
  4108de:	68fb      	ldr	r3, [r7, #12]
  4108e0:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  4108e4:	8afb      	ldrh	r3, [r7, #22]
  4108e6:	4293      	cmp	r3, r2
  4108e8:	bf28      	it	cs
  4108ea:	4613      	movcs	r3, r2
  4108ec:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  4108ee:	687b      	ldr	r3, [r7, #4]
  4108f0:	8afa      	ldrh	r2, [r7, #22]
  4108f2:	801a      	strh	r2, [r3, #0]
			break;
  4108f4:	e075      	b.n	4109e2 <inv_icm20648_augmented_sensors_update_odr+0x1f6>
		case ANDROID_SENSOR_WAKEUP_GRAVITY:
        case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
        case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, lDelayInMs);
  4108f6:	211d      	movs	r1, #29
  4108f8:	68f8      	ldr	r0, [r7, #12]
  4108fa:	4b3c      	ldr	r3, [pc, #240]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  4108fc:	4798      	blx	r3
  4108fe:	4603      	mov	r3, r0
  410900:	2b00      	cmp	r3, #0
  410902:	d007      	beq.n	410914 <inv_icm20648_augmented_sensors_update_odr+0x128>
  410904:	68fb      	ldr	r3, [r7, #12]
  410906:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  41090a:	8afb      	ldrh	r3, [r7, #22]
  41090c:	4293      	cmp	r3, r2
  41090e:	bf28      	it	cs
  410910:	4613      	movcs	r3, r2
  410912:	82fb      	strh	r3, [r7, #22]
  410914:	2123      	movs	r1, #35	; 0x23
  410916:	68f8      	ldr	r0, [r7, #12]
  410918:	4b34      	ldr	r3, [pc, #208]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  41091a:	4798      	blx	r3
  41091c:	4603      	mov	r3, r0
  41091e:	2b00      	cmp	r3, #0
  410920:	d007      	beq.n	410932 <inv_icm20648_augmented_sensors_update_odr+0x146>
  410922:	68fb      	ldr	r3, [r7, #12]
  410924:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  410928:	8afb      	ldrh	r3, [r7, #22]
  41092a:	4293      	cmp	r3, r2
  41092c:	bf28      	it	cs
  41092e:	4613      	movcs	r3, r2
  410930:	82fb      	strh	r3, [r7, #22]
  410932:	211e      	movs	r1, #30
  410934:	68f8      	ldr	r0, [r7, #12]
  410936:	4b2d      	ldr	r3, [pc, #180]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  410938:	4798      	blx	r3
  41093a:	4603      	mov	r3, r0
  41093c:	2b00      	cmp	r3, #0
  41093e:	d007      	beq.n	410950 <inv_icm20648_augmented_sensors_update_odr+0x164>
  410940:	68fb      	ldr	r3, [r7, #12]
  410942:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  410946:	8afb      	ldrh	r3, [r7, #22]
  410948:	4293      	cmp	r3, r2
  41094a:	bf28      	it	cs
  41094c:	4613      	movcs	r3, r2
  41094e:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  410950:	687b      	ldr	r3, [r7, #4]
  410952:	8afa      	ldrh	r2, [r7, #22]
  410954:	801a      	strh	r2, [r3, #0]
			break;
  410956:	e044      	b.n	4109e2 <inv_icm20648_augmented_sensors_update_odr+0x1f6>
		case ANDROID_SENSOR_ORIENTATION:
        case ANDROID_SENSOR_ROTATION_VECTOR:
			AUGMENTED_SENSOR_GET_9QUAT_MIN_ODR(s, lDelayInMs);
  410958:	2103      	movs	r1, #3
  41095a:	68f8      	ldr	r0, [r7, #12]
  41095c:	4b23      	ldr	r3, [pc, #140]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  41095e:	4798      	blx	r3
  410960:	4603      	mov	r3, r0
  410962:	2b00      	cmp	r3, #0
  410964:	d007      	beq.n	410976 <inv_icm20648_augmented_sensors_update_odr+0x18a>
  410966:	68fb      	ldr	r3, [r7, #12]
  410968:	f8b3 24ec 	ldrh.w	r2, [r3, #1260]	; 0x4ec
  41096c:	8afb      	ldrh	r3, [r7, #22]
  41096e:	4293      	cmp	r3, r2
  410970:	bf28      	it	cs
  410972:	4613      	movcs	r3, r2
  410974:	82fb      	strh	r3, [r7, #22]
  410976:	210b      	movs	r1, #11
  410978:	68f8      	ldr	r0, [r7, #12]
  41097a:	4b1c      	ldr	r3, [pc, #112]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  41097c:	4798      	blx	r3
  41097e:	4603      	mov	r3, r0
  410980:	2b00      	cmp	r3, #0
  410982:	d007      	beq.n	410994 <inv_icm20648_augmented_sensors_update_odr+0x1a8>
  410984:	68fb      	ldr	r3, [r7, #12]
  410986:	f8b3 24ea 	ldrh.w	r2, [r3, #1258]	; 0x4ea
  41098a:	8afb      	ldrh	r3, [r7, #22]
  41098c:	4293      	cmp	r3, r2
  41098e:	bf28      	it	cs
  410990:	4613      	movcs	r3, r2
  410992:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  410994:	687b      	ldr	r3, [r7, #4]
  410996:	8afa      	ldrh	r2, [r7, #22]
  410998:	801a      	strh	r2, [r3, #0]
			break;
  41099a:	e022      	b.n	4109e2 <inv_icm20648_augmented_sensors_update_odr+0x1f6>
		case ANDROID_SENSOR_WAKEUP_ORIENTATION:
        case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
			AUGMENTED_SENSOR_GET_9QUATWU_MIN_ODR(s, lDelayInMs);
  41099c:	2119      	movs	r1, #25
  41099e:	68f8      	ldr	r0, [r7, #12]
  4109a0:	4b12      	ldr	r3, [pc, #72]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  4109a2:	4798      	blx	r3
  4109a4:	4603      	mov	r3, r0
  4109a6:	2b00      	cmp	r3, #0
  4109a8:	d007      	beq.n	4109ba <inv_icm20648_augmented_sensors_update_odr+0x1ce>
  4109aa:	68fb      	ldr	r3, [r7, #12]
  4109ac:	f8b3 24f0 	ldrh.w	r2, [r3, #1264]	; 0x4f0
  4109b0:	8afb      	ldrh	r3, [r7, #22]
  4109b2:	4293      	cmp	r3, r2
  4109b4:	bf28      	it	cs
  4109b6:	4613      	movcs	r3, r2
  4109b8:	82fb      	strh	r3, [r7, #22]
  4109ba:	211f      	movs	r1, #31
  4109bc:	68f8      	ldr	r0, [r7, #12]
  4109be:	4b0b      	ldr	r3, [pc, #44]	; (4109ec <inv_icm20648_augmented_sensors_update_odr+0x200>)
  4109c0:	4798      	blx	r3
  4109c2:	4603      	mov	r3, r0
  4109c4:	2b00      	cmp	r3, #0
  4109c6:	d007      	beq.n	4109d8 <inv_icm20648_augmented_sensors_update_odr+0x1ec>
  4109c8:	68fb      	ldr	r3, [r7, #12]
  4109ca:	f8b3 24ee 	ldrh.w	r2, [r3, #1262]	; 0x4ee
  4109ce:	8afb      	ldrh	r3, [r7, #22]
  4109d0:	4293      	cmp	r3, r2
  4109d2:	bf28      	it	cs
  4109d4:	4613      	movcs	r3, r2
  4109d6:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  4109d8:	687b      	ldr	r3, [r7, #4]
  4109da:	8afa      	ldrh	r2, [r7, #22]
  4109dc:	801a      	strh	r2, [r3, #0]
			break;
  4109de:	e000      	b.n	4109e2 <inv_icm20648_augmented_sensors_update_odr+0x1f6>
		default :
			break;
  4109e0:	bf00      	nop
	}

}
  4109e2:	bf00      	nop
  4109e4:	3718      	adds	r7, #24
  4109e6:	46bd      	mov	sp, r7
  4109e8:	bd80      	pop	{r7, pc}
  4109ea:	bf00      	nop
  4109ec:	004109f1 	.word	0x004109f1

004109f0 <inv_icm20648_ctrl_androidSensor_enabled>:
static int inv_set_hw_smplrt_dmp_odrs(struct inv_icm20648 * s);
static void inv_reGenerate_sensorControl(struct inv_icm20648 * s, const short *sen_num_2_ctrl, unsigned short *sensor_control, uint8_t header2_count);
static short get_multiple_56_rate(unsigned short delayInMs);

unsigned long inv_icm20648_ctrl_androidSensor_enabled(struct inv_icm20648 * s, unsigned char androidSensor)
{
  4109f0:	b480      	push	{r7}
  4109f2:	b083      	sub	sp, #12
  4109f4:	af00      	add	r7, sp, #0
  4109f6:	6078      	str	r0, [r7, #4]
  4109f8:	460b      	mov	r3, r1
  4109fa:	70fb      	strb	r3, [r7, #3]
	return s->inv_androidSensorsOn_mask[(androidSensor>>5)] & (1L << (androidSensor&0x1F));
  4109fc:	78fb      	ldrb	r3, [r7, #3]
  4109fe:	095b      	lsrs	r3, r3, #5
  410a00:	b2db      	uxtb	r3, r3
  410a02:	461a      	mov	r2, r3
  410a04:	687b      	ldr	r3, [r7, #4]
  410a06:	3258      	adds	r2, #88	; 0x58
  410a08:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  410a0c:	78fa      	ldrb	r2, [r7, #3]
  410a0e:	f002 021f 	and.w	r2, r2, #31
  410a12:	2101      	movs	r1, #1
  410a14:	fa01 f202 	lsl.w	r2, r1, r2
  410a18:	4013      	ands	r3, r2
}
  410a1a:	4618      	mov	r0, r3
  410a1c:	370c      	adds	r7, #12
  410a1e:	46bd      	mov	sp, r7
  410a20:	f85d 7b04 	ldr.w	r7, [sp], #4
  410a24:	4770      	bx	lr
	...

00410a28 <MinDelayGenActual>:
}	MinDelayGenElementT;

#define MinDelayGen(s, list) MinDelayGenActual(s, list, sizeof(list) / sizeof (MinDelayGenElementT))

static unsigned short MinDelayGenActual(struct inv_icm20648 *s, const MinDelayGenElementT *element, unsigned long elementQuan)
{
  410a28:	b580      	push	{r7, lr}
  410a2a:	b086      	sub	sp, #24
  410a2c:	af00      	add	r7, sp, #0
  410a2e:	60f8      	str	r0, [r7, #12]
  410a30:	60b9      	str	r1, [r7, #8]
  410a32:	607a      	str	r2, [r7, #4]
	unsigned short minDelay = (unsigned short) -1;
  410a34:	f64f 73ff 	movw	r3, #65535	; 0xffff
  410a38:	82fb      	strh	r3, [r7, #22]

	while(elementQuan--) {
  410a3a:	e019      	b.n	410a70 <MinDelayGenActual+0x48>
		if (inv_icm20648_ctrl_androidSensor_enabled(s, element->AndroidSensor)) {
  410a3c:	68bb      	ldr	r3, [r7, #8]
  410a3e:	781b      	ldrb	r3, [r3, #0]
  410a40:	4619      	mov	r1, r3
  410a42:	68f8      	ldr	r0, [r7, #12]
  410a44:	4b0f      	ldr	r3, [pc, #60]	; (410a84 <MinDelayGenActual+0x5c>)
  410a46:	4798      	blx	r3
  410a48:	4603      	mov	r3, r0
  410a4a:	2b00      	cmp	r3, #0
  410a4c:	d00d      	beq.n	410a6a <MinDelayGenActual+0x42>
			unsigned short odrDelay = s->inv_dmp_odr_delays[element->InvSensor];
  410a4e:	68bb      	ldr	r3, [r7, #8]
  410a50:	785b      	ldrb	r3, [r3, #1]
  410a52:	68fa      	ldr	r2, [r7, #12]
  410a54:	3380      	adds	r3, #128	; 0x80
  410a56:	005b      	lsls	r3, r3, #1
  410a58:	4413      	add	r3, r2
  410a5a:	88db      	ldrh	r3, [r3, #6]
  410a5c:	82bb      	strh	r3, [r7, #20]

			if (minDelay > odrDelay)
  410a5e:	8afa      	ldrh	r2, [r7, #22]
  410a60:	8abb      	ldrh	r3, [r7, #20]
  410a62:	429a      	cmp	r2, r3
  410a64:	d901      	bls.n	410a6a <MinDelayGenActual+0x42>
					minDelay = odrDelay;
  410a66:	8abb      	ldrh	r3, [r7, #20]
  410a68:	82fb      	strh	r3, [r7, #22]
		}
		element++;
  410a6a:	68bb      	ldr	r3, [r7, #8]
  410a6c:	3302      	adds	r3, #2
  410a6e:	60bb      	str	r3, [r7, #8]
	while(elementQuan--) {
  410a70:	687b      	ldr	r3, [r7, #4]
  410a72:	1e5a      	subs	r2, r3, #1
  410a74:	607a      	str	r2, [r7, #4]
  410a76:	2b00      	cmp	r3, #0
  410a78:	d1e0      	bne.n	410a3c <MinDelayGenActual+0x14>
	} // end while elements to process

	return	minDelay;
  410a7a:	8afb      	ldrh	r3, [r7, #22]
}
  410a7c:	4618      	mov	r0, r3
  410a7e:	3718      	adds	r7, #24
  410a80:	46bd      	mov	sp, r7
  410a82:	bd80      	pop	{r7, pc}
  410a84:	004109f1 	.word	0x004109f1

00410a88 <DividerRateSet>:

static int DividerRateSet(struct inv_icm20648 *s, unsigned short minDelay, unsigned short hwSampleRateDivider, enum INV_SENSORS InvSensor)
{
  410a88:	b580      	push	{r7, lr}
  410a8a:	b086      	sub	sp, #24
  410a8c:	af00      	add	r7, sp, #0
  410a8e:	60f8      	str	r0, [r7, #12]
  410a90:	4608      	mov	r0, r1
  410a92:	4611      	mov	r1, r2
  410a94:	461a      	mov	r2, r3
  410a96:	4603      	mov	r3, r0
  410a98:	817b      	strh	r3, [r7, #10]
  410a9a:	460b      	mov	r3, r1
  410a9c:	813b      	strh	r3, [r7, #8]
  410a9e:	4613      	mov	r3, r2
  410aa0:	71fb      	strb	r3, [r7, #7]
	int result = 0;
  410aa2:	2300      	movs	r3, #0
  410aa4:	617b      	str	r3, [r7, #20]

	if (minDelay != 0xFFFF) {
  410aa6:	897b      	ldrh	r3, [r7, #10]
  410aa8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  410aac:	4293      	cmp	r3, r2
  410aae:	d025      	beq.n	410afc <DividerRateSet+0x74>
		unsigned short dmpOdrDivider = (minDelay * 1125L) / (hwSampleRateDivider * 1000L); // a divider from (1125Hz/hw_smplrt_divider).
  410ab0:	897b      	ldrh	r3, [r7, #10]
  410ab2:	f240 4265 	movw	r2, #1125	; 0x465
  410ab6:	fb02 f203 	mul.w	r2, r2, r3
  410aba:	893b      	ldrh	r3, [r7, #8]
  410abc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  410ac0:	fb01 f303 	mul.w	r3, r1, r3
  410ac4:	fb92 f3f3 	sdiv	r3, r2, r3
  410ac8:	827b      	strh	r3, [r7, #18]

		s->inv_dmp_odr_dividers[InvSensor] = hwSampleRateDivider * dmpOdrDivider;
  410aca:	79fb      	ldrb	r3, [r7, #7]
  410acc:	8939      	ldrh	r1, [r7, #8]
  410ace:	8a7a      	ldrh	r2, [r7, #18]
  410ad0:	fb11 f202 	smulbb	r2, r1, r2
  410ad4:	b291      	uxth	r1, r2
  410ad6:	68fa      	ldr	r2, [r7, #12]
  410ad8:	335c      	adds	r3, #92	; 0x5c
  410ada:	005b      	lsls	r3, r3, #1
  410adc:	4413      	add	r3, r2
  410ade:	460a      	mov	r2, r1
  410ae0:	809a      	strh	r2, [r3, #4]
		result |= dmp_icm20648_set_sensor_rate(s, InvSensor, (dmpOdrDivider - 1));
  410ae2:	79f9      	ldrb	r1, [r7, #7]
  410ae4:	8a7b      	ldrh	r3, [r7, #18]
  410ae6:	3b01      	subs	r3, #1
  410ae8:	b29b      	uxth	r3, r3
  410aea:	b21b      	sxth	r3, r3
  410aec:	461a      	mov	r2, r3
  410aee:	68f8      	ldr	r0, [r7, #12]
  410af0:	4b05      	ldr	r3, [pc, #20]	; (410b08 <DividerRateSet+0x80>)
  410af2:	4798      	blx	r3
  410af4:	4602      	mov	r2, r0
  410af6:	697b      	ldr	r3, [r7, #20]
  410af8:	4313      	orrs	r3, r2
  410afa:	617b      	str	r3, [r7, #20]
	}

	return result;
  410afc:	697b      	ldr	r3, [r7, #20]
}
  410afe:	4618      	mov	r0, r3
  410b00:	3718      	adds	r7, #24
  410b02:	46bd      	mov	sp, r7
  410b04:	bd80      	pop	{r7, pc}
  410b06:	bf00      	nop
  410b08:	0040823d 	.word	0x0040823d

00410b0c <SampleRateDividerGet>:

static unsigned short SampleRateDividerGet(unsigned short minDelay)
{
  410b0c:	b480      	push	{r7}
  410b0e:	b085      	sub	sp, #20
  410b10:	af00      	add	r7, sp, #0
  410b12:	4603      	mov	r3, r0
  410b14:	80fb      	strh	r3, [r7, #6]
	unsigned short delay = min(INV_ODR_MIN_DELAY, minDelay); // because of GYRO_SMPLRT_DIV which relies on 8 bits, we can't have ODR value higher than 200ms
  410b16:	88fb      	ldrh	r3, [r7, #6]
  410b18:	2bc8      	cmp	r3, #200	; 0xc8
  410b1a:	bf28      	it	cs
  410b1c:	23c8      	movcs	r3, #200	; 0xc8
  410b1e:	81fb      	strh	r3, [r7, #14]
	return delay * 1125L / 1000L; // a divider from 1125Hz.
  410b20:	89fb      	ldrh	r3, [r7, #14]
  410b22:	f240 4265 	movw	r2, #1125	; 0x465
  410b26:	fb02 f303 	mul.w	r3, r2, r3
  410b2a:	4a06      	ldr	r2, [pc, #24]	; (410b44 <SampleRateDividerGet+0x38>)
  410b2c:	fb82 1203 	smull	r1, r2, r2, r3
  410b30:	1192      	asrs	r2, r2, #6
  410b32:	17db      	asrs	r3, r3, #31
  410b34:	1ad3      	subs	r3, r2, r3
  410b36:	b29b      	uxth	r3, r3
}
  410b38:	4618      	mov	r0, r3
  410b3a:	3714      	adds	r7, #20
  410b3c:	46bd      	mov	sp, r7
  410b3e:	f85d 7b04 	ldr.w	r7, [sp], #4
  410b42:	4770      	bx	lr
  410b44:	10624dd3 	.word	0x10624dd3

00410b48 <getMinDlyAccel>:

/** @brief Get minimum ODR to be applied to accel engine based on all accel-based enabled sensors.
* @return ODR in ms we expect to be applied to accel engine
*/
static unsigned short getMinDlyAccel(struct inv_icm20648 *s)
{
  410b48:	b5b0      	push	{r4, r5, r7, lr}
  410b4a:	b08e      	sub	sp, #56	; 0x38
  410b4c:	af00      	add	r7, sp, #0
  410b4e:	6078      	str	r0, [r7, #4]
	const MinDelayGenElementT MinDelayGenAccelList[] ={
  410b50:	4b4b      	ldr	r3, [pc, #300]	; (410c80 <getMinDlyAccel+0x138>)
  410b52:	f107 040c 	add.w	r4, r7, #12
  410b56:	461d      	mov	r5, r3
  410b58:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410b5a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410b5c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410b5e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410b60:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
  410b64:	c403      	stmia	r4!, {r0, r1}
  410b66:	8022      	strh	r2, [r4, #0]
		{ANDROID_SENSOR_ROTATION_VECTOR,                    INV_SENSOR_NINEQ_accel          },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ_accel   },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ_accel   }
	};

	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenAccelList);
  410b68:	f107 030c 	add.w	r3, r7, #12
  410b6c:	2215      	movs	r2, #21
  410b6e:	4619      	mov	r1, r3
  410b70:	6878      	ldr	r0, [r7, #4]
  410b72:	4b44      	ldr	r3, [pc, #272]	; (410c84 <getMinDlyAccel+0x13c>)
  410b74:	4798      	blx	r3
  410b76:	4603      	mov	r3, r0
  410b78:	86fb      	strh	r3, [r7, #54]	; 0x36

	if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER))
  410b7a:	2101      	movs	r1, #1
  410b7c:	6878      	ldr	r0, [r7, #4]
  410b7e:	4b42      	ldr	r3, [pc, #264]	; (410c88 <getMinDlyAccel+0x140>)
  410b80:	4798      	blx	r3
  410b82:	4603      	mov	r3, r0
  410b84:	2b00      	cmp	r3, #0
  410b86:	d01b      	beq.n	410bc0 <getMinDlyAccel+0x78>
		if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
  410b88:	212a      	movs	r1, #42	; 0x2a
  410b8a:	6878      	ldr	r0, [r7, #4]
  410b8c:	4b3e      	ldr	r3, [pc, #248]	; (410c88 <getMinDlyAccel+0x140>)
  410b8e:	4798      	blx	r3
  410b90:	4603      	mov	r3, r0
  410b92:	2b00      	cmp	r3, #0
  410b94:	d00d      	beq.n	410bb2 <getMinDlyAccel+0x6a>
			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(s->odr_acc_ms,s->odr_racc_ms);
  410b96:	687b      	ldr	r3, [r7, #4]
  410b98:	f8b3 2248 	ldrh.w	r2, [r3, #584]	; 0x248
  410b9c:	687b      	ldr	r3, [r7, #4]
  410b9e:	f8b3 3246 	ldrh.w	r3, [r3, #582]	; 0x246
  410ba2:	4293      	cmp	r3, r2
  410ba4:	bf28      	it	cs
  410ba6:	4613      	movcs	r3, r2
  410ba8:	b29a      	uxth	r2, r3
  410baa:	687b      	ldr	r3, [r7, #4]
  410bac:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  410bb0:	e013      	b.n	410bda <getMinDlyAccel+0x92>
		else
			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = s->odr_acc_ms;
  410bb2:	687b      	ldr	r3, [r7, #4]
  410bb4:	f8b3 2246 	ldrh.w	r2, [r3, #582]	; 0x246
  410bb8:	687b      	ldr	r3, [r7, #4]
  410bba:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  410bbe:	e00c      	b.n	410bda <getMinDlyAccel+0x92>
	else
		if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
  410bc0:	212a      	movs	r1, #42	; 0x2a
  410bc2:	6878      	ldr	r0, [r7, #4]
  410bc4:	4b30      	ldr	r3, [pc, #192]	; (410c88 <getMinDlyAccel+0x140>)
  410bc6:	4798      	blx	r3
  410bc8:	4603      	mov	r3, r0
  410bca:	2b00      	cmp	r3, #0
  410bcc:	d005      	beq.n	410bda <getMinDlyAccel+0x92>
			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = s->odr_racc_ms;
  410bce:	687b      	ldr	r3, [r7, #4]
  410bd0:	f8b3 2248 	ldrh.w	r2, [r3, #584]	; 0x248
  410bd4:	687b      	ldr	r3, [r7, #4]
  410bd6:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106

	if (s->bac_status != 0)
  410bda:	687b      	ldr	r3, [r7, #4]
  410bdc:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
  410be0:	2b00      	cmp	r3, #0
  410be2:	d007      	beq.n	410bf4 <getMinDlyAccel+0xac>
		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_ACTIVITY_CLASSIFIER]);
  410be4:	687b      	ldr	r3, [r7, #4]
  410be6:	f8b3 2120 	ldrh.w	r2, [r3, #288]	; 0x120
  410bea:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410bec:	4293      	cmp	r3, r2
  410bee:	bf28      	it	cs
  410bf0:	4613      	movcs	r3, r2
  410bf2:	86fb      	strh	r3, [r7, #54]	; 0x36
	if (s->flip_pickup_status != 0)
  410bf4:	687b      	ldr	r3, [r7, #4]
  410bf6:	f8b3 3158 	ldrh.w	r3, [r3, #344]	; 0x158
  410bfa:	2b00      	cmp	r3, #0
  410bfc:	d007      	beq.n	410c0e <getMinDlyAccel+0xc6>
		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_FLIP_PICKUP]);
  410bfe:	687b      	ldr	r3, [r7, #4]
  410c00:	f8b3 2122 	ldrh.w	r2, [r3, #290]	; 0x122
  410c04:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410c06:	4293      	cmp	r3, r2
  410c08:	bf28      	it	cs
  410c0a:	4613      	movcs	r3, r2
  410c0c:	86fb      	strh	r3, [r7, #54]	; 0x36
	if (s->b2s_status != 0)
  410c0e:	687b      	ldr	r3, [r7, #4]
  410c10:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  410c14:	2b00      	cmp	r3, #0
  410c16:	d007      	beq.n	410c28 <getMinDlyAccel+0xe0>
		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_BRING_TO_SEE]);
  410c18:	687b      	ldr	r3, [r7, #4]
  410c1a:	f8b3 2124 	ldrh.w	r2, [r3, #292]	; 0x124
  410c1e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410c20:	4293      	cmp	r3, r2
  410c22:	bf28      	it	cs
  410c24:	4613      	movcs	r3, r2
  410c26:	86fb      	strh	r3, [r7, #54]	; 0x36

	/** To have correct algorithm performance and quick convergence of GMRV, it is advised to set accelerometer to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR)
  410c28:	2127      	movs	r1, #39	; 0x27
  410c2a:	6878      	ldr	r0, [r7, #4]
  410c2c:	4b16      	ldr	r3, [pc, #88]	; (410c88 <getMinDlyAccel+0x140>)
  410c2e:	4798      	blx	r3
  410c30:	4603      	mov	r3, r0
  410c32:	2b00      	cmp	r3, #0
  410c34:	d106      	bne.n	410c44 <getMinDlyAccel+0xfc>
		|| inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) )
  410c36:	2114      	movs	r1, #20
  410c38:	6878      	ldr	r0, [r7, #4]
  410c3a:	4b13      	ldr	r3, [pc, #76]	; (410c88 <getMinDlyAccel+0x140>)
  410c3c:	4798      	blx	r3
  410c3e:	4603      	mov	r3, r0
  410c40:	2b00      	cmp	r3, #0
  410c42:	d004      	beq.n	410c4e <getMinDlyAccel+0x106>
		lMinOdr = min(lMinOdr, 5);
  410c44:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410c46:	2b05      	cmp	r3, #5
  410c48:	bf28      	it	cs
  410c4a:	2305      	movcs	r3, #5
  410c4c:	86fb      	strh	r3, [r7, #54]	; 0x36

	/** To have correct algorithm performance and quick convergence of RV, it is advised to set accelerometer to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR)
  410c4e:	211f      	movs	r1, #31
  410c50:	6878      	ldr	r0, [r7, #4]
  410c52:	4b0d      	ldr	r3, [pc, #52]	; (410c88 <getMinDlyAccel+0x140>)
  410c54:	4798      	blx	r3
  410c56:	4603      	mov	r3, r0
  410c58:	2b00      	cmp	r3, #0
  410c5a:	d106      	bne.n	410c6a <getMinDlyAccel+0x122>
		|| inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
  410c5c:	210b      	movs	r1, #11
  410c5e:	6878      	ldr	r0, [r7, #4]
  410c60:	4b09      	ldr	r3, [pc, #36]	; (410c88 <getMinDlyAccel+0x140>)
  410c62:	4798      	blx	r3
  410c64:	4603      	mov	r3, r0
  410c66:	2b00      	cmp	r3, #0
  410c68:	d004      	beq.n	410c74 <getMinDlyAccel+0x12c>
		lMinOdr = min(lMinOdr, 5);
  410c6a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410c6c:	2b05      	cmp	r3, #5
  410c6e:	bf28      	it	cs
  410c70:	2305      	movcs	r3, #5
  410c72:	86fb      	strh	r3, [r7, #54]	; 0x36

	return lMinOdr;
  410c74:	8efb      	ldrh	r3, [r7, #54]	; 0x36
}
  410c76:	4618      	mov	r0, r3
  410c78:	3738      	adds	r7, #56	; 0x38
  410c7a:	46bd      	mov	sp, r7
  410c7c:	bdb0      	pop	{r4, r5, r7, pc}
  410c7e:	bf00      	nop
  410c80:	0041d324 	.word	0x0041d324
  410c84:	00410a29 	.word	0x00410a29
  410c88:	004109f1 	.word	0x004109f1

00410c8c <getMinDlyGyro>:

/** @brief Get minimum ODR to be applied to gyro engine based on all gyro-based enabled sensors.
* @return ODR in ms we expect to be applied to gyro engine
*/
static unsigned short getMinDlyGyro(struct inv_icm20648 *s)
{
  410c8c:	b5b0      	push	{r4, r5, r7, lr}
  410c8e:	b08a      	sub	sp, #40	; 0x28
  410c90:	af00      	add	r7, sp, #0
  410c92:	6078      	str	r0, [r7, #4]
	const MinDelayGenElementT MinDelayGenGyroList[] = {
  410c94:	4b2d      	ldr	r3, [pc, #180]	; (410d4c <getMinDlyGyro+0xc0>)
  410c96:	f107 0408 	add.w	r4, r7, #8
  410c9a:	461d      	mov	r5, r3
  410c9c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410c9e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410ca0:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  410ca4:	c407      	stmia	r4!, {r0, r1, r2}
  410ca6:	8023      	strh	r3, [r4, #0]
		{ANDROID_SENSOR_ROTATION_VECTOR,               INV_SENSOR_NINEQ             },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,            INV_SENSOR_WAKEUP_NINEQ      },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,        INV_SENSOR_WAKEUP_NINEQ      }
	};

	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenGyroList);
  410ca8:	f107 0308 	add.w	r3, r7, #8
  410cac:	220f      	movs	r2, #15
  410cae:	4619      	mov	r1, r3
  410cb0:	6878      	ldr	r0, [r7, #4]
  410cb2:	4b27      	ldr	r3, [pc, #156]	; (410d50 <getMinDlyGyro+0xc4>)
  410cb4:	4798      	blx	r3
  410cb6:	4603      	mov	r3, r0
  410cb8:	84fb      	strh	r3, [r7, #38]	; 0x26

	if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED))
  410cba:	2110      	movs	r1, #16
  410cbc:	6878      	ldr	r0, [r7, #4]
  410cbe:	4b25      	ldr	r3, [pc, #148]	; (410d54 <getMinDlyGyro+0xc8>)
  410cc0:	4798      	blx	r3
  410cc2:	4603      	mov	r3, r0
  410cc4:	2b00      	cmp	r3, #0
  410cc6:	d01b      	beq.n	410d00 <getMinDlyGyro+0x74>
		if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
  410cc8:	212b      	movs	r1, #43	; 0x2b
  410cca:	6878      	ldr	r0, [r7, #4]
  410ccc:	4b21      	ldr	r3, [pc, #132]	; (410d54 <getMinDlyGyro+0xc8>)
  410cce:	4798      	blx	r3
  410cd0:	4603      	mov	r3, r0
  410cd2:	2b00      	cmp	r3, #0
  410cd4:	d00d      	beq.n	410cf2 <getMinDlyGyro+0x66>
			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(s->odr_gyr_ms,s->odr_rgyr_ms);
  410cd6:	687b      	ldr	r3, [r7, #4]
  410cd8:	f8b3 224c 	ldrh.w	r2, [r3, #588]	; 0x24c
  410cdc:	687b      	ldr	r3, [r7, #4]
  410cde:	f8b3 324a 	ldrh.w	r3, [r3, #586]	; 0x24a
  410ce2:	4293      	cmp	r3, r2
  410ce4:	bf28      	it	cs
  410ce6:	4613      	movcs	r3, r2
  410ce8:	b29a      	uxth	r2, r3
  410cea:	687b      	ldr	r3, [r7, #4]
  410cec:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  410cf0:	e013      	b.n	410d1a <getMinDlyGyro+0x8e>
		else
			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = s->odr_gyr_ms;
  410cf2:	687b      	ldr	r3, [r7, #4]
  410cf4:	f8b3 224a 	ldrh.w	r2, [r3, #586]	; 0x24a
  410cf8:	687b      	ldr	r3, [r7, #4]
  410cfa:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  410cfe:	e00c      	b.n	410d1a <getMinDlyGyro+0x8e>
	else
		if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
  410d00:	212b      	movs	r1, #43	; 0x2b
  410d02:	6878      	ldr	r0, [r7, #4]
  410d04:	4b13      	ldr	r3, [pc, #76]	; (410d54 <getMinDlyGyro+0xc8>)
  410d06:	4798      	blx	r3
  410d08:	4603      	mov	r3, r0
  410d0a:	2b00      	cmp	r3, #0
  410d0c:	d005      	beq.n	410d1a <getMinDlyGyro+0x8e>
			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = s->odr_rgyr_ms;
  410d0e:	687b      	ldr	r3, [r7, #4]
  410d10:	f8b3 224c 	ldrh.w	r2, [r3, #588]	; 0x24c
  410d14:	687b      	ldr	r3, [r7, #4]
  410d16:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108

	/** To have correct algorithm performance and quick convergence of RV, it is advised to set gyro to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR)
  410d1a:	211f      	movs	r1, #31
  410d1c:	6878      	ldr	r0, [r7, #4]
  410d1e:	4b0d      	ldr	r3, [pc, #52]	; (410d54 <getMinDlyGyro+0xc8>)
  410d20:	4798      	blx	r3
  410d22:	4603      	mov	r3, r0
  410d24:	2b00      	cmp	r3, #0
  410d26:	d106      	bne.n	410d36 <getMinDlyGyro+0xaa>
		|| inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
  410d28:	210b      	movs	r1, #11
  410d2a:	6878      	ldr	r0, [r7, #4]
  410d2c:	4b09      	ldr	r3, [pc, #36]	; (410d54 <getMinDlyGyro+0xc8>)
  410d2e:	4798      	blx	r3
  410d30:	4603      	mov	r3, r0
  410d32:	2b00      	cmp	r3, #0
  410d34:	d004      	beq.n	410d40 <getMinDlyGyro+0xb4>
		lMinOdr	= min(lMinOdr, 5);
  410d36:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  410d38:	2b05      	cmp	r3, #5
  410d3a:	bf28      	it	cs
  410d3c:	2305      	movcs	r3, #5
  410d3e:	84fb      	strh	r3, [r7, #38]	; 0x26

	return lMinOdr;
  410d40:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
  410d42:	4618      	mov	r0, r3
  410d44:	3728      	adds	r7, #40	; 0x28
  410d46:	46bd      	mov	sp, r7
  410d48:	bdb0      	pop	{r4, r5, r7, pc}
  410d4a:	bf00      	nop
  410d4c:	0041d350 	.word	0x0041d350
  410d50:	00410a29 	.word	0x00410a29
  410d54:	004109f1 	.word	0x004109f1

00410d58 <getMinDlyCompass>:

/** @brief Get minimum ODR to be applied to compass engine based on all compass-based enabled sensors.
* @return ODR in ms we expect to be applied to compass engine
*/
static unsigned short getMinDlyCompass(struct inv_icm20648 *s)
{
  410d58:	b5b0      	push	{r4, r5, r7, lr}
  410d5a:	b088      	sub	sp, #32
  410d5c:	af00      	add	r7, sp, #0
  410d5e:	6078      	str	r0, [r7, #4]
	const MinDelayGenElementT MinDelayGenCpassList[] = {
  410d60:	4b1d      	ldr	r3, [pc, #116]	; (410dd8 <getMinDlyCompass+0x80>)
  410d62:	f107 0408 	add.w	r4, r7, #8
  410d66:	461d      	mov	r5, r3
  410d68:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410d6a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410d6c:	682b      	ldr	r3, [r5, #0]
  410d6e:	6023      	str	r3, [r4, #0]
		{ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR, INV_SENSOR_WAKEUP_GEOMAG_cpass  },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ_cpass   },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ_cpass   }
	};

	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenCpassList);
  410d70:	f107 0308 	add.w	r3, r7, #8
  410d74:	220a      	movs	r2, #10
  410d76:	4619      	mov	r1, r3
  410d78:	6878      	ldr	r0, [r7, #4]
  410d7a:	4b18      	ldr	r3, [pc, #96]	; (410ddc <getMinDlyCompass+0x84>)
  410d7c:	4798      	blx	r3
  410d7e:	4603      	mov	r3, r0
  410d80:	83fb      	strh	r3, [r7, #30]

	/** To have correct algorithm performance and quick convergence of GMRV, it is advised to set compass to 70Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR)
  410d82:	2127      	movs	r1, #39	; 0x27
  410d84:	6878      	ldr	r0, [r7, #4]
  410d86:	4b16      	ldr	r3, [pc, #88]	; (410de0 <getMinDlyCompass+0x88>)
  410d88:	4798      	blx	r3
  410d8a:	4603      	mov	r3, r0
  410d8c:	2b00      	cmp	r3, #0
  410d8e:	d106      	bne.n	410d9e <getMinDlyCompass+0x46>
		|| inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) )
  410d90:	2114      	movs	r1, #20
  410d92:	6878      	ldr	r0, [r7, #4]
  410d94:	4b12      	ldr	r3, [pc, #72]	; (410de0 <getMinDlyCompass+0x88>)
  410d96:	4798      	blx	r3
  410d98:	4603      	mov	r3, r0
  410d9a:	2b00      	cmp	r3, #0
  410d9c:	d004      	beq.n	410da8 <getMinDlyCompass+0x50>
		lMinOdr= min(lMinOdr, 15);
  410d9e:	8bfb      	ldrh	r3, [r7, #30]
  410da0:	2b0f      	cmp	r3, #15
  410da2:	bf28      	it	cs
  410da4:	230f      	movcs	r3, #15
  410da6:	83fb      	strh	r3, [r7, #30]
	/** To have correct algorithm performance and quick convergence of RV, it is advised to set compass to 35Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR)
  410da8:	211f      	movs	r1, #31
  410daa:	6878      	ldr	r0, [r7, #4]
  410dac:	4b0c      	ldr	r3, [pc, #48]	; (410de0 <getMinDlyCompass+0x88>)
  410dae:	4798      	blx	r3
  410db0:	4603      	mov	r3, r0
  410db2:	2b00      	cmp	r3, #0
  410db4:	d106      	bne.n	410dc4 <getMinDlyCompass+0x6c>
		|| inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
  410db6:	210b      	movs	r1, #11
  410db8:	6878      	ldr	r0, [r7, #4]
  410dba:	4b09      	ldr	r3, [pc, #36]	; (410de0 <getMinDlyCompass+0x88>)
  410dbc:	4798      	blx	r3
  410dbe:	4603      	mov	r3, r0
  410dc0:	2b00      	cmp	r3, #0
  410dc2:	d004      	beq.n	410dce <getMinDlyCompass+0x76>
		lMinOdr = min(lMinOdr, 28);
  410dc4:	8bfb      	ldrh	r3, [r7, #30]
  410dc6:	2b1c      	cmp	r3, #28
  410dc8:	bf28      	it	cs
  410dca:	231c      	movcs	r3, #28
  410dcc:	83fb      	strh	r3, [r7, #30]

	return lMinOdr;
  410dce:	8bfb      	ldrh	r3, [r7, #30]
}
  410dd0:	4618      	mov	r0, r3
  410dd2:	3720      	adds	r7, #32
  410dd4:	46bd      	mov	sp, r7
  410dd6:	bdb0      	pop	{r4, r5, r7, pc}
  410dd8:	0041d370 	.word	0x0041d370
  410ddc:	00410a29 	.word	0x00410a29
  410de0:	004109f1 	.word	0x004109f1

00410de4 <inv_icm20648_base_control_init>:

int inv_icm20648_base_control_init(struct inv_icm20648 * s)
{
  410de4:	b580      	push	{r7, lr}
  410de6:	b084      	sub	sp, #16
  410de8:	af00      	add	r7, sp, #0
  410dea:	6078      	str	r0, [r7, #4]
	int result = 0;
  410dec:	2300      	movs	r3, #0
  410dee:	60bb      	str	r3, [r7, #8]
	unsigned int i;

	memset(s->inv_dmp_odr_dividers, 0, sizeof(s->inv_dmp_odr_dividers));
  410df0:	687b      	ldr	r3, [r7, #4]
  410df2:	33bc      	adds	r3, #188	; 0xbc
  410df4:	224a      	movs	r2, #74	; 0x4a
  410df6:	2100      	movs	r1, #0
  410df8:	4618      	mov	r0, r3
  410dfa:	4b65      	ldr	r3, [pc, #404]	; (410f90 <inv_icm20648_base_control_init+0x1ac>)
  410dfc:	4798      	blx	r3

	for(i = 0; i < (sizeof(s->inv_dmp_odr_delays)/sizeof(unsigned short)); i++) {
  410dfe:	2300      	movs	r3, #0
  410e00:	60fb      	str	r3, [r7, #12]
  410e02:	e02b      	b.n	410e5c <inv_icm20648_base_control_init+0x78>
		if((i == INV_SENSOR_ACTIVITY_CLASSIFIER) ||
  410e04:	68fb      	ldr	r3, [r7, #12]
  410e06:	2b0d      	cmp	r3, #13
  410e08:	d00b      	beq.n	410e22 <inv_icm20648_base_control_init+0x3e>
  410e0a:	68fb      	ldr	r3, [r7, #12]
  410e0c:	2b0c      	cmp	r3, #12
  410e0e:	d008      	beq.n	410e22 <inv_icm20648_base_control_init+0x3e>
		   (i == INV_SENSOR_STEP_COUNTER) ||
  410e10:	68fb      	ldr	r3, [r7, #12]
  410e12:	2b1f      	cmp	r3, #31
  410e14:	d005      	beq.n	410e22 <inv_icm20648_base_control_init+0x3e>
		   (i == INV_SENSOR_WAKEUP_STEP_COUNTER) ||
  410e16:	68fb      	ldr	r3, [r7, #12]
  410e18:	2b20      	cmp	r3, #32
  410e1a:	d002      	beq.n	410e22 <inv_icm20648_base_control_init+0x3e>
		   (i == INV_SENSOR_WAKEUP_TILT_DETECTOR) ||
  410e1c:	68fb      	ldr	r3, [r7, #12]
  410e1e:	2b0e      	cmp	r3, #14
  410e20:	d107      	bne.n	410e32 <inv_icm20648_base_control_init+0x4e>
		   (i == INV_SENSOR_FLIP_PICKUP) )
			s->inv_dmp_odr_delays[i] = INV_ODR_DEFAULT_BAC;
  410e22:	687a      	ldr	r2, [r7, #4]
  410e24:	68fb      	ldr	r3, [r7, #12]
  410e26:	3380      	adds	r3, #128	; 0x80
  410e28:	005b      	lsls	r3, r3, #1
  410e2a:	4413      	add	r3, r2
  410e2c:	2212      	movs	r2, #18
  410e2e:	80da      	strh	r2, [r3, #6]
  410e30:	e011      	b.n	410e56 <inv_icm20648_base_control_init+0x72>
		else if(i == INV_SENSOR_BRING_TO_SEE)
  410e32:	68fb      	ldr	r3, [r7, #12]
  410e34:	2b0f      	cmp	r3, #15
  410e36:	d107      	bne.n	410e48 <inv_icm20648_base_control_init+0x64>
			s->inv_dmp_odr_delays[i] = INV_ODR_DEFAULT_B2S;
  410e38:	687a      	ldr	r2, [r7, #4]
  410e3a:	68fb      	ldr	r3, [r7, #12]
  410e3c:	3380      	adds	r3, #128	; 0x80
  410e3e:	005b      	lsls	r3, r3, #1
  410e40:	4413      	add	r3, r2
  410e42:	2212      	movs	r2, #18
  410e44:	80da      	strh	r2, [r3, #6]
  410e46:	e006      	b.n	410e56 <inv_icm20648_base_control_init+0x72>
		else
			s->inv_dmp_odr_delays[i] = INV_ODR_MIN_DELAY;
  410e48:	687a      	ldr	r2, [r7, #4]
  410e4a:	68fb      	ldr	r3, [r7, #12]
  410e4c:	3380      	adds	r3, #128	; 0x80
  410e4e:	005b      	lsls	r3, r3, #1
  410e50:	4413      	add	r3, r2
  410e52:	22c8      	movs	r2, #200	; 0xc8
  410e54:	80da      	strh	r2, [r3, #6]
	for(i = 0; i < (sizeof(s->inv_dmp_odr_delays)/sizeof(unsigned short)); i++) {
  410e56:	68fb      	ldr	r3, [r7, #12]
  410e58:	3301      	adds	r3, #1
  410e5a:	60fb      	str	r3, [r7, #12]
  410e5c:	68fb      	ldr	r3, [r7, #12]
  410e5e:	2b24      	cmp	r3, #36	; 0x24
  410e60:	d9d0      	bls.n	410e04 <inv_icm20648_base_control_init+0x20>
	}
	for(i = 0; i < (sizeof(s->inv_androidSensorsOdr_boundaries)/sizeof(s->inv_androidSensorsOdr_boundaries[0])); i++) {
  410e62:	2300      	movs	r3, #0
  410e64:	60fb      	str	r3, [r7, #12]
  410e66:	e057      	b.n	410f18 <inv_icm20648_base_control_init+0x134>
		if ((i == ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED) || (i == ANDROID_SENSOR_GEOMAGNETIC_FIELD) ||
  410e68:	68fb      	ldr	r3, [r7, #12]
  410e6a:	2b0e      	cmp	r3, #14
  410e6c:	d008      	beq.n	410e80 <inv_icm20648_base_control_init+0x9c>
  410e6e:	68fb      	ldr	r3, [r7, #12]
  410e70:	2b02      	cmp	r3, #2
  410e72:	d005      	beq.n	410e80 <inv_icm20648_base_control_init+0x9c>
  410e74:	68fb      	ldr	r3, [r7, #12]
  410e76:	2b22      	cmp	r3, #34	; 0x22
  410e78:	d002      	beq.n	410e80 <inv_icm20648_base_control_init+0x9c>
		    (i == ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED) || (i == ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD)) {
  410e7a:	68fb      	ldr	r3, [r7, #12]
  410e7c:	2b18      	cmp	r3, #24
  410e7e:	d10e      	bne.n	410e9e <inv_icm20648_base_control_init+0xba>
			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR_CPASS;
  410e80:	687b      	ldr	r3, [r7, #4]
  410e82:	68fa      	ldr	r2, [r7, #12]
  410e84:	325a      	adds	r2, #90	; 0x5a
  410e86:	210e      	movs	r1, #14
  410e88:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR_CPASS;
  410e8c:	687a      	ldr	r2, [r7, #4]
  410e8e:	68fb      	ldr	r3, [r7, #12]
  410e90:	009b      	lsls	r3, r3, #2
  410e92:	4413      	add	r3, r2
  410e94:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  410e98:	f8a3 216a 	strh.w	r2, [r3, #362]	; 0x16a
  410e9c:	e039      	b.n	410f12 <inv_icm20648_base_control_init+0x12e>
		} else if ((i == ANDROID_SENSOR_GAME_ROTATION_VECTOR) || (i == ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR) ||
  410e9e:	68fb      	ldr	r3, [r7, #12]
  410ea0:	2b0f      	cmp	r3, #15
  410ea2:	d01a      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
  410ea4:	68fb      	ldr	r3, [r7, #12]
  410ea6:	2b23      	cmp	r3, #35	; 0x23
  410ea8:	d017      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
  410eaa:	68fb      	ldr	r3, [r7, #12]
  410eac:	2b09      	cmp	r3, #9
  410eae:	d014      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_GRAVITY) || (i == ANDROID_SENSOR_WAKEUP_GRAVITY) ||
  410eb0:	68fb      	ldr	r3, [r7, #12]
  410eb2:	2b1d      	cmp	r3, #29
  410eb4:	d011      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
  410eb6:	68fb      	ldr	r3, [r7, #12]
  410eb8:	2b0a      	cmp	r3, #10
  410eba:	d00e      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_LINEAR_ACCELERATION) || (i == ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION) ||
  410ebc:	68fb      	ldr	r3, [r7, #12]
  410ebe:	2b1e      	cmp	r3, #30
  410ec0:	d00b      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
  410ec2:	68fb      	ldr	r3, [r7, #12]
  410ec4:	2b0b      	cmp	r3, #11
  410ec6:	d008      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_ROTATION_VECTOR) || (i == ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) ||
  410ec8:	68fb      	ldr	r3, [r7, #12]
  410eca:	2b1f      	cmp	r3, #31
  410ecc:	d005      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
  410ece:	68fb      	ldr	r3, [r7, #12]
  410ed0:	2b03      	cmp	r3, #3
  410ed2:	d002      	beq.n	410eda <inv_icm20648_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_ORIENTATION) || (i == ANDROID_SENSOR_WAKEUP_ORIENTATION)) {
  410ed4:	68fb      	ldr	r3, [r7, #12]
  410ed6:	2b19      	cmp	r3, #25
  410ed8:	d10d      	bne.n	410ef6 <inv_icm20648_base_control_init+0x112>
			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR_GRV;
  410eda:	687b      	ldr	r3, [r7, #4]
  410edc:	68fa      	ldr	r2, [r7, #12]
  410ede:	325a      	adds	r2, #90	; 0x5a
  410ee0:	2105      	movs	r1, #5
  410ee2:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR_GRV;
  410ee6:	687a      	ldr	r2, [r7, #4]
  410ee8:	68fb      	ldr	r3, [r7, #12]
  410eea:	009b      	lsls	r3, r3, #2
  410eec:	4413      	add	r3, r2
  410eee:	2214      	movs	r2, #20
  410ef0:	f8a3 216a 	strh.w	r2, [r3, #362]	; 0x16a
  410ef4:	e00d      	b.n	410f12 <inv_icm20648_base_control_init+0x12e>
		} else {
			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR;
  410ef6:	687b      	ldr	r3, [r7, #4]
  410ef8:	68fa      	ldr	r2, [r7, #12]
  410efa:	325a      	adds	r2, #90	; 0x5a
  410efc:	2105      	movs	r1, #5
  410efe:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR;
  410f02:	687a      	ldr	r2, [r7, #4]
  410f04:	68fb      	ldr	r3, [r7, #12]
  410f06:	009b      	lsls	r3, r3, #2
  410f08:	4413      	add	r3, r2
  410f0a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  410f0e:	f8a3 216a 	strh.w	r2, [r3, #362]	; 0x16a
	for(i = 0; i < (sizeof(s->inv_androidSensorsOdr_boundaries)/sizeof(s->inv_androidSensorsOdr_boundaries[0])); i++) {
  410f12:	68fb      	ldr	r3, [r7, #12]
  410f14:	3301      	adds	r3, #1
  410f16:	60fb      	str	r3, [r7, #12]
  410f18:	68fb      	ldr	r3, [r7, #12]
  410f1a:	2b32      	cmp	r3, #50	; 0x32
  410f1c:	d9a4      	bls.n	410e68 <inv_icm20648_base_control_init+0x84>
		}
	}
	s->lLastHwSmplrtDividerAcc = 0;
  410f1e:	687b      	ldr	r3, [r7, #4]
  410f20:	2200      	movs	r2, #0
  410f22:	f8a3 2236 	strh.w	r2, [r3, #566]	; 0x236
	s->lLastHwSmplrtDividerGyr = 0;
  410f26:	687b      	ldr	r3, [r7, #4]
  410f28:	2200      	movs	r2, #0
  410f2a:	f8a3 2238 	strh.w	r2, [r3, #568]	; 0x238
	s->sBatchMode              = 0;
  410f2e:	687b      	ldr	r3, [r7, #4]
  410f30:	2200      	movs	r2, #0
  410f32:	f883 223a 	strb.w	r2, [r3, #570]	; 0x23a
	s->header2_count           = 0;
  410f36:	687b      	ldr	r3, [r7, #4]
  410f38:	2200      	movs	r2, #0
  410f3a:	f883 223b 	strb.w	r2, [r3, #571]	; 0x23b
	s->mems_put_to_sleep       = 1;
  410f3e:	687b      	ldr	r3, [r7, #4]
  410f40:	2201      	movs	r2, #1
  410f42:	f883 223c 	strb.w	r2, [r3, #572]	; 0x23c
	s->smd_status              = 0;
  410f46:	687b      	ldr	r3, [r7, #4]
  410f48:	2200      	movs	r2, #0
  410f4a:	f8a3 223e 	strh.w	r2, [r3, #574]	; 0x23e
	s->ped_int_status          = 0;
  410f4e:	687b      	ldr	r3, [r7, #4]
  410f50:	2200      	movs	r2, #0
  410f52:	f8a3 2240 	strh.w	r2, [r3, #576]	; 0x240
	s->b2s_status              = 0;
  410f56:	687b      	ldr	r3, [r7, #4]
  410f58:	2200      	movs	r2, #0
  410f5a:	f8a3 2156 	strh.w	r2, [r3, #342]	; 0x156
	s->bac_request             = 0;
  410f5e:	687b      	ldr	r3, [r7, #4]
  410f60:	2200      	movs	r2, #0
  410f62:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
	s->odr_acc_ms = INV_ODR_MIN_DELAY;
  410f66:	687b      	ldr	r3, [r7, #4]
  410f68:	22c8      	movs	r2, #200	; 0xc8
  410f6a:	f8a3 2246 	strh.w	r2, [r3, #582]	; 0x246
	//s->odr_acc_wom_ms = INV_ODR_MIN_DELAY;
	s->odr_racc_ms = INV_ODR_MIN_DELAY;
  410f6e:	687b      	ldr	r3, [r7, #4]
  410f70:	22c8      	movs	r2, #200	; 0xc8
  410f72:	f8a3 2248 	strh.w	r2, [r3, #584]	; 0x248
	s->odr_gyr_ms = INV_ODR_MIN_DELAY;
  410f76:	687b      	ldr	r3, [r7, #4]
  410f78:	22c8      	movs	r2, #200	; 0xc8
  410f7a:	f8a3 224a 	strh.w	r2, [r3, #586]	; 0x24a
	s->odr_rgyr_ms = INV_ODR_MIN_DELAY;
  410f7e:	687b      	ldr	r3, [r7, #4]
  410f80:	22c8      	movs	r2, #200	; 0xc8
  410f82:	f8a3 224c 	strh.w	r2, [r3, #588]	; 0x24c

	return result;
  410f86:	68bb      	ldr	r3, [r7, #8]
}
  410f88:	4618      	mov	r0, r3
  410f8a:	3710      	adds	r7, #16
  410f8c:	46bd      	mov	sp, r7
  410f8e:	bd80      	pop	{r7, pc}
  410f90:	00414431 	.word	0x00414431

00410f94 <inv_set_hw_smplrt_dmp_odrs>:

static int inv_set_hw_smplrt_dmp_odrs(struct inv_icm20648 * s)
{
  410f94:	b590      	push	{r4, r7, lr}
  410f96:	b09d      	sub	sp, #116	; 0x74
  410f98:	af00      	add	r7, sp, #0
  410f9a:	6078      	str	r0, [r7, #4]
	int result = 0;
  410f9c:	2300      	movs	r3, #0
  410f9e:	66fb      	str	r3, [r7, #108]	; 0x6c
	unsigned short minDly, minDly_accel, minDly_gyro;
	unsigned short minDly_cpass;
	unsigned short minDly_pressure;
	unsigned short hw_smplrt_divider = 0;
  410fa0:	2300      	movs	r3, #0
  410fa2:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

	const MinDelayGenElementT MinDelayGenPressureList[] = {
  410fa6:	4b45      	ldr	r3, [pc, #276]	; (4110bc <inv_set_hw_smplrt_dmp_odrs+0x128>)
  410fa8:	681b      	ldr	r3, [r3, #0]
  410faa:	65bb      	str	r3, [r7, #88]	; 0x58
		{ANDROID_SENSOR_PRESSURE,                           INV_SENSOR_PRESSURE             },
		{ANDROID_SENSOR_WAKEUP_PRESSURE,                    INV_SENSOR_WAKEUP_PRESSURE      }
	};
	const MinDelayGenElementT MinDelayGenAccel2List[] = {
  410fac:	4a44      	ldr	r2, [pc, #272]	; (4110c0 <inv_set_hw_smplrt_dmp_odrs+0x12c>)
  410fae:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  410fb2:	ca07      	ldmia	r2, {r0, r1, r2}
  410fb4:	c303      	stmia	r3!, {r0, r1}
  410fb6:	801a      	strh	r2, [r3, #0]
		{ANDROID_SENSOR_WAKEUP_ACCELEROMETER,               INV_SENSOR_WAKEUP_ACCEL         },
		{ANDROID_SENSOR_RAW_ACCELEROMETER,                  INV_SENSOR_ACCEL                },
		{ANDROID_SENSOR_LINEAR_ACCELERATION,                INV_SENSOR_SIXQ_accel           },
		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,         INV_SENSOR_WAKEUP_SIXQ_accel    }
	};
	const MinDelayGenElementT MinDelayGenAccel3List[] = {
  410fb8:	4b42      	ldr	r3, [pc, #264]	; (4110c4 <inv_set_hw_smplrt_dmp_odrs+0x130>)
  410fba:	681b      	ldr	r3, [r3, #0]
  410fbc:	64bb      	str	r3, [r7, #72]	; 0x48
		{ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR,        INV_SENSOR_GEOMAG               },
		{ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR, INV_SENSOR_WAKEUP_GEOMAG        }
	};
	const MinDelayGenElementT MinDelayGenAccel4List[] = {
  410fbe:	4a42      	ldr	r2, [pc, #264]	; (4110c8 <inv_set_hw_smplrt_dmp_odrs+0x134>)
  410fc0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  410fc4:	ca07      	ldmia	r2, {r0, r1, r2}
  410fc6:	c303      	stmia	r3!, {r0, r1}
  410fc8:	801a      	strh	r2, [r3, #0]
		{ANDROID_SENSOR_STEP_COUNTER,                       INV_SENSOR_STEP_COUNTER         },
		{ANDROID_SENSOR_WAKEUP_STEP_DETECTOR,               INV_SENSOR_WAKEUP_STEP_COUNTER  },
		{ANDROID_SENSOR_WAKEUP_STEP_COUNTER,                INV_SENSOR_WAKEUP_STEP_COUNTER  },
		{ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION,          INV_SENSOR_WAKEUP_STEP_COUNTER  }
	};
	const MinDelayGenElementT MinDelayGenGyro2List[] = {
  410fca:	4a40      	ldr	r2, [pc, #256]	; (4110cc <inv_set_hw_smplrt_dmp_odrs+0x138>)
  410fcc:	f107 0330 	add.w	r3, r7, #48	; 0x30
  410fd0:	ca07      	ldmia	r2, {r0, r1, r2}
  410fd2:	c303      	stmia	r3!, {r0, r1}
  410fd4:	801a      	strh	r2, [r3, #0]
		{ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED,      INV_SENSOR_WAKEUP_GYRO          },
		{ANDROID_SENSOR_GYROSCOPE,                          INV_SENSOR_CALIB_GYRO           },
		{ANDROID_SENSOR_RAW_GYROSCOPE,                      INV_SENSOR_GYRO           },
		{ANDROID_SENSOR_WAKEUP_GYROSCOPE,                   INV_SENSOR_WAKEUP_CALIB_GYRO    }
	};
	const MinDelayGenElementT MinDelayGenGyro3List[] = {
  410fd6:	4b3e      	ldr	r3, [pc, #248]	; (4110d0 <inv_set_hw_smplrt_dmp_odrs+0x13c>)
  410fd8:	681b      	ldr	r3, [r3, #0]
  410fda:	62fb      	str	r3, [r7, #44]	; 0x2c
		{ANDROID_SENSOR_GYROSCOPE,                          INV_SENSOR_CALIB_GYRO           },
		{ANDROID_SENSOR_WAKEUP_GYROSCOPE,                   INV_SENSOR_WAKEUP_CALIB_GYRO    }
	};
	const MinDelayGenElementT MinDelayGenGyro4List[] = {
  410fdc:	4a3d      	ldr	r2, [pc, #244]	; (4110d4 <inv_set_hw_smplrt_dmp_odrs+0x140>)
  410fde:	f107 0320 	add.w	r3, r7, #32
  410fe2:	ca07      	ldmia	r2, {r0, r1, r2}
  410fe4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		{ANDROID_SENSOR_LINEAR_ACCELERATION,                INV_SENSOR_SIXQ                 },
		{ANDROID_SENSOR_WAKEUP_GRAVITY,                     INV_SENSOR_WAKEUP_SIXQ          },
		{ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR,        INV_SENSOR_WAKEUP_SIXQ          },
		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,         INV_SENSOR_WAKEUP_SIXQ          }
	};
	const MinDelayGenElementT MinDelayGenGyro5List[] = {
  410fe8:	4a3b      	ldr	r2, [pc, #236]	; (4110d8 <inv_set_hw_smplrt_dmp_odrs+0x144>)
  410fea:	f107 0318 	add.w	r3, r7, #24
  410fee:	e892 0003 	ldmia.w	r2, {r0, r1}
  410ff2:	e883 0003 	stmia.w	r3, {r0, r1}
		{ANDROID_SENSOR_ORIENTATION,                        INV_SENSOR_NINEQ                },
		{ANDROID_SENSOR_ROTATION_VECTOR,                    INV_SENSOR_NINEQ                },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ         },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ         }
	};
	const MinDelayGenElementT MinDelayGenCpass2List[] = {
  410ff6:	4b39      	ldr	r3, [pc, #228]	; (4110dc <inv_set_hw_smplrt_dmp_odrs+0x148>)
  410ff8:	681b      	ldr	r3, [r3, #0]
  410ffa:	617b      	str	r3, [r7, #20]
		{ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED,        INV_SENSOR_COMPASS              },
		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED,	INV_SENSOR_WAKEUP_COMPASS       }
	};
	const MinDelayGenElementT MinDelayGenCpass3List[] = {
  410ffc:	4b38      	ldr	r3, [pc, #224]	; (4110e0 <inv_set_hw_smplrt_dmp_odrs+0x14c>)
  410ffe:	681b      	ldr	r3, [r3, #0]
  411000:	613b      	str	r3, [r7, #16]
		{ANDROID_SENSOR_GEOMAGNETIC_FIELD,                  INV_SENSOR_CALIB_COMPASS        },
		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD,              INV_SENSOR_WAKEUP_CALIB_COMPASS }
	};
	const MinDelayGenElementT MinDelayGenPressure2List[] = {
  411002:	4b2e      	ldr	r3, [pc, #184]	; (4110bc <inv_set_hw_smplrt_dmp_odrs+0x128>)
  411004:	681b      	ldr	r3, [r3, #0]
  411006:	60fb      	str	r3, [r7, #12]
		{ANDROID_SENSOR_PRESSURE,                           INV_SENSOR_PRESSURE             },
		{ANDROID_SENSOR_WAKEUP_PRESSURE,                    INV_SENSOR_WAKEUP_PRESSURE      }
	};

	// Engine ACCEL Based
	minDly_accel = getMinDlyAccel(s);
  411008:	6878      	ldr	r0, [r7, #4]
  41100a:	4b36      	ldr	r3, [pc, #216]	; (4110e4 <inv_set_hw_smplrt_dmp_odrs+0x150>)
  41100c:	4798      	blx	r3
  41100e:	4603      	mov	r3, r0
  411010:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

	// Engine Gyro Based
	minDly_gyro  = getMinDlyGyro(s);
  411014:	6878      	ldr	r0, [r7, #4]
  411016:	4b34      	ldr	r3, [pc, #208]	; (4110e8 <inv_set_hw_smplrt_dmp_odrs+0x154>)
  411018:	4798      	blx	r3
  41101a:	4603      	mov	r3, r0
  41101c:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68

	// Engine Cpass Based
	minDly_cpass = getMinDlyCompass(s);
  411020:	6878      	ldr	r0, [r7, #4]
  411022:	4b32      	ldr	r3, [pc, #200]	; (4110ec <inv_set_hw_smplrt_dmp_odrs+0x158>)
  411024:	4798      	blx	r3
  411026:	4603      	mov	r3, r0
  411028:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

	// Engine Pressure Based
	minDly_pressure	=	MinDelayGen	(s, MinDelayGenPressureList);
  41102c:	f107 0358 	add.w	r3, r7, #88	; 0x58
  411030:	2202      	movs	r2, #2
  411032:	4619      	mov	r1, r3
  411034:	6878      	ldr	r0, [r7, #4]
  411036:	4b2e      	ldr	r3, [pc, #184]	; (4110f0 <inv_set_hw_smplrt_dmp_odrs+0x15c>)
  411038:	4798      	blx	r3
  41103a:	4603      	mov	r3, r0
  41103c:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

	// get min delay of all enabled sensors of all sensor engine groups
	minDly = min(minDly_gyro, minDly_accel);
  411040:	f8b7 206a 	ldrh.w	r2, [r7, #106]	; 0x6a
  411044:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  411048:	4293      	cmp	r3, r2
  41104a:	bf28      	it	cs
  41104c:	4613      	movcs	r3, r2
  41104e:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
	minDly = min(minDly, minDly_cpass);
  411052:	f8b7 2066 	ldrh.w	r2, [r7, #102]	; 0x66
  411056:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  41105a:	4293      	cmp	r3, r2
  41105c:	bf28      	it	cs
  41105e:	4613      	movcs	r3, r2
  411060:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
	minDly = min(minDly, minDly_pressure);
  411064:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
  411068:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  41106c:	4293      	cmp	r3, r2
  41106e:	bf28      	it	cs
  411070:	4613      	movcs	r3, r2
  411072:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60

	// switch between low power and low noise at 500Hz boundary
	if (minDly != 0xFFFF) {
  411076:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  41107a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  41107e:	4293      	cmp	r3, r2
  411080:	d03c      	beq.n	4110fc <inv_set_hw_smplrt_dmp_odrs+0x168>
		// above 500Hz boundary, force LN mode
		if (minDly==1) {
  411082:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  411086:	2b01      	cmp	r3, #1
  411088:	d10b      	bne.n	4110a2 <inv_set_hw_smplrt_dmp_odrs+0x10e>
			if (s->base_state.chip_lp_ln_mode == CHIP_LOW_POWER_ICM20648) {
  41108a:	687b      	ldr	r3, [r7, #4]
  41108c:	7e5b      	ldrb	r3, [r3, #25]
  41108e:	2b01      	cmp	r3, #1
  411090:	d140      	bne.n	411114 <inv_set_hw_smplrt_dmp_odrs+0x180>
				s->go_back_lp_when_odr_low = 1;
  411092:	687b      	ldr	r3, [r7, #4]
  411094:	2201      	movs	r2, #1
  411096:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
				inv_icm20648_enter_low_noise_mode(s);
  41109a:	6878      	ldr	r0, [r7, #4]
  41109c:	4b15      	ldr	r3, [pc, #84]	; (4110f4 <inv_set_hw_smplrt_dmp_odrs+0x160>)
  41109e:	4798      	blx	r3
  4110a0:	e038      	b.n	411114 <inv_set_hw_smplrt_dmp_odrs+0x180>
			}
		} else { // below 500 Hz boundary, go back to originally requested mode
			if (s->go_back_lp_when_odr_low) {
  4110a2:	687b      	ldr	r3, [r7, #4]
  4110a4:	f893 3244 	ldrb.w	r3, [r3, #580]	; 0x244
  4110a8:	2b00      	cmp	r3, #0
  4110aa:	d033      	beq.n	411114 <inv_set_hw_smplrt_dmp_odrs+0x180>
				s->go_back_lp_when_odr_low = 0;
  4110ac:	687b      	ldr	r3, [r7, #4]
  4110ae:	2200      	movs	r2, #0
  4110b0:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
				inv_icm20648_enter_duty_cycle_mode(s);
  4110b4:	6878      	ldr	r0, [r7, #4]
  4110b6:	4b10      	ldr	r3, [pc, #64]	; (4110f8 <inv_set_hw_smplrt_dmp_odrs+0x164>)
  4110b8:	4798      	blx	r3
  4110ba:	e02b      	b.n	411114 <inv_set_hw_smplrt_dmp_odrs+0x180>
  4110bc:	0041d384 	.word	0x0041d384
  4110c0:	0041d388 	.word	0x0041d388
  4110c4:	0041d394 	.word	0x0041d394
  4110c8:	0041d398 	.word	0x0041d398
  4110cc:	0041d3a4 	.word	0x0041d3a4
  4110d0:	0041d3b0 	.word	0x0041d3b0
  4110d4:	0041d3b4 	.word	0x0041d3b4
  4110d8:	0041d3c0 	.word	0x0041d3c0
  4110dc:	0041d3c8 	.word	0x0041d3c8
  4110e0:	0041d3cc 	.word	0x0041d3cc
  4110e4:	00410b49 	.word	0x00410b49
  4110e8:	00410c8d 	.word	0x00410c8d
  4110ec:	00410d59 	.word	0x00410d59
  4110f0:	00410a29 	.word	0x00410a29
  4110f4:	00405ec5 	.word	0x00405ec5
  4110f8:	00405e95 	.word	0x00405e95
			}
		}
	} else // all sensors are turned OFF, force originally requested mode
	{
		if (s->go_back_lp_when_odr_low) {
  4110fc:	687b      	ldr	r3, [r7, #4]
  4110fe:	f893 3244 	ldrb.w	r3, [r3, #580]	; 0x244
  411102:	2b00      	cmp	r3, #0
  411104:	d006      	beq.n	411114 <inv_set_hw_smplrt_dmp_odrs+0x180>
			s->go_back_lp_when_odr_low = 0;
  411106:	687b      	ldr	r3, [r7, #4]
  411108:	2200      	movs	r2, #0
  41110a:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
			inv_icm20648_enter_duty_cycle_mode(s);
  41110e:	6878      	ldr	r0, [r7, #4]
  411110:	4bbf      	ldr	r3, [pc, #764]	; (411410 <inv_set_hw_smplrt_dmp_odrs+0x47c>)
  411112:	4798      	blx	r3
		}
	}

	if (minDly_accel != 0xFFFF)
  411114:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411118:	f64f 72ff 	movw	r2, #65535	; 0xffff
  41111c:	4293      	cmp	r3, r2
  41111e:	d003      	beq.n	411128 <inv_set_hw_smplrt_dmp_odrs+0x194>
		minDly_accel = minDly;
  411120:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  411124:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

	if (minDly_gyro  != 0xFFFF)
  411128:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  41112c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411130:	4293      	cmp	r3, r2
  411132:	d003      	beq.n	41113c <inv_set_hw_smplrt_dmp_odrs+0x1a8>
		minDly_gyro  = minDly;
  411134:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  411138:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68

	if (minDly_cpass != 0xFFFF)
  41113c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  411140:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411144:	4293      	cmp	r3, r2
  411146:	d003      	beq.n	411150 <inv_set_hw_smplrt_dmp_odrs+0x1bc>
		minDly_cpass = minDly;
  411148:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  41114c:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

	if (minDly_pressure != 0xFFFF)
  411150:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
  411154:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411158:	4293      	cmp	r3, r2
  41115a:	d003      	beq.n	411164 <inv_set_hw_smplrt_dmp_odrs+0x1d0>
		minDly_pressure = minDly;
  41115c:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  411160:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

	if (s->bac_request != 0) {
  411164:	687b      	ldr	r3, [r7, #4]
  411166:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  41116a:	2b00      	cmp	r3, #0
  41116c:	d035      	beq.n	4111da <inv_set_hw_smplrt_dmp_odrs+0x246>
		unsigned short lBACMinDly = min(INV_ODR_DEFAULT_BAC, minDly_accel);
  41116e:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411172:	2b12      	cmp	r3, #18
  411174:	bf28      	it	cs
  411176:	2312      	movcs	r3, #18
  411178:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
		// estimate closest decimator value to have 56Hz multiple and apply it
		lBACMinDly = 1000/(get_multiple_56_rate(lBACMinDly));
  41117c:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
  411180:	4618      	mov	r0, r3
  411182:	4ba4      	ldr	r3, [pc, #656]	; (411414 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  411184:	4798      	blx	r3
  411186:	4603      	mov	r3, r0
  411188:	461a      	mov	r2, r3
  41118a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  41118e:	fb93 f3f2 	sdiv	r3, r3, r2
  411192:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
		dmp_icm20648_set_bac_rate(s, get_multiple_56_rate(lBACMinDly));
  411196:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
  41119a:	4618      	mov	r0, r3
  41119c:	4b9d      	ldr	r3, [pc, #628]	; (411414 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  41119e:	4798      	blx	r3
  4111a0:	4603      	mov	r3, r0
  4111a2:	4619      	mov	r1, r3
  4111a4:	6878      	ldr	r0, [r7, #4]
  4111a6:	4b9c      	ldr	r3, [pc, #624]	; (411418 <inv_set_hw_smplrt_dmp_odrs+0x484>)
  4111a8:	4798      	blx	r3
		minDly_accel = lBACMinDly;
  4111aa:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
  4111ae:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
  4111b2:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  4111b6:	4618      	mov	r0, r3
  4111b8:	4b98      	ldr	r3, [pc, #608]	; (41141c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  4111ba:	4798      	blx	r3
  4111bc:	4603      	mov	r3, r0
  4111be:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
		result |= DividerRateSet(s, lBACMinDly, hw_smplrt_divider, INV_SENSOR_ACTIVITY_CLASSIFIER);
  4111c2:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4111c6:	f8b7 105e 	ldrh.w	r1, [r7, #94]	; 0x5e
  4111ca:	230d      	movs	r3, #13
  4111cc:	6878      	ldr	r0, [r7, #4]
  4111ce:	4c94      	ldr	r4, [pc, #592]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4111d0:	47a0      	blx	r4
  4111d2:	4602      	mov	r2, r0
  4111d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4111d6:	4313      	orrs	r3, r2
  4111d8:	66fb      	str	r3, [r7, #108]	; 0x6c
	}
	if (s->b2s_status != 0) {
  4111da:	687b      	ldr	r3, [r7, #4]
  4111dc:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  4111e0:	2b00      	cmp	r3, #0
  4111e2:	d035      	beq.n	411250 <inv_set_hw_smplrt_dmp_odrs+0x2bc>
		unsigned short lB2SMinDly = min(INV_ODR_DEFAULT_B2S, minDly_accel);
  4111e4:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  4111e8:	2b12      	cmp	r3, #18
  4111ea:	bf28      	it	cs
  4111ec:	2312      	movcs	r3, #18
  4111ee:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
		lB2SMinDly = 1000/(get_multiple_56_rate(lB2SMinDly));
  4111f2:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
  4111f6:	4618      	mov	r0, r3
  4111f8:	4b86      	ldr	r3, [pc, #536]	; (411414 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  4111fa:	4798      	blx	r3
  4111fc:	4603      	mov	r3, r0
  4111fe:	461a      	mov	r2, r3
  411200:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  411204:	fb93 f3f2 	sdiv	r3, r3, r2
  411208:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
		dmp_icm20648_set_b2s_rate(s, get_multiple_56_rate(lB2SMinDly));
  41120c:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
  411210:	4618      	mov	r0, r3
  411212:	4b80      	ldr	r3, [pc, #512]	; (411414 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  411214:	4798      	blx	r3
  411216:	4603      	mov	r3, r0
  411218:	4619      	mov	r1, r3
  41121a:	6878      	ldr	r0, [r7, #4]
  41121c:	4b81      	ldr	r3, [pc, #516]	; (411424 <inv_set_hw_smplrt_dmp_odrs+0x490>)
  41121e:	4798      	blx	r3
		minDly_accel = lB2SMinDly;
  411220:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
  411224:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
  411228:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  41122c:	4618      	mov	r0, r3
  41122e:	4b7b      	ldr	r3, [pc, #492]	; (41141c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  411230:	4798      	blx	r3
  411232:	4603      	mov	r3, r0
  411234:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
		result |= DividerRateSet(s, lB2SMinDly, hw_smplrt_divider, INV_SENSOR_BRING_TO_SEE);
  411238:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  41123c:	f8b7 105c 	ldrh.w	r1, [r7, #92]	; 0x5c
  411240:	230f      	movs	r3, #15
  411242:	6878      	ldr	r0, [r7, #4]
  411244:	4c76      	ldr	r4, [pc, #472]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  411246:	47a0      	blx	r4
  411248:	4602      	mov	r2, r0
  41124a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41124c:	4313      	orrs	r3, r2
  41124e:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	// set odrs for each enabled sensors

	// Engine ACCEL Based
	if (minDly_accel != 0xFFFF)	{ // 0xFFFF -- none accel based sensor enable
  411250:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411254:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411258:	4293      	cmp	r3, r2
  41125a:	d06d      	beq.n	411338 <inv_set_hw_smplrt_dmp_odrs+0x3a4>
		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
  41125c:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411260:	4618      	mov	r0, r3
  411262:	4b6e      	ldr	r3, [pc, #440]	; (41141c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  411264:	4798      	blx	r3
  411266:	4603      	mov	r3, r0
  411268:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		if (hw_smplrt_divider != s->lLastHwSmplrtDividerAcc) {
  41126c:	687b      	ldr	r3, [r7, #4]
  41126e:	f8b3 3236 	ldrh.w	r3, [r3, #566]	; 0x236
  411272:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411276:	429a      	cmp	r2, r3
  411278:	d025      	beq.n	4112c6 <inv_set_hw_smplrt_dmp_odrs+0x332>

			result |= inv_icm20648_ctrl_set_accel_quaternion_gain(s, hw_smplrt_divider);
  41127a:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  41127e:	4619      	mov	r1, r3
  411280:	6878      	ldr	r0, [r7, #4]
  411282:	4b69      	ldr	r3, [pc, #420]	; (411428 <inv_set_hw_smplrt_dmp_odrs+0x494>)
  411284:	4798      	blx	r3
  411286:	4602      	mov	r2, r0
  411288:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41128a:	4313      	orrs	r3, r2
  41128c:	66fb      	str	r3, [r7, #108]	; 0x6c
			result |= inv_icm20648_ctrl_set_accel_cal_params(s, hw_smplrt_divider);
  41128e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  411292:	4619      	mov	r1, r3
  411294:	6878      	ldr	r0, [r7, #4]
  411296:	4b65      	ldr	r3, [pc, #404]	; (41142c <inv_set_hw_smplrt_dmp_odrs+0x498>)
  411298:	4798      	blx	r3
  41129a:	4602      	mov	r2, r0
  41129c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41129e:	4313      	orrs	r3, r2
  4112a0:	66fb      	str	r3, [r7, #108]	; 0x6c
			result |= inv_icm20648_set_accel_divider(s, hw_smplrt_divider - 1);
  4112a2:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  4112a6:	3b01      	subs	r3, #1
  4112a8:	b29b      	uxth	r3, r3
  4112aa:	b21b      	sxth	r3, r3
  4112ac:	4619      	mov	r1, r3
  4112ae:	6878      	ldr	r0, [r7, #4]
  4112b0:	4b5f      	ldr	r3, [pc, #380]	; (411430 <inv_set_hw_smplrt_dmp_odrs+0x49c>)
  4112b2:	4798      	blx	r3
  4112b4:	4602      	mov	r2, r0
  4112b6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4112b8:	4313      	orrs	r3, r2
  4112ba:	66fb      	str	r3, [r7, #108]	; 0x6c
			s->lLastHwSmplrtDividerAcc = hw_smplrt_divider;
  4112bc:	687b      	ldr	r3, [r7, #4]
  4112be:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4112c2:	f8a3 2236 	strh.w	r2, [r3, #566]	; 0x236
		}

		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel2List), hw_smplrt_divider, INV_SENSOR_ACCEL);
  4112c6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  4112ca:	2205      	movs	r2, #5
  4112cc:	4619      	mov	r1, r3
  4112ce:	6878      	ldr	r0, [r7, #4]
  4112d0:	4b58      	ldr	r3, [pc, #352]	; (411434 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4112d2:	4798      	blx	r3
  4112d4:	4603      	mov	r3, r0
  4112d6:	4619      	mov	r1, r3
  4112d8:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4112dc:	2300      	movs	r3, #0
  4112de:	6878      	ldr	r0, [r7, #4]
  4112e0:	4c4f      	ldr	r4, [pc, #316]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4112e2:	47a0      	blx	r4
  4112e4:	4602      	mov	r2, r0
  4112e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4112e8:	4313      	orrs	r3, r2
  4112ea:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel3List), hw_smplrt_divider, INV_SENSOR_GEOMAG);
  4112ec:	f107 0348 	add.w	r3, r7, #72	; 0x48
  4112f0:	2202      	movs	r2, #2
  4112f2:	4619      	mov	r1, r3
  4112f4:	6878      	ldr	r0, [r7, #4]
  4112f6:	4b4f      	ldr	r3, [pc, #316]	; (411434 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4112f8:	4798      	blx	r3
  4112fa:	4603      	mov	r3, r0
  4112fc:	4619      	mov	r1, r3
  4112fe:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411302:	2307      	movs	r3, #7
  411304:	6878      	ldr	r0, [r7, #4]
  411306:	4c46      	ldr	r4, [pc, #280]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  411308:	47a0      	blx	r4
  41130a:	4602      	mov	r2, r0
  41130c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41130e:	4313      	orrs	r3, r2
  411310:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel4List), hw_smplrt_divider, INV_SENSOR_STEP_COUNTER);
  411312:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  411316:	2205      	movs	r2, #5
  411318:	4619      	mov	r1, r3
  41131a:	6878      	ldr	r0, [r7, #4]
  41131c:	4b45      	ldr	r3, [pc, #276]	; (411434 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  41131e:	4798      	blx	r3
  411320:	4603      	mov	r3, r0
  411322:	4619      	mov	r1, r3
  411324:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411328:	230c      	movs	r3, #12
  41132a:	6878      	ldr	r0, [r7, #4]
  41132c:	4c3c      	ldr	r4, [pc, #240]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  41132e:	47a0      	blx	r4
  411330:	4602      	mov	r2, r0
  411332:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  411334:	4313      	orrs	r3, r2
  411336:	66fb      	str	r3, [r7, #108]	; 0x6c

	}

	// Engine Gyro Based
	if (minDly_gyro != 0xFFFF) { // 0xFFFF -- none gyro based sensor enable
  411338:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  41133c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411340:	4293      	cmp	r3, r2
  411342:	f000 8085 	beq.w	411450 <inv_set_hw_smplrt_dmp_odrs+0x4bc>
		hw_smplrt_divider = SampleRateDividerGet(minDly_gyro);
  411346:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  41134a:	4618      	mov	r0, r3
  41134c:	4b33      	ldr	r3, [pc, #204]	; (41141c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  41134e:	4798      	blx	r3
  411350:	4603      	mov	r3, r0
  411352:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		if (hw_smplrt_divider != s->lLastHwSmplrtDividerGyr) {
  411356:	687b      	ldr	r3, [r7, #4]
  411358:	f8b3 3238 	ldrh.w	r3, [r3, #568]	; 0x238
  41135c:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411360:	429a      	cmp	r2, r3
  411362:	d011      	beq.n	411388 <inv_set_hw_smplrt_dmp_odrs+0x3f4>
			result |= inv_icm20648_set_gyro_divider(s, (unsigned char)(hw_smplrt_divider - 1));
  411364:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  411368:	b2db      	uxtb	r3, r3
  41136a:	3b01      	subs	r3, #1
  41136c:	b2db      	uxtb	r3, r3
  41136e:	4619      	mov	r1, r3
  411370:	6878      	ldr	r0, [r7, #4]
  411372:	4b31      	ldr	r3, [pc, #196]	; (411438 <inv_set_hw_smplrt_dmp_odrs+0x4a4>)
  411374:	4798      	blx	r3
  411376:	4602      	mov	r2, r0
  411378:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41137a:	4313      	orrs	r3, r2
  41137c:	66fb      	str	r3, [r7, #108]	; 0x6c
			s->lLastHwSmplrtDividerGyr = hw_smplrt_divider;
  41137e:	687b      	ldr	r3, [r7, #4]
  411380:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411384:	f8a3 2238 	strh.w	r2, [r3, #568]	; 0x238
		}

		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro2List), hw_smplrt_divider, INV_SENSOR_GYRO);
  411388:	f107 0330 	add.w	r3, r7, #48	; 0x30
  41138c:	2205      	movs	r2, #5
  41138e:	4619      	mov	r1, r3
  411390:	6878      	ldr	r0, [r7, #4]
  411392:	4b28      	ldr	r3, [pc, #160]	; (411434 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  411394:	4798      	blx	r3
  411396:	4603      	mov	r3, r0
  411398:	4619      	mov	r1, r3
  41139a:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  41139e:	2301      	movs	r3, #1
  4113a0:	6878      	ldr	r0, [r7, #4]
  4113a2:	4c1f      	ldr	r4, [pc, #124]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4113a4:	47a0      	blx	r4
  4113a6:	4602      	mov	r2, r0
  4113a8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4113aa:	4313      	orrs	r3, r2
  4113ac:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro3List), hw_smplrt_divider, INV_SENSOR_CALIB_GYRO);
  4113ae:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  4113b2:	2202      	movs	r2, #2
  4113b4:	4619      	mov	r1, r3
  4113b6:	6878      	ldr	r0, [r7, #4]
  4113b8:	4b1e      	ldr	r3, [pc, #120]	; (411434 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4113ba:	4798      	blx	r3
  4113bc:	4603      	mov	r3, r0
  4113be:	4619      	mov	r1, r3
  4113c0:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4113c4:	230a      	movs	r3, #10
  4113c6:	6878      	ldr	r0, [r7, #4]
  4113c8:	4c15      	ldr	r4, [pc, #84]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4113ca:	47a0      	blx	r4
  4113cc:	4602      	mov	r2, r0
  4113ce:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4113d0:	4313      	orrs	r3, r2
  4113d2:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro4List), hw_smplrt_divider, INV_SENSOR_SIXQ);
  4113d4:	f107 0320 	add.w	r3, r7, #32
  4113d8:	2206      	movs	r2, #6
  4113da:	4619      	mov	r1, r3
  4113dc:	6878      	ldr	r0, [r7, #4]
  4113de:	4b15      	ldr	r3, [pc, #84]	; (411434 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4113e0:	4798      	blx	r3
  4113e2:	4603      	mov	r3, r0
  4113e4:	4619      	mov	r1, r3
  4113e6:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4113ea:	2305      	movs	r3, #5
  4113ec:	6878      	ldr	r0, [r7, #4]
  4113ee:	4c0c      	ldr	r4, [pc, #48]	; (411420 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4113f0:	47a0      	blx	r4
  4113f2:	4602      	mov	r2, r0
  4113f4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4113f6:	4313      	orrs	r3, r2
  4113f8:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro5List), hw_smplrt_divider, INV_SENSOR_NINEQ);
  4113fa:	f107 0318 	add.w	r3, r7, #24
  4113fe:	2204      	movs	r2, #4
  411400:	4619      	mov	r1, r3
  411402:	6878      	ldr	r0, [r7, #4]
  411404:	4b0b      	ldr	r3, [pc, #44]	; (411434 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  411406:	4798      	blx	r3
  411408:	4603      	mov	r3, r0
  41140a:	4619      	mov	r1, r3
  41140c:	e016      	b.n	41143c <inv_set_hw_smplrt_dmp_odrs+0x4a8>
  41140e:	bf00      	nop
  411410:	00405e95 	.word	0x00405e95
  411414:	00411571 	.word	0x00411571
  411418:	00408955 	.word	0x00408955
  41141c:	00410b0d 	.word	0x00410b0d
  411420:	00410a89 	.word	0x00410a89
  411424:	004089e9 	.word	0x004089e9
  411428:	00412515 	.word	0x00412515
  41142c:	004125bd 	.word	0x004125bd
  411430:	004062f5 	.word	0x004062f5
  411434:	00410a29 	.word	0x00410a29
  411438:	00406275 	.word	0x00406275
  41143c:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411440:	2306      	movs	r3, #6
  411442:	6878      	ldr	r0, [r7, #4]
  411444:	4c46      	ldr	r4, [pc, #280]	; (411560 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  411446:	47a0      	blx	r4
  411448:	4602      	mov	r2, r0
  41144a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41144c:	4313      	orrs	r3, r2
  41144e:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	// Engine Cpass and Pressure Based
	if ((minDly_cpass != 0xFFFF) || (minDly_pressure != 0xFFFF)) {
  411450:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  411454:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411458:	4293      	cmp	r3, r2
  41145a:	d105      	bne.n	411468 <inv_set_hw_smplrt_dmp_odrs+0x4d4>
  41145c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
  411460:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411464:	4293      	cmp	r3, r2
  411466:	d075      	beq.n	411554 <inv_set_hw_smplrt_dmp_odrs+0x5c0>
		unsigned int lI2cEffectiveDivider = 0;
  411468:	2300      	movs	r3, #0
  41146a:	60bb      	str	r3, [r7, #8]

		// if compass or pressure are alone, compute 1st stage divider, otherwise it will be taken from accel or gyro
		if ( (minDly_accel == 0xFFFF) && (minDly_gyro == 0xFFFF) )
  41146c:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411470:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411474:	4293      	cmp	r3, r2
  411476:	d10d      	bne.n	411494 <inv_set_hw_smplrt_dmp_odrs+0x500>
  411478:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  41147c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411480:	4293      	cmp	r3, r2
  411482:	d107      	bne.n	411494 <inv_set_hw_smplrt_dmp_odrs+0x500>
			hw_smplrt_divider = SampleRateDividerGet(minDly);
  411484:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  411488:	4618      	mov	r0, r3
  41148a:	4b36      	ldr	r3, [pc, #216]	; (411564 <inv_set_hw_smplrt_dmp_odrs+0x5d0>)
  41148c:	4798      	blx	r3
  41148e:	4603      	mov	r3, r0
  411490:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		// Apply compass or pressure ODR to I2C and get effective ODR
		// so that 2nd level of divider can take into account real frequency we can expect
		// to determine its divider value
		result |= inv_icm20648_secondary_set_odr(s, hw_smplrt_divider, &lI2cEffectiveDivider);
  411494:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  411498:	f107 0208 	add.w	r2, r7, #8
  41149c:	4619      	mov	r1, r3
  41149e:	6878      	ldr	r0, [r7, #4]
  4114a0:	4b31      	ldr	r3, [pc, #196]	; (411568 <inv_set_hw_smplrt_dmp_odrs+0x5d4>)
  4114a2:	4798      	blx	r3
  4114a4:	4602      	mov	r2, r0
  4114a6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4114a8:	4313      	orrs	r3, r2
  4114aa:	66fb      	str	r3, [r7, #108]	; 0x6c

		// if compass or pressure are alone, recompute 1st stage divider based on configured divider for I2C
		// otherwise divider is taken from accel or gyro, so there is no need to recompute effective divider value
		// based on the divider we just applied
		if ( (minDly_accel == 0xFFFF) && (minDly_gyro == 0xFFFF) )
  4114ac:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  4114b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4114b4:	4293      	cmp	r3, r2
  4114b6:	d108      	bne.n	4114ca <inv_set_hw_smplrt_dmp_odrs+0x536>
  4114b8:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  4114bc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4114c0:	4293      	cmp	r3, r2
  4114c2:	d102      	bne.n	4114ca <inv_set_hw_smplrt_dmp_odrs+0x536>
			hw_smplrt_divider = lI2cEffectiveDivider;
  4114c4:	68bb      	ldr	r3, [r7, #8]
  4114c6:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		if (minDly_cpass != 0xFFFF) {
  4114ca:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  4114ce:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4114d2:	4293      	cmp	r3, r2
  4114d4:	d025      	beq.n	411522 <inv_set_hw_smplrt_dmp_odrs+0x58e>
			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenCpass2List), hw_smplrt_divider, INV_SENSOR_COMPASS);
  4114d6:	f107 0314 	add.w	r3, r7, #20
  4114da:	2202      	movs	r2, #2
  4114dc:	4619      	mov	r1, r3
  4114de:	6878      	ldr	r0, [r7, #4]
  4114e0:	4b22      	ldr	r3, [pc, #136]	; (41156c <inv_set_hw_smplrt_dmp_odrs+0x5d8>)
  4114e2:	4798      	blx	r3
  4114e4:	4603      	mov	r3, r0
  4114e6:	4619      	mov	r1, r3
  4114e8:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4114ec:	2303      	movs	r3, #3
  4114ee:	6878      	ldr	r0, [r7, #4]
  4114f0:	4c1b      	ldr	r4, [pc, #108]	; (411560 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  4114f2:	47a0      	blx	r4
  4114f4:	4602      	mov	r2, r0
  4114f6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4114f8:	4313      	orrs	r3, r2
  4114fa:	66fb      	str	r3, [r7, #108]	; 0x6c
			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenCpass3List), hw_smplrt_divider, INV_SENSOR_CALIB_COMPASS);
  4114fc:	f107 0310 	add.w	r3, r7, #16
  411500:	2202      	movs	r2, #2
  411502:	4619      	mov	r1, r3
  411504:	6878      	ldr	r0, [r7, #4]
  411506:	4b19      	ldr	r3, [pc, #100]	; (41156c <inv_set_hw_smplrt_dmp_odrs+0x5d8>)
  411508:	4798      	blx	r3
  41150a:	4603      	mov	r3, r0
  41150c:	4619      	mov	r1, r3
  41150e:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411512:	230b      	movs	r3, #11
  411514:	6878      	ldr	r0, [r7, #4]
  411516:	4c12      	ldr	r4, [pc, #72]	; (411560 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  411518:	47a0      	blx	r4
  41151a:	4602      	mov	r2, r0
  41151c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41151e:	4313      	orrs	r3, r2
  411520:	66fb      	str	r3, [r7, #108]	; 0x6c
		}

		if (minDly_pressure != 0xFFFF)
  411522:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
  411526:	f64f 72ff 	movw	r2, #65535	; 0xffff
  41152a:	4293      	cmp	r3, r2
  41152c:	d012      	beq.n	411554 <inv_set_hw_smplrt_dmp_odrs+0x5c0>
			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenPressure2List), hw_smplrt_divider, INV_SENSOR_PRESSURE);
  41152e:	f107 030c 	add.w	r3, r7, #12
  411532:	2202      	movs	r2, #2
  411534:	4619      	mov	r1, r3
  411536:	6878      	ldr	r0, [r7, #4]
  411538:	4b0c      	ldr	r3, [pc, #48]	; (41156c <inv_set_hw_smplrt_dmp_odrs+0x5d8>)
  41153a:	4798      	blx	r3
  41153c:	4603      	mov	r3, r0
  41153e:	4619      	mov	r1, r3
  411540:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411544:	2309      	movs	r3, #9
  411546:	6878      	ldr	r0, [r7, #4]
  411548:	4c05      	ldr	r4, [pc, #20]	; (411560 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  41154a:	47a0      	blx	r4
  41154c:	4602      	mov	r2, r0
  41154e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  411550:	4313      	orrs	r3, r2
  411552:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	return result;
  411554:	6efb      	ldr	r3, [r7, #108]	; 0x6c
}
  411556:	4618      	mov	r0, r3
  411558:	3774      	adds	r7, #116	; 0x74
  41155a:	46bd      	mov	sp, r7
  41155c:	bd90      	pop	{r4, r7, pc}
  41155e:	bf00      	nop
  411560:	00410a89 	.word	0x00410a89
  411564:	00410b0d 	.word	0x00410b0d
  411568:	00405ad5 	.word	0x00405ad5
  41156c:	00410a29 	.word	0x00410a29

00411570 <get_multiple_56_rate>:

static short get_multiple_56_rate(unsigned short delayInMs)
{
  411570:	b480      	push	{r7}
  411572:	b085      	sub	sp, #20
  411574:	af00      	add	r7, sp, #0
  411576:	4603      	mov	r3, r0
  411578:	80fb      	strh	r3, [r7, #6]
	short lfreq = 0;
  41157a:	2300      	movs	r3, #0
  41157c:	81fb      	strh	r3, [r7, #14]

	// > 1KHz
	if( delayInMs < 2 ){
  41157e:	88fb      	ldrh	r3, [r7, #6]
  411580:	2b01      	cmp	r3, #1
  411582:	d803      	bhi.n	41158c <get_multiple_56_rate+0x1c>
	lfreq = DMP_ALGO_FREQ_900;
  411584:	f44f 7361 	mov.w	r3, #900	; 0x384
  411588:	81fb      	strh	r3, [r7, #14]
  41158a:	e020      	b.n	4115ce <get_multiple_56_rate+0x5e>
	}
	// 225Hz - 500Hz
	else if(( delayInMs >= 2 ) && ( delayInMs < 4 )){
  41158c:	88fb      	ldrh	r3, [r7, #6]
  41158e:	2b01      	cmp	r3, #1
  411590:	d906      	bls.n	4115a0 <get_multiple_56_rate+0x30>
  411592:	88fb      	ldrh	r3, [r7, #6]
  411594:	2b03      	cmp	r3, #3
  411596:	d803      	bhi.n	4115a0 <get_multiple_56_rate+0x30>
	lfreq = DMP_ALGO_FREQ_450;
  411598:	f44f 73e1 	mov.w	r3, #450	; 0x1c2
  41159c:	81fb      	strh	r3, [r7, #14]
  41159e:	e016      	b.n	4115ce <get_multiple_56_rate+0x5e>
	}
	// 112Hz - 225Hz
	else if(( delayInMs >= 4 ) && ( delayInMs < 8 )){
  4115a0:	88fb      	ldrh	r3, [r7, #6]
  4115a2:	2b03      	cmp	r3, #3
  4115a4:	d905      	bls.n	4115b2 <get_multiple_56_rate+0x42>
  4115a6:	88fb      	ldrh	r3, [r7, #6]
  4115a8:	2b07      	cmp	r3, #7
  4115aa:	d802      	bhi.n	4115b2 <get_multiple_56_rate+0x42>
	lfreq = DMP_ALGO_FREQ_225;
  4115ac:	23e1      	movs	r3, #225	; 0xe1
  4115ae:	81fb      	strh	r3, [r7, #14]
  4115b0:	e00d      	b.n	4115ce <get_multiple_56_rate+0x5e>
	}
	// 56Hz - 112Hz
	else if(( delayInMs >= 8 ) && ( delayInMs < 17 )){
  4115b2:	88fb      	ldrh	r3, [r7, #6]
  4115b4:	2b07      	cmp	r3, #7
  4115b6:	d905      	bls.n	4115c4 <get_multiple_56_rate+0x54>
  4115b8:	88fb      	ldrh	r3, [r7, #6]
  4115ba:	2b10      	cmp	r3, #16
  4115bc:	d802      	bhi.n	4115c4 <get_multiple_56_rate+0x54>
	lfreq = DMP_ALGO_FREQ_112;
  4115be:	2370      	movs	r3, #112	; 0x70
  4115c0:	81fb      	strh	r3, [r7, #14]
  4115c2:	e004      	b.n	4115ce <get_multiple_56_rate+0x5e>
	}
	// < 56Hz
	else if(delayInMs >= 17){
  4115c4:	88fb      	ldrh	r3, [r7, #6]
  4115c6:	2b10      	cmp	r3, #16
  4115c8:	d901      	bls.n	4115ce <get_multiple_56_rate+0x5e>
	lfreq = DMP_ALGO_FREQ_56;
  4115ca:	2338      	movs	r3, #56	; 0x38
  4115cc:	81fb      	strh	r3, [r7, #14]
	}

	return lfreq;
  4115ce:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
  4115d2:	4618      	mov	r0, r3
  4115d4:	3714      	adds	r7, #20
  4115d6:	46bd      	mov	sp, r7
  4115d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4115dc:	4770      	bx	lr
	...

004115e0 <inv_icm20648_set_odr>:

int inv_icm20648_set_odr(struct inv_icm20648 * s, unsigned char androidSensor, unsigned short delayInMs)
{
  4115e0:	b590      	push	{r4, r7, lr}
  4115e2:	b085      	sub	sp, #20
  4115e4:	af00      	add	r7, sp, #0
  4115e6:	6078      	str	r0, [r7, #4]
  4115e8:	460b      	mov	r3, r1
  4115ea:	70fb      	strb	r3, [r7, #3]
  4115ec:	4613      	mov	r3, r2
  4115ee:	803b      	strh	r3, [r7, #0]
	int result;

	if(sensor_needs_compass(androidSensor))
  4115f0:	78fb      	ldrb	r3, [r7, #3]
  4115f2:	4618      	mov	r0, r3
  4115f4:	4bb4      	ldr	r3, [pc, #720]	; (4118c8 <inv_icm20648_set_odr+0x2e8>)
  4115f6:	4798      	blx	r3
  4115f8:	4603      	mov	r3, r0
  4115fa:	2b00      	cmp	r3, #0
  4115fc:	d008      	beq.n	411610 <inv_icm20648_set_odr+0x30>
		if(!inv_icm20648_get_compass_availability(s))
  4115fe:	6878      	ldr	r0, [r7, #4]
  411600:	4bb2      	ldr	r3, [pc, #712]	; (4118cc <inv_icm20648_set_odr+0x2ec>)
  411602:	4798      	blx	r3
  411604:	4603      	mov	r3, r0
  411606:	2b00      	cmp	r3, #0
  411608:	d102      	bne.n	411610 <inv_icm20648_set_odr+0x30>
			return -1;
  41160a:	f04f 33ff 	mov.w	r3, #4294967295
  41160e:	e1e3      	b.n	4119d8 <inv_icm20648_set_odr+0x3f8>

	//check if sensor is bac algo dependant
	if(sensor_needs_bac_algo(androidSensor)) {
  411610:	78fb      	ldrb	r3, [r7, #3]
  411612:	4618      	mov	r0, r3
  411614:	4bae      	ldr	r3, [pc, #696]	; (4118d0 <inv_icm20648_set_odr+0x2f0>)
  411616:	4798      	blx	r3
  411618:	4603      	mov	r3, r0
  41161a:	2b00      	cmp	r3, #0
  41161c:	d001      	beq.n	411622 <inv_icm20648_set_odr+0x42>
		// set odr for sensors using BAC (1/56)
		delayInMs = INV_ODR_DEFAULT_BAC;
  41161e:	2312      	movs	r3, #18
  411620:	803b      	strh	r3, [r7, #0]
	}

	inv_icm20648_prevent_lpen_control(s);
  411622:	6878      	ldr	r0, [r7, #4]
  411624:	4bab      	ldr	r3, [pc, #684]	; (4118d4 <inv_icm20648_set_odr+0x2f4>)
  411626:	4798      	blx	r3

	// check that requested ODR is within the allowed limits
	if (delayInMs < s->inv_androidSensorsOdr_boundaries[androidSensor][0]) delayInMs = s->inv_androidSensorsOdr_boundaries[androidSensor][0];
  411628:	78fa      	ldrb	r2, [r7, #3]
  41162a:	687b      	ldr	r3, [r7, #4]
  41162c:	325a      	adds	r2, #90	; 0x5a
  41162e:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  411632:	883a      	ldrh	r2, [r7, #0]
  411634:	429a      	cmp	r2, r3
  411636:	d205      	bcs.n	411644 <inv_icm20648_set_odr+0x64>
  411638:	78fa      	ldrb	r2, [r7, #3]
  41163a:	687b      	ldr	r3, [r7, #4]
  41163c:	325a      	adds	r2, #90	; 0x5a
  41163e:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  411642:	803b      	strh	r3, [r7, #0]
	if (delayInMs > s->inv_androidSensorsOdr_boundaries[androidSensor][1]) delayInMs = s->inv_androidSensorsOdr_boundaries[androidSensor][1];
  411644:	78fb      	ldrb	r3, [r7, #3]
  411646:	687a      	ldr	r2, [r7, #4]
  411648:	009b      	lsls	r3, r3, #2
  41164a:	4413      	add	r3, r2
  41164c:	f8b3 316a 	ldrh.w	r3, [r3, #362]	; 0x16a
  411650:	883a      	ldrh	r2, [r7, #0]
  411652:	429a      	cmp	r2, r3
  411654:	d906      	bls.n	411664 <inv_icm20648_set_odr+0x84>
  411656:	78fb      	ldrb	r3, [r7, #3]
  411658:	687a      	ldr	r2, [r7, #4]
  41165a:	009b      	lsls	r3, r3, #2
  41165c:	4413      	add	r3, r2
  41165e:	f8b3 316a 	ldrh.w	r3, [r3, #362]	; 0x16a
  411662:	803b      	strh	r3, [r7, #0]
	switch (androidSensor) {
  411664:	78fb      	ldrb	r3, [r7, #3]
  411666:	2b30      	cmp	r3, #48	; 0x30
  411668:	f200 819b 	bhi.w	4119a2 <inv_icm20648_set_odr+0x3c2>
  41166c:	a201      	add	r2, pc, #4	; (adr r2, 411674 <inv_icm20648_set_odr+0x94>)
  41166e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  411672:	bf00      	nop
  411674:	004119a3 	.word	0x004119a3
  411678:	00411739 	.word	0x00411739
  41167c:	0041189f 	.word	0x0041189f
  411680:	0041186b 	.word	0x0041186b
  411684:	0041183f 	.word	0x0041183f
  411688:	004118a9 	.word	0x004118a9
  41168c:	00411985 	.word	0x00411985
  411690:	004119a3 	.word	0x004119a3
  411694:	0041197b 	.word	0x0041197b
  411698:	00411849 	.word	0x00411849
  41169c:	00411849 	.word	0x00411849
  4116a0:	0041186b 	.word	0x0041186b
  4116a4:	004119a3 	.word	0x004119a3
  4116a8:	004119a3 	.word	0x004119a3
  4116ac:	00411895 	.word	0x00411895
  4116b0:	00411849 	.word	0x00411849
  4116b4:	004117cf 	.word	0x004117cf
  4116b8:	004118bd 	.word	0x004118bd
  4116bc:	004117a9 	.word	0x004117a9
  4116c0:	004117a9 	.word	0x004117a9
  4116c4:	004117b3 	.word	0x004117b3
  4116c8:	004119a3 	.word	0x004119a3
  4116cc:	004118a9 	.word	0x004118a9
  4116d0:	004118b3 	.word	0x004118b3
  4116d4:	00411971 	.word	0x00411971
  4116d8:	0041193d 	.word	0x0041193d
  4116dc:	00411911 	.word	0x00411911
  4116e0:	0041197b 	.word	0x0041197b
  4116e4:	0041198f 	.word	0x0041198f
  4116e8:	0041191b 	.word	0x0041191b
  4116ec:	0041191b 	.word	0x0041191b
  4116f0:	0041193d 	.word	0x0041193d
  4116f4:	004119a3 	.word	0x004119a3
  4116f8:	004119a3 	.word	0x004119a3
  4116fc:	00411967 	.word	0x00411967
  411700:	0041191b 	.word	0x0041191b
  411704:	00411907 	.word	0x00411907
  411708:	004118bd 	.word	0x004118bd
  41170c:	004118bd 	.word	0x004118bd
  411710:	004118e1 	.word	0x004118e1
  411714:	004119a3 	.word	0x004119a3
  411718:	004118f3 	.word	0x004118f3
  41171c:	00411771 	.word	0x00411771
  411720:	00411807 	.word	0x00411807
  411724:	004119a3 	.word	0x004119a3
  411728:	004118fd 	.word	0x004118fd
  41172c:	00411999 	.word	0x00411999
  411730:	004117c5 	.word	0x004117c5
  411734:	004119a3 	.word	0x004119a3
		case ANDROID_SENSOR_ACCELEROMETER:
			if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
  411738:	212a      	movs	r1, #42	; 0x2a
  41173a:	6878      	ldr	r0, [r7, #4]
  41173c:	4b66      	ldr	r3, [pc, #408]	; (4118d8 <inv_icm20648_set_odr+0x2f8>)
  41173e:	4798      	blx	r3
  411740:	4603      	mov	r3, r0
  411742:	2b00      	cmp	r3, #0
  411744:	d00b      	beq.n	41175e <inv_icm20648_set_odr+0x17e>
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(delayInMs,s->odr_racc_ms);
  411746:	687b      	ldr	r3, [r7, #4]
  411748:	f8b3 2248 	ldrh.w	r2, [r3, #584]	; 0x248
  41174c:	883b      	ldrh	r3, [r7, #0]
  41174e:	4293      	cmp	r3, r2
  411750:	bf28      	it	cs
  411752:	4613      	movcs	r3, r2
  411754:	b29a      	uxth	r2, r3
  411756:	687b      	ldr	r3, [r7, #4]
  411758:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  41175c:	e003      	b.n	411766 <inv_icm20648_set_odr+0x186>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = delayInMs;
  41175e:	687b      	ldr	r3, [r7, #4]
  411760:	883a      	ldrh	r2, [r7, #0]
  411762:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
			s->odr_acc_ms = delayInMs;
  411766:	687b      	ldr	r3, [r7, #4]
  411768:	883a      	ldrh	r2, [r7, #0]
  41176a:	f8a3 2246 	strh.w	r2, [r3, #582]	; 0x246
			break;
  41176e:	e119      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_RAW_ACCELEROMETER:
			if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER))
  411770:	2101      	movs	r1, #1
  411772:	6878      	ldr	r0, [r7, #4]
  411774:	4b58      	ldr	r3, [pc, #352]	; (4118d8 <inv_icm20648_set_odr+0x2f8>)
  411776:	4798      	blx	r3
  411778:	4603      	mov	r3, r0
  41177a:	2b00      	cmp	r3, #0
  41177c:	d00b      	beq.n	411796 <inv_icm20648_set_odr+0x1b6>
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(delayInMs,s->odr_acc_ms);
  41177e:	687b      	ldr	r3, [r7, #4]
  411780:	f8b3 2246 	ldrh.w	r2, [r3, #582]	; 0x246
  411784:	883b      	ldrh	r3, [r7, #0]
  411786:	4293      	cmp	r3, r2
  411788:	bf28      	it	cs
  41178a:	4613      	movcs	r3, r2
  41178c:	b29a      	uxth	r2, r3
  41178e:	687b      	ldr	r3, [r7, #4]
  411790:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  411794:	e003      	b.n	41179e <inv_icm20648_set_odr+0x1be>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = delayInMs;
  411796:	687b      	ldr	r3, [r7, #4]
  411798:	883a      	ldrh	r2, [r7, #0]
  41179a:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
			s->odr_racc_ms = delayInMs;
  41179e:	687b      	ldr	r3, [r7, #4]
  4117a0:	883a      	ldrh	r2, [r7, #0]
  4117a2:	f8a3 2248 	strh.w	r2, [r3, #584]	; 0x248
			break;
  4117a6:	e0fd      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_STEP_DETECTOR:
		case ANDROID_SENSOR_STEP_COUNTER:
			s->inv_dmp_odr_delays[INV_SENSOR_STEP_COUNTER] = delayInMs;
  4117a8:	687b      	ldr	r3, [r7, #4]
  4117aa:	883a      	ldrh	r2, [r7, #0]
  4117ac:	f8a3 211e 	strh.w	r2, [r3, #286]	; 0x11e
			break;
  4117b0:	e0f8      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:
			s->inv_dmp_odr_delays[INV_SENSOR_GEOMAG] = delayInMs;
  4117b2:	687b      	ldr	r3, [r7, #4]
  4117b4:	883a      	ldrh	r2, [r7, #0]
  4117b6:	f8a3 2114 	strh.w	r2, [r3, #276]	; 0x114
			s->inv_dmp_odr_delays[INV_SENSOR_GEOMAG_cpass] = delayInMs;
  4117ba:	687b      	ldr	r3, [r7, #4]
  4117bc:	883a      	ldrh	r2, [r7, #0]
  4117be:	f8a3 212a 	strh.w	r2, [r3, #298]	; 0x12a
			break;
  4117c2:	e0ef      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_ACTIVITY_CLASSIFICATON:
			s->inv_dmp_odr_delays[INV_SENSOR_ACTIVITY_CLASSIFIER] = delayInMs;
  4117c4:	687b      	ldr	r3, [r7, #4]
  4117c6:	883a      	ldrh	r2, [r7, #0]
  4117c8:	f8a3 2120 	strh.w	r2, [r3, #288]	; 0x120
			break;
  4117cc:	e0ea      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED:
			if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
  4117ce:	212b      	movs	r1, #43	; 0x2b
  4117d0:	6878      	ldr	r0, [r7, #4]
  4117d2:	4b41      	ldr	r3, [pc, #260]	; (4118d8 <inv_icm20648_set_odr+0x2f8>)
  4117d4:	4798      	blx	r3
  4117d6:	4603      	mov	r3, r0
  4117d8:	2b00      	cmp	r3, #0
  4117da:	d00b      	beq.n	4117f4 <inv_icm20648_set_odr+0x214>
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(delayInMs,s->odr_rgyr_ms);
  4117dc:	687b      	ldr	r3, [r7, #4]
  4117de:	f8b3 224c 	ldrh.w	r2, [r3, #588]	; 0x24c
  4117e2:	883b      	ldrh	r3, [r7, #0]
  4117e4:	4293      	cmp	r3, r2
  4117e6:	bf28      	it	cs
  4117e8:	4613      	movcs	r3, r2
  4117ea:	b29a      	uxth	r2, r3
  4117ec:	687b      	ldr	r3, [r7, #4]
  4117ee:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  4117f2:	e003      	b.n	4117fc <inv_icm20648_set_odr+0x21c>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = delayInMs;
  4117f4:	687b      	ldr	r3, [r7, #4]
  4117f6:	883a      	ldrh	r2, [r7, #0]
  4117f8:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
			s->odr_gyr_ms = delayInMs;
  4117fc:	687b      	ldr	r3, [r7, #4]
  4117fe:	883a      	ldrh	r2, [r7, #0]
  411800:	f8a3 224a 	strh.w	r2, [r3, #586]	; 0x24a
			break;
  411804:	e0ce      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_RAW_GYROSCOPE:
			if(inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED))
  411806:	2110      	movs	r1, #16
  411808:	6878      	ldr	r0, [r7, #4]
  41180a:	4b33      	ldr	r3, [pc, #204]	; (4118d8 <inv_icm20648_set_odr+0x2f8>)
  41180c:	4798      	blx	r3
  41180e:	4603      	mov	r3, r0
  411810:	2b00      	cmp	r3, #0
  411812:	d00b      	beq.n	41182c <inv_icm20648_set_odr+0x24c>
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(delayInMs,s->odr_gyr_ms);
  411814:	687b      	ldr	r3, [r7, #4]
  411816:	f8b3 224a 	ldrh.w	r2, [r3, #586]	; 0x24a
  41181a:	883b      	ldrh	r3, [r7, #0]
  41181c:	4293      	cmp	r3, r2
  41181e:	bf28      	it	cs
  411820:	4613      	movcs	r3, r2
  411822:	b29a      	uxth	r2, r3
  411824:	687b      	ldr	r3, [r7, #4]
  411826:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  41182a:	e003      	b.n	411834 <inv_icm20648_set_odr+0x254>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = delayInMs;
  41182c:	687b      	ldr	r3, [r7, #4]
  41182e:	883a      	ldrh	r2, [r7, #0]
  411830:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
			s->odr_rgyr_ms = delayInMs;
  411834:	687b      	ldr	r3, [r7, #4]
  411836:	883a      	ldrh	r2, [r7, #0]
  411838:	f8a3 224c 	strh.w	r2, [r3, #588]	; 0x24c
			break;
  41183c:	e0b2      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_GYROSCOPE:
			s->inv_dmp_odr_delays[INV_SENSOR_CALIB_GYRO] = delayInMs;
  41183e:	687b      	ldr	r3, [r7, #4]
  411840:	883a      	ldrh	r2, [r7, #0]
  411842:	f8a3 211a 	strh.w	r2, [r3, #282]	; 0x11a
			break;
  411846:	e0ad      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
		case ANDROID_SENSOR_LINEAR_ACCELERATION:
			// if augmented sensors are handled by this driver,
			// then the fastest 6quat-based sensor which is enabled
			// should be applied to all 6quat-based sensors
			delayInMs = inv_icm20648_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  411848:	883a      	ldrh	r2, [r7, #0]
  41184a:	78fb      	ldrb	r3, [r7, #3]
  41184c:	4619      	mov	r1, r3
  41184e:	6878      	ldr	r0, [r7, #4]
  411850:	4b22      	ldr	r3, [pc, #136]	; (4118dc <inv_icm20648_set_odr+0x2fc>)
  411852:	4798      	blx	r3
  411854:	4603      	mov	r3, r0
  411856:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_SIXQ] = delayInMs;
  411858:	687b      	ldr	r3, [r7, #4]
  41185a:	883a      	ldrh	r2, [r7, #0]
  41185c:	f8a3 2110 	strh.w	r2, [r3, #272]	; 0x110
			s->inv_dmp_odr_delays[INV_SENSOR_SIXQ_accel] = delayInMs;
  411860:	687b      	ldr	r3, [r7, #4]
  411862:	883a      	ldrh	r2, [r7, #0]
  411864:	f8a3 2126 	strh.w	r2, [r3, #294]	; 0x126
			break;
  411868:	e09c      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_ORIENTATION:
		case ANDROID_SENSOR_ROTATION_VECTOR:
			// if augmented sensors are handled by this driver,
			// then the fastest 9quat-based sensor which is enabled
			// should be applied to all 9quat-based sensors
			delayInMs = inv_icm20648_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  41186a:	883a      	ldrh	r2, [r7, #0]
  41186c:	78fb      	ldrb	r3, [r7, #3]
  41186e:	4619      	mov	r1, r3
  411870:	6878      	ldr	r0, [r7, #4]
  411872:	4b1a      	ldr	r3, [pc, #104]	; (4118dc <inv_icm20648_set_odr+0x2fc>)
  411874:	4798      	blx	r3
  411876:	4603      	mov	r3, r0
  411878:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ] = delayInMs;
  41187a:	687b      	ldr	r3, [r7, #4]
  41187c:	883a      	ldrh	r2, [r7, #0]
  41187e:	f8a3 2112 	strh.w	r2, [r3, #274]	; 0x112
			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_accel] = delayInMs;
  411882:	687b      	ldr	r3, [r7, #4]
  411884:	883a      	ldrh	r2, [r7, #0]
  411886:	f8a3 2128 	strh.w	r2, [r3, #296]	; 0x128
			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_cpass] = delayInMs;
  41188a:	687b      	ldr	r3, [r7, #4]
  41188c:	883a      	ldrh	r2, [r7, #0]
  41188e:	f8a3 212c 	strh.w	r2, [r3, #300]	; 0x12c
			break;
  411892:	e087      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:
			s->inv_dmp_odr_delays[INV_SENSOR_COMPASS] = delayInMs;
  411894:	687b      	ldr	r3, [r7, #4]
  411896:	883a      	ldrh	r2, [r7, #0]
  411898:	f8a3 210c 	strh.w	r2, [r3, #268]	; 0x10c
			break;
  41189c:	e082      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_GEOMAGNETIC_FIELD:
			s->inv_dmp_odr_delays[INV_SENSOR_CALIB_COMPASS] = delayInMs;
  41189e:	687b      	ldr	r3, [r7, #4]
  4118a0:	883a      	ldrh	r2, [r7, #0]
  4118a2:	f8a3 211c 	strh.w	r2, [r3, #284]	; 0x11c
			break;
  4118a6:	e07d      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_LIGHT:
		case ANDROID_SENSOR_PROXIMITY:
			s->inv_dmp_odr_delays[INV_SENSOR_ALS] = delayInMs;
  4118a8:	687b      	ldr	r3, [r7, #4]
  4118aa:	883a      	ldrh	r2, [r7, #0]
  4118ac:	f8a3 210e 	strh.w	r2, [r3, #270]	; 0x10e
			break;
  4118b0:	e078      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_ACCELEROMETER:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_ACCEL] = delayInMs;
  4118b2:	687b      	ldr	r3, [r7, #4]
  4118b4:	883a      	ldrh	r2, [r7, #0]
  4118b6:	f8a3 212e 	strh.w	r2, [r3, #302]	; 0x12e
			break;
  4118ba:	e073      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_STEP_DETECTOR:
		case ANDROID_SENSOR_WAKEUP_STEP_COUNTER:
		case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_STEP_COUNTER] = delayInMs;
  4118bc:	687b      	ldr	r3, [r7, #4]
  4118be:	883a      	ldrh	r2, [r7, #0]
  4118c0:	f8a3 2144 	strh.w	r2, [r3, #324]	; 0x144
			break;
  4118c4:	e06e      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
  4118c6:	bf00      	nop
  4118c8:	004126b1 	.word	0x004126b1
  4118cc:	004061d1 	.word	0x004061d1
  4118d0:	00412775 	.word	0x00412775
  4118d4:	00405b2d 	.word	0x00405b2d
  4118d8:	004109f1 	.word	0x004109f1
  4118dc:	0041038d 	.word	0x0041038d

		case ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GEOMAG] = delayInMs;
  4118e0:	687b      	ldr	r3, [r7, #4]
  4118e2:	883a      	ldrh	r2, [r7, #0]
  4118e4:	f8a3 213a 	strh.w	r2, [r3, #314]	; 0x13a
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GEOMAG_cpass] = delayInMs;
  4118e8:	687b      	ldr	r3, [r7, #4]
  4118ea:	883a      	ldrh	r2, [r7, #0]
  4118ec:	f8a3 214c 	strh.w	r2, [r3, #332]	; 0x14c
			break;
  4118f0:	e058      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_TILT_DETECTOR] = delayInMs;
  4118f2:	687b      	ldr	r3, [r7, #4]
  4118f4:	883a      	ldrh	r2, [r7, #0]
  4118f6:	f8a3 2146 	strh.w	r2, [r3, #326]	; 0x146
			break;
  4118fa:	e053      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_B2S:
			s->inv_dmp_odr_delays[INV_SENSOR_BRING_TO_SEE] = delayInMs;
  4118fc:	687b      	ldr	r3, [r7, #4]
  4118fe:	883a      	ldrh	r2, [r7, #0]
  411900:	f8a3 2124 	strh.w	r2, [r3, #292]	; 0x124
			break;
  411904:	e04e      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GYRO] = delayInMs;
  411906:	687b      	ldr	r3, [r7, #4]
  411908:	883a      	ldrh	r2, [r7, #0]
  41190a:	f8a3 2130 	strh.w	r2, [r3, #304]	; 0x130
			break;
  41190e:	e049      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_GYROSCOPE:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_CALIB_GYRO] = delayInMs;
  411910:	687b      	ldr	r3, [r7, #4]
  411912:	883a      	ldrh	r2, [r7, #0]
  411914:	f8a3 2140 	strh.w	r2, [r3, #320]	; 0x140
			break;
  411918:	e044      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
		case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
			// if augmented sensors are handled by this driver,
			// then the fastest 6quat-based sensor which is enabled
			// should be applied to all 6quat-based sensors
			delayInMs = inv_icm20648_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  41191a:	883a      	ldrh	r2, [r7, #0]
  41191c:	78fb      	ldrb	r3, [r7, #3]
  41191e:	4619      	mov	r1, r3
  411920:	6878      	ldr	r0, [r7, #4]
  411922:	4b2f      	ldr	r3, [pc, #188]	; (4119e0 <inv_icm20648_set_odr+0x400>)
  411924:	4798      	blx	r3
  411926:	4603      	mov	r3, r0
  411928:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ] = delayInMs;
  41192a:	687b      	ldr	r3, [r7, #4]
  41192c:	883a      	ldrh	r2, [r7, #0]
  41192e:	f8a3 2136 	strh.w	r2, [r3, #310]	; 0x136
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ_accel] = delayInMs;
  411932:	687b      	ldr	r3, [r7, #4]
  411934:	883a      	ldrh	r2, [r7, #0]
  411936:	f8a3 2148 	strh.w	r2, [r3, #328]	; 0x148
			break;
  41193a:	e033      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_WAKEUP_ORIENTATION:
		case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
			// if augmented sensors are handled by this driver,
			// then the fastest 9quat-based sensor which is enabled
			// should be applied to all 9quat-based sensors
			delayInMs = inv_icm20648_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  41193c:	883a      	ldrh	r2, [r7, #0]
  41193e:	78fb      	ldrb	r3, [r7, #3]
  411940:	4619      	mov	r1, r3
  411942:	6878      	ldr	r0, [r7, #4]
  411944:	4b26      	ldr	r3, [pc, #152]	; (4119e0 <inv_icm20648_set_odr+0x400>)
  411946:	4798      	blx	r3
  411948:	4603      	mov	r3, r0
  41194a:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ] = delayInMs;
  41194c:	687b      	ldr	r3, [r7, #4]
  41194e:	883a      	ldrh	r2, [r7, #0]
  411950:	f8a3 2138 	strh.w	r2, [r3, #312]	; 0x138
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_accel] = delayInMs;
  411954:	687b      	ldr	r3, [r7, #4]
  411956:	883a      	ldrh	r2, [r7, #0]
  411958:	f8a3 214a 	strh.w	r2, [r3, #330]	; 0x14a
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_cpass] = delayInMs;
  41195c:	687b      	ldr	r3, [r7, #4]
  41195e:	883a      	ldrh	r2, [r7, #0]
  411960:	f8a3 214e 	strh.w	r2, [r3, #334]	; 0x14e
			break;
  411964:	e01e      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_COMPASS] = delayInMs;
  411966:	687b      	ldr	r3, [r7, #4]
  411968:	883a      	ldrh	r2, [r7, #0]
  41196a:	f8a3 2132 	strh.w	r2, [r3, #306]	; 0x132
			break;
  41196e:	e019      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_CALIB_COMPASS] = delayInMs;
  411970:	687b      	ldr	r3, [r7, #4]
  411972:	883a      	ldrh	r2, [r7, #0]
  411974:	f8a3 2142 	strh.w	r2, [r3, #322]	; 0x142
			break;
  411978:	e014      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_LIGHT:
		case ANDROID_SENSOR_WAKEUP_PROXIMITY:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_ALS] = delayInMs;
  41197a:	687b      	ldr	r3, [r7, #4]
  41197c:	883a      	ldrh	r2, [r7, #0]
  41197e:	f8a3 2134 	strh.w	r2, [r3, #308]	; 0x134
			break;
  411982:	e00f      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_PRESSURE:
			s->inv_dmp_odr_delays[INV_SENSOR_PRESSURE] = delayInMs;
  411984:	687b      	ldr	r3, [r7, #4]
  411986:	883a      	ldrh	r2, [r7, #0]
  411988:	f8a3 2118 	strh.w	r2, [r3, #280]	; 0x118
			break;
  41198c:	e00a      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_PRESSURE:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_PRESSURE] = delayInMs;
  41198e:	687b      	ldr	r3, [r7, #4]
  411990:	883a      	ldrh	r2, [r7, #0]
  411992:	f8a3 213e 	strh.w	r2, [r3, #318]	; 0x13e
			break;
  411996:	e005      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>

		case ANDROID_SENSOR_FLIP_PICKUP:
			s->inv_dmp_odr_delays[INV_SENSOR_FLIP_PICKUP] = delayInMs;
  411998:	687b      	ldr	r3, [r7, #4]
  41199a:	883a      	ldrh	r2, [r7, #0]
  41199c:	f8a3 2122 	strh.w	r2, [r3, #290]	; 0x122
			break;
  4119a0:	e000      	b.n	4119a4 <inv_icm20648_set_odr+0x3c4>
		case ANDROID_SENSOR_WAKEUP_RELATIVE_HUMIDITY:
		case ANDROID_SENSOR_WAKEUP_HEART_RATE:
			break;

		default:
			break;
  4119a2:	bf00      	nop
	}

	result = inv_set_hw_smplrt_dmp_odrs(s);
  4119a4:	6878      	ldr	r0, [r7, #4]
  4119a6:	4b0f      	ldr	r3, [pc, #60]	; (4119e4 <inv_icm20648_set_odr+0x404>)
  4119a8:	4798      	blx	r3
  4119aa:	60f8      	str	r0, [r7, #12]
	result |= inv_icm20648_set_gyro_sf(s, inv_icm20648_get_gyro_divider(s), inv_icm20648_get_gyro_fullscale(s));
  4119ac:	6878      	ldr	r0, [r7, #4]
  4119ae:	4b0e      	ldr	r3, [pc, #56]	; (4119e8 <inv_icm20648_set_odr+0x408>)
  4119b0:	4798      	blx	r3
  4119b2:	4603      	mov	r3, r0
  4119b4:	461c      	mov	r4, r3
  4119b6:	6878      	ldr	r0, [r7, #4]
  4119b8:	4b0c      	ldr	r3, [pc, #48]	; (4119ec <inv_icm20648_set_odr+0x40c>)
  4119ba:	4798      	blx	r3
  4119bc:	4603      	mov	r3, r0
  4119be:	461a      	mov	r2, r3
  4119c0:	4621      	mov	r1, r4
  4119c2:	6878      	ldr	r0, [r7, #4]
  4119c4:	4b0a      	ldr	r3, [pc, #40]	; (4119f0 <inv_icm20648_set_odr+0x410>)
  4119c6:	4798      	blx	r3
  4119c8:	4602      	mov	r2, r0
  4119ca:	68fb      	ldr	r3, [r7, #12]
  4119cc:	4313      	orrs	r3, r2
  4119ce:	60fb      	str	r3, [r7, #12]
	// i.e. If you use: O a 63 [ Press capital O then 'a' then 63 then ENTER]
	// You should get the nearest number to 63 here if you debug  the 'test_odr'

	//inv_icm20648_ctrl_get_odr( androidSensor, &test_odr );

	inv_icm20648_allow_lpen_control(s);
  4119d0:	6878      	ldr	r0, [r7, #4]
  4119d2:	4b08      	ldr	r3, [pc, #32]	; (4119f4 <inv_icm20648_set_odr+0x414>)
  4119d4:	4798      	blx	r3
	return result;
  4119d6:	68fb      	ldr	r3, [r7, #12]
}
  4119d8:	4618      	mov	r0, r3
  4119da:	3714      	adds	r7, #20
  4119dc:	46bd      	mov	sp, r7
  4119de:	bd90      	pop	{r4, r7, pc}
  4119e0:	0041038d 	.word	0x0041038d
  4119e4:	00410f95 	.word	0x00410f95
  4119e8:	004062a5 	.word	0x004062a5
  4119ec:	00406549 	.word	0x00406549
  4119f0:	00406341 	.word	0x00406341
  4119f4:	00405b49 	.word	0x00405b49

004119f8 <inv_reGenerate_sensorControl>:

	return result;
}

static void inv_reGenerate_sensorControl(struct inv_icm20648 * s, const short *sen_num_2_ctrl, unsigned short *sensor_control, uint8_t header2_count)
{
  4119f8:	b480      	push	{r7}
  4119fa:	b089      	sub	sp, #36	; 0x24
  4119fc:	af00      	add	r7, sp, #0
  4119fe:	60f8      	str	r0, [r7, #12]
  411a00:	60b9      	str	r1, [r7, #8]
  411a02:	607a      	str	r2, [r7, #4]
  411a04:	70fb      	strb	r3, [r7, #3]
	short delta;
	int i, cntr;
	unsigned long tmp_androidSensorsOn_mask;

	//check if only header2 still remaining
	if(header2_count)
  411a06:	78fb      	ldrb	r3, [r7, #3]
  411a08:	2b00      	cmp	r3, #0
  411a0a:	d003      	beq.n	411a14 <inv_reGenerate_sensorControl+0x1c>
		*sensor_control = HEADER2_SET;
  411a0c:	687b      	ldr	r3, [r7, #4]
  411a0e:	2208      	movs	r2, #8
  411a10:	801a      	strh	r2, [r3, #0]
  411a12:	e002      	b.n	411a1a <inv_reGenerate_sensorControl+0x22>
	else
		*sensor_control = 0;
  411a14:	687b      	ldr	r3, [r7, #4]
  411a16:	2200      	movs	r2, #0
  411a18:	801a      	strh	r2, [r3, #0]
	for (i = 0; i < 2; i++) {
  411a1a:	2300      	movs	r3, #0
  411a1c:	61fb      	str	r3, [r7, #28]
  411a1e:	e02e      	b.n	411a7e <inv_reGenerate_sensorControl+0x86>
		cntr = 32 * i;
  411a20:	69fb      	ldr	r3, [r7, #28]
  411a22:	015b      	lsls	r3, r3, #5
  411a24:	61bb      	str	r3, [r7, #24]
		tmp_androidSensorsOn_mask = s->inv_androidSensorsOn_mask[i];
  411a26:	68fb      	ldr	r3, [r7, #12]
  411a28:	69fa      	ldr	r2, [r7, #28]
  411a2a:	3258      	adds	r2, #88	; 0x58
  411a2c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  411a30:	617b      	str	r3, [r7, #20]
		while (tmp_androidSensorsOn_mask) {
  411a32:	e01e      	b.n	411a72 <inv_reGenerate_sensorControl+0x7a>
			if (tmp_androidSensorsOn_mask & 1) {
  411a34:	697b      	ldr	r3, [r7, #20]
  411a36:	f003 0301 	and.w	r3, r3, #1
  411a3a:	2b00      	cmp	r3, #0
  411a3c:	d013      	beq.n	411a66 <inv_reGenerate_sensorControl+0x6e>
				delta = sen_num_2_ctrl[cntr];
  411a3e:	69bb      	ldr	r3, [r7, #24]
  411a40:	005b      	lsls	r3, r3, #1
  411a42:	68ba      	ldr	r2, [r7, #8]
  411a44:	4413      	add	r3, r2
  411a46:	881b      	ldrh	r3, [r3, #0]
  411a48:	827b      	strh	r3, [r7, #18]
				if (delta != -1) *sensor_control |= delta;
  411a4a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
  411a4e:	f1b3 3fff 	cmp.w	r3, #4294967295
  411a52:	d008      	beq.n	411a66 <inv_reGenerate_sensorControl+0x6e>
  411a54:	687b      	ldr	r3, [r7, #4]
  411a56:	881b      	ldrh	r3, [r3, #0]
  411a58:	b21a      	sxth	r2, r3
  411a5a:	8a7b      	ldrh	r3, [r7, #18]
  411a5c:	4313      	orrs	r3, r2
  411a5e:	b21b      	sxth	r3, r3
  411a60:	b29a      	uxth	r2, r3
  411a62:	687b      	ldr	r3, [r7, #4]
  411a64:	801a      	strh	r2, [r3, #0]
			}
			tmp_androidSensorsOn_mask >>= 1;
  411a66:	697b      	ldr	r3, [r7, #20]
  411a68:	085b      	lsrs	r3, r3, #1
  411a6a:	617b      	str	r3, [r7, #20]
			cntr++;
  411a6c:	69bb      	ldr	r3, [r7, #24]
  411a6e:	3301      	adds	r3, #1
  411a70:	61bb      	str	r3, [r7, #24]
		while (tmp_androidSensorsOn_mask) {
  411a72:	697b      	ldr	r3, [r7, #20]
  411a74:	2b00      	cmp	r3, #0
  411a76:	d1dd      	bne.n	411a34 <inv_reGenerate_sensorControl+0x3c>
	for (i = 0; i < 2; i++) {
  411a78:	69fb      	ldr	r3, [r7, #28]
  411a7a:	3301      	adds	r3, #1
  411a7c:	61fb      	str	r3, [r7, #28]
  411a7e:	69fb      	ldr	r3, [r7, #28]
  411a80:	2b01      	cmp	r3, #1
  411a82:	ddcd      	ble.n	411a20 <inv_reGenerate_sensorControl+0x28>
		}
	}
}
  411a84:	bf00      	nop
  411a86:	3724      	adds	r7, #36	; 0x24
  411a88:	46bd      	mov	sp, r7
  411a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  411a8e:	4770      	bx	lr

00411a90 <inv_convert_androidSensor_to_control>:
* @param[in] enable non-zero to turn sensor on, 0 to turn sensor off
* @param[in] sen_num_2_ctrl Table matching android sensor number to bits in DMP control register
* @param[in,out] sensor_control Sensor control register to write to DMP to enable/disable sensors
*/
static void inv_convert_androidSensor_to_control(struct inv_icm20648 * s, unsigned char androidSensor, unsigned char enable, const short *sen_num_2_ctrl, unsigned short *sensor_control)
{
  411a90:	b590      	push	{r4, r7, lr}
  411a92:	b087      	sub	sp, #28
  411a94:	af00      	add	r7, sp, #0
  411a96:	60f8      	str	r0, [r7, #12]
  411a98:	607b      	str	r3, [r7, #4]
  411a9a:	460b      	mov	r3, r1
  411a9c:	72fb      	strb	r3, [r7, #11]
  411a9e:	4613      	mov	r3, r2
  411aa0:	72bb      	strb	r3, [r7, #10]
	short delta = 0;
  411aa2:	2300      	movs	r3, #0
  411aa4:	82fb      	strh	r3, [r7, #22]

	if (androidSensor == ANDROID_SENSOR_ACTIVITY_CLASSIFICATON || androidSensor == ANDROID_SENSOR_FLIP_PICKUP ||
  411aa6:	7afb      	ldrb	r3, [r7, #11]
  411aa8:	2b2f      	cmp	r3, #47	; 0x2f
  411aaa:	d008      	beq.n	411abe <inv_convert_androidSensor_to_control+0x2e>
  411aac:	7afb      	ldrb	r3, [r7, #11]
  411aae:	2b2e      	cmp	r3, #46	; 0x2e
  411ab0:	d005      	beq.n	411abe <inv_convert_androidSensor_to_control+0x2e>
  411ab2:	7afb      	ldrb	r3, [r7, #11]
  411ab4:	2b29      	cmp	r3, #41	; 0x29
  411ab6:	d002      	beq.n	411abe <inv_convert_androidSensor_to_control+0x2e>
			androidSensor == ANDROID_SENSOR_WAKEUP_TILT_DETECTOR || androidSensor == ANDROID_SENSOR_B2S) {
  411ab8:	7afb      	ldrb	r3, [r7, #11]
  411aba:	2b2d      	cmp	r3, #45	; 0x2d
  411abc:	d122      	bne.n	411b04 <inv_convert_androidSensor_to_control+0x74>
		if (enable) {
  411abe:	7abb      	ldrb	r3, [r7, #10]
  411ac0:	2b00      	cmp	r3, #0
  411ac2:	d00f      	beq.n	411ae4 <inv_convert_androidSensor_to_control+0x54>
			*sensor_control |= HEADER2_SET;
  411ac4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411ac6:	881b      	ldrh	r3, [r3, #0]
  411ac8:	f043 0308 	orr.w	r3, r3, #8
  411acc:	b29a      	uxth	r2, r3
  411ace:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411ad0:	801a      	strh	r2, [r3, #0]
			//we increment counter
			s->header2_count ++;
  411ad2:	68fb      	ldr	r3, [r7, #12]
  411ad4:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  411ad8:	3301      	adds	r3, #1
  411ada:	b2da      	uxtb	r2, r3
  411adc:	68fb      	ldr	r3, [r7, #12]
  411ade:	f883 223b 	strb.w	r2, [r3, #571]	; 0x23b
  411ae2:	e00f      	b.n	411b04 <inv_convert_androidSensor_to_control+0x74>
		}
		else {
			s->header2_count --;
  411ae4:	68fb      	ldr	r3, [r7, #12]
  411ae6:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  411aea:	3b01      	subs	r3, #1
  411aec:	b2da      	uxtb	r2, r3
  411aee:	68fb      	ldr	r3, [r7, #12]
  411af0:	f883 223b 	strb.w	r2, [r3, #571]	; 0x23b
			// control has to be regenerated when removing sensors because of overlap
			inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
  411af4:	68fb      	ldr	r3, [r7, #12]
  411af6:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  411afa:	6aba      	ldr	r2, [r7, #40]	; 0x28
  411afc:	6879      	ldr	r1, [r7, #4]
  411afe:	68f8      	ldr	r0, [r7, #12]
  411b00:	4c2f      	ldr	r4, [pc, #188]	; (411bc0 <inv_convert_androidSensor_to_control+0x130>)
  411b02:	47a0      	blx	r4
		}
	}

	if (androidSensor >= ANDROID_SENSOR_NUM_MAX)
  411b04:	7afb      	ldrb	r3, [r7, #11]
  411b06:	2b2b      	cmp	r3, #43	; 0x2b
  411b08:	d854      	bhi.n	411bb4 <inv_convert_androidSensor_to_control+0x124>
		return; // Sensor not supported

	delta = sen_num_2_ctrl[androidSensor];
  411b0a:	7afb      	ldrb	r3, [r7, #11]
  411b0c:	005b      	lsls	r3, r3, #1
  411b0e:	687a      	ldr	r2, [r7, #4]
  411b10:	4413      	add	r3, r2
  411b12:	881b      	ldrh	r3, [r3, #0]
  411b14:	82fb      	strh	r3, [r7, #22]
	if (delta == -1)
  411b16:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  411b1a:	f1b3 3fff 	cmp.w	r3, #4294967295
  411b1e:	d04b      	beq.n	411bb8 <inv_convert_androidSensor_to_control+0x128>
		return; // This sensor not supported

	if (enable) {
  411b20:	7abb      	ldrb	r3, [r7, #10]
  411b22:	2b00      	cmp	r3, #0
  411b24:	d022      	beq.n	411b6c <inv_convert_androidSensor_to_control+0xdc>
		s->inv_androidSensorsOn_mask[(androidSensor>>5)] |= 1L << (androidSensor & 0x1F); // Set bit
  411b26:	7afb      	ldrb	r3, [r7, #11]
  411b28:	095b      	lsrs	r3, r3, #5
  411b2a:	b2db      	uxtb	r3, r3
  411b2c:	4618      	mov	r0, r3
  411b2e:	7afb      	ldrb	r3, [r7, #11]
  411b30:	095b      	lsrs	r3, r3, #5
  411b32:	b2db      	uxtb	r3, r3
  411b34:	461a      	mov	r2, r3
  411b36:	68fb      	ldr	r3, [r7, #12]
  411b38:	3258      	adds	r2, #88	; 0x58
  411b3a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  411b3e:	7afa      	ldrb	r2, [r7, #11]
  411b40:	f002 021f 	and.w	r2, r2, #31
  411b44:	2101      	movs	r1, #1
  411b46:	fa01 f202 	lsl.w	r2, r1, r2
  411b4a:	ea43 0102 	orr.w	r1, r3, r2
  411b4e:	68fb      	ldr	r3, [r7, #12]
  411b50:	f100 0258 	add.w	r2, r0, #88	; 0x58
  411b54:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		*sensor_control |= delta;
  411b58:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411b5a:	881b      	ldrh	r3, [r3, #0]
  411b5c:	b21a      	sxth	r2, r3
  411b5e:	8afb      	ldrh	r3, [r7, #22]
  411b60:	4313      	orrs	r3, r2
  411b62:	b21b      	sxth	r3, r3
  411b64:	b29a      	uxth	r2, r3
  411b66:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411b68:	801a      	strh	r2, [r3, #0]
		s->inv_androidSensorsOn_mask[(androidSensor>>5)] &= ~(1L << (androidSensor & 0x1F)); // Clear bit
		// control has to be regenerated when removing sensors because of overlap
		inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
	}

	return;
  411b6a:	e026      	b.n	411bba <inv_convert_androidSensor_to_control+0x12a>
		s->inv_androidSensorsOn_mask[(androidSensor>>5)] &= ~(1L << (androidSensor & 0x1F)); // Clear bit
  411b6c:	7afb      	ldrb	r3, [r7, #11]
  411b6e:	095b      	lsrs	r3, r3, #5
  411b70:	b2db      	uxtb	r3, r3
  411b72:	4618      	mov	r0, r3
  411b74:	7afb      	ldrb	r3, [r7, #11]
  411b76:	095b      	lsrs	r3, r3, #5
  411b78:	b2db      	uxtb	r3, r3
  411b7a:	461a      	mov	r2, r3
  411b7c:	68fb      	ldr	r3, [r7, #12]
  411b7e:	3258      	adds	r2, #88	; 0x58
  411b80:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  411b84:	7afa      	ldrb	r2, [r7, #11]
  411b86:	f002 021f 	and.w	r2, r2, #31
  411b8a:	2101      	movs	r1, #1
  411b8c:	fa01 f202 	lsl.w	r2, r1, r2
  411b90:	43d2      	mvns	r2, r2
  411b92:	ea03 0102 	and.w	r1, r3, r2
  411b96:	68fb      	ldr	r3, [r7, #12]
  411b98:	f100 0258 	add.w	r2, r0, #88	; 0x58
  411b9c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
  411ba0:	68fb      	ldr	r3, [r7, #12]
  411ba2:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  411ba6:	6aba      	ldr	r2, [r7, #40]	; 0x28
  411ba8:	6879      	ldr	r1, [r7, #4]
  411baa:	68f8      	ldr	r0, [r7, #12]
  411bac:	4c04      	ldr	r4, [pc, #16]	; (411bc0 <inv_convert_androidSensor_to_control+0x130>)
  411bae:	47a0      	blx	r4
	return;
  411bb0:	bf00      	nop
  411bb2:	e002      	b.n	411bba <inv_convert_androidSensor_to_control+0x12a>
		return; // Sensor not supported
  411bb4:	bf00      	nop
  411bb6:	e000      	b.n	411bba <inv_convert_androidSensor_to_control+0x12a>
		return; // This sensor not supported
  411bb8:	bf00      	nop
}
  411bba:	371c      	adds	r7, #28
  411bbc:	46bd      	mov	sp, r7
  411bbe:	bd90      	pop	{r4, r7, pc}
  411bc0:	004119f9 	.word	0x004119f9

00411bc4 <inv_icm20648_ctrl_enable_sensor>:

int inv_icm20648_ctrl_enable_sensor(struct inv_icm20648 * s, unsigned char androidSensor, unsigned char enable)
{
  411bc4:	b590      	push	{r4, r7, lr}
  411bc6:	b085      	sub	sp, #20
  411bc8:	af00      	add	r7, sp, #0
  411bca:	6078      	str	r0, [r7, #4]
  411bcc:	460b      	mov	r3, r1
  411bce:	70fb      	strb	r3, [r7, #3]
  411bd0:	4613      	mov	r3, r2
  411bd2:	70bb      	strb	r3, [r7, #2]
	int result = 0;
  411bd4:	2300      	movs	r3, #0
  411bd6:	60fb      	str	r3, [r7, #12]

	if(sensor_needs_compass(androidSensor))
  411bd8:	78fb      	ldrb	r3, [r7, #3]
  411bda:	4618      	mov	r0, r3
  411bdc:	4b1a      	ldr	r3, [pc, #104]	; (411c48 <inv_icm20648_ctrl_enable_sensor+0x84>)
  411bde:	4798      	blx	r3
  411be0:	4603      	mov	r3, r0
  411be2:	2b00      	cmp	r3, #0
  411be4:	d008      	beq.n	411bf8 <inv_icm20648_ctrl_enable_sensor+0x34>
		if(!inv_icm20648_get_compass_availability(s))
  411be6:	6878      	ldr	r0, [r7, #4]
  411be8:	4b18      	ldr	r3, [pc, #96]	; (411c4c <inv_icm20648_ctrl_enable_sensor+0x88>)
  411bea:	4798      	blx	r3
  411bec:	4603      	mov	r3, r0
  411bee:	2b00      	cmp	r3, #0
  411bf0:	d102      	bne.n	411bf8 <inv_icm20648_ctrl_enable_sensor+0x34>
			return -1;
  411bf2:	f04f 33ff 	mov.w	r3, #4294967295
  411bf6:	e022      	b.n	411c3e <inv_icm20648_ctrl_enable_sensor+0x7a>

	inv_icm20648_prevent_lpen_control(s);
  411bf8:	6878      	ldr	r0, [r7, #4]
  411bfa:	4b15      	ldr	r3, [pc, #84]	; (411c50 <inv_icm20648_ctrl_enable_sensor+0x8c>)
  411bfc:	4798      	blx	r3
	if( s->mems_put_to_sleep ) {
  411bfe:	687b      	ldr	r3, [r7, #4]
  411c00:	f993 323c 	ldrsb.w	r3, [r3, #572]	; 0x23c
  411c04:	2b00      	cmp	r3, #0
  411c06:	d00a      	beq.n	411c1e <inv_icm20648_ctrl_enable_sensor+0x5a>
		s->mems_put_to_sleep = 0;
  411c08:	687b      	ldr	r3, [r7, #4]
  411c0a:	2200      	movs	r2, #0
  411c0c:	f883 223c 	strb.w	r2, [r3, #572]	; 0x23c
		result |= inv_icm20648_wakeup_mems(s);
  411c10:	6878      	ldr	r0, [r7, #4]
  411c12:	4b10      	ldr	r3, [pc, #64]	; (411c54 <inv_icm20648_ctrl_enable_sensor+0x90>)
  411c14:	4798      	blx	r3
  411c16:	4602      	mov	r2, r0
  411c18:	68fb      	ldr	r3, [r7, #12]
  411c1a:	4313      	orrs	r3, r2
  411c1c:	60fb      	str	r3, [r7, #12]
	}
	result |= inv_enable_sensor_internal(s, androidSensor, enable, &s->mems_put_to_sleep);
  411c1e:	687b      	ldr	r3, [r7, #4]
  411c20:	f503 730f 	add.w	r3, r3, #572	; 0x23c
  411c24:	78ba      	ldrb	r2, [r7, #2]
  411c26:	78f9      	ldrb	r1, [r7, #3]
  411c28:	6878      	ldr	r0, [r7, #4]
  411c2a:	4c0b      	ldr	r4, [pc, #44]	; (411c58 <inv_icm20648_ctrl_enable_sensor+0x94>)
  411c2c:	47a0      	blx	r4
  411c2e:	4602      	mov	r2, r0
  411c30:	68fb      	ldr	r3, [r7, #12]
  411c32:	4313      	orrs	r3, r2
  411c34:	60fb      	str	r3, [r7, #12]
	inv_icm20648_allow_lpen_control(s);
  411c36:	6878      	ldr	r0, [r7, #4]
  411c38:	4b08      	ldr	r3, [pc, #32]	; (411c5c <inv_icm20648_ctrl_enable_sensor+0x98>)
  411c3a:	4798      	blx	r3
	return result;
  411c3c:	68fb      	ldr	r3, [r7, #12]
}
  411c3e:	4618      	mov	r0, r3
  411c40:	3714      	adds	r7, #20
  411c42:	46bd      	mov	sp, r7
  411c44:	bd90      	pop	{r4, r7, pc}
  411c46:	bf00      	nop
  411c48:	004126b1 	.word	0x004126b1
  411c4c:	004061d1 	.word	0x004061d1
  411c50:	00405b2d 	.word	0x00405b2d
  411c54:	00405d05 	.word	0x00405d05
  411c58:	00411c61 	.word	0x00411c61
  411c5c:	00405b49 	.word	0x00405b49

00411c60 <inv_enable_sensor_internal>:

static int inv_enable_sensor_internal(struct inv_icm20648 * s, unsigned char androidSensor, unsigned char enable, char * mems_put_to_sleep)
{
  411c60:	b590      	push	{r4, r7, lr}
  411c62:	b0a1      	sub	sp, #132	; 0x84
  411c64:	af02      	add	r7, sp, #8
  411c66:	60f8      	str	r0, [r7, #12]
  411c68:	607b      	str	r3, [r7, #4]
  411c6a:	460b      	mov	r3, r1
  411c6c:	72fb      	strb	r3, [r7, #11]
  411c6e:	4613      	mov	r3, r2
  411c70:	72bb      	strb	r3, [r7, #10]
	int result = 0;
  411c72:	2300      	movs	r3, #0
  411c74:	677b      	str	r3, [r7, #116]	; 0x74
	unsigned short inv_event_control = 0;
  411c76:	2300      	movs	r3, #0
  411c78:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
	unsigned short data_rdy_status = 0;
  411c7c:	2300      	movs	r3, #0
  411c7e:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
	unsigned long steps=0;
  411c82:	2300      	movs	r3, #0
  411c84:	66fb      	str	r3, [r7, #108]	; 0x6c
	const short inv_androidSensor_to_control_bits[ANDROID_SENSOR_NUM_MAX]=
  411c86:	4aaf      	ldr	r2, [pc, #700]	; (411f44 <inv_enable_sensor_internal+0x2e4>)
  411c88:	f107 0314 	add.w	r3, r7, #20
  411c8c:	4611      	mov	r1, r2
  411c8e:	2258      	movs	r2, #88	; 0x58
  411c90:	4618      	mov	r0, r3
  411c92:	4bad      	ldr	r3, [pc, #692]	; (411f48 <inv_enable_sensor_internal+0x2e8>)
  411c94:	4798      	blx	r3
		-1,		// ANDROID_SENSOR_WAKEUP_HEART_RATE,
		0,		// ANDROID_SENSOR_WAKEUP_TILT_DETECTOR,
		0x8008, // Raw Acc
		0x4048, // Raw Gyr
	};
	if(enable && !inv_icm20648_ctrl_androidSensor_enabled(s, androidSensor))
  411c96:	7abb      	ldrb	r3, [r7, #10]
  411c98:	2b00      	cmp	r3, #0
  411c9a:	d012      	beq.n	411cc2 <inv_enable_sensor_internal+0x62>
  411c9c:	7afb      	ldrb	r3, [r7, #11]
  411c9e:	4619      	mov	r1, r3
  411ca0:	68f8      	ldr	r0, [r7, #12]
  411ca2:	4baa      	ldr	r3, [pc, #680]	; (411f4c <inv_enable_sensor_internal+0x2ec>)
  411ca4:	4798      	blx	r3
  411ca6:	4603      	mov	r3, r0
  411ca8:	2b00      	cmp	r3, #0
  411caa:	d10a      	bne.n	411cc2 <inv_enable_sensor_internal+0x62>
		s->skip_sample[inv_icm20648_sensor_android_2_sensor_type(androidSensor)] = 1;
  411cac:	7afb      	ldrb	r3, [r7, #11]
  411cae:	4618      	mov	r0, r3
  411cb0:	4ba7      	ldr	r3, [pc, #668]	; (411f50 <inv_enable_sensor_internal+0x2f0>)
  411cb2:	4798      	blx	r3
  411cb4:	4603      	mov	r3, r0
  411cb6:	461a      	mov	r2, r3
  411cb8:	68fb      	ldr	r3, [r7, #12]
  411cba:	4413      	add	r3, r2
  411cbc:	2201      	movs	r2, #1
  411cbe:	f883 22ac 	strb.w	r2, [r3, #684]	; 0x2ac

	if (androidSensor == ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION) {
  411cc2:	7afb      	ldrb	r3, [r7, #11]
  411cc4:	2b11      	cmp	r3, #17
  411cc6:	d11c      	bne.n	411d02 <inv_enable_sensor_internal+0xa2>
		if (enable) {
  411cc8:	7abb      	ldrb	r3, [r7, #10]
  411cca:	2b00      	cmp	r3, #0
  411ccc:	d00d      	beq.n	411cea <inv_enable_sensor_internal+0x8a>
			s->smd_status = INV_SMD_EN;
  411cce:	68fb      	ldr	r3, [r7, #12]
  411cd0:	f44f 6200 	mov.w	r2, #2048	; 0x800
  411cd4:	f8a3 223e 	strh.w	r2, [r3, #574]	; 0x23e
			s->bac_request ++;
  411cd8:	68fb      	ldr	r3, [r7, #12]
  411cda:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411cde:	3301      	adds	r3, #1
  411ce0:	b29a      	uxth	r2, r3
  411ce2:	68fb      	ldr	r3, [r7, #12]
  411ce4:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411ce8:	e00b      	b.n	411d02 <inv_enable_sensor_internal+0xa2>
		}
		else {
			s->smd_status = 0;
  411cea:	68fb      	ldr	r3, [r7, #12]
  411cec:	2200      	movs	r2, #0
  411cee:	f8a3 223e 	strh.w	r2, [r3, #574]	; 0x23e
			s->bac_request --;
  411cf2:	68fb      	ldr	r3, [r7, #12]
  411cf4:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411cf8:	3b01      	subs	r3, #1
  411cfa:	b29a      	uxth	r2, r3
  411cfc:	68fb      	ldr	r3, [r7, #12]
  411cfe:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}

	if (androidSensor == ANDROID_SENSOR_STEP_DETECTOR) {
  411d02:	7afb      	ldrb	r3, [r7, #11]
  411d04:	2b12      	cmp	r3, #18
  411d06:	d11c      	bne.n	411d42 <inv_enable_sensor_internal+0xe2>
		if (enable) {
  411d08:	7abb      	ldrb	r3, [r7, #10]
  411d0a:	2b00      	cmp	r3, #0
  411d0c:	d00d      	beq.n	411d2a <inv_enable_sensor_internal+0xca>
			s->ped_int_status = INV_PEDOMETER_INT_EN;
  411d0e:	68fb      	ldr	r3, [r7, #12]
  411d10:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  411d14:	f8a3 2240 	strh.w	r2, [r3, #576]	; 0x240
			s->bac_request ++;
  411d18:	68fb      	ldr	r3, [r7, #12]
  411d1a:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411d1e:	3301      	adds	r3, #1
  411d20:	b29a      	uxth	r2, r3
  411d22:	68fb      	ldr	r3, [r7, #12]
  411d24:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411d28:	e00b      	b.n	411d42 <inv_enable_sensor_internal+0xe2>
		}
		else {
			s->ped_int_status = 0;
  411d2a:	68fb      	ldr	r3, [r7, #12]
  411d2c:	2200      	movs	r2, #0
  411d2e:	f8a3 2240 	strh.w	r2, [r3, #576]	; 0x240
			s->bac_request --;
  411d32:	68fb      	ldr	r3, [r7, #12]
  411d34:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411d38:	3b01      	subs	r3, #1
  411d3a:	b29a      	uxth	r2, r3
  411d3c:	68fb      	ldr	r3, [r7, #12]
  411d3e:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}

	if (androidSensor == ANDROID_SENSOR_STEP_COUNTER) {
  411d42:	7afb      	ldrb	r3, [r7, #11]
  411d44:	2b13      	cmp	r3, #19
  411d46:	d113      	bne.n	411d70 <inv_enable_sensor_internal+0x110>
		if (enable) {
  411d48:	7abb      	ldrb	r3, [r7, #10]
  411d4a:	2b00      	cmp	r3, #0
  411d4c:	d008      	beq.n	411d60 <inv_enable_sensor_internal+0x100>
			s->bac_request ++;
  411d4e:	68fb      	ldr	r3, [r7, #12]
  411d50:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411d54:	3301      	adds	r3, #1
  411d56:	b29a      	uxth	r2, r3
  411d58:	68fb      	ldr	r3, [r7, #12]
  411d5a:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411d5e:	e007      	b.n	411d70 <inv_enable_sensor_internal+0x110>
		}
		else {
			s->bac_request --;
  411d60:	68fb      	ldr	r3, [r7, #12]
  411d62:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411d66:	3b01      	subs	r3, #1
  411d68:	b29a      	uxth	r2, r3
  411d6a:	68fb      	ldr	r3, [r7, #12]
  411d6c:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}

	if (androidSensor == ANDROID_SENSOR_FLIP_PICKUP) {
  411d70:	7afb      	ldrb	r3, [r7, #11]
  411d72:	2b2e      	cmp	r3, #46	; 0x2e
  411d74:	d10c      	bne.n	411d90 <inv_enable_sensor_internal+0x130>
		if (enable){
  411d76:	7abb      	ldrb	r3, [r7, #10]
  411d78:	2b00      	cmp	r3, #0
  411d7a:	d005      	beq.n	411d88 <inv_enable_sensor_internal+0x128>
			s->flip_pickup_status = FLIP_PICKUP_SET;
  411d7c:	68fb      	ldr	r3, [r7, #12]
  411d7e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  411d82:	f8a3 2158 	strh.w	r2, [r3, #344]	; 0x158
  411d86:	e003      	b.n	411d90 <inv_enable_sensor_internal+0x130>
		}
		else
			s->flip_pickup_status = 0;
  411d88:	68fb      	ldr	r3, [r7, #12]
  411d8a:	2200      	movs	r2, #0
  411d8c:	f8a3 2158 	strh.w	r2, [r3, #344]	; 0x158
	}

	if (androidSensor == ANDROID_SENSOR_B2S) {
  411d90:	7afb      	ldrb	r3, [r7, #11]
  411d92:	2b2d      	cmp	r3, #45	; 0x2d
  411d94:	d11b      	bne.n	411dce <inv_enable_sensor_internal+0x16e>
		if(enable){
  411d96:	7abb      	ldrb	r3, [r7, #10]
  411d98:	2b00      	cmp	r3, #0
  411d9a:	d00c      	beq.n	411db6 <inv_enable_sensor_internal+0x156>
			s->b2s_status = INV_BTS_EN;
  411d9c:	68fb      	ldr	r3, [r7, #12]
  411d9e:	2220      	movs	r2, #32
  411da0:	f8a3 2156 	strh.w	r2, [r3, #342]	; 0x156
			s->bac_request ++;
  411da4:	68fb      	ldr	r3, [r7, #12]
  411da6:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411daa:	3301      	adds	r3, #1
  411dac:	b29a      	uxth	r2, r3
  411dae:	68fb      	ldr	r3, [r7, #12]
  411db0:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411db4:	e00b      	b.n	411dce <inv_enable_sensor_internal+0x16e>
		}
		else {
			s->b2s_status = 0;
  411db6:	68fb      	ldr	r3, [r7, #12]
  411db8:	2200      	movs	r2, #0
  411dba:	f8a3 2156 	strh.w	r2, [r3, #342]	; 0x156
			s->bac_request --;
  411dbe:	68fb      	ldr	r3, [r7, #12]
  411dc0:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411dc4:	3b01      	subs	r3, #1
  411dc6:	b29a      	uxth	r2, r3
  411dc8:	68fb      	ldr	r3, [r7, #12]
  411dca:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}
	if (androidSensor == ANDROID_SENSOR_ACTIVITY_CLASSIFICATON)
  411dce:	7afb      	ldrb	r3, [r7, #11]
  411dd0:	2b2f      	cmp	r3, #47	; 0x2f
  411dd2:	d104      	bne.n	411dde <inv_enable_sensor_internal+0x17e>
		inv_icm20648_ctrl_enable_activity_classifier(s, enable);
  411dd4:	7abb      	ldrb	r3, [r7, #10]
  411dd6:	4619      	mov	r1, r3
  411dd8:	68f8      	ldr	r0, [r7, #12]
  411dda:	4b5e      	ldr	r3, [pc, #376]	; (411f54 <inv_enable_sensor_internal+0x2f4>)
  411ddc:	4798      	blx	r3

	if (androidSensor == ANDROID_SENSOR_WAKEUP_TILT_DETECTOR)
  411dde:	7afb      	ldrb	r3, [r7, #11]
  411de0:	2b29      	cmp	r3, #41	; 0x29
  411de2:	d104      	bne.n	411dee <inv_enable_sensor_internal+0x18e>
		inv_icm20648_ctrl_enable_tilt(s, enable);
  411de4:	7abb      	ldrb	r3, [r7, #10]
  411de6:	4619      	mov	r1, r3
  411de8:	68f8      	ldr	r0, [r7, #12]
  411dea:	4b5b      	ldr	r3, [pc, #364]	; (411f58 <inv_enable_sensor_internal+0x2f8>)
  411dec:	4798      	blx	r3

	inv_convert_androidSensor_to_control(s, androidSensor, enable, inv_androidSensor_to_control_bits, &s->inv_sensor_control);
  411dee:	68fb      	ldr	r3, [r7, #12]
  411df0:	f503 73ad 	add.w	r3, r3, #346	; 0x15a
  411df4:	f107 0014 	add.w	r0, r7, #20
  411df8:	7aba      	ldrb	r2, [r7, #10]
  411dfa:	7af9      	ldrb	r1, [r7, #11]
  411dfc:	9300      	str	r3, [sp, #0]
  411dfe:	4603      	mov	r3, r0
  411e00:	68f8      	ldr	r0, [r7, #12]
  411e02:	4c56      	ldr	r4, [pc, #344]	; (411f5c <inv_enable_sensor_internal+0x2fc>)
  411e04:	47a0      	blx	r4
	result = dmp_icm20648_set_data_output_control1(s, s->inv_sensor_control);
  411e06:	68fb      	ldr	r3, [r7, #12]
  411e08:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411e0c:	4619      	mov	r1, r3
  411e0e:	68f8      	ldr	r0, [r7, #12]
  411e10:	4b53      	ldr	r3, [pc, #332]	; (411f60 <inv_enable_sensor_internal+0x300>)
  411e12:	4798      	blx	r3
  411e14:	6778      	str	r0, [r7, #116]	; 0x74
	if (s->b2s_status)
  411e16:	68fb      	ldr	r3, [r7, #12]
  411e18:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  411e1c:	2b00      	cmp	r3, #0
  411e1e:	d00e      	beq.n	411e3e <inv_enable_sensor_internal+0x1de>
		result |= dmp_icm20648_set_data_interrupt_control(s, s->inv_sensor_control|0x8008);
  411e20:	68fb      	ldr	r3, [r7, #12]
  411e22:	f8b3 215a 	ldrh.w	r2, [r3, #346]	; 0x15a
  411e26:	4b4f      	ldr	r3, [pc, #316]	; (411f64 <inv_enable_sensor_internal+0x304>)
  411e28:	4313      	orrs	r3, r2
  411e2a:	b29b      	uxth	r3, r3
  411e2c:	4619      	mov	r1, r3
  411e2e:	68f8      	ldr	r0, [r7, #12]
  411e30:	4b4d      	ldr	r3, [pc, #308]	; (411f68 <inv_enable_sensor_internal+0x308>)
  411e32:	4798      	blx	r3
  411e34:	4602      	mov	r2, r0
  411e36:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  411e38:	4313      	orrs	r3, r2
  411e3a:	677b      	str	r3, [r7, #116]	; 0x74
  411e3c:	e00a      	b.n	411e54 <inv_enable_sensor_internal+0x1f4>
		// result |= dmp_icm20648_set_data_interrupt_control(s, s->inv_sensor_control|0x0000);
	else
		result |= dmp_icm20648_set_data_interrupt_control(s, s->inv_sensor_control);
  411e3e:	68fb      	ldr	r3, [r7, #12]
  411e40:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411e44:	4619      	mov	r1, r3
  411e46:	68f8      	ldr	r0, [r7, #12]
  411e48:	4b47      	ldr	r3, [pc, #284]	; (411f68 <inv_enable_sensor_internal+0x308>)
  411e4a:	4798      	blx	r3
  411e4c:	4602      	mov	r2, r0
  411e4e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  411e50:	4313      	orrs	r3, r2
  411e52:	677b      	str	r3, [r7, #116]	; 0x74

	if (s->inv_sensor_control & ACCEL_SET)
  411e54:	68fb      	ldr	r3, [r7, #12]
  411e56:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411e5a:	b21b      	sxth	r3, r3
  411e5c:	2b00      	cmp	r3, #0
  411e5e:	da09      	bge.n	411e74 <inv_enable_sensor_internal+0x214>
		s->inv_sensor_control2 |= ACCEL_ACCURACY_SET;
  411e60:	68fb      	ldr	r3, [r7, #12]
  411e62:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411e66:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  411e6a:	b29a      	uxth	r2, r3
  411e6c:	68fb      	ldr	r3, [r7, #12]
  411e6e:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411e72:	e008      	b.n	411e86 <inv_enable_sensor_internal+0x226>
	else
		s->inv_sensor_control2 &= ~ACCEL_ACCURACY_SET;
  411e74:	68fb      	ldr	r3, [r7, #12]
  411e76:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411e7a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  411e7e:	b29a      	uxth	r2, r3
  411e80:	68fb      	ldr	r3, [r7, #12]
  411e82:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	if ((s->inv_sensor_control & GYRO_CALIBR_SET) || (s->inv_sensor_control & GYRO_SET))
  411e86:	68fb      	ldr	r3, [r7, #12]
  411e88:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411e8c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  411e90:	2b00      	cmp	r3, #0
  411e92:	d106      	bne.n	411ea2 <inv_enable_sensor_internal+0x242>
  411e94:	68fb      	ldr	r3, [r7, #12]
  411e96:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411e9a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  411e9e:	2b00      	cmp	r3, #0
  411ea0:	d009      	beq.n	411eb6 <inv_enable_sensor_internal+0x256>
		s->inv_sensor_control2 |= GYRO_ACCURACY_SET;
  411ea2:	68fb      	ldr	r3, [r7, #12]
  411ea4:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411ea8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  411eac:	b29a      	uxth	r2, r3
  411eae:	68fb      	ldr	r3, [r7, #12]
  411eb0:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411eb4:	e008      	b.n	411ec8 <inv_enable_sensor_internal+0x268>
	else
		s->inv_sensor_control2 &= ~GYRO_ACCURACY_SET;
  411eb6:	68fb      	ldr	r3, [r7, #12]
  411eb8:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411ebc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  411ec0:	b29a      	uxth	r2, r3
  411ec2:	68fb      	ldr	r3, [r7, #12]
  411ec4:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	if ((s->inv_sensor_control & CPASS_CALIBR_SET) || (s->inv_sensor_control & QUAT9_SET)
  411ec8:	68fb      	ldr	r3, [r7, #12]
  411eca:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411ece:	f003 0320 	and.w	r3, r3, #32
  411ed2:	2b00      	cmp	r3, #0
  411ed4:	d114      	bne.n	411f00 <inv_enable_sensor_internal+0x2a0>
  411ed6:	68fb      	ldr	r3, [r7, #12]
  411ed8:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411edc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  411ee0:	2b00      	cmp	r3, #0
  411ee2:	d10d      	bne.n	411f00 <inv_enable_sensor_internal+0x2a0>
		|| (s->inv_sensor_control & GEOMAG_SET) || (s->inv_sensor_control & CPASS_SET))
  411ee4:	68fb      	ldr	r3, [r7, #12]
  411ee6:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411eea:	f403 7380 	and.w	r3, r3, #256	; 0x100
  411eee:	2b00      	cmp	r3, #0
  411ef0:	d106      	bne.n	411f00 <inv_enable_sensor_internal+0x2a0>
  411ef2:	68fb      	ldr	r3, [r7, #12]
  411ef4:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411ef8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  411efc:	2b00      	cmp	r3, #0
  411efe:	d009      	beq.n	411f14 <inv_enable_sensor_internal+0x2b4>
		s->inv_sensor_control2 |= CPASS_ACCURACY_SET;
  411f00:	68fb      	ldr	r3, [r7, #12]
  411f02:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411f06:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  411f0a:	b29a      	uxth	r2, r3
  411f0c:	68fb      	ldr	r3, [r7, #12]
  411f0e:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411f12:	e008      	b.n	411f26 <inv_enable_sensor_internal+0x2c6>
	else
		s->inv_sensor_control2 &= ~CPASS_ACCURACY_SET;
  411f14:	68fb      	ldr	r3, [r7, #12]
  411f16:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411f1a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  411f1e:	b29a      	uxth	r2, r3
  411f20:	68fb      	ldr	r3, [r7, #12]
  411f22:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	if(s->flip_pickup_status)
  411f26:	68fb      	ldr	r3, [r7, #12]
  411f28:	f8b3 3158 	ldrh.w	r3, [r3, #344]	; 0x158
  411f2c:	2b00      	cmp	r3, #0
  411f2e:	d01d      	beq.n	411f6c <inv_enable_sensor_internal+0x30c>
		s->inv_sensor_control2 |= FLIP_PICKUP_SET;
  411f30:	68fb      	ldr	r3, [r7, #12]
  411f32:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411f36:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  411f3a:	b29a      	uxth	r2, r3
  411f3c:	68fb      	ldr	r3, [r7, #12]
  411f3e:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411f42:	e01c      	b.n	411f7e <inv_enable_sensor_internal+0x31e>
  411f44:	0041d3d0 	.word	0x0041d3d0
  411f48:	00414235 	.word	0x00414235
  411f4c:	004109f1 	.word	0x004109f1
  411f50:	0040a87d 	.word	0x0040a87d
  411f54:	004123d5 	.word	0x004123d5
  411f58:	00412461 	.word	0x00412461
  411f5c:	00411a91 	.word	0x00411a91
  411f60:	00408021 	.word	0x00408021
  411f64:	ffff8008 	.word	0xffff8008
  411f68:	00408121 	.word	0x00408121
	else
		s->inv_sensor_control2 &= ~FLIP_PICKUP_SET;
  411f6c:	68fb      	ldr	r3, [r7, #12]
  411f6e:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411f72:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  411f76:	b29a      	uxth	r2, r3
  411f78:	68fb      	ldr	r3, [r7, #12]
  411f7a:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	// inv_event_control   |= s->b2s_status;
	if(s->b2s_status)
  411f7e:	68fb      	ldr	r3, [r7, #12]
  411f80:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  411f84:	2b00      	cmp	r3, #0
  411f86:	d01b      	beq.n	411fc0 <inv_enable_sensor_internal+0x360>
	{
		inv_event_control |= INV_BRING_AND_LOOK_T0_SEE_EN;
  411f88:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f8c:	f043 0304 	orr.w	r3, r3, #4
  411f90:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		inv_event_control |= INV_PEDOMETER_EN;
  411f94:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f98:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  411f9c:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20648_FOR_MOBILE // Next lines change BAC behavior to wearable platform
		inv_event_control |= INV_BAC_WEARABLE_EN;
  411fa0:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411fa4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  411fa8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  411fac:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		dmp_icm20648_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
  411fb0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  411fb4:	68f8      	ldr	r0, [r7, #12]
  411fb6:	4b01      	ldr	r3, [pc, #4]	; (411fbc <inv_enable_sensor_internal+0x35c>)
  411fb8:	4798      	blx	r3
  411fba:	e013      	b.n	411fe4 <inv_enable_sensor_internal+0x384>
  411fbc:	00408c09 	.word	0x00408c09
#endif
	}
	else
	{
		inv_event_control &= ~INV_BRING_AND_LOOK_T0_SEE_EN;
  411fc0:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411fc4:	f023 0304 	bic.w	r3, r3, #4
  411fc8:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		inv_event_control &= ~INV_PEDOMETER_EN;
  411fcc:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411fd0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  411fd4:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20648_FOR_MOBILE // Next lines change BAC behavior to wearable platform
		inv_event_control &= ~INV_BAC_WEARABLE_EN;
  411fd8:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411fdc:	f3c3 030e 	ubfx	r3, r3, #0, #15
  411fe0:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#endif
	}

	result |= dmp_icm20648_set_data_output_control2(s, s->inv_sensor_control2);
  411fe4:	68fb      	ldr	r3, [r7, #12]
  411fe6:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411fea:	4619      	mov	r1, r3
  411fec:	68f8      	ldr	r0, [r7, #12]
  411fee:	4bbb      	ldr	r3, [pc, #748]	; (4122dc <inv_enable_sensor_internal+0x67c>)
  411ff0:	4798      	blx	r3
  411ff2:	4602      	mov	r2, r0
  411ff4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  411ff6:	4313      	orrs	r3, r2
  411ff8:	677b      	str	r3, [r7, #116]	; 0x74

	// sets DATA_RDY_STATUS in DMP based on which sensors are on
	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_GYRO_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_GYRO_MASK1)
  411ffa:	68fb      	ldr	r3, [r7, #12]
  411ffc:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
  412000:	4bb7      	ldr	r3, [pc, #732]	; (4122e0 <inv_enable_sensor_internal+0x680>)
  412002:	4013      	ands	r3, r2
  412004:	2b00      	cmp	r3, #0
  412006:	d107      	bne.n	412018 <inv_enable_sensor_internal+0x3b8>
  412008:	68fb      	ldr	r3, [r7, #12]
  41200a:	f8d3 2164 	ldr.w	r2, [r3, #356]	; 0x164
  41200e:	f640 0318 	movw	r3, #2072	; 0x818
  412012:	4013      	ands	r3, r2
  412014:	2b00      	cmp	r3, #0
  412016:	d005      	beq.n	412024 <inv_enable_sensor_internal+0x3c4>
		data_rdy_status |= GYRO_AVAILABLE;
  412018:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  41201c:	f043 0301 	orr.w	r3, r3, #1
  412020:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_ACCEL_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_ACCEL_MASK1)
  412024:	68fb      	ldr	r3, [r7, #12]
  412026:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
  41202a:	4bae      	ldr	r3, [pc, #696]	; (4122e4 <inv_enable_sensor_internal+0x684>)
  41202c:	4013      	ands	r3, r2
  41202e:	2b00      	cmp	r3, #0
  412030:	d106      	bne.n	412040 <inv_enable_sensor_internal+0x3e0>
  412032:	68fb      	ldr	r3, [r7, #12]
  412034:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
  412038:	f403 63dd 	and.w	r3, r3, #1768	; 0x6e8
  41203c:	2b00      	cmp	r3, #0
  41203e:	d005      	beq.n	41204c <inv_enable_sensor_internal+0x3ec>
		data_rdy_status |= ACCEL_AVAILABLE;
  412040:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  412044:	f043 0302 	orr.w	r3, r3, #2
  412048:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

	if (s->flip_pickup_status || s->b2s_status)
  41204c:	68fb      	ldr	r3, [r7, #12]
  41204e:	f8b3 3158 	ldrh.w	r3, [r3, #344]	; 0x158
  412052:	2b00      	cmp	r3, #0
  412054:	d104      	bne.n	412060 <inv_enable_sensor_internal+0x400>
  412056:	68fb      	ldr	r3, [r7, #12]
  412058:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  41205c:	2b00      	cmp	r3, #0
  41205e:	d005      	beq.n	41206c <inv_enable_sensor_internal+0x40c>
		data_rdy_status |= ACCEL_AVAILABLE;
  412060:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  412064:	f043 0302 	orr.w	r3, r3, #2
  412068:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

	if (s->bac_status)
  41206c:	68fb      	ldr	r3, [r7, #12]
  41206e:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
  412072:	2b00      	cmp	r3, #0
  412074:	d005      	beq.n	412082 <inv_enable_sensor_internal+0x422>
		data_rdy_status |= ACCEL_AVAILABLE;
  412076:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  41207a:	f043 0302 	orr.w	r3, r3, #2
  41207e:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_COMPASS_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_COMPASS_MASK1) {
  412082:	68fb      	ldr	r3, [r7, #12]
  412084:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
  412088:	4b97      	ldr	r3, [pc, #604]	; (4122e8 <inv_enable_sensor_internal+0x688>)
  41208a:	4013      	ands	r3, r2
  41208c:	2b00      	cmp	r3, #0
  41208e:	d106      	bne.n	41209e <inv_enable_sensor_internal+0x43e>
  412090:	68fb      	ldr	r3, [r7, #12]
  412092:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
  412096:	f003 0384 	and.w	r3, r3, #132	; 0x84
  41209a:	2b00      	cmp	r3, #0
  41209c:	d00b      	beq.n	4120b6 <inv_enable_sensor_internal+0x456>
		data_rdy_status |= SECONDARY_COMPASS_AVAILABLE;
  41209e:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  4120a2:	f043 0308 	orr.w	r3, r3, #8
  4120a6:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
		inv_event_control |= INV_COMPASS_CAL_EN;
  4120aa:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  4120ae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  4120b2:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
	}
	// turn on gyro cal only if gyro is available
	if (data_rdy_status & GYRO_AVAILABLE)
  4120b6:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  4120ba:	f003 0301 	and.w	r3, r3, #1
  4120be:	2b00      	cmp	r3, #0
  4120c0:	d005      	beq.n	4120ce <inv_enable_sensor_internal+0x46e>
		inv_event_control |= INV_GYRO_CAL_EN;
  4120c2:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  4120c6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4120ca:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	// turn on acc cal only if acc is available
	if (data_rdy_status & ACCEL_AVAILABLE)
  4120ce:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  4120d2:	f003 0302 	and.w	r3, r3, #2
  4120d6:	2b00      	cmp	r3, #0
  4120d8:	d005      	beq.n	4120e6 <inv_enable_sensor_internal+0x486>
		inv_event_control |= INV_ACCEL_CAL_EN;
  4120da:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  4120de:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  4120e2:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	inv_event_control |= s->smd_status | s->ped_int_status;
  4120e6:	68fb      	ldr	r3, [r7, #12]
  4120e8:	f8b3 223e 	ldrh.w	r2, [r3, #574]	; 0x23e
  4120ec:	68fb      	ldr	r3, [r7, #12]
  4120ee:	f8b3 3240 	ldrh.w	r3, [r3, #576]	; 0x240
  4120f2:	4313      	orrs	r3, r2
  4120f4:	b29a      	uxth	r2, r3
  4120f6:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  4120fa:	4313      	orrs	r3, r2
  4120fc:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	if (s->inv_sensor_control & QUAT9_SET)
  412100:	68fb      	ldr	r3, [r7, #12]
  412102:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  412106:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  41210a:	2b00      	cmp	r3, #0
  41210c:	d005      	beq.n	41211a <inv_enable_sensor_internal+0x4ba>
		inv_event_control |= INV_NINE_AXIS_EN;
  41210e:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  412112:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  412116:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	if (s->inv_sensor_control & (PED_STEPDET_SET | PED_STEPIND_SET) || inv_event_control & INV_SMD_EN) {
  41211a:	68fb      	ldr	r3, [r7, #12]
  41211c:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  412120:	f003 0317 	and.w	r3, r3, #23
  412124:	2b00      	cmp	r3, #0
  412126:	d105      	bne.n	412134 <inv_enable_sensor_internal+0x4d4>
  412128:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  41212c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  412130:	2b00      	cmp	r3, #0
  412132:	d012      	beq.n	41215a <inv_enable_sensor_internal+0x4fa>
		inv_event_control |= INV_PEDOMETER_EN;
  412134:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  412138:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  41213c:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20648_FOR_MOBILE // Next lines change BAC behavior to wearable platform
		inv_event_control |= INV_BAC_WEARABLE_EN;
  412140:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  412144:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  412148:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  41214c:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		dmp_icm20648_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
  412150:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  412154:	68f8      	ldr	r0, [r7, #12]
  412156:	4b65      	ldr	r3, [pc, #404]	; (4122ec <inv_enable_sensor_internal+0x68c>)
  412158:	4798      	blx	r3
#endif
	}

	if (s->inv_sensor_control2 & ACT_RECOG_SET) {
  41215a:	68fb      	ldr	r3, [r7, #12]
  41215c:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  412160:	f003 0380 	and.w	r3, r3, #128	; 0x80
  412164:	2b00      	cmp	r3, #0
  412166:	d012      	beq.n	41218e <inv_enable_sensor_internal+0x52e>
		inv_event_control |= INV_PEDOMETER_EN;
  412168:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  41216c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  412170:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20648_FOR_MOBILE // Next lines this to change BAC behavior to wearable platform
		inv_event_control |= INV_BAC_WEARABLE_EN;
  412174:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  412178:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  41217c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  412180:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		dmp_icm20648_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
  412184:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  412188:	68f8      	ldr	r0, [r7, #12]
  41218a:	4b58      	ldr	r3, [pc, #352]	; (4122ec <inv_enable_sensor_internal+0x68c>)
  41218c:	4798      	blx	r3
#endif
	}

	if (s->inv_sensor_control2 & FLIP_PICKUP_SET){
  41218e:	68fb      	ldr	r3, [r7, #12]
  412190:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  412194:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  412198:	2b00      	cmp	r3, #0
  41219a:	d005      	beq.n	4121a8 <inv_enable_sensor_internal+0x548>
		inv_event_control |= FLIP_PICKUP_EN;
  41219c:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  4121a0:	f043 0310 	orr.w	r3, r3, #16
  4121a4:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
	}

	if (s->inv_sensor_control & GEOMAG_SET)
  4121a8:	68fb      	ldr	r3, [r7, #12]
  4121aa:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  4121ae:	f403 7380 	and.w	r3, r3, #256	; 0x100
  4121b2:	2b00      	cmp	r3, #0
  4121b4:	d005      	beq.n	4121c2 <inv_enable_sensor_internal+0x562>
		inv_event_control |= GEOMAG_EN;
  4121b6:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  4121ba:	f043 0308 	orr.w	r3, r3, #8
  4121be:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	result |= dmp_icm20648_set_motion_event_control(s, inv_event_control);
  4121c2:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  4121c6:	4619      	mov	r1, r3
  4121c8:	68f8      	ldr	r0, [r7, #12]
  4121ca:	4b49      	ldr	r3, [pc, #292]	; (4122f0 <inv_enable_sensor_internal+0x690>)
  4121cc:	4798      	blx	r3
  4121ce:	4602      	mov	r2, r0
  4121d0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  4121d2:	4313      	orrs	r3, r2
  4121d4:	677b      	str	r3, [r7, #116]	; 0x74

	// A sensor was just enabled/disabled, need to recompute the required ODR for all augmented sensor-related sensors
	// The fastest ODR will always be applied to other related sensors
	if (   (androidSensor == ANDROID_SENSOR_GRAVITY)
  4121d6:	7afb      	ldrb	r3, [r7, #11]
  4121d8:	2b09      	cmp	r3, #9
  4121da:	d005      	beq.n	4121e8 <inv_enable_sensor_internal+0x588>
		|| (androidSensor == ANDROID_SENSOR_GAME_ROTATION_VECTOR)
  4121dc:	7afb      	ldrb	r3, [r7, #11]
  4121de:	2b0f      	cmp	r3, #15
  4121e0:	d002      	beq.n	4121e8 <inv_enable_sensor_internal+0x588>
		|| (androidSensor == ANDROID_SENSOR_LINEAR_ACCELERATION) ) {
  4121e2:	7afb      	ldrb	r3, [r7, #11]
  4121e4:	2b0a      	cmp	r3, #10
  4121e6:	d10f      	bne.n	412208 <inv_enable_sensor_internal+0x5a8>
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_SIXQ]);
  4121e8:	68fb      	ldr	r3, [r7, #12]
  4121ea:	f503 7288 	add.w	r2, r3, #272	; 0x110
  4121ee:	7afb      	ldrb	r3, [r7, #11]
  4121f0:	4619      	mov	r1, r3
  4121f2:	68f8      	ldr	r0, [r7, #12]
  4121f4:	4b3f      	ldr	r3, [pc, #252]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  4121f6:	4798      	blx	r3
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_SIXQ_accel]);
  4121f8:	68fb      	ldr	r3, [r7, #12]
  4121fa:	f503 7293 	add.w	r2, r3, #294	; 0x126
  4121fe:	7afb      	ldrb	r3, [r7, #11]
  412200:	4619      	mov	r1, r3
  412202:	68f8      	ldr	r0, [r7, #12]
  412204:	4b3b      	ldr	r3, [pc, #236]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  412206:	4798      	blx	r3
	}

	if (   (androidSensor == ANDROID_SENSOR_ORIENTATION)
  412208:	7afb      	ldrb	r3, [r7, #11]
  41220a:	2b03      	cmp	r3, #3
  41220c:	d002      	beq.n	412214 <inv_enable_sensor_internal+0x5b4>
		|| (androidSensor == ANDROID_SENSOR_ROTATION_VECTOR) ) {
  41220e:	7afb      	ldrb	r3, [r7, #11]
  412210:	2b0b      	cmp	r3, #11
  412212:	d117      	bne.n	412244 <inv_enable_sensor_internal+0x5e4>
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ]);
  412214:	68fb      	ldr	r3, [r7, #12]
  412216:	f503 7289 	add.w	r2, r3, #274	; 0x112
  41221a:	7afb      	ldrb	r3, [r7, #11]
  41221c:	4619      	mov	r1, r3
  41221e:	68f8      	ldr	r0, [r7, #12]
  412220:	4b34      	ldr	r3, [pc, #208]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  412222:	4798      	blx	r3
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_accel]);
  412224:	68fb      	ldr	r3, [r7, #12]
  412226:	f503 7294 	add.w	r2, r3, #296	; 0x128
  41222a:	7afb      	ldrb	r3, [r7, #11]
  41222c:	4619      	mov	r1, r3
  41222e:	68f8      	ldr	r0, [r7, #12]
  412230:	4b30      	ldr	r3, [pc, #192]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  412232:	4798      	blx	r3
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_cpass]);
  412234:	68fb      	ldr	r3, [r7, #12]
  412236:	f503 7296 	add.w	r2, r3, #300	; 0x12c
  41223a:	7afb      	ldrb	r3, [r7, #11]
  41223c:	4619      	mov	r1, r3
  41223e:	68f8      	ldr	r0, [r7, #12]
  412240:	4b2c      	ldr	r3, [pc, #176]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  412242:	4798      	blx	r3
	}

	if (   (androidSensor == ANDROID_SENSOR_WAKEUP_GRAVITY)
  412244:	7afb      	ldrb	r3, [r7, #11]
  412246:	2b1d      	cmp	r3, #29
  412248:	d005      	beq.n	412256 <inv_enable_sensor_internal+0x5f6>
		|| (androidSensor == ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR)
  41224a:	7afb      	ldrb	r3, [r7, #11]
  41224c:	2b23      	cmp	r3, #35	; 0x23
  41224e:	d002      	beq.n	412256 <inv_enable_sensor_internal+0x5f6>
		|| (androidSensor == ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION) ) {
  412250:	7afb      	ldrb	r3, [r7, #11]
  412252:	2b1e      	cmp	r3, #30
  412254:	d10f      	bne.n	412276 <inv_enable_sensor_internal+0x616>
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ]);
  412256:	68fb      	ldr	r3, [r7, #12]
  412258:	f503 729b 	add.w	r2, r3, #310	; 0x136
  41225c:	7afb      	ldrb	r3, [r7, #11]
  41225e:	4619      	mov	r1, r3
  412260:	68f8      	ldr	r0, [r7, #12]
  412262:	4b24      	ldr	r3, [pc, #144]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  412264:	4798      	blx	r3
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ_accel]);
  412266:	68fb      	ldr	r3, [r7, #12]
  412268:	f503 72a4 	add.w	r2, r3, #328	; 0x148
  41226c:	7afb      	ldrb	r3, [r7, #11]
  41226e:	4619      	mov	r1, r3
  412270:	68f8      	ldr	r0, [r7, #12]
  412272:	4b20      	ldr	r3, [pc, #128]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  412274:	4798      	blx	r3
	}

	if (   (androidSensor == ANDROID_SENSOR_WAKEUP_ORIENTATION)
  412276:	7afb      	ldrb	r3, [r7, #11]
  412278:	2b19      	cmp	r3, #25
  41227a:	d002      	beq.n	412282 <inv_enable_sensor_internal+0x622>
		|| (androidSensor == ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) ) {
  41227c:	7afb      	ldrb	r3, [r7, #11]
  41227e:	2b1f      	cmp	r3, #31
  412280:	d117      	bne.n	4122b2 <inv_enable_sensor_internal+0x652>
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ]);
  412282:	68fb      	ldr	r3, [r7, #12]
  412284:	f503 729c 	add.w	r2, r3, #312	; 0x138
  412288:	7afb      	ldrb	r3, [r7, #11]
  41228a:	4619      	mov	r1, r3
  41228c:	68f8      	ldr	r0, [r7, #12]
  41228e:	4b19      	ldr	r3, [pc, #100]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  412290:	4798      	blx	r3
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_accel]);
  412292:	68fb      	ldr	r3, [r7, #12]
  412294:	f503 72a5 	add.w	r2, r3, #330	; 0x14a
  412298:	7afb      	ldrb	r3, [r7, #11]
  41229a:	4619      	mov	r1, r3
  41229c:	68f8      	ldr	r0, [r7, #12]
  41229e:	4b15      	ldr	r3, [pc, #84]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  4122a0:	4798      	blx	r3
		inv_icm20648_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_cpass]);
  4122a2:	68fb      	ldr	r3, [r7, #12]
  4122a4:	f503 72a7 	add.w	r2, r3, #334	; 0x14e
  4122a8:	7afb      	ldrb	r3, [r7, #11]
  4122aa:	4619      	mov	r1, r3
  4122ac:	68f8      	ldr	r0, [r7, #12]
  4122ae:	4b11      	ldr	r3, [pc, #68]	; (4122f4 <inv_enable_sensor_internal+0x694>)
  4122b0:	4798      	blx	r3
	}

	result |= inv_set_hw_smplrt_dmp_odrs(s);
  4122b2:	68f8      	ldr	r0, [r7, #12]
  4122b4:	4b10      	ldr	r3, [pc, #64]	; (4122f8 <inv_enable_sensor_internal+0x698>)
  4122b6:	4798      	blx	r3
  4122b8:	4602      	mov	r2, r0
  4122ba:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  4122bc:	4313      	orrs	r3, r2
  4122be:	677b      	str	r3, [r7, #116]	; 0x74
	result |= inv_icm20648_set_gyro_sf(s, inv_icm20648_get_gyro_divider(s), inv_icm20648_get_gyro_fullscale(s));
  4122c0:	68f8      	ldr	r0, [r7, #12]
  4122c2:	4b0e      	ldr	r3, [pc, #56]	; (4122fc <inv_enable_sensor_internal+0x69c>)
  4122c4:	4798      	blx	r3
  4122c6:	4603      	mov	r3, r0
  4122c8:	461c      	mov	r4, r3
  4122ca:	68f8      	ldr	r0, [r7, #12]
  4122cc:	4b0c      	ldr	r3, [pc, #48]	; (412300 <inv_enable_sensor_internal+0x6a0>)
  4122ce:	4798      	blx	r3
  4122d0:	4603      	mov	r3, r0
  4122d2:	461a      	mov	r2, r3
  4122d4:	4621      	mov	r1, r4
  4122d6:	68f8      	ldr	r0, [r7, #12]
  4122d8:	e014      	b.n	412304 <inv_enable_sensor_internal+0x6a4>
  4122da:	bf00      	nop
  4122dc:	00408059 	.word	0x00408059
  4122e0:	e6018e18 	.word	0xe6018e18
  4122e4:	e29e8e0a 	.word	0xe29e8e0a
  4122e8:	8310480c 	.word	0x8310480c
  4122ec:	00408c09 	.word	0x00408c09
  4122f0:	00408201 	.word	0x00408201
  4122f4:	004107ed 	.word	0x004107ed
  4122f8:	00410f95 	.word	0x00410f95
  4122fc:	004062a5 	.word	0x004062a5
  412300:	00406549 	.word	0x00406549
  412304:	4b2e      	ldr	r3, [pc, #184]	; (4123c0 <inv_enable_sensor_internal+0x760>)
  412306:	4798      	blx	r3
  412308:	4602      	mov	r2, r0
  41230a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  41230c:	4313      	orrs	r3, r2
  41230e:	677b      	str	r3, [r7, #116]	; 0x74

	if (!s->inv_sensor_control && !(s->inv_androidSensorsOn_mask[0] & (1L << ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION)) && !s->b2s_status) {
  412310:	68fb      	ldr	r3, [r7, #12]
  412312:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  412316:	2b00      	cmp	r3, #0
  412318:	d115      	bne.n	412346 <inv_enable_sensor_internal+0x6e6>
  41231a:	68fb      	ldr	r3, [r7, #12]
  41231c:	f8d3 3160 	ldr.w	r3, [r3, #352]	; 0x160
  412320:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  412324:	2b00      	cmp	r3, #0
  412326:	d10e      	bne.n	412346 <inv_enable_sensor_internal+0x6e6>
  412328:	68fb      	ldr	r3, [r7, #12]
  41232a:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  41232e:	2b00      	cmp	r3, #0
  412330:	d109      	bne.n	412346 <inv_enable_sensor_internal+0x6e6>
		*mems_put_to_sleep =1 ;
  412332:	687b      	ldr	r3, [r7, #4]
  412334:	2201      	movs	r2, #1
  412336:	701a      	strb	r2, [r3, #0]
		result |= inv_icm20648_sleep_mems(s);
  412338:	68f8      	ldr	r0, [r7, #12]
  41233a:	4b22      	ldr	r3, [pc, #136]	; (4123c4 <inv_enable_sensor_internal+0x764>)
  41233c:	4798      	blx	r3
  41233e:	4602      	mov	r2, r0
  412340:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  412342:	4313      	orrs	r3, r2
  412344:	677b      	str	r3, [r7, #116]	; 0x74
	}

	// DMP no longer controls PWR_MGMT_2 because of hardware bug, 0x80 set to override default behaviour of inv_icm20648_enable_hw_sensors()
	result |= inv_icm20648_enable_hw_sensors(s, (int)data_rdy_status | 0x80);
  412346:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  41234a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  41234e:	b29b      	uxth	r3, r3
  412350:	4619      	mov	r1, r3
  412352:	68f8      	ldr	r0, [r7, #12]
  412354:	4b1c      	ldr	r3, [pc, #112]	; (4123c8 <inv_enable_sensor_internal+0x768>)
  412356:	4798      	blx	r3
  412358:	4602      	mov	r2, r0
  41235a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  41235c:	4313      	orrs	r3, r2
  41235e:	677b      	str	r3, [r7, #116]	; 0x74

	// set DATA_RDY_STATUS in DMP
	if (data_rdy_status & SECONDARY_COMPASS_AVAILABLE)	{
  412360:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  412364:	f003 0308 	and.w	r3, r3, #8
  412368:	2b00      	cmp	r3, #0
  41236a:	d005      	beq.n	412378 <inv_enable_sensor_internal+0x718>
		data_rdy_status |= SECONDARY_COMPASS_AVAILABLE;
  41236c:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  412370:	f043 0308 	orr.w	r3, r3, #8
  412374:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
	}

	result |= dmp_icm20648_set_data_rdy_status(s, data_rdy_status);
  412378:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  41237c:	4619      	mov	r1, r3
  41237e:	68f8      	ldr	r0, [r7, #12]
  412380:	4b12      	ldr	r3, [pc, #72]	; (4123cc <inv_enable_sensor_internal+0x76c>)
  412382:	4798      	blx	r3
  412384:	4602      	mov	r2, r0
  412386:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  412388:	4313      	orrs	r3, r2
  41238a:	677b      	str	r3, [r7, #116]	; 0x74

	// To have the all steps when you enable the sensor
	if (androidSensor == ANDROID_SENSOR_STEP_COUNTER)
  41238c:	7afb      	ldrb	r3, [r7, #11]
  41238e:	2b13      	cmp	r3, #19
  412390:	d110      	bne.n	4123b4 <inv_enable_sensor_internal+0x754>
	{
		if (enable)
  412392:	7abb      	ldrb	r3, [r7, #10]
  412394:	2b00      	cmp	r3, #0
  412396:	d00d      	beq.n	4123b4 <inv_enable_sensor_internal+0x754>
		{
			dmp_icm20648_get_pedometer_num_of_steps(s, &steps);
  412398:	f107 036c 	add.w	r3, r7, #108	; 0x6c
  41239c:	4619      	mov	r1, r3
  41239e:	68f8      	ldr	r0, [r7, #12]
  4123a0:	4b0b      	ldr	r3, [pc, #44]	; (4123d0 <inv_enable_sensor_internal+0x770>)
  4123a2:	4798      	blx	r3
			s->sStepCounterToBeSubtracted = steps - s->sOldSteps;
  4123a4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  4123a6:	68fb      	ldr	r3, [r7, #12]
  4123a8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  4123ac:	1ad2      	subs	r2, r2, r3
  4123ae:	68fb      	ldr	r3, [r7, #12]
  4123b0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		}
	}

	return result;
  4123b4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
}
  4123b6:	4618      	mov	r0, r3
  4123b8:	377c      	adds	r7, #124	; 0x7c
  4123ba:	46bd      	mov	sp, r7
  4123bc:	bd90      	pop	{r4, r7, pc}
  4123be:	bf00      	nop
  4123c0:	00406341 	.word	0x00406341
  4123c4:	00405db9 	.word	0x00405db9
  4123c8:	004068a5 	.word	0x004068a5
  4123cc:	004081b5 	.word	0x004081b5
  4123d0:	00408665 	.word	0x00408665

004123d4 <inv_icm20648_ctrl_enable_activity_classifier>:

void inv_icm20648_ctrl_enable_activity_classifier(struct inv_icm20648 * s, unsigned char enable)
{
  4123d4:	b580      	push	{r7, lr}
  4123d6:	b082      	sub	sp, #8
  4123d8:	af00      	add	r7, sp, #0
  4123da:	6078      	str	r0, [r7, #4]
  4123dc:	460b      	mov	r3, r1
  4123de:	70fb      	strb	r3, [r7, #3]
	s->bac_on = enable;
  4123e0:	78fb      	ldrb	r3, [r7, #3]
  4123e2:	b29a      	uxth	r2, r3
  4123e4:	687b      	ldr	r3, [r7, #4]
  4123e6:	f8a3 2150 	strh.w	r2, [r3, #336]	; 0x150
	if (enable) {
  4123ea:	78fb      	ldrb	r3, [r7, #3]
  4123ec:	2b00      	cmp	r3, #0
  4123ee:	d015      	beq.n	41241c <inv_icm20648_ctrl_enable_activity_classifier+0x48>
		s->bac_status = ACT_RECOG_SET;
  4123f0:	687b      	ldr	r3, [r7, #4]
  4123f2:	2280      	movs	r2, #128	; 0x80
  4123f4:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
		s->inv_sensor_control2 |= ACT_RECOG_SET;
  4123f8:	687b      	ldr	r3, [r7, #4]
  4123fa:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  4123fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  412402:	b29a      	uxth	r2, r3
  412404:	687b      	ldr	r3, [r7, #4]
  412406:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
		s->bac_request ++;
  41240a:	687b      	ldr	r3, [r7, #4]
  41240c:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  412410:	3301      	adds	r3, #1
  412412:	b29a      	uxth	r2, r3
  412414:	687b      	ldr	r3, [r7, #4]
  412416:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
			s->bac_status = 0;
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
			s->bac_request --;
		}
	}
}
  41241a:	e01b      	b.n	412454 <inv_icm20648_ctrl_enable_activity_classifier+0x80>
		if (!inv_icm20648_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_TILT_DETECTOR)) {
  41241c:	2129      	movs	r1, #41	; 0x29
  41241e:	6878      	ldr	r0, [r7, #4]
  412420:	4b0e      	ldr	r3, [pc, #56]	; (41245c <inv_icm20648_ctrl_enable_activity_classifier+0x88>)
  412422:	4798      	blx	r3
  412424:	4603      	mov	r3, r0
  412426:	2b00      	cmp	r3, #0
  412428:	d114      	bne.n	412454 <inv_icm20648_ctrl_enable_activity_classifier+0x80>
			s->bac_status = 0;
  41242a:	687b      	ldr	r3, [r7, #4]
  41242c:	2200      	movs	r2, #0
  41242e:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
  412432:	687b      	ldr	r3, [r7, #4]
  412434:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  412438:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  41243c:	b29a      	uxth	r2, r3
  41243e:	687b      	ldr	r3, [r7, #4]
  412440:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
			s->bac_request --;
  412444:	687b      	ldr	r3, [r7, #4]
  412446:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  41244a:	3b01      	subs	r3, #1
  41244c:	b29a      	uxth	r2, r3
  41244e:	687b      	ldr	r3, [r7, #4]
  412450:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
}
  412454:	bf00      	nop
  412456:	3708      	adds	r7, #8
  412458:	46bd      	mov	sp, r7
  41245a:	bd80      	pop	{r7, pc}
  41245c:	004109f1 	.word	0x004109f1

00412460 <inv_icm20648_ctrl_enable_tilt>:

void inv_icm20648_ctrl_enable_tilt(struct inv_icm20648 * s, unsigned char enable)
{
  412460:	b480      	push	{r7}
  412462:	b083      	sub	sp, #12
  412464:	af00      	add	r7, sp, #0
  412466:	6078      	str	r0, [r7, #4]
  412468:	460b      	mov	r3, r1
  41246a:	70fb      	strb	r3, [r7, #3]
	if (enable) {
  41246c:	78fb      	ldrb	r3, [r7, #3]
  41246e:	2b00      	cmp	r3, #0
  412470:	d015      	beq.n	41249e <inv_icm20648_ctrl_enable_tilt+0x3e>
		s->bac_status = ACT_RECOG_SET;
  412472:	687b      	ldr	r3, [r7, #4]
  412474:	2280      	movs	r2, #128	; 0x80
  412476:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
		s->inv_sensor_control2 |= ACT_RECOG_SET;
  41247a:	687b      	ldr	r3, [r7, #4]
  41247c:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  412480:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  412484:	b29a      	uxth	r2, r3
  412486:	687b      	ldr	r3, [r7, #4]
  412488:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
		s->bac_request ++;
  41248c:	687b      	ldr	r3, [r7, #4]
  41248e:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  412492:	3301      	adds	r3, #1
  412494:	b29a      	uxth	r2, r3
  412496:	687b      	ldr	r3, [r7, #4]
  412498:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
			s->bac_status = 0;
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
			s->bac_request --;
		}
	}
}
  41249c:	e019      	b.n	4124d2 <inv_icm20648_ctrl_enable_tilt+0x72>
		if (!s->bac_on) {
  41249e:	687b      	ldr	r3, [r7, #4]
  4124a0:	f8b3 3150 	ldrh.w	r3, [r3, #336]	; 0x150
  4124a4:	2b00      	cmp	r3, #0
  4124a6:	d114      	bne.n	4124d2 <inv_icm20648_ctrl_enable_tilt+0x72>
			s->bac_status = 0;
  4124a8:	687b      	ldr	r3, [r7, #4]
  4124aa:	2200      	movs	r2, #0
  4124ac:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
  4124b0:	687b      	ldr	r3, [r7, #4]
  4124b2:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  4124b6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  4124ba:	b29a      	uxth	r2, r3
  4124bc:	687b      	ldr	r3, [r7, #4]
  4124be:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
			s->bac_request --;
  4124c2:	687b      	ldr	r3, [r7, #4]
  4124c4:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  4124c8:	3b01      	subs	r3, #1
  4124ca:	b29a      	uxth	r2, r3
  4124cc:	687b      	ldr	r3, [r7, #4]
  4124ce:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
}
  4124d2:	bf00      	nop
  4124d4:	370c      	adds	r7, #12
  4124d6:	46bd      	mov	sp, r7
  4124d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4124dc:	4770      	bx	lr

004124de <inv_icm20648_ctrl_get_batch_mode_status>:
	else
		s->sBatchMode=0;
}

unsigned char inv_icm20648_ctrl_get_batch_mode_status(struct inv_icm20648 * s)
{
  4124de:	b480      	push	{r7}
  4124e0:	b083      	sub	sp, #12
  4124e2:	af00      	add	r7, sp, #0
  4124e4:	6078      	str	r0, [r7, #4]
	return s->sBatchMode;
  4124e6:	687b      	ldr	r3, [r7, #4]
  4124e8:	f893 323a 	ldrb.w	r3, [r3, #570]	; 0x23a
}
  4124ec:	4618      	mov	r0, r3
  4124ee:	370c      	adds	r7, #12
  4124f0:	46bd      	mov	sp, r7
  4124f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4124f6:	4770      	bx	lr

004124f8 <inv_icm20648_ctrl_get_activitiy_classifier_on_flag>:
{
	return s->inv_androidSensorsOn_mask;
}

unsigned short inv_icm20648_ctrl_get_activitiy_classifier_on_flag(struct inv_icm20648 * s)
{
  4124f8:	b480      	push	{r7}
  4124fa:	b083      	sub	sp, #12
  4124fc:	af00      	add	r7, sp, #0
  4124fe:	6078      	str	r0, [r7, #4]
	return s->bac_on;
  412500:	687b      	ldr	r3, [r7, #4]
  412502:	f8b3 3150 	ldrh.w	r3, [r3, #336]	; 0x150
}
  412506:	4618      	mov	r0, r3
  412508:	370c      	adds	r7, #12
  41250a:	46bd      	mov	sp, r7
  41250c:	f85d 7b04 	ldr.w	r7, [sp], #4
  412510:	4770      	bx	lr
	...

00412514 <inv_icm20648_ctrl_set_accel_quaternion_gain>:
/** @brief Sets accel quaternion gain according to accel engine rate.
* @param[in] hw_smplrt_divider  hardware sample rate divider such that accel engine rate = 1125Hz/hw_smplrt_divider
* @return 0 in case of success, -1 for any error
*/
int inv_icm20648_ctrl_set_accel_quaternion_gain(struct inv_icm20648 * s, unsigned short hw_smplrt_divider)
{
  412514:	b580      	push	{r7, lr}
  412516:	b084      	sub	sp, #16
  412518:	af00      	add	r7, sp, #0
  41251a:	6078      	str	r0, [r7, #4]
  41251c:	460b      	mov	r3, r1
  41251e:	807b      	strh	r3, [r7, #2]
	int accel_gain = 15252014L; //set 225Hz gain as default
  412520:	4b23      	ldr	r3, [pc, #140]	; (4125b0 <inv_icm20648_ctrl_set_accel_quaternion_gain+0x9c>)
  412522:	60fb      	str	r3, [r7, #12]

	switch (hw_smplrt_divider) {
  412524:	887b      	ldrh	r3, [r7, #2]
  412526:	3b05      	subs	r3, #5
  412528:	2b11      	cmp	r3, #17
  41252a:	d835      	bhi.n	412598 <inv_icm20648_ctrl_set_accel_quaternion_gain+0x84>
  41252c:	a201      	add	r2, pc, #4	; (adr r2, 412534 <inv_icm20648_ctrl_set_accel_quaternion_gain+0x20>)
  41252e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  412532:	bf00      	nop
  412534:	0041257d 	.word	0x0041257d
  412538:	00412599 	.word	0x00412599
  41253c:	00412599 	.word	0x00412599
  412540:	00412599 	.word	0x00412599
  412544:	00412599 	.word	0x00412599
  412548:	00412583 	.word	0x00412583
  41254c:	00412589 	.word	0x00412589
  412550:	00412599 	.word	0x00412599
  412554:	00412599 	.word	0x00412599
  412558:	00412599 	.word	0x00412599
  41255c:	00412599 	.word	0x00412599
  412560:	00412599 	.word	0x00412599
  412564:	00412599 	.word	0x00412599
  412568:	00412599 	.word	0x00412599
  41256c:	00412599 	.word	0x00412599
  412570:	00412599 	.word	0x00412599
  412574:	00412599 	.word	0x00412599
  412578:	00412591 	.word	0x00412591
		case 5: //1125Hz/5 = 225Hz
			accel_gain = 15252014L;
  41257c:	4b0c      	ldr	r3, [pc, #48]	; (4125b0 <inv_icm20648_ctrl_set_accel_quaternion_gain+0x9c>)
  41257e:	60fb      	str	r3, [r7, #12]
			break;
  412580:	e00d      	b.n	41259e <inv_icm20648_ctrl_set_accel_quaternion_gain+0x8a>
		case 10: //1125Hz/10 = 112Hz
			accel_gain = 30504029L;
  412582:	4b0c      	ldr	r3, [pc, #48]	; (4125b4 <inv_icm20648_ctrl_set_accel_quaternion_gain+0xa0>)
  412584:	60fb      	str	r3, [r7, #12]
			break;
  412586:	e00a      	b.n	41259e <inv_icm20648_ctrl_set_accel_quaternion_gain+0x8a>
		case 11: //1125Hz/11 = 102Hz
			accel_gain = 33554432L;
  412588:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  41258c:	60fb      	str	r3, [r7, #12]
			break;
  41258e:	e006      	b.n	41259e <inv_icm20648_ctrl_set_accel_quaternion_gain+0x8a>
		case 22: //1125Hz/22 = 51Hz
			accel_gain = 67108864L;
  412590:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  412594:	60fb      	str	r3, [r7, #12]
			break;
  412596:	e002      	b.n	41259e <inv_icm20648_ctrl_set_accel_quaternion_gain+0x8a>
		default:
			accel_gain = 15252014L;
  412598:	4b05      	ldr	r3, [pc, #20]	; (4125b0 <inv_icm20648_ctrl_set_accel_quaternion_gain+0x9c>)
  41259a:	60fb      	str	r3, [r7, #12]
			break;
  41259c:	bf00      	nop
	}

	return dmp_icm20648_set_accel_feedback_gain(s, accel_gain);
  41259e:	68f9      	ldr	r1, [r7, #12]
  4125a0:	6878      	ldr	r0, [r7, #4]
  4125a2:	4b05      	ldr	r3, [pc, #20]	; (4125b8 <inv_icm20648_ctrl_set_accel_quaternion_gain+0xa4>)
  4125a4:	4798      	blx	r3
  4125a6:	4603      	mov	r3, r0
}
  4125a8:	4618      	mov	r0, r3
  4125aa:	3710      	adds	r7, #16
  4125ac:	46bd      	mov	sp, r7
  4125ae:	bd80      	pop	{r7, pc}
  4125b0:	00e8ba2e 	.word	0x00e8ba2e
  4125b4:	01d1745d 	.word	0x01d1745d
  4125b8:	004083f1 	.word	0x004083f1

004125bc <inv_icm20648_ctrl_set_accel_cal_params>:

int inv_icm20648_ctrl_set_accel_cal_params(struct inv_icm20648 * s, unsigned short hw_smplrt_divider)
{
  4125bc:	b580      	push	{r7, lr}
  4125be:	b086      	sub	sp, #24
  4125c0:	af00      	add	r7, sp, #0
  4125c2:	6078      	str	r0, [r7, #4]
  4125c4:	460b      	mov	r3, r1
  4125c6:	807b      	strh	r3, [r7, #2]
	int accel_cal_params[NUM_ACCEL_CAL_PARAMS] = {0};
  4125c8:	f107 030c 	add.w	r3, r7, #12
  4125cc:	2200      	movs	r2, #0
  4125ce:	601a      	str	r2, [r3, #0]
  4125d0:	605a      	str	r2, [r3, #4]
  4125d2:	609a      	str	r2, [r3, #8]

	if (hw_smplrt_divider <= 5) { // freq = 225Hz
  4125d4:	887b      	ldrh	r3, [r7, #2]
  4125d6:	2b05      	cmp	r3, #5
  4125d8:	d804      	bhi.n	4125e4 <inv_icm20648_ctrl_set_accel_cal_params+0x28>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 1026019965L;
  4125da:	4b21      	ldr	r3, [pc, #132]	; (412660 <inv_icm20648_ctrl_set_accel_cal_params+0xa4>)
  4125dc:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 47721859L;
  4125de:	4b21      	ldr	r3, [pc, #132]	; (412664 <inv_icm20648_ctrl_set_accel_cal_params+0xa8>)
  4125e0:	613b      	str	r3, [r7, #16]
  4125e2:	e032      	b.n	41264a <inv_icm20648_ctrl_set_accel_cal_params+0x8e>
	}
	else if (hw_smplrt_divider <= 10) { // 225Hz > freq >= 112Hz
  4125e4:	887b      	ldrh	r3, [r7, #2]
  4125e6:	2b0a      	cmp	r3, #10
  4125e8:	d804      	bhi.n	4125f4 <inv_icm20648_ctrl_set_accel_cal_params+0x38>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 977872018L;
  4125ea:	4b1f      	ldr	r3, [pc, #124]	; (412668 <inv_icm20648_ctrl_set_accel_cal_params+0xac>)
  4125ec:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 95869806L;
  4125ee:	4b1f      	ldr	r3, [pc, #124]	; (41266c <inv_icm20648_ctrl_set_accel_cal_params+0xb0>)
  4125f0:	613b      	str	r3, [r7, #16]
  4125f2:	e02a      	b.n	41264a <inv_icm20648_ctrl_set_accel_cal_params+0x8e>
	}
	else if (hw_smplrt_divider <= 11) { // 112Hz > freq >= 102Hz
  4125f4:	887b      	ldrh	r3, [r7, #2]
  4125f6:	2b0b      	cmp	r3, #11
  4125f8:	d807      	bhi.n	41260a <inv_icm20648_ctrl_set_accel_cal_params+0x4e>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 858993459L;
  4125fa:	f04f 3333 	mov.w	r3, #858993459	; 0x33333333
  4125fe:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 214748365L;
  412600:	4b1b      	ldr	r3, [pc, #108]	; (412670 <inv_icm20648_ctrl_set_accel_cal_params+0xb4>)
  412602:	613b      	str	r3, [r7, #16]
		accel_cal_params[ACCEL_CAL_DIV] = 1;
  412604:	2301      	movs	r3, #1
  412606:	617b      	str	r3, [r7, #20]
  412608:	e01f      	b.n	41264a <inv_icm20648_ctrl_set_accel_cal_params+0x8e>
	}
	else if (hw_smplrt_divider <= 20) { // 102Hz > freq >= 56Hz
  41260a:	887b      	ldrh	r3, [r7, #2]
  41260c:	2b14      	cmp	r3, #20
  41260e:	d804      	bhi.n	41261a <inv_icm20648_ctrl_set_accel_cal_params+0x5e>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 882002213L;
  412610:	4b18      	ldr	r3, [pc, #96]	; (412674 <inv_icm20648_ctrl_set_accel_cal_params+0xb8>)
  412612:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 191739611L;
  412614:	4b18      	ldr	r3, [pc, #96]	; (412678 <inv_icm20648_ctrl_set_accel_cal_params+0xbc>)
  412616:	613b      	str	r3, [r7, #16]
  412618:	e017      	b.n	41264a <inv_icm20648_ctrl_set_accel_cal_params+0x8e>
	}
	else if (hw_smplrt_divider <= 22) { // 56Hz > freq >= 51Hz
  41261a:	887b      	ldrh	r3, [r7, #2]
  41261c:	2b16      	cmp	r3, #22
  41261e:	d805      	bhi.n	41262c <inv_icm20648_ctrl_set_accel_cal_params+0x70>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 858993459L;
  412620:	f04f 3333 	mov.w	r3, #858993459	; 0x33333333
  412624:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 214748365L;
  412626:	4b12      	ldr	r3, [pc, #72]	; (412670 <inv_icm20648_ctrl_set_accel_cal_params+0xb4>)
  412628:	613b      	str	r3, [r7, #16]
  41262a:	e00e      	b.n	41264a <inv_icm20648_ctrl_set_accel_cal_params+0x8e>
	}
	else if (hw_smplrt_divider <= 75) { // 51Hz > freq >= 15Hz
  41262c:	887b      	ldrh	r3, [r7, #2]
  41262e:	2b4b      	cmp	r3, #75	; 0x4b
  412630:	d804      	bhi.n	41263c <inv_icm20648_ctrl_set_accel_cal_params+0x80>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 357913941L;
  412632:	4b12      	ldr	r3, [pc, #72]	; (41267c <inv_icm20648_ctrl_set_accel_cal_params+0xc0>)
  412634:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 715827883L;
  412636:	4b12      	ldr	r3, [pc, #72]	; (412680 <inv_icm20648_ctrl_set_accel_cal_params+0xc4>)
  412638:	613b      	str	r3, [r7, #16]
  41263a:	e006      	b.n	41264a <inv_icm20648_ctrl_set_accel_cal_params+0x8e>
	}
	else if (hw_smplrt_divider <= 225) { // 15Hz > freq >= 5Hz
  41263c:	887b      	ldrh	r3, [r7, #2]
  41263e:	2be1      	cmp	r3, #225	; 0xe1
  412640:	d803      	bhi.n	41264a <inv_icm20648_ctrl_set_accel_cal_params+0x8e>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 107374182L;
  412642:	4b10      	ldr	r3, [pc, #64]	; (412684 <inv_icm20648_ctrl_set_accel_cal_params+0xc8>)
  412644:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 966367642L;
  412646:	4b10      	ldr	r3, [pc, #64]	; (412688 <inv_icm20648_ctrl_set_accel_cal_params+0xcc>)
  412648:	613b      	str	r3, [r7, #16]
	}

	return dmp_icm20648_set_accel_cal_params(s, accel_cal_params);
  41264a:	f107 030c 	add.w	r3, r7, #12
  41264e:	4619      	mov	r1, r3
  412650:	6878      	ldr	r0, [r7, #4]
  412652:	4b0e      	ldr	r3, [pc, #56]	; (41268c <inv_icm20648_ctrl_set_accel_cal_params+0xd0>)
  412654:	4798      	blx	r3
  412656:	4603      	mov	r3, r0
}
  412658:	4618      	mov	r0, r3
  41265a:	3718      	adds	r7, #24
  41265c:	46bd      	mov	sp, r7
  41265e:	bd80      	pop	{r7, pc}
  412660:	3d27d27d 	.word	0x3d27d27d
  412664:	02d82d83 	.word	0x02d82d83
  412668:	3a492492 	.word	0x3a492492
  41266c:	05b6db6e 	.word	0x05b6db6e
  412670:	0ccccccd 	.word	0x0ccccccd
  412674:	34924925 	.word	0x34924925
  412678:	0b6db6db 	.word	0x0b6db6db
  41267c:	15555555 	.word	0x15555555
  412680:	2aaaaaab 	.word	0x2aaaaaab
  412684:	06666666 	.word	0x06666666
  412688:	3999999a 	.word	0x3999999a
  41268c:	00408439 	.word	0x00408439

00412690 <inv_icm20648_ctrl_get_mag_bias>:
{
	return dmp_icm20648_get_bias_gyr(s, gyr_bias);
}

int inv_icm20648_ctrl_get_mag_bias(struct inv_icm20648 * s, int * mag_bias)
{
  412690:	b580      	push	{r7, lr}
  412692:	b082      	sub	sp, #8
  412694:	af00      	add	r7, sp, #0
  412696:	6078      	str	r0, [r7, #4]
  412698:	6039      	str	r1, [r7, #0]
	return dmp_icm20648_get_bias_cmp(s, mag_bias);
  41269a:	6839      	ldr	r1, [r7, #0]
  41269c:	6878      	ldr	r0, [r7, #4]
  41269e:	4b03      	ldr	r3, [pc, #12]	; (4126ac <inv_icm20648_ctrl_get_mag_bias+0x1c>)
  4126a0:	4798      	blx	r3
  4126a2:	4603      	mov	r3, r0
}
  4126a4:	4618      	mov	r0, r3
  4126a6:	3708      	adds	r7, #8
  4126a8:	46bd      	mov	sp, r7
  4126aa:	bd80      	pop	{r7, pc}
  4126ac:	00408315 	.word	0x00408315

004126b0 <sensor_needs_compass>:
	rc = dmp_icm20648_set_bias_cmp(s, &s->bias[6]);

	return rc;
}
static unsigned char sensor_needs_compass(unsigned char androidSensor)
{
  4126b0:	b480      	push	{r7}
  4126b2:	b083      	sub	sp, #12
  4126b4:	af00      	add	r7, sp, #0
  4126b6:	4603      	mov	r3, r0
  4126b8:	71fb      	strb	r3, [r7, #7]
	switch(androidSensor) {
  4126ba:	79fb      	ldrb	r3, [r7, #7]
  4126bc:	3b02      	subs	r3, #2
  4126be:	2b25      	cmp	r3, #37	; 0x25
  4126c0:	d850      	bhi.n	412764 <sensor_needs_compass+0xb4>
  4126c2:	a201      	add	r2, pc, #4	; (adr r2, 4126c8 <sensor_needs_compass+0x18>)
  4126c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4126c8:	00412761 	.word	0x00412761
  4126cc:	00412765 	.word	0x00412765
  4126d0:	00412765 	.word	0x00412765
  4126d4:	00412765 	.word	0x00412765
  4126d8:	00412765 	.word	0x00412765
  4126dc:	00412765 	.word	0x00412765
  4126e0:	00412765 	.word	0x00412765
  4126e4:	00412765 	.word	0x00412765
  4126e8:	00412765 	.word	0x00412765
  4126ec:	00412761 	.word	0x00412761
  4126f0:	00412765 	.word	0x00412765
  4126f4:	00412765 	.word	0x00412765
  4126f8:	00412761 	.word	0x00412761
  4126fc:	00412765 	.word	0x00412765
  412700:	00412765 	.word	0x00412765
  412704:	00412765 	.word	0x00412765
  412708:	00412765 	.word	0x00412765
  41270c:	00412765 	.word	0x00412765
  412710:	00412761 	.word	0x00412761
  412714:	00412765 	.word	0x00412765
  412718:	00412765 	.word	0x00412765
  41271c:	00412765 	.word	0x00412765
  412720:	00412761 	.word	0x00412761
  412724:	00412765 	.word	0x00412765
  412728:	00412765 	.word	0x00412765
  41272c:	00412765 	.word	0x00412765
  412730:	00412765 	.word	0x00412765
  412734:	00412765 	.word	0x00412765
  412738:	00412765 	.word	0x00412765
  41273c:	00412761 	.word	0x00412761
  412740:	00412765 	.word	0x00412765
  412744:	00412765 	.word	0x00412765
  412748:	00412761 	.word	0x00412761
  41274c:	00412765 	.word	0x00412765
  412750:	00412765 	.word	0x00412765
  412754:	00412765 	.word	0x00412765
  412758:	00412765 	.word	0x00412765
  41275c:	00412761 	.word	0x00412761
		case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:
		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD:
		case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED:
		case ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR:
			return 1;
  412760:	2301      	movs	r3, #1
  412762:	e000      	b.n	412766 <sensor_needs_compass+0xb6>

		default :
			return 0;
  412764:	2300      	movs	r3, #0
	}
}
  412766:	4618      	mov	r0, r3
  412768:	370c      	adds	r7, #12
  41276a:	46bd      	mov	sp, r7
  41276c:	f85d 7b04 	ldr.w	r7, [sp], #4
  412770:	4770      	bx	lr
  412772:	bf00      	nop

00412774 <sensor_needs_bac_algo>:

static unsigned char sensor_needs_bac_algo(unsigned char androidSensor)
{
  412774:	b480      	push	{r7}
  412776:	b083      	sub	sp, #12
  412778:	af00      	add	r7, sp, #0
  41277a:	4603      	mov	r3, r0
  41277c:	71fb      	strb	r3, [r7, #7]
	switch(androidSensor){
  41277e:	79fb      	ldrb	r3, [r7, #7]
  412780:	3b11      	subs	r3, #17
  412782:	2b1e      	cmp	r3, #30
  412784:	d842      	bhi.n	41280c <sensor_needs_bac_algo+0x98>
  412786:	a201      	add	r2, pc, #4	; (adr r2, 41278c <sensor_needs_bac_algo+0x18>)
  412788:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  41278c:	00412809 	.word	0x00412809
  412790:	00412809 	.word	0x00412809
  412794:	00412809 	.word	0x00412809
  412798:	0041280d 	.word	0x0041280d
  41279c:	0041280d 	.word	0x0041280d
  4127a0:	0041280d 	.word	0x0041280d
  4127a4:	0041280d 	.word	0x0041280d
  4127a8:	0041280d 	.word	0x0041280d
  4127ac:	0041280d 	.word	0x0041280d
  4127b0:	0041280d 	.word	0x0041280d
  4127b4:	0041280d 	.word	0x0041280d
  4127b8:	0041280d 	.word	0x0041280d
  4127bc:	0041280d 	.word	0x0041280d
  4127c0:	0041280d 	.word	0x0041280d
  4127c4:	0041280d 	.word	0x0041280d
  4127c8:	0041280d 	.word	0x0041280d
  4127cc:	0041280d 	.word	0x0041280d
  4127d0:	0041280d 	.word	0x0041280d
  4127d4:	0041280d 	.word	0x0041280d
  4127d8:	0041280d 	.word	0x0041280d
  4127dc:	00412809 	.word	0x00412809
  4127e0:	00412809 	.word	0x00412809
  4127e4:	0041280d 	.word	0x0041280d
  4127e8:	0041280d 	.word	0x0041280d
  4127ec:	00412809 	.word	0x00412809
  4127f0:	0041280d 	.word	0x0041280d
  4127f4:	0041280d 	.word	0x0041280d
  4127f8:	0041280d 	.word	0x0041280d
  4127fc:	00412809 	.word	0x00412809
  412800:	00412809 	.word	0x00412809
  412804:	00412809 	.word	0x00412809
	case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:
	case ANDROID_SENSOR_WAKEUP_STEP_DETECTOR:
	case ANDROID_SENSOR_WAKEUP_STEP_COUNTER:
	case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:
	case ANDROID_SENSOR_B2S:
		return 1;
  412808:	2301      	movs	r3, #1
  41280a:	e000      	b.n	41280e <sensor_needs_bac_algo+0x9a>
	default:
		return 0;
  41280c:	2300      	movs	r3, #0
	}
}
  41280e:	4618      	mov	r0, r3
  412810:	370c      	adds	r7, #12
  412812:	46bd      	mov	sp, r7
  412814:	f85d 7b04 	ldr.w	r7, [sp], #4
  412818:	4770      	bx	lr
  41281a:	bf00      	nop

0041281c <cosf>:
  41281c:	b500      	push	{lr}
  41281e:	ee10 3a10 	vmov	r3, s0
  412822:	4a20      	ldr	r2, [pc, #128]	; (4128a4 <cosf+0x88>)
  412824:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  412828:	4293      	cmp	r3, r2
  41282a:	b083      	sub	sp, #12
  41282c:	dd19      	ble.n	412862 <cosf+0x46>
  41282e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
  412832:	db04      	blt.n	41283e <cosf+0x22>
  412834:	ee30 0a40 	vsub.f32	s0, s0, s0
  412838:	b003      	add	sp, #12
  41283a:	f85d fb04 	ldr.w	pc, [sp], #4
  41283e:	4668      	mov	r0, sp
  412840:	f000 f8d4 	bl	4129ec <__ieee754_rem_pio2f>
  412844:	f000 0003 	and.w	r0, r0, #3
  412848:	2801      	cmp	r0, #1
  41284a:	d01a      	beq.n	412882 <cosf+0x66>
  41284c:	2802      	cmp	r0, #2
  41284e:	d00f      	beq.n	412870 <cosf+0x54>
  412850:	b300      	cbz	r0, 412894 <cosf+0x78>
  412852:	2001      	movs	r0, #1
  412854:	eddd 0a01 	vldr	s1, [sp, #4]
  412858:	ed9d 0a00 	vldr	s0, [sp]
  41285c:	f000 fddc 	bl	413418 <__kernel_sinf>
  412860:	e7ea      	b.n	412838 <cosf+0x1c>
  412862:	eddf 0a11 	vldr	s1, [pc, #68]	; 4128a8 <cosf+0x8c>
  412866:	f000 fa0d 	bl	412c84 <__kernel_cosf>
  41286a:	b003      	add	sp, #12
  41286c:	f85d fb04 	ldr.w	pc, [sp], #4
  412870:	eddd 0a01 	vldr	s1, [sp, #4]
  412874:	ed9d 0a00 	vldr	s0, [sp]
  412878:	f000 fa04 	bl	412c84 <__kernel_cosf>
  41287c:	eeb1 0a40 	vneg.f32	s0, s0
  412880:	e7da      	b.n	412838 <cosf+0x1c>
  412882:	eddd 0a01 	vldr	s1, [sp, #4]
  412886:	ed9d 0a00 	vldr	s0, [sp]
  41288a:	f000 fdc5 	bl	413418 <__kernel_sinf>
  41288e:	eeb1 0a40 	vneg.f32	s0, s0
  412892:	e7d1      	b.n	412838 <cosf+0x1c>
  412894:	eddd 0a01 	vldr	s1, [sp, #4]
  412898:	ed9d 0a00 	vldr	s0, [sp]
  41289c:	f000 f9f2 	bl	412c84 <__kernel_cosf>
  4128a0:	e7ca      	b.n	412838 <cosf+0x1c>
  4128a2:	bf00      	nop
  4128a4:	3f490fd8 	.word	0x3f490fd8
  4128a8:	00000000 	.word	0x00000000

004128ac <sinf>:
  4128ac:	b500      	push	{lr}
  4128ae:	ee10 3a10 	vmov	r3, s0
  4128b2:	4a21      	ldr	r2, [pc, #132]	; (412938 <sinf+0x8c>)
  4128b4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  4128b8:	4293      	cmp	r3, r2
  4128ba:	b083      	sub	sp, #12
  4128bc:	dd1a      	ble.n	4128f4 <sinf+0x48>
  4128be:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
  4128c2:	db04      	blt.n	4128ce <sinf+0x22>
  4128c4:	ee30 0a40 	vsub.f32	s0, s0, s0
  4128c8:	b003      	add	sp, #12
  4128ca:	f85d fb04 	ldr.w	pc, [sp], #4
  4128ce:	4668      	mov	r0, sp
  4128d0:	f000 f88c 	bl	4129ec <__ieee754_rem_pio2f>
  4128d4:	f000 0003 	and.w	r0, r0, #3
  4128d8:	2801      	cmp	r0, #1
  4128da:	d01d      	beq.n	412918 <sinf+0x6c>
  4128dc:	2802      	cmp	r0, #2
  4128de:	d011      	beq.n	412904 <sinf+0x58>
  4128e0:	b308      	cbz	r0, 412926 <sinf+0x7a>
  4128e2:	eddd 0a01 	vldr	s1, [sp, #4]
  4128e6:	ed9d 0a00 	vldr	s0, [sp]
  4128ea:	f000 f9cb 	bl	412c84 <__kernel_cosf>
  4128ee:	eeb1 0a40 	vneg.f32	s0, s0
  4128f2:	e7e9      	b.n	4128c8 <sinf+0x1c>
  4128f4:	2000      	movs	r0, #0
  4128f6:	eddf 0a11 	vldr	s1, [pc, #68]	; 41293c <sinf+0x90>
  4128fa:	f000 fd8d 	bl	413418 <__kernel_sinf>
  4128fe:	b003      	add	sp, #12
  412900:	f85d fb04 	ldr.w	pc, [sp], #4
  412904:	2001      	movs	r0, #1
  412906:	eddd 0a01 	vldr	s1, [sp, #4]
  41290a:	ed9d 0a00 	vldr	s0, [sp]
  41290e:	f000 fd83 	bl	413418 <__kernel_sinf>
  412912:	eeb1 0a40 	vneg.f32	s0, s0
  412916:	e7d7      	b.n	4128c8 <sinf+0x1c>
  412918:	eddd 0a01 	vldr	s1, [sp, #4]
  41291c:	ed9d 0a00 	vldr	s0, [sp]
  412920:	f000 f9b0 	bl	412c84 <__kernel_cosf>
  412924:	e7d0      	b.n	4128c8 <sinf+0x1c>
  412926:	2001      	movs	r0, #1
  412928:	eddd 0a01 	vldr	s1, [sp, #4]
  41292c:	ed9d 0a00 	vldr	s0, [sp]
  412930:	f000 fd72 	bl	413418 <__kernel_sinf>
  412934:	e7c8      	b.n	4128c8 <sinf+0x1c>
  412936:	bf00      	nop
  412938:	3f490fd8 	.word	0x3f490fd8
  41293c:	00000000 	.word	0x00000000

00412940 <sqrtf>:
  412940:	b510      	push	{r4, lr}
  412942:	ed2d 8b02 	vpush	{d8}
  412946:	b08a      	sub	sp, #40	; 0x28
  412948:	eeb0 8a40 	vmov.f32	s16, s0
  41294c:	f000 f996 	bl	412c7c <__ieee754_sqrtf>
  412950:	4b24      	ldr	r3, [pc, #144]	; (4129e4 <sqrtf+0xa4>)
  412952:	f993 4000 	ldrsb.w	r4, [r3]
  412956:	1c63      	adds	r3, r4, #1
  412958:	d009      	beq.n	41296e <sqrtf+0x2e>
  41295a:	eeb4 8a48 	vcmp.f32	s16, s16
  41295e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412962:	d604      	bvs.n	41296e <sqrtf+0x2e>
  412964:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  412968:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41296c:	d403      	bmi.n	412976 <sqrtf+0x36>
  41296e:	b00a      	add	sp, #40	; 0x28
  412970:	ecbd 8b02 	vpop	{d8}
  412974:	bd10      	pop	{r4, pc}
  412976:	2301      	movs	r3, #1
  412978:	4a1b      	ldr	r2, [pc, #108]	; (4129e8 <sqrtf+0xa8>)
  41297a:	9300      	str	r3, [sp, #0]
  41297c:	ee18 0a10 	vmov	r0, s16
  412980:	2300      	movs	r3, #0
  412982:	9201      	str	r2, [sp, #4]
  412984:	9308      	str	r3, [sp, #32]
  412986:	f000 ffb9 	bl	4138fc <__aeabi_f2d>
  41298a:	2200      	movs	r2, #0
  41298c:	e9cd 0104 	strd	r0, r1, [sp, #16]
  412990:	e9cd 0102 	strd	r0, r1, [sp, #8]
  412994:	2300      	movs	r3, #0
  412996:	b1bc      	cbz	r4, 4129c8 <sqrtf+0x88>
  412998:	4610      	mov	r0, r2
  41299a:	4619      	mov	r1, r3
  41299c:	f001 f92c 	bl	413bf8 <__aeabi_ddiv>
  4129a0:	2c02      	cmp	r4, #2
  4129a2:	e9cd 0106 	strd	r0, r1, [sp, #24]
  4129a6:	d111      	bne.n	4129cc <sqrtf+0x8c>
  4129a8:	f001 fbe6 	bl	414178 <__errno>
  4129ac:	2321      	movs	r3, #33	; 0x21
  4129ae:	6003      	str	r3, [r0, #0]
  4129b0:	9b08      	ldr	r3, [sp, #32]
  4129b2:	b98b      	cbnz	r3, 4129d8 <sqrtf+0x98>
  4129b4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  4129b8:	f001 fa06 	bl	413dc8 <__aeabi_d2f>
  4129bc:	ee00 0a10 	vmov	s0, r0
  4129c0:	b00a      	add	sp, #40	; 0x28
  4129c2:	ecbd 8b02 	vpop	{d8}
  4129c6:	bd10      	pop	{r4, pc}
  4129c8:	e9cd 2306 	strd	r2, r3, [sp, #24]
  4129cc:	4668      	mov	r0, sp
  4129ce:	f000 fd6b 	bl	4134a8 <matherr>
  4129d2:	2800      	cmp	r0, #0
  4129d4:	d1ec      	bne.n	4129b0 <sqrtf+0x70>
  4129d6:	e7e7      	b.n	4129a8 <sqrtf+0x68>
  4129d8:	f001 fbce 	bl	414178 <__errno>
  4129dc:	9b08      	ldr	r3, [sp, #32]
  4129de:	6003      	str	r3, [r0, #0]
  4129e0:	e7e8      	b.n	4129b4 <sqrtf+0x74>
  4129e2:	bf00      	nop
  4129e4:	20000354 	.word	0x20000354
  4129e8:	0041d428 	.word	0x0041d428

004129ec <__ieee754_rem_pio2f>:
  4129ec:	b570      	push	{r4, r5, r6, lr}
  4129ee:	ee10 3a10 	vmov	r3, s0
  4129f2:	4a94      	ldr	r2, [pc, #592]	; (412c44 <__ieee754_rem_pio2f+0x258>)
  4129f4:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
  4129f8:	4294      	cmp	r4, r2
  4129fa:	b086      	sub	sp, #24
  4129fc:	4605      	mov	r5, r0
  4129fe:	dd68      	ble.n	412ad2 <__ieee754_rem_pio2f+0xe6>
  412a00:	4a91      	ldr	r2, [pc, #580]	; (412c48 <__ieee754_rem_pio2f+0x25c>)
  412a02:	4294      	cmp	r4, r2
  412a04:	ee10 6a10 	vmov	r6, s0
  412a08:	dc1a      	bgt.n	412a40 <__ieee754_rem_pio2f+0x54>
  412a0a:	2b00      	cmp	r3, #0
  412a0c:	eddf 7a8f 	vldr	s15, [pc, #572]	; 412c4c <__ieee754_rem_pio2f+0x260>
  412a10:	4a8f      	ldr	r2, [pc, #572]	; (412c50 <__ieee754_rem_pio2f+0x264>)
  412a12:	f024 040f 	bic.w	r4, r4, #15
  412a16:	f340 80dd 	ble.w	412bd4 <__ieee754_rem_pio2f+0x1e8>
  412a1a:	4294      	cmp	r4, r2
  412a1c:	ee70 7a67 	vsub.f32	s15, s0, s15
  412a20:	d066      	beq.n	412af0 <__ieee754_rem_pio2f+0x104>
  412a22:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 412c54 <__ieee754_rem_pio2f+0x268>
  412a26:	ee77 6ac7 	vsub.f32	s13, s15, s14
  412a2a:	2001      	movs	r0, #1
  412a2c:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412a30:	edc5 6a00 	vstr	s13, [r5]
  412a34:	ee77 7ac7 	vsub.f32	s15, s15, s14
  412a38:	edc5 7a01 	vstr	s15, [r5, #4]
  412a3c:	b006      	add	sp, #24
  412a3e:	bd70      	pop	{r4, r5, r6, pc}
  412a40:	4a85      	ldr	r2, [pc, #532]	; (412c58 <__ieee754_rem_pio2f+0x26c>)
  412a42:	4294      	cmp	r4, r2
  412a44:	dd66      	ble.n	412b14 <__ieee754_rem_pio2f+0x128>
  412a46:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
  412a4a:	da49      	bge.n	412ae0 <__ieee754_rem_pio2f+0xf4>
  412a4c:	15e2      	asrs	r2, r4, #23
  412a4e:	3a86      	subs	r2, #134	; 0x86
  412a50:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
  412a54:	ee07 3a90 	vmov	s15, r3
  412a58:	eebd 7ae7 	vcvt.s32.f32	s14, s15
  412a5c:	eddf 6a7f 	vldr	s13, [pc, #508]	; 412c5c <__ieee754_rem_pio2f+0x270>
  412a60:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  412a64:	ee77 7ac7 	vsub.f32	s15, s15, s14
  412a68:	ed8d 7a03 	vstr	s14, [sp, #12]
  412a6c:	ee67 7aa6 	vmul.f32	s15, s15, s13
  412a70:	eebd 7ae7 	vcvt.s32.f32	s14, s15
  412a74:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  412a78:	ee77 7ac7 	vsub.f32	s15, s15, s14
  412a7c:	ed8d 7a04 	vstr	s14, [sp, #16]
  412a80:	ee67 7aa6 	vmul.f32	s15, s15, s13
  412a84:	eef5 7a40 	vcmp.f32	s15, #0.0
  412a88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412a8c:	edcd 7a05 	vstr	s15, [sp, #20]
  412a90:	f040 80b3 	bne.w	412bfa <__ieee754_rem_pio2f+0x20e>
  412a94:	eeb5 7a40 	vcmp.f32	s14, #0.0
  412a98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412a9c:	bf0c      	ite	eq
  412a9e:	2301      	moveq	r3, #1
  412aa0:	2302      	movne	r3, #2
  412aa2:	496f      	ldr	r1, [pc, #444]	; (412c60 <__ieee754_rem_pio2f+0x274>)
  412aa4:	9101      	str	r1, [sp, #4]
  412aa6:	2102      	movs	r1, #2
  412aa8:	9100      	str	r1, [sp, #0]
  412aaa:	a803      	add	r0, sp, #12
  412aac:	4629      	mov	r1, r5
  412aae:	f000 f96b 	bl	412d88 <__kernel_rem_pio2f>
  412ab2:	2e00      	cmp	r6, #0
  412ab4:	da12      	bge.n	412adc <__ieee754_rem_pio2f+0xf0>
  412ab6:	ed95 7a00 	vldr	s14, [r5]
  412aba:	edd5 7a01 	vldr	s15, [r5, #4]
  412abe:	eeb1 7a47 	vneg.f32	s14, s14
  412ac2:	eef1 7a67 	vneg.f32	s15, s15
  412ac6:	4240      	negs	r0, r0
  412ac8:	ed85 7a00 	vstr	s14, [r5]
  412acc:	edc5 7a01 	vstr	s15, [r5, #4]
  412ad0:	e004      	b.n	412adc <__ieee754_rem_pio2f+0xf0>
  412ad2:	2200      	movs	r2, #0
  412ad4:	ed85 0a00 	vstr	s0, [r5]
  412ad8:	6042      	str	r2, [r0, #4]
  412ada:	2000      	movs	r0, #0
  412adc:	b006      	add	sp, #24
  412ade:	bd70      	pop	{r4, r5, r6, pc}
  412ae0:	ee70 7a40 	vsub.f32	s15, s0, s0
  412ae4:	2000      	movs	r0, #0
  412ae6:	edc5 7a01 	vstr	s15, [r5, #4]
  412aea:	edc5 7a00 	vstr	s15, [r5]
  412aee:	e7f5      	b.n	412adc <__ieee754_rem_pio2f+0xf0>
  412af0:	eddf 6a5c 	vldr	s13, [pc, #368]	; 412c64 <__ieee754_rem_pio2f+0x278>
  412af4:	ed9f 7a5c 	vldr	s14, [pc, #368]	; 412c68 <__ieee754_rem_pio2f+0x27c>
  412af8:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412afc:	2001      	movs	r0, #1
  412afe:	ee77 6ac7 	vsub.f32	s13, s15, s14
  412b02:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412b06:	edc5 6a00 	vstr	s13, [r5]
  412b0a:	ee77 7ac7 	vsub.f32	s15, s15, s14
  412b0e:	edc5 7a01 	vstr	s15, [r5, #4]
  412b12:	e7e3      	b.n	412adc <__ieee754_rem_pio2f+0xf0>
  412b14:	f000 fcca 	bl	4134ac <fabsf>
  412b18:	eddf 6a54 	vldr	s13, [pc, #336]	; 412c6c <__ieee754_rem_pio2f+0x280>
  412b1c:	eddf 5a4b 	vldr	s11, [pc, #300]	; 412c4c <__ieee754_rem_pio2f+0x260>
  412b20:	eddf 7a4c 	vldr	s15, [pc, #304]	; 412c54 <__ieee754_rem_pio2f+0x268>
  412b24:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
  412b28:	eea0 7a26 	vfma.f32	s14, s0, s13
  412b2c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  412b30:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  412b34:	ee17 0a10 	vmov	r0, s14
  412b38:	eeb1 6a66 	vneg.f32	s12, s13
  412b3c:	281f      	cmp	r0, #31
  412b3e:	eea6 0a25 	vfma.f32	s0, s12, s11
  412b42:	ee66 7aa7 	vmul.f32	s15, s13, s15
  412b46:	dc1d      	bgt.n	412b84 <__ieee754_rem_pio2f+0x198>
  412b48:	4a49      	ldr	r2, [pc, #292]	; (412c70 <__ieee754_rem_pio2f+0x284>)
  412b4a:	1e41      	subs	r1, r0, #1
  412b4c:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
  412b50:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  412b54:	4293      	cmp	r3, r2
  412b56:	d015      	beq.n	412b84 <__ieee754_rem_pio2f+0x198>
  412b58:	ee30 7a67 	vsub.f32	s14, s0, s15
  412b5c:	ed85 7a00 	vstr	s14, [r5]
  412b60:	ee30 0a47 	vsub.f32	s0, s0, s14
  412b64:	2e00      	cmp	r6, #0
  412b66:	ee30 0a67 	vsub.f32	s0, s0, s15
  412b6a:	ed85 0a01 	vstr	s0, [r5, #4]
  412b6e:	dab5      	bge.n	412adc <__ieee754_rem_pio2f+0xf0>
  412b70:	eeb1 7a47 	vneg.f32	s14, s14
  412b74:	eeb1 0a40 	vneg.f32	s0, s0
  412b78:	ed85 7a00 	vstr	s14, [r5]
  412b7c:	ed85 0a01 	vstr	s0, [r5, #4]
  412b80:	4240      	negs	r0, r0
  412b82:	e7ab      	b.n	412adc <__ieee754_rem_pio2f+0xf0>
  412b84:	ee30 7a67 	vsub.f32	s14, s0, s15
  412b88:	15e4      	asrs	r4, r4, #23
  412b8a:	ee17 3a10 	vmov	r3, s14
  412b8e:	f3c3 53c7 	ubfx	r3, r3, #23, #8
  412b92:	1ae3      	subs	r3, r4, r3
  412b94:	2b08      	cmp	r3, #8
  412b96:	dde1      	ble.n	412b5c <__ieee754_rem_pio2f+0x170>
  412b98:	eddf 7a32 	vldr	s15, [pc, #200]	; 412c64 <__ieee754_rem_pio2f+0x278>
  412b9c:	ed9f 7a32 	vldr	s14, [pc, #200]	; 412c68 <__ieee754_rem_pio2f+0x27c>
  412ba0:	eef0 5a40 	vmov.f32	s11, s0
  412ba4:	eee6 5a27 	vfma.f32	s11, s12, s15
  412ba8:	ee30 0a65 	vsub.f32	s0, s0, s11
  412bac:	eea6 0a27 	vfma.f32	s0, s12, s15
  412bb0:	eef0 7a40 	vmov.f32	s15, s0
  412bb4:	eed6 7a87 	vfnms.f32	s15, s13, s14
  412bb8:	ee35 7ae7 	vsub.f32	s14, s11, s15
  412bbc:	ee17 3a10 	vmov	r3, s14
  412bc0:	f3c3 53c7 	ubfx	r3, r3, #23, #8
  412bc4:	1ae4      	subs	r4, r4, r3
  412bc6:	2c19      	cmp	r4, #25
  412bc8:	dc2c      	bgt.n	412c24 <__ieee754_rem_pio2f+0x238>
  412bca:	ed85 7a00 	vstr	s14, [r5]
  412bce:	eeb0 0a65 	vmov.f32	s0, s11
  412bd2:	e7c5      	b.n	412b60 <__ieee754_rem_pio2f+0x174>
  412bd4:	4294      	cmp	r4, r2
  412bd6:	ee70 7a27 	vadd.f32	s15, s0, s15
  412bda:	d010      	beq.n	412bfe <__ieee754_rem_pio2f+0x212>
  412bdc:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 412c54 <__ieee754_rem_pio2f+0x268>
  412be0:	ee77 6a87 	vadd.f32	s13, s15, s14
  412be4:	f04f 30ff 	mov.w	r0, #4294967295
  412be8:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412bec:	edc5 6a00 	vstr	s13, [r5]
  412bf0:	ee77 7a87 	vadd.f32	s15, s15, s14
  412bf4:	edc5 7a01 	vstr	s15, [r5, #4]
  412bf8:	e770      	b.n	412adc <__ieee754_rem_pio2f+0xf0>
  412bfa:	2303      	movs	r3, #3
  412bfc:	e751      	b.n	412aa2 <__ieee754_rem_pio2f+0xb6>
  412bfe:	eddf 6a19 	vldr	s13, [pc, #100]	; 412c64 <__ieee754_rem_pio2f+0x278>
  412c02:	ed9f 7a19 	vldr	s14, [pc, #100]	; 412c68 <__ieee754_rem_pio2f+0x27c>
  412c06:	ee77 7aa6 	vadd.f32	s15, s15, s13
  412c0a:	f04f 30ff 	mov.w	r0, #4294967295
  412c0e:	ee77 6a87 	vadd.f32	s13, s15, s14
  412c12:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412c16:	edc5 6a00 	vstr	s13, [r5]
  412c1a:	ee77 7a87 	vadd.f32	s15, s15, s14
  412c1e:	edc5 7a01 	vstr	s15, [r5, #4]
  412c22:	e75b      	b.n	412adc <__ieee754_rem_pio2f+0xf0>
  412c24:	ed9f 7a13 	vldr	s14, [pc, #76]	; 412c74 <__ieee754_rem_pio2f+0x288>
  412c28:	ed9f 5a13 	vldr	s10, [pc, #76]	; 412c78 <__ieee754_rem_pio2f+0x28c>
  412c2c:	eeb0 0a65 	vmov.f32	s0, s11
  412c30:	eea6 0a07 	vfma.f32	s0, s12, s14
  412c34:	ee75 7ac0 	vsub.f32	s15, s11, s0
  412c38:	eee6 7a07 	vfma.f32	s15, s12, s14
  412c3c:	eed6 7a85 	vfnms.f32	s15, s13, s10
  412c40:	e78a      	b.n	412b58 <__ieee754_rem_pio2f+0x16c>
  412c42:	bf00      	nop
  412c44:	3f490fd8 	.word	0x3f490fd8
  412c48:	4016cbe3 	.word	0x4016cbe3
  412c4c:	3fc90f80 	.word	0x3fc90f80
  412c50:	3fc90fd0 	.word	0x3fc90fd0
  412c54:	37354443 	.word	0x37354443
  412c58:	43490f80 	.word	0x43490f80
  412c5c:	43800000 	.word	0x43800000
  412c60:	0041d4b0 	.word	0x0041d4b0
  412c64:	37354400 	.word	0x37354400
  412c68:	2e85a308 	.word	0x2e85a308
  412c6c:	3f22f984 	.word	0x3f22f984
  412c70:	0041d430 	.word	0x0041d430
  412c74:	2e85a300 	.word	0x2e85a300
  412c78:	248d3132 	.word	0x248d3132

00412c7c <__ieee754_sqrtf>:
  412c7c:	eeb1 0ac0 	vsqrt.f32	s0, s0
  412c80:	4770      	bx	lr
  412c82:	bf00      	nop

00412c84 <__kernel_cosf>:
  412c84:	ee10 3a10 	vmov	r3, s0
  412c88:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  412c8c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
  412c90:	da2c      	bge.n	412cec <__kernel_cosf+0x68>
  412c92:	eefd 7ac0 	vcvt.s32.f32	s15, s0
  412c96:	ee17 3a90 	vmov	r3, s15
  412c9a:	2b00      	cmp	r3, #0
  412c9c:	d060      	beq.n	412d60 <__kernel_cosf+0xdc>
  412c9e:	ee20 7a00 	vmul.f32	s14, s0, s0
  412ca2:	eddf 4a31 	vldr	s9, [pc, #196]	; 412d68 <__kernel_cosf+0xe4>
  412ca6:	ed9f 5a31 	vldr	s10, [pc, #196]	; 412d6c <__kernel_cosf+0xe8>
  412caa:	eddf 5a31 	vldr	s11, [pc, #196]	; 412d70 <__kernel_cosf+0xec>
  412cae:	ed9f 6a31 	vldr	s12, [pc, #196]	; 412d74 <__kernel_cosf+0xf0>
  412cb2:	eddf 7a31 	vldr	s15, [pc, #196]	; 412d78 <__kernel_cosf+0xf4>
  412cb6:	eddf 6a31 	vldr	s13, [pc, #196]	; 412d7c <__kernel_cosf+0xf8>
  412cba:	eea7 5a24 	vfma.f32	s10, s14, s9
  412cbe:	eee7 5a05 	vfma.f32	s11, s14, s10
  412cc2:	eea7 6a25 	vfma.f32	s12, s14, s11
  412cc6:	eee7 7a06 	vfma.f32	s15, s14, s12
  412cca:	eee7 6a27 	vfma.f32	s13, s14, s15
  412cce:	ee66 6a87 	vmul.f32	s13, s13, s14
  412cd2:	ee60 0ac0 	vnmul.f32	s1, s1, s0
  412cd6:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
  412cda:	eee7 0a26 	vfma.f32	s1, s14, s13
  412cde:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  412ce2:	eed7 0a06 	vfnms.f32	s1, s14, s12
  412ce6:	ee37 0ae0 	vsub.f32	s0, s15, s1
  412cea:	4770      	bx	lr
  412cec:	ee20 7a00 	vmul.f32	s14, s0, s0
  412cf0:	eddf 4a1d 	vldr	s9, [pc, #116]	; 412d68 <__kernel_cosf+0xe4>
  412cf4:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 412d6c <__kernel_cosf+0xe8>
  412cf8:	eddf 5a1d 	vldr	s11, [pc, #116]	; 412d70 <__kernel_cosf+0xec>
  412cfc:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 412d74 <__kernel_cosf+0xf0>
  412d00:	eddf 7a1d 	vldr	s15, [pc, #116]	; 412d78 <__kernel_cosf+0xf4>
  412d04:	eddf 6a1d 	vldr	s13, [pc, #116]	; 412d7c <__kernel_cosf+0xf8>
  412d08:	4a1d      	ldr	r2, [pc, #116]	; (412d80 <__kernel_cosf+0xfc>)
  412d0a:	eea7 5a24 	vfma.f32	s10, s14, s9
  412d0e:	4293      	cmp	r3, r2
  412d10:	eee7 5a05 	vfma.f32	s11, s14, s10
  412d14:	eea7 6a25 	vfma.f32	s12, s14, s11
  412d18:	eee7 7a06 	vfma.f32	s15, s14, s12
  412d1c:	eee7 6a27 	vfma.f32	s13, s14, s15
  412d20:	ee66 6a87 	vmul.f32	s13, s13, s14
  412d24:	ddd5      	ble.n	412cd2 <__kernel_cosf+0x4e>
  412d26:	4a17      	ldr	r2, [pc, #92]	; (412d84 <__kernel_cosf+0x100>)
  412d28:	4293      	cmp	r3, r2
  412d2a:	dc14      	bgt.n	412d56 <__kernel_cosf+0xd2>
  412d2c:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
  412d30:	ee07 3a90 	vmov	s15, r3
  412d34:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
  412d38:	ee36 6a67 	vsub.f32	s12, s12, s15
  412d3c:	ee60 0ac0 	vnmul.f32	s1, s1, s0
  412d40:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
  412d44:	eee7 0a26 	vfma.f32	s1, s14, s13
  412d48:	eed7 7a25 	vfnms.f32	s15, s14, s11
  412d4c:	ee77 7ae0 	vsub.f32	s15, s15, s1
  412d50:	ee36 0a67 	vsub.f32	s0, s12, s15
  412d54:	4770      	bx	lr
  412d56:	eeb6 6a07 	vmov.f32	s12, #103	; 0x3f380000  0.7187500
  412d5a:	eef5 7a02 	vmov.f32	s15, #82	; 0x3e900000  0.2812500
  412d5e:	e7ed      	b.n	412d3c <__kernel_cosf+0xb8>
  412d60:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  412d64:	4770      	bx	lr
  412d66:	bf00      	nop
  412d68:	ad47d74e 	.word	0xad47d74e
  412d6c:	310f74f6 	.word	0x310f74f6
  412d70:	b493f27c 	.word	0xb493f27c
  412d74:	37d00d01 	.word	0x37d00d01
  412d78:	bab60b61 	.word	0xbab60b61
  412d7c:	3d2aaaab 	.word	0x3d2aaaab
  412d80:	3e999999 	.word	0x3e999999
  412d84:	3f480000 	.word	0x3f480000

00412d88 <__kernel_rem_pio2f>:
  412d88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  412d8c:	ed2d 8b04 	vpush	{d8-d9}
  412d90:	b0d9      	sub	sp, #356	; 0x164
  412d92:	f103 3aff 	add.w	sl, r3, #4294967295
  412d96:	9304      	str	r3, [sp, #16]
  412d98:	1ed3      	subs	r3, r2, #3
  412d9a:	bf48      	it	mi
  412d9c:	1d13      	addmi	r3, r2, #4
  412d9e:	4cd4      	ldr	r4, [pc, #848]	; (4130f0 <__kernel_rem_pio2f+0x368>)
  412da0:	9d66      	ldr	r5, [sp, #408]	; 0x198
  412da2:	9102      	str	r1, [sp, #8]
  412da4:	10db      	asrs	r3, r3, #3
  412da6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  412daa:	4619      	mov	r1, r3
  412dac:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
  412db0:	9306      	str	r3, [sp, #24]
  412db2:	3301      	adds	r3, #1
  412db4:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
  412db8:	9301      	str	r3, [sp, #4]
  412dba:	eba1 030a 	sub.w	r3, r1, sl
  412dbe:	eb16 010a 	adds.w	r1, r6, sl
  412dc2:	4681      	mov	r9, r0
  412dc4:	d416      	bmi.n	412df4 <__kernel_rem_pio2f+0x6c>
  412dc6:	4419      	add	r1, r3
  412dc8:	ed9f 7aca 	vldr	s14, [pc, #808]	; 4130f4 <__kernel_rem_pio2f+0x36c>
  412dcc:	9867      	ldr	r0, [sp, #412]	; 0x19c
  412dce:	3101      	adds	r1, #1
  412dd0:	aa1c      	add	r2, sp, #112	; 0x70
  412dd2:	2b00      	cmp	r3, #0
  412dd4:	bfa4      	itt	ge
  412dd6:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
  412dda:	ee07 4a90 	vmovge	s15, r4
  412dde:	f103 0301 	add.w	r3, r3, #1
  412de2:	bfac      	ite	ge
  412de4:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
  412de8:	eef0 7a47 	vmovlt.f32	s15, s14
  412dec:	428b      	cmp	r3, r1
  412dee:	ece2 7a01 	vstmia	r2!, {s15}
  412df2:	d1ee      	bne.n	412dd2 <__kernel_rem_pio2f+0x4a>
  412df4:	2e00      	cmp	r6, #0
  412df6:	f2c0 8307 	blt.w	413408 <__kernel_rem_pio2f+0x680>
  412dfa:	9b04      	ldr	r3, [sp, #16]
  412dfc:	ad44      	add	r5, sp, #272	; 0x110
  412dfe:	009c      	lsls	r4, r3, #2
  412e00:	1c77      	adds	r7, r6, #1
  412e02:	ab1c      	add	r3, sp, #112	; 0x70
  412e04:	eb05 0787 	add.w	r7, r5, r7, lsl #2
  412e08:	1918      	adds	r0, r3, r4
  412e0a:	eb09 0104 	add.w	r1, r9, r4
  412e0e:	f1ba 0f00 	cmp.w	sl, #0
  412e12:	f2c0 8275 	blt.w	413300 <__kernel_rem_pio2f+0x578>
  412e16:	eddf 7ab7 	vldr	s15, [pc, #732]	; 4130f4 <__kernel_rem_pio2f+0x36c>
  412e1a:	464b      	mov	r3, r9
  412e1c:	4602      	mov	r2, r0
  412e1e:	ecf3 6a01 	vldmia	r3!, {s13}
  412e22:	ed32 7a01 	vldmdb	r2!, {s14}
  412e26:	428b      	cmp	r3, r1
  412e28:	eee6 7a87 	vfma.f32	s15, s13, s14
  412e2c:	d1f7      	bne.n	412e1e <__kernel_rem_pio2f+0x96>
  412e2e:	ece5 7a01 	vstmia	r5!, {s15}
  412e32:	42bd      	cmp	r5, r7
  412e34:	f100 0004 	add.w	r0, r0, #4
  412e38:	d1e9      	bne.n	412e0e <__kernel_rem_pio2f+0x86>
  412e3a:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
  412e3e:	3b01      	subs	r3, #1
  412e40:	009b      	lsls	r3, r3, #2
  412e42:	ad08      	add	r5, sp, #32
  412e44:	1f1a      	subs	r2, r3, #4
  412e46:	18aa      	adds	r2, r5, r2
  412e48:	46b3      	mov	fp, r6
  412e4a:	9603      	str	r6, [sp, #12]
  412e4c:	eddf 8aab 	vldr	s17, [pc, #684]	; 4130fc <__kernel_rem_pio2f+0x374>
  412e50:	ed9f 8aa9 	vldr	s16, [pc, #676]	; 4130f8 <__kernel_rem_pio2f+0x370>
  412e54:	9e01      	ldr	r6, [sp, #4]
  412e56:	9207      	str	r2, [sp, #28]
  412e58:	444c      	add	r4, r9
  412e5a:	eb05 0803 	add.w	r8, r5, r3
  412e5e:	af44      	add	r7, sp, #272	; 0x110
  412e60:	ea4f 038b 	mov.w	r3, fp, lsl #2
  412e64:	aa58      	add	r2, sp, #352	; 0x160
  412e66:	441a      	add	r2, r3
  412e68:	f1bb 0f00 	cmp.w	fp, #0
  412e6c:	ed12 0a14 	vldr	s0, [r2, #-80]	; 0xffffffb0
  412e70:	dd18      	ble.n	412ea4 <__kernel_rem_pio2f+0x11c>
  412e72:	a907      	add	r1, sp, #28
  412e74:	eb07 028b 	add.w	r2, r7, fp, lsl #2
  412e78:	ee60 7a28 	vmul.f32	s15, s0, s17
  412e7c:	eeb0 7a40 	vmov.f32	s14, s0
  412e80:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  412e84:	ed72 6a01 	vldmdb	r2!, {s13}
  412e88:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  412e8c:	42ba      	cmp	r2, r7
  412e8e:	eea7 7ac8 	vfms.f32	s14, s15, s16
  412e92:	ee37 0aa6 	vadd.f32	s0, s15, s13
  412e96:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  412e9a:	ee17 0a10 	vmov	r0, s14
  412e9e:	f841 0f04 	str.w	r0, [r1, #4]!
  412ea2:	d1e9      	bne.n	412e78 <__kernel_rem_pio2f+0xf0>
  412ea4:	4630      	mov	r0, r6
  412ea6:	9305      	str	r3, [sp, #20]
  412ea8:	f000 fb50 	bl	41354c <scalbnf>
  412eac:	eeb0 9a40 	vmov.f32	s18, s0
  412eb0:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
  412eb4:	ee29 0a00 	vmul.f32	s0, s18, s0
  412eb8:	f000 fb00 	bl	4134bc <floorf>
  412ebc:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
  412ec0:	eea0 9a67 	vfms.f32	s18, s0, s15
  412ec4:	2e00      	cmp	r6, #0
  412ec6:	9b05      	ldr	r3, [sp, #20]
  412ec8:	eefd 9ac9 	vcvt.s32.f32	s19, s18
  412ecc:	eef8 7ae9 	vcvt.f32.s32	s15, s19
  412ed0:	ee39 9a67 	vsub.f32	s18, s18, s15
  412ed4:	f340 80c9 	ble.w	41306a <__kernel_rem_pio2f+0x2e2>
  412ed8:	f10b 3eff 	add.w	lr, fp, #4294967295
  412edc:	f1c6 0208 	rsb	r2, r6, #8
  412ee0:	f855 102e 	ldr.w	r1, [r5, lr, lsl #2]
  412ee4:	fa41 f002 	asr.w	r0, r1, r2
  412ee8:	fa00 f202 	lsl.w	r2, r0, r2
  412eec:	1a89      	subs	r1, r1, r2
  412eee:	f845 102e 	str.w	r1, [r5, lr, lsl #2]
  412ef2:	ee19 ea90 	vmov	lr, s19
  412ef6:	4486      	add	lr, r0
  412ef8:	f1c6 0207 	rsb	r2, r6, #7
  412efc:	ee09 ea90 	vmov	s19, lr
  412f00:	4111      	asrs	r1, r2
  412f02:	2900      	cmp	r1, #0
  412f04:	dd51      	ble.n	412faa <__kernel_rem_pio2f+0x222>
  412f06:	ee19 2a90 	vmov	r2, s19
  412f0a:	f1bb 0f00 	cmp.w	fp, #0
  412f0e:	f102 0201 	add.w	r2, r2, #1
  412f12:	ee09 2a90 	vmov	s19, r2
  412f16:	f340 8212 	ble.w	41333e <__kernel_rem_pio2f+0x5b6>
  412f1a:	682a      	ldr	r2, [r5, #0]
  412f1c:	2a00      	cmp	r2, #0
  412f1e:	f040 8269 	bne.w	4133f4 <__kernel_rem_pio2f+0x66c>
  412f22:	f1bb 0f01 	cmp.w	fp, #1
  412f26:	f340 8229 	ble.w	41337c <__kernel_rem_pio2f+0x5f4>
  412f2a:	46ae      	mov	lr, r5
  412f2c:	2001      	movs	r0, #1
  412f2e:	f85e 2f04 	ldr.w	r2, [lr, #4]!
  412f32:	2a00      	cmp	r2, #0
  412f34:	f000 821e 	beq.w	413374 <__kernel_rem_pio2f+0x5ec>
  412f38:	f100 0e01 	add.w	lr, r0, #1
  412f3c:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
  412f40:	45f3      	cmp	fp, lr
  412f42:	f845 2020 	str.w	r2, [r5, r0, lsl #2]
  412f46:	dd12      	ble.n	412f6e <__kernel_rem_pio2f+0x1e6>
  412f48:	f855 202e 	ldr.w	r2, [r5, lr, lsl #2]
  412f4c:	3002      	adds	r0, #2
  412f4e:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
  412f52:	4583      	cmp	fp, r0
  412f54:	f845 202e 	str.w	r2, [r5, lr, lsl #2]
  412f58:	dd09      	ble.n	412f6e <__kernel_rem_pio2f+0x1e6>
  412f5a:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  412f5e:	18ea      	adds	r2, r5, r3
  412f60:	6803      	ldr	r3, [r0, #0]
  412f62:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
  412f66:	f840 3b04 	str.w	r3, [r0], #4
  412f6a:	4290      	cmp	r0, r2
  412f6c:	d1f8      	bne.n	412f60 <__kernel_rem_pio2f+0x1d8>
  412f6e:	2e00      	cmp	r6, #0
  412f70:	dd0d      	ble.n	412f8e <__kernel_rem_pio2f+0x206>
  412f72:	2e01      	cmp	r6, #1
  412f74:	f04f 0201 	mov.w	r2, #1
  412f78:	f040 81e7 	bne.w	41334a <__kernel_rem_pio2f+0x5c2>
  412f7c:	f10b 30ff 	add.w	r0, fp, #4294967295
  412f80:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
  412f84:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  412f88:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
  412f8c:	e1e7      	b.n	41335e <__kernel_rem_pio2f+0x5d6>
  412f8e:	2902      	cmp	r1, #2
  412f90:	d10b      	bne.n	412faa <__kernel_rem_pio2f+0x222>
  412f92:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  412f96:	ee37 9ac9 	vsub.f32	s18, s15, s18
  412f9a:	4630      	mov	r0, r6
  412f9c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  412fa0:	f000 fad4 	bl	41354c <scalbnf>
  412fa4:	ee39 9a40 	vsub.f32	s18, s18, s0
  412fa8:	2102      	movs	r1, #2
  412faa:	eeb5 9a40 	vcmp.f32	s18, #0.0
  412fae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412fb2:	d170      	bne.n	413096 <__kernel_rem_pio2f+0x30e>
  412fb4:	9b03      	ldr	r3, [sp, #12]
  412fb6:	f10b 3eff 	add.w	lr, fp, #4294967295
  412fba:	4573      	cmp	r3, lr
  412fbc:	dc0e      	bgt.n	412fdc <__kernel_rem_pio2f+0x254>
  412fbe:	f10b 4280 	add.w	r2, fp, #1073741824	; 0x40000000
  412fc2:	3a01      	subs	r2, #1
  412fc4:	eb05 0282 	add.w	r2, r5, r2, lsl #2
  412fc8:	2000      	movs	r0, #0
  412fca:	f852 3904 	ldr.w	r3, [r2], #-4
  412fce:	4542      	cmp	r2, r8
  412fd0:	ea40 0003 	orr.w	r0, r0, r3
  412fd4:	d1f9      	bne.n	412fca <__kernel_rem_pio2f+0x242>
  412fd6:	2800      	cmp	r0, #0
  412fd8:	f040 8094 	bne.w	413104 <__kernel_rem_pio2f+0x37c>
  412fdc:	9b03      	ldr	r3, [sp, #12]
  412fde:	3b01      	subs	r3, #1
  412fe0:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
  412fe4:	2b00      	cmp	r3, #0
  412fe6:	f040 81d3 	bne.w	413390 <__kernel_rem_pio2f+0x608>
  412fea:	9b07      	ldr	r3, [sp, #28]
  412fec:	f04f 0c01 	mov.w	ip, #1
  412ff0:	f853 2904 	ldr.w	r2, [r3], #-4
  412ff4:	f10c 0c01 	add.w	ip, ip, #1
  412ff8:	2a00      	cmp	r2, #0
  412ffa:	d0f9      	beq.n	412ff0 <__kernel_rem_pio2f+0x268>
  412ffc:	44dc      	add	ip, fp
  412ffe:	f10b 0e01 	add.w	lr, fp, #1
  413002:	45e6      	cmp	lr, ip
  413004:	dc2f      	bgt.n	413066 <__kernel_rem_pio2f+0x2de>
  413006:	9a06      	ldr	r2, [sp, #24]
  413008:	9b04      	ldr	r3, [sp, #16]
  41300a:	eb0e 0102 	add.w	r1, lr, r2
  41300e:	eb03 000b 	add.w	r0, r3, fp
  413012:	eb0c 0302 	add.w	r3, ip, r2
  413016:	aa1c      	add	r2, sp, #112	; 0x70
  413018:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
  41301c:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  413020:	9a67      	ldr	r2, [sp, #412]	; 0x19c
  413022:	3901      	subs	r1, #1
  413024:	eb02 0181 	add.w	r1, r2, r1, lsl #2
  413028:	eb07 0e8e 	add.w	lr, r7, lr, lsl #2
  41302c:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
  413030:	f851 3f04 	ldr.w	r3, [r1, #4]!
  413034:	ee07 3a90 	vmov	s15, r3
  413038:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  41303c:	f1ba 0f00 	cmp.w	sl, #0
  413040:	ece0 7a01 	vstmia	r0!, {s15}
  413044:	eddf 7a2b 	vldr	s15, [pc, #172]	; 4130f4 <__kernel_rem_pio2f+0x36c>
  413048:	db09      	blt.n	41305e <__kernel_rem_pio2f+0x2d6>
  41304a:	464b      	mov	r3, r9
  41304c:	4602      	mov	r2, r0
  41304e:	ecf3 6a01 	vldmia	r3!, {s13}
  413052:	ed32 7a01 	vldmdb	r2!, {s14}
  413056:	42a3      	cmp	r3, r4
  413058:	eee6 7a87 	vfma.f32	s15, s13, s14
  41305c:	d1f7      	bne.n	41304e <__kernel_rem_pio2f+0x2c6>
  41305e:	4559      	cmp	r1, fp
  413060:	ecee 7a01 	vstmia	lr!, {s15}
  413064:	d1e4      	bne.n	413030 <__kernel_rem_pio2f+0x2a8>
  413066:	46e3      	mov	fp, ip
  413068:	e6fa      	b.n	412e60 <__kernel_rem_pio2f+0xd8>
  41306a:	d105      	bne.n	413078 <__kernel_rem_pio2f+0x2f0>
  41306c:	f10b 32ff 	add.w	r2, fp, #4294967295
  413070:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
  413074:	1209      	asrs	r1, r1, #8
  413076:	e744      	b.n	412f02 <__kernel_rem_pio2f+0x17a>
  413078:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  41307c:	eeb4 9ae7 	vcmpe.f32	s18, s15
  413080:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  413084:	f280 8146 	bge.w	413314 <__kernel_rem_pio2f+0x58c>
  413088:	eeb5 9a40 	vcmp.f32	s18, #0.0
  41308c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  413090:	f04f 0100 	mov.w	r1, #0
  413094:	d08e      	beq.n	412fb4 <__kernel_rem_pio2f+0x22c>
  413096:	9c01      	ldr	r4, [sp, #4]
  413098:	9e03      	ldr	r6, [sp, #12]
  41309a:	eeb0 0a49 	vmov.f32	s0, s18
  41309e:	4260      	negs	r0, r4
  4130a0:	4688      	mov	r8, r1
  4130a2:	f000 fa53 	bl	41354c <scalbnf>
  4130a6:	ed9f 7a14 	vldr	s14, [pc, #80]	; 4130f8 <__kernel_rem_pio2f+0x370>
  4130aa:	eeb4 0ac7 	vcmpe.f32	s0, s14
  4130ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4130b2:	f2c0 8185 	blt.w	4133c0 <__kernel_rem_pio2f+0x638>
  4130b6:	eddf 7a11 	vldr	s15, [pc, #68]	; 4130fc <__kernel_rem_pio2f+0x374>
  4130ba:	ee60 7a27 	vmul.f32	s15, s0, s15
  4130be:	4623      	mov	r3, r4
  4130c0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  4130c4:	3308      	adds	r3, #8
  4130c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  4130ca:	9301      	str	r3, [sp, #4]
  4130cc:	eea7 0ac7 	vfms.f32	s0, s15, s14
  4130d0:	f10b 0301 	add.w	r3, fp, #1
  4130d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  4130d8:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  4130dc:	ee10 2a10 	vmov	r2, s0
  4130e0:	f845 202b 	str.w	r2, [r5, fp, lsl #2]
  4130e4:	ee17 2a90 	vmov	r2, s15
  4130e8:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
  4130ec:	e01f      	b.n	41312e <__kernel_rem_pio2f+0x3a6>
  4130ee:	bf00      	nop
  4130f0:	0041d7f4 	.word	0x0041d7f4
  4130f4:	00000000 	.word	0x00000000
  4130f8:	43800000 	.word	0x43800000
  4130fc:	3b800000 	.word	0x3b800000
  413100:	3fc90000 	.word	0x3fc90000
  413104:	4688      	mov	r8, r1
  413106:	9901      	ldr	r1, [sp, #4]
  413108:	f855 202e 	ldr.w	r2, [r5, lr, lsl #2]
  41310c:	9e03      	ldr	r6, [sp, #12]
  41310e:	3908      	subs	r1, #8
  413110:	4673      	mov	r3, lr
  413112:	9101      	str	r1, [sp, #4]
  413114:	b95a      	cbnz	r2, 41312e <__kernel_rem_pio2f+0x3a6>
  413116:	f10e 4280 	add.w	r2, lr, #1073741824	; 0x40000000
  41311a:	3a01      	subs	r2, #1
  41311c:	eb05 0282 	add.w	r2, r5, r2, lsl #2
  413120:	f852 0904 	ldr.w	r0, [r2], #-4
  413124:	3b01      	subs	r3, #1
  413126:	3908      	subs	r1, #8
  413128:	2800      	cmp	r0, #0
  41312a:	d0f9      	beq.n	413120 <__kernel_rem_pio2f+0x398>
  41312c:	9101      	str	r1, [sp, #4]
  41312e:	9801      	ldr	r0, [sp, #4]
  413130:	9303      	str	r3, [sp, #12]
  413132:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  413136:	f000 fa09 	bl	41354c <scalbnf>
  41313a:	9b03      	ldr	r3, [sp, #12]
  41313c:	2b00      	cmp	r3, #0
  41313e:	f2c0 814a 	blt.w	4133d6 <__kernel_rem_pio2f+0x64e>
  413142:	009f      	lsls	r7, r3, #2
  413144:	aa44      	add	r2, sp, #272	; 0x110
  413146:	19d0      	adds	r0, r2, r7
  413148:	f107 0e04 	add.w	lr, r7, #4
  41314c:	ed1f 7a15 	vldr	s14, [pc, #-84]	; 4130fc <__kernel_rem_pio2f+0x374>
  413150:	eb05 020e 	add.w	r2, r5, lr
  413154:	1d01      	adds	r1, r0, #4
  413156:	ed72 7a01 	vldmdb	r2!, {s15}
  41315a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  41315e:	42aa      	cmp	r2, r5
  413160:	ee67 7a80 	vmul.f32	s15, s15, s0
  413164:	ee20 0a07 	vmul.f32	s0, s0, s14
  413168:	ed61 7a01 	vstmdb	r1!, {s15}
  41316c:	d1f3      	bne.n	413156 <__kernel_rem_pio2f+0x3ce>
  41316e:	ed1f 6a1c 	vldr	s12, [pc, #-112]	; 413100 <__kernel_rem_pio2f+0x378>
  413172:	4605      	mov	r5, r0
  413174:	f50d 7c86 	add.w	ip, sp, #268	; 0x10c
  413178:	2400      	movs	r4, #0
  41317a:	2e00      	cmp	r6, #0
  41317c:	f2c0 80dc 	blt.w	413338 <__kernel_rem_pio2f+0x5b0>
  413180:	48a3      	ldr	r0, [pc, #652]	; (413410 <__kernel_rem_pio2f+0x688>)
  413182:	eddf 7aa4 	vldr	s15, [pc, #656]	; 413414 <__kernel_rem_pio2f+0x68c>
  413186:	4629      	mov	r1, r5
  413188:	eeb0 7a46 	vmov.f32	s14, s12
  41318c:	2200      	movs	r2, #0
  41318e:	e003      	b.n	413198 <__kernel_rem_pio2f+0x410>
  413190:	42a2      	cmp	r2, r4
  413192:	dc08      	bgt.n	4131a6 <__kernel_rem_pio2f+0x41e>
  413194:	ecb0 7a01 	vldmia	r0!, {s14}
  413198:	ecf1 6a01 	vldmia	r1!, {s13}
  41319c:	3201      	adds	r2, #1
  41319e:	4296      	cmp	r6, r2
  4131a0:	eee7 7a26 	vfma.f32	s15, s14, s13
  4131a4:	daf4      	bge.n	413190 <__kernel_rem_pio2f+0x408>
  4131a6:	3d04      	subs	r5, #4
  4131a8:	aa58      	add	r2, sp, #352	; 0x160
  4131aa:	eb02 0284 	add.w	r2, r2, r4, lsl #2
  4131ae:	4565      	cmp	r5, ip
  4131b0:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
  4131b4:	f104 0401 	add.w	r4, r4, #1
  4131b8:	d1df      	bne.n	41317a <__kernel_rem_pio2f+0x3f2>
  4131ba:	9a66      	ldr	r2, [sp, #408]	; 0x198
  4131bc:	2a03      	cmp	r2, #3
  4131be:	d85a      	bhi.n	413276 <__kernel_rem_pio2f+0x4ee>
  4131c0:	e8df f002 	tbb	[pc, r2]
  4131c4:	0262628c 	.word	0x0262628c
  4131c8:	2b00      	cmp	r3, #0
  4131ca:	f340 8101 	ble.w	4133d0 <__kernel_rem_pio2f+0x648>
  4131ce:	aa58      	add	r2, sp, #352	; 0x160
  4131d0:	443a      	add	r2, r7
  4131d2:	a930      	add	r1, sp, #192	; 0xc0
  4131d4:	ed12 7a28 	vldr	s14, [r2, #-160]	; 0xffffff60
  4131d8:	1d3a      	adds	r2, r7, #4
  4131da:	440a      	add	r2, r1
  4131dc:	a831      	add	r0, sp, #196	; 0xc4
  4131de:	4439      	add	r1, r7
  4131e0:	ed51 7a01 	vldr	s15, [r1, #-4]
  4131e4:	ee77 6a87 	vadd.f32	s13, s15, s14
  4131e8:	ee77 7ae6 	vsub.f32	s15, s15, s13
  4131ec:	ee77 7a87 	vadd.f32	s15, s15, s14
  4131f0:	eeb0 7a66 	vmov.f32	s14, s13
  4131f4:	ed62 7a01 	vstmdb	r2!, {s15}
  4131f8:	4282      	cmp	r2, r0
  4131fa:	ed61 6a01 	vstmdb	r1!, {s13}
  4131fe:	d1ef      	bne.n	4131e0 <__kernel_rem_pio2f+0x458>
  413200:	2b01      	cmp	r3, #1
  413202:	f340 80e5 	ble.w	4133d0 <__kernel_rem_pio2f+0x648>
  413206:	ab58      	add	r3, sp, #352	; 0x160
  413208:	443b      	add	r3, r7
  41320a:	aa30      	add	r2, sp, #192	; 0xc0
  41320c:	ed13 7a28 	vldr	s14, [r3, #-160]	; 0xffffff60
  413210:	1d3b      	adds	r3, r7, #4
  413212:	a932      	add	r1, sp, #200	; 0xc8
  413214:	4417      	add	r7, r2
  413216:	441a      	add	r2, r3
  413218:	ed57 7a01 	vldr	s15, [r7, #-4]
  41321c:	ee77 6a87 	vadd.f32	s13, s15, s14
  413220:	ee77 7ae6 	vsub.f32	s15, s15, s13
  413224:	ee77 7a87 	vadd.f32	s15, s15, s14
  413228:	eeb0 7a66 	vmov.f32	s14, s13
  41322c:	ed62 7a01 	vstmdb	r2!, {s15}
  413230:	4291      	cmp	r1, r2
  413232:	ed67 6a01 	vstmdb	r7!, {s13}
  413236:	d1ef      	bne.n	413218 <__kernel_rem_pio2f+0x490>
  413238:	a930      	add	r1, sp, #192	; 0xc0
  41323a:	eddf 7a76 	vldr	s15, [pc, #472]	; 413414 <__kernel_rem_pio2f+0x68c>
  41323e:	440b      	add	r3, r1
  413240:	ed33 7a01 	vldmdb	r3!, {s14}
  413244:	429a      	cmp	r2, r3
  413246:	ee77 7a87 	vadd.f32	s15, s15, s14
  41324a:	d1f9      	bne.n	413240 <__kernel_rem_pio2f+0x4b8>
  41324c:	4643      	mov	r3, r8
  41324e:	2b00      	cmp	r3, #0
  413250:	f000 80ae 	beq.w	4133b0 <__kernel_rem_pio2f+0x628>
  413254:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
  413258:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
  41325c:	9a02      	ldr	r2, [sp, #8]
  41325e:	eef1 7a67 	vneg.f32	s15, s15
  413262:	eef1 6a66 	vneg.f32	s13, s13
  413266:	eeb1 7a47 	vneg.f32	s14, s14
  41326a:	edc2 7a02 	vstr	s15, [r2, #8]
  41326e:	edc2 6a00 	vstr	s13, [r2]
  413272:	ed82 7a01 	vstr	s14, [r2, #4]
  413276:	ee19 3a90 	vmov	r3, s19
  41327a:	f003 0007 	and.w	r0, r3, #7
  41327e:	b059      	add	sp, #356	; 0x164
  413280:	ecbd 8b04 	vpop	{d8-d9}
  413284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413288:	1d3a      	adds	r2, r7, #4
  41328a:	a930      	add	r1, sp, #192	; 0xc0
  41328c:	eddf 7a61 	vldr	s15, [pc, #388]	; 413414 <__kernel_rem_pio2f+0x68c>
  413290:	440a      	add	r2, r1
  413292:	ed32 7a01 	vldmdb	r2!, {s14}
  413296:	428a      	cmp	r2, r1
  413298:	ee77 7a87 	vadd.f32	s15, s15, s14
  41329c:	d1f9      	bne.n	413292 <__kernel_rem_pio2f+0x50a>
  41329e:	4642      	mov	r2, r8
  4132a0:	2a00      	cmp	r2, #0
  4132a2:	d078      	beq.n	413396 <__kernel_rem_pio2f+0x60e>
  4132a4:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
  4132a8:	9a02      	ldr	r2, [sp, #8]
  4132aa:	eeb1 7a67 	vneg.f32	s14, s15
  4132ae:	2b00      	cmp	r3, #0
  4132b0:	ee76 7ae7 	vsub.f32	s15, s13, s15
  4132b4:	ed82 7a00 	vstr	s14, [r2]
  4132b8:	dd0a      	ble.n	4132d0 <__kernel_rem_pio2f+0x548>
  4132ba:	a931      	add	r1, sp, #196	; 0xc4
  4132bc:	2201      	movs	r2, #1
  4132be:	ecb1 7a01 	vldmia	r1!, {s14}
  4132c2:	3201      	adds	r2, #1
  4132c4:	4293      	cmp	r3, r2
  4132c6:	ee77 7a87 	vadd.f32	s15, s15, s14
  4132ca:	daf8      	bge.n	4132be <__kernel_rem_pio2f+0x536>
  4132cc:	4643      	mov	r3, r8
  4132ce:	b10b      	cbz	r3, 4132d4 <__kernel_rem_pio2f+0x54c>
  4132d0:	eef1 7a67 	vneg.f32	s15, s15
  4132d4:	9b02      	ldr	r3, [sp, #8]
  4132d6:	edc3 7a01 	vstr	s15, [r3, #4]
  4132da:	e7cc      	b.n	413276 <__kernel_rem_pio2f+0x4ee>
  4132dc:	ab30      	add	r3, sp, #192	; 0xc0
  4132de:	eddf 7a4d 	vldr	s15, [pc, #308]	; 413414 <__kernel_rem_pio2f+0x68c>
  4132e2:	449e      	add	lr, r3
  4132e4:	ed3e 7a01 	vldmdb	lr!, {s14}
  4132e8:	4573      	cmp	r3, lr
  4132ea:	ee77 7a87 	vadd.f32	s15, s15, s14
  4132ee:	d1f9      	bne.n	4132e4 <__kernel_rem_pio2f+0x55c>
  4132f0:	4643      	mov	r3, r8
  4132f2:	b10b      	cbz	r3, 4132f8 <__kernel_rem_pio2f+0x570>
  4132f4:	eef1 7a67 	vneg.f32	s15, s15
  4132f8:	9b02      	ldr	r3, [sp, #8]
  4132fa:	edc3 7a00 	vstr	s15, [r3]
  4132fe:	e7ba      	b.n	413276 <__kernel_rem_pio2f+0x4ee>
  413300:	eddf 7a44 	vldr	s15, [pc, #272]	; 413414 <__kernel_rem_pio2f+0x68c>
  413304:	ece5 7a01 	vstmia	r5!, {s15}
  413308:	42bd      	cmp	r5, r7
  41330a:	f100 0004 	add.w	r0, r0, #4
  41330e:	f47f ad7e 	bne.w	412e0e <__kernel_rem_pio2f+0x86>
  413312:	e592      	b.n	412e3a <__kernel_rem_pio2f+0xb2>
  413314:	ee19 2a90 	vmov	r2, s19
  413318:	f1bb 0f00 	cmp.w	fp, #0
  41331c:	f102 0201 	add.w	r2, r2, #1
  413320:	ee09 2a90 	vmov	s19, r2
  413324:	bfc8      	it	gt
  413326:	2102      	movgt	r1, #2
  413328:	f73f adf7 	bgt.w	412f1a <__kernel_rem_pio2f+0x192>
  41332c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  413330:	ee37 9ac9 	vsub.f32	s18, s15, s18
  413334:	2102      	movs	r1, #2
  413336:	e638      	b.n	412faa <__kernel_rem_pio2f+0x222>
  413338:	eddf 7a36 	vldr	s15, [pc, #216]	; 413414 <__kernel_rem_pio2f+0x68c>
  41333c:	e733      	b.n	4131a6 <__kernel_rem_pio2f+0x41e>
  41333e:	2e00      	cmp	r6, #0
  413340:	dd1e      	ble.n	413380 <__kernel_rem_pio2f+0x5f8>
  413342:	2200      	movs	r2, #0
  413344:	2e01      	cmp	r6, #1
  413346:	f43f ae19 	beq.w	412f7c <__kernel_rem_pio2f+0x1f4>
  41334a:	2e02      	cmp	r6, #2
  41334c:	d107      	bne.n	41335e <__kernel_rem_pio2f+0x5d6>
  41334e:	f10b 30ff 	add.w	r0, fp, #4294967295
  413352:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
  413356:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  41335a:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
  41335e:	2902      	cmp	r1, #2
  413360:	f47f ae23 	bne.w	412faa <__kernel_rem_pio2f+0x222>
  413364:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  413368:	ee37 9ac9 	vsub.f32	s18, s15, s18
  41336c:	2a00      	cmp	r2, #0
  41336e:	f43f ae1c 	beq.w	412faa <__kernel_rem_pio2f+0x222>
  413372:	e612      	b.n	412f9a <__kernel_rem_pio2f+0x212>
  413374:	3001      	adds	r0, #1
  413376:	4583      	cmp	fp, r0
  413378:	f47f add9 	bne.w	412f2e <__kernel_rem_pio2f+0x1a6>
  41337c:	2e00      	cmp	r6, #0
  41337e:	dce1      	bgt.n	413344 <__kernel_rem_pio2f+0x5bc>
  413380:	2902      	cmp	r1, #2
  413382:	f47f ae12 	bne.w	412faa <__kernel_rem_pio2f+0x222>
  413386:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  41338a:	ee37 9ac9 	vsub.f32	s18, s15, s18
  41338e:	e60c      	b.n	412faa <__kernel_rem_pio2f+0x222>
  413390:	f04f 0c01 	mov.w	ip, #1
  413394:	e632      	b.n	412ffc <__kernel_rem_pio2f+0x274>
  413396:	ed9d 7a30 	vldr	s14, [sp, #192]	; 0xc0
  41339a:	9a02      	ldr	r2, [sp, #8]
  41339c:	2b00      	cmp	r3, #0
  41339e:	edc2 7a00 	vstr	s15, [r2]
  4133a2:	ee77 7a67 	vsub.f32	s15, s14, s15
  4133a6:	dc88      	bgt.n	4132ba <__kernel_rem_pio2f+0x532>
  4133a8:	9b02      	ldr	r3, [sp, #8]
  4133aa:	edc3 7a01 	vstr	s15, [r3, #4]
  4133ae:	e762      	b.n	413276 <__kernel_rem_pio2f+0x4ee>
  4133b0:	9802      	ldr	r0, [sp, #8]
  4133b2:	9a30      	ldr	r2, [sp, #192]	; 0xc0
  4133b4:	9b31      	ldr	r3, [sp, #196]	; 0xc4
  4133b6:	edc0 7a02 	vstr	s15, [r0, #8]
  4133ba:	6002      	str	r2, [r0, #0]
  4133bc:	6043      	str	r3, [r0, #4]
  4133be:	e75a      	b.n	413276 <__kernel_rem_pio2f+0x4ee>
  4133c0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  4133c4:	465b      	mov	r3, fp
  4133c6:	ee10 2a10 	vmov	r2, s0
  4133ca:	f845 202b 	str.w	r2, [r5, fp, lsl #2]
  4133ce:	e6ae      	b.n	41312e <__kernel_rem_pio2f+0x3a6>
  4133d0:	eddf 7a10 	vldr	s15, [pc, #64]	; 413414 <__kernel_rem_pio2f+0x68c>
  4133d4:	e73a      	b.n	41324c <__kernel_rem_pio2f+0x4c4>
  4133d6:	9a66      	ldr	r2, [sp, #408]	; 0x198
  4133d8:	2a03      	cmp	r2, #3
  4133da:	f63f af4c 	bhi.w	413276 <__kernel_rem_pio2f+0x4ee>
  4133de:	a101      	add	r1, pc, #4	; (adr r1, 4133e4 <__kernel_rem_pio2f+0x65c>)
  4133e0:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
  4133e4:	00413403 	.word	0x00413403
  4133e8:	004133fd 	.word	0x004133fd
  4133ec:	004133fd 	.word	0x004133fd
  4133f0:	004133d1 	.word	0x004133d1
  4133f4:	f04f 0e01 	mov.w	lr, #1
  4133f8:	2000      	movs	r0, #0
  4133fa:	e59f      	b.n	412f3c <__kernel_rem_pio2f+0x1b4>
  4133fc:	eddf 7a05 	vldr	s15, [pc, #20]	; 413414 <__kernel_rem_pio2f+0x68c>
  413400:	e74d      	b.n	41329e <__kernel_rem_pio2f+0x516>
  413402:	eddf 7a04 	vldr	s15, [pc, #16]	; 413414 <__kernel_rem_pio2f+0x68c>
  413406:	e773      	b.n	4132f0 <__kernel_rem_pio2f+0x568>
  413408:	9b04      	ldr	r3, [sp, #16]
  41340a:	009c      	lsls	r4, r3, #2
  41340c:	e515      	b.n	412e3a <__kernel_rem_pio2f+0xb2>
  41340e:	bf00      	nop
  413410:	0041d7cc 	.word	0x0041d7cc
  413414:	00000000 	.word	0x00000000

00413418 <__kernel_sinf>:
  413418:	ee10 3a10 	vmov	r3, s0
  41341c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  413420:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
  413424:	da04      	bge.n	413430 <__kernel_sinf+0x18>
  413426:	eefd 7ac0 	vcvt.s32.f32	s15, s0
  41342a:	ee17 3a90 	vmov	r3, s15
  41342e:	b323      	cbz	r3, 41347a <__kernel_sinf+0x62>
  413430:	ee60 7a00 	vmul.f32	s15, s0, s0
  413434:	ed9f 5a15 	vldr	s10, [pc, #84]	; 41348c <__kernel_sinf+0x74>
  413438:	eddf 5a15 	vldr	s11, [pc, #84]	; 413490 <__kernel_sinf+0x78>
  41343c:	ed9f 6a15 	vldr	s12, [pc, #84]	; 413494 <__kernel_sinf+0x7c>
  413440:	eddf 6a15 	vldr	s13, [pc, #84]	; 413498 <__kernel_sinf+0x80>
  413444:	ed9f 7a15 	vldr	s14, [pc, #84]	; 41349c <__kernel_sinf+0x84>
  413448:	eee7 5a85 	vfma.f32	s11, s15, s10
  41344c:	ee20 5a27 	vmul.f32	s10, s0, s15
  413450:	eea7 6aa5 	vfma.f32	s12, s15, s11
  413454:	eee7 6a86 	vfma.f32	s13, s15, s12
  413458:	eea7 7aa6 	vfma.f32	s14, s15, s13
  41345c:	b170      	cbz	r0, 41347c <__kernel_sinf+0x64>
  41345e:	ee27 7a45 	vnmul.f32	s14, s14, s10
  413462:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
  413466:	eea0 7aa6 	vfma.f32	s14, s1, s13
  41346a:	eddf 6a0d 	vldr	s13, [pc, #52]	; 4134a0 <__kernel_sinf+0x88>
  41346e:	eed7 0a87 	vfnms.f32	s1, s15, s14
  413472:	eee5 0a26 	vfma.f32	s1, s10, s13
  413476:	ee30 0a60 	vsub.f32	s0, s0, s1
  41347a:	4770      	bx	lr
  41347c:	eddf 6a09 	vldr	s13, [pc, #36]	; 4134a4 <__kernel_sinf+0x8c>
  413480:	eee7 6a87 	vfma.f32	s13, s15, s14
  413484:	eea5 0a26 	vfma.f32	s0, s10, s13
  413488:	4770      	bx	lr
  41348a:	bf00      	nop
  41348c:	2f2ec9d3 	.word	0x2f2ec9d3
  413490:	b2d72f34 	.word	0xb2d72f34
  413494:	3638ef1b 	.word	0x3638ef1b
  413498:	b9500d01 	.word	0xb9500d01
  41349c:	3c088889 	.word	0x3c088889
  4134a0:	3e2aaaab 	.word	0x3e2aaaab
  4134a4:	be2aaaab 	.word	0xbe2aaaab

004134a8 <matherr>:
  4134a8:	2000      	movs	r0, #0
  4134aa:	4770      	bx	lr

004134ac <fabsf>:
  4134ac:	ee10 3a10 	vmov	r3, s0
  4134b0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  4134b4:	ee00 3a10 	vmov	s0, r3
  4134b8:	4770      	bx	lr
  4134ba:	bf00      	nop

004134bc <floorf>:
  4134bc:	ee10 2a10 	vmov	r2, s0
  4134c0:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
  4134c4:	0dcb      	lsrs	r3, r1, #23
  4134c6:	3b7f      	subs	r3, #127	; 0x7f
  4134c8:	2b16      	cmp	r3, #22
  4134ca:	dc17      	bgt.n	4134fc <floorf+0x40>
  4134cc:	2b00      	cmp	r3, #0
  4134ce:	ee10 0a10 	vmov	r0, s0
  4134d2:	db19      	blt.n	413508 <floorf+0x4c>
  4134d4:	491a      	ldr	r1, [pc, #104]	; (413540 <floorf+0x84>)
  4134d6:	4119      	asrs	r1, r3
  4134d8:	420a      	tst	r2, r1
  4134da:	d022      	beq.n	413522 <floorf+0x66>
  4134dc:	eddf 7a19 	vldr	s15, [pc, #100]	; 413544 <floorf+0x88>
  4134e0:	ee70 7a27 	vadd.f32	s15, s0, s15
  4134e4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4134e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4134ec:	dd19      	ble.n	413522 <floorf+0x66>
  4134ee:	2a00      	cmp	r2, #0
  4134f0:	db18      	blt.n	413524 <floorf+0x68>
  4134f2:	ea20 0301 	bic.w	r3, r0, r1
  4134f6:	ee00 3a10 	vmov	s0, r3
  4134fa:	4770      	bx	lr
  4134fc:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
  413500:	d30f      	bcc.n	413522 <floorf+0x66>
  413502:	ee30 0a00 	vadd.f32	s0, s0, s0
  413506:	4770      	bx	lr
  413508:	eddf 7a0e 	vldr	s15, [pc, #56]	; 413544 <floorf+0x88>
  41350c:	ee70 7a27 	vadd.f32	s15, s0, s15
  413510:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  413514:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  413518:	dd03      	ble.n	413522 <floorf+0x66>
  41351a:	2a00      	cmp	r2, #0
  41351c:	db08      	blt.n	413530 <floorf+0x74>
  41351e:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 413548 <floorf+0x8c>
  413522:	4770      	bx	lr
  413524:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  413528:	fa42 f303 	asr.w	r3, r2, r3
  41352c:	4418      	add	r0, r3
  41352e:	e7e0      	b.n	4134f2 <floorf+0x36>
  413530:	2900      	cmp	r1, #0
  413532:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
  413536:	bf18      	it	ne
  413538:	eeb0 0a67 	vmovne.f32	s0, s15
  41353c:	4770      	bx	lr
  41353e:	bf00      	nop
  413540:	007fffff 	.word	0x007fffff
  413544:	7149f2ca 	.word	0x7149f2ca
  413548:	00000000 	.word	0x00000000

0041354c <scalbnf>:
  41354c:	b508      	push	{r3, lr}
  41354e:	ee10 3a10 	vmov	r3, s0
  413552:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
  413556:	ed2d 8b02 	vpush	{d8}
  41355a:	d011      	beq.n	413580 <scalbnf+0x34>
  41355c:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
  413560:	d211      	bcs.n	413586 <scalbnf+0x3a>
  413562:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
  413566:	d313      	bcc.n	413590 <scalbnf+0x44>
  413568:	0dd2      	lsrs	r2, r2, #23
  41356a:	4402      	add	r2, r0
  41356c:	2afe      	cmp	r2, #254	; 0xfe
  41356e:	dc2e      	bgt.n	4135ce <scalbnf+0x82>
  413570:	2a00      	cmp	r2, #0
  413572:	dd1a      	ble.n	4135aa <scalbnf+0x5e>
  413574:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
  413578:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
  41357c:	ee00 3a10 	vmov	s0, r3
  413580:	ecbd 8b02 	vpop	{d8}
  413584:	bd08      	pop	{r3, pc}
  413586:	ecbd 8b02 	vpop	{d8}
  41358a:	ee30 0a00 	vadd.f32	s0, s0, s0
  41358e:	bd08      	pop	{r3, pc}
  413590:	4b1d      	ldr	r3, [pc, #116]	; (413608 <scalbnf+0xbc>)
  413592:	eddf 7a1e 	vldr	s15, [pc, #120]	; 41360c <scalbnf+0xc0>
  413596:	4298      	cmp	r0, r3
  413598:	ee20 0a27 	vmul.f32	s0, s0, s15
  41359c:	db22      	blt.n	4135e4 <scalbnf+0x98>
  41359e:	ee10 3a10 	vmov	r3, s0
  4135a2:	f3c3 52c7 	ubfx	r2, r3, #23, #8
  4135a6:	3a19      	subs	r2, #25
  4135a8:	e7df      	b.n	41356a <scalbnf+0x1e>
  4135aa:	f112 0f16 	cmn.w	r2, #22
  4135ae:	da1e      	bge.n	4135ee <scalbnf+0xa2>
  4135b0:	f24c 3350 	movw	r3, #50000	; 0xc350
  4135b4:	4298      	cmp	r0, r3
  4135b6:	dc0a      	bgt.n	4135ce <scalbnf+0x82>
  4135b8:	ed9f 8a15 	vldr	s16, [pc, #84]	; 413610 <scalbnf+0xc4>
  4135bc:	eef0 0a40 	vmov.f32	s1, s0
  4135c0:	eeb0 0a48 	vmov.f32	s0, s16
  4135c4:	f000 f82a 	bl	41361c <copysignf>
  4135c8:	ee20 0a08 	vmul.f32	s0, s0, s16
  4135cc:	e7d8      	b.n	413580 <scalbnf+0x34>
  4135ce:	ed9f 8a11 	vldr	s16, [pc, #68]	; 413614 <scalbnf+0xc8>
  4135d2:	eef0 0a40 	vmov.f32	s1, s0
  4135d6:	eeb0 0a48 	vmov.f32	s0, s16
  4135da:	f000 f81f 	bl	41361c <copysignf>
  4135de:	ee20 0a08 	vmul.f32	s0, s0, s16
  4135e2:	e7cd      	b.n	413580 <scalbnf+0x34>
  4135e4:	eddf 0a0a 	vldr	s1, [pc, #40]	; 413610 <scalbnf+0xc4>
  4135e8:	ee20 0a20 	vmul.f32	s0, s0, s1
  4135ec:	e7c8      	b.n	413580 <scalbnf+0x34>
  4135ee:	3219      	adds	r2, #25
  4135f0:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
  4135f4:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
  4135f8:	eddf 7a07 	vldr	s15, [pc, #28]	; 413618 <scalbnf+0xcc>
  4135fc:	ee00 3a10 	vmov	s0, r3
  413600:	ee20 0a27 	vmul.f32	s0, s0, s15
  413604:	e7bc      	b.n	413580 <scalbnf+0x34>
  413606:	bf00      	nop
  413608:	ffff3cb0 	.word	0xffff3cb0
  41360c:	4c000000 	.word	0x4c000000
  413610:	0da24260 	.word	0x0da24260
  413614:	7149f2ca 	.word	0x7149f2ca
  413618:	33000000 	.word	0x33000000

0041361c <copysignf>:
  41361c:	ee10 3a10 	vmov	r3, s0
  413620:	ee10 2a90 	vmov	r2, s1
  413624:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  413628:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
  41362c:	4313      	orrs	r3, r2
  41362e:	ee00 3a10 	vmov	s0, r3
  413632:	4770      	bx	lr

00413634 <__aeabi_drsub>:
  413634:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  413638:	e002      	b.n	413640 <__adddf3>
  41363a:	bf00      	nop

0041363c <__aeabi_dsub>:
  41363c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00413640 <__adddf3>:
  413640:	b530      	push	{r4, r5, lr}
  413642:	ea4f 0441 	mov.w	r4, r1, lsl #1
  413646:	ea4f 0543 	mov.w	r5, r3, lsl #1
  41364a:	ea94 0f05 	teq	r4, r5
  41364e:	bf08      	it	eq
  413650:	ea90 0f02 	teqeq	r0, r2
  413654:	bf1f      	itttt	ne
  413656:	ea54 0c00 	orrsne.w	ip, r4, r0
  41365a:	ea55 0c02 	orrsne.w	ip, r5, r2
  41365e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  413662:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  413666:	f000 80e2 	beq.w	41382e <__adddf3+0x1ee>
  41366a:	ea4f 5454 	mov.w	r4, r4, lsr #21
  41366e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  413672:	bfb8      	it	lt
  413674:	426d      	neglt	r5, r5
  413676:	dd0c      	ble.n	413692 <__adddf3+0x52>
  413678:	442c      	add	r4, r5
  41367a:	ea80 0202 	eor.w	r2, r0, r2
  41367e:	ea81 0303 	eor.w	r3, r1, r3
  413682:	ea82 0000 	eor.w	r0, r2, r0
  413686:	ea83 0101 	eor.w	r1, r3, r1
  41368a:	ea80 0202 	eor.w	r2, r0, r2
  41368e:	ea81 0303 	eor.w	r3, r1, r3
  413692:	2d36      	cmp	r5, #54	; 0x36
  413694:	bf88      	it	hi
  413696:	bd30      	pophi	{r4, r5, pc}
  413698:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  41369c:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4136a0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  4136a4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  4136a8:	d002      	beq.n	4136b0 <__adddf3+0x70>
  4136aa:	4240      	negs	r0, r0
  4136ac:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4136b0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  4136b4:	ea4f 3303 	mov.w	r3, r3, lsl #12
  4136b8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  4136bc:	d002      	beq.n	4136c4 <__adddf3+0x84>
  4136be:	4252      	negs	r2, r2
  4136c0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4136c4:	ea94 0f05 	teq	r4, r5
  4136c8:	f000 80a7 	beq.w	41381a <__adddf3+0x1da>
  4136cc:	f1a4 0401 	sub.w	r4, r4, #1
  4136d0:	f1d5 0e20 	rsbs	lr, r5, #32
  4136d4:	db0d      	blt.n	4136f2 <__adddf3+0xb2>
  4136d6:	fa02 fc0e 	lsl.w	ip, r2, lr
  4136da:	fa22 f205 	lsr.w	r2, r2, r5
  4136de:	1880      	adds	r0, r0, r2
  4136e0:	f141 0100 	adc.w	r1, r1, #0
  4136e4:	fa03 f20e 	lsl.w	r2, r3, lr
  4136e8:	1880      	adds	r0, r0, r2
  4136ea:	fa43 f305 	asr.w	r3, r3, r5
  4136ee:	4159      	adcs	r1, r3
  4136f0:	e00e      	b.n	413710 <__adddf3+0xd0>
  4136f2:	f1a5 0520 	sub.w	r5, r5, #32
  4136f6:	f10e 0e20 	add.w	lr, lr, #32
  4136fa:	2a01      	cmp	r2, #1
  4136fc:	fa03 fc0e 	lsl.w	ip, r3, lr
  413700:	bf28      	it	cs
  413702:	f04c 0c02 	orrcs.w	ip, ip, #2
  413706:	fa43 f305 	asr.w	r3, r3, r5
  41370a:	18c0      	adds	r0, r0, r3
  41370c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  413710:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  413714:	d507      	bpl.n	413726 <__adddf3+0xe6>
  413716:	f04f 0e00 	mov.w	lr, #0
  41371a:	f1dc 0c00 	rsbs	ip, ip, #0
  41371e:	eb7e 0000 	sbcs.w	r0, lr, r0
  413722:	eb6e 0101 	sbc.w	r1, lr, r1
  413726:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  41372a:	d31b      	bcc.n	413764 <__adddf3+0x124>
  41372c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  413730:	d30c      	bcc.n	41374c <__adddf3+0x10c>
  413732:	0849      	lsrs	r1, r1, #1
  413734:	ea5f 0030 	movs.w	r0, r0, rrx
  413738:	ea4f 0c3c 	mov.w	ip, ip, rrx
  41373c:	f104 0401 	add.w	r4, r4, #1
  413740:	ea4f 5244 	mov.w	r2, r4, lsl #21
  413744:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  413748:	f080 809a 	bcs.w	413880 <__adddf3+0x240>
  41374c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  413750:	bf08      	it	eq
  413752:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  413756:	f150 0000 	adcs.w	r0, r0, #0
  41375a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  41375e:	ea41 0105 	orr.w	r1, r1, r5
  413762:	bd30      	pop	{r4, r5, pc}
  413764:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  413768:	4140      	adcs	r0, r0
  41376a:	eb41 0101 	adc.w	r1, r1, r1
  41376e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413772:	f1a4 0401 	sub.w	r4, r4, #1
  413776:	d1e9      	bne.n	41374c <__adddf3+0x10c>
  413778:	f091 0f00 	teq	r1, #0
  41377c:	bf04      	itt	eq
  41377e:	4601      	moveq	r1, r0
  413780:	2000      	moveq	r0, #0
  413782:	fab1 f381 	clz	r3, r1
  413786:	bf08      	it	eq
  413788:	3320      	addeq	r3, #32
  41378a:	f1a3 030b 	sub.w	r3, r3, #11
  41378e:	f1b3 0220 	subs.w	r2, r3, #32
  413792:	da0c      	bge.n	4137ae <__adddf3+0x16e>
  413794:	320c      	adds	r2, #12
  413796:	dd08      	ble.n	4137aa <__adddf3+0x16a>
  413798:	f102 0c14 	add.w	ip, r2, #20
  41379c:	f1c2 020c 	rsb	r2, r2, #12
  4137a0:	fa01 f00c 	lsl.w	r0, r1, ip
  4137a4:	fa21 f102 	lsr.w	r1, r1, r2
  4137a8:	e00c      	b.n	4137c4 <__adddf3+0x184>
  4137aa:	f102 0214 	add.w	r2, r2, #20
  4137ae:	bfd8      	it	le
  4137b0:	f1c2 0c20 	rsble	ip, r2, #32
  4137b4:	fa01 f102 	lsl.w	r1, r1, r2
  4137b8:	fa20 fc0c 	lsr.w	ip, r0, ip
  4137bc:	bfdc      	itt	le
  4137be:	ea41 010c 	orrle.w	r1, r1, ip
  4137c2:	4090      	lslle	r0, r2
  4137c4:	1ae4      	subs	r4, r4, r3
  4137c6:	bfa2      	ittt	ge
  4137c8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  4137cc:	4329      	orrge	r1, r5
  4137ce:	bd30      	popge	{r4, r5, pc}
  4137d0:	ea6f 0404 	mvn.w	r4, r4
  4137d4:	3c1f      	subs	r4, #31
  4137d6:	da1c      	bge.n	413812 <__adddf3+0x1d2>
  4137d8:	340c      	adds	r4, #12
  4137da:	dc0e      	bgt.n	4137fa <__adddf3+0x1ba>
  4137dc:	f104 0414 	add.w	r4, r4, #20
  4137e0:	f1c4 0220 	rsb	r2, r4, #32
  4137e4:	fa20 f004 	lsr.w	r0, r0, r4
  4137e8:	fa01 f302 	lsl.w	r3, r1, r2
  4137ec:	ea40 0003 	orr.w	r0, r0, r3
  4137f0:	fa21 f304 	lsr.w	r3, r1, r4
  4137f4:	ea45 0103 	orr.w	r1, r5, r3
  4137f8:	bd30      	pop	{r4, r5, pc}
  4137fa:	f1c4 040c 	rsb	r4, r4, #12
  4137fe:	f1c4 0220 	rsb	r2, r4, #32
  413802:	fa20 f002 	lsr.w	r0, r0, r2
  413806:	fa01 f304 	lsl.w	r3, r1, r4
  41380a:	ea40 0003 	orr.w	r0, r0, r3
  41380e:	4629      	mov	r1, r5
  413810:	bd30      	pop	{r4, r5, pc}
  413812:	fa21 f004 	lsr.w	r0, r1, r4
  413816:	4629      	mov	r1, r5
  413818:	bd30      	pop	{r4, r5, pc}
  41381a:	f094 0f00 	teq	r4, #0
  41381e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  413822:	bf06      	itte	eq
  413824:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  413828:	3401      	addeq	r4, #1
  41382a:	3d01      	subne	r5, #1
  41382c:	e74e      	b.n	4136cc <__adddf3+0x8c>
  41382e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  413832:	bf18      	it	ne
  413834:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  413838:	d029      	beq.n	41388e <__adddf3+0x24e>
  41383a:	ea94 0f05 	teq	r4, r5
  41383e:	bf08      	it	eq
  413840:	ea90 0f02 	teqeq	r0, r2
  413844:	d005      	beq.n	413852 <__adddf3+0x212>
  413846:	ea54 0c00 	orrs.w	ip, r4, r0
  41384a:	bf04      	itt	eq
  41384c:	4619      	moveq	r1, r3
  41384e:	4610      	moveq	r0, r2
  413850:	bd30      	pop	{r4, r5, pc}
  413852:	ea91 0f03 	teq	r1, r3
  413856:	bf1e      	ittt	ne
  413858:	2100      	movne	r1, #0
  41385a:	2000      	movne	r0, #0
  41385c:	bd30      	popne	{r4, r5, pc}
  41385e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  413862:	d105      	bne.n	413870 <__adddf3+0x230>
  413864:	0040      	lsls	r0, r0, #1
  413866:	4149      	adcs	r1, r1
  413868:	bf28      	it	cs
  41386a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  41386e:	bd30      	pop	{r4, r5, pc}
  413870:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  413874:	bf3c      	itt	cc
  413876:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  41387a:	bd30      	popcc	{r4, r5, pc}
  41387c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  413880:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  413884:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  413888:	f04f 0000 	mov.w	r0, #0
  41388c:	bd30      	pop	{r4, r5, pc}
  41388e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  413892:	bf1a      	itte	ne
  413894:	4619      	movne	r1, r3
  413896:	4610      	movne	r0, r2
  413898:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  41389c:	bf1c      	itt	ne
  41389e:	460b      	movne	r3, r1
  4138a0:	4602      	movne	r2, r0
  4138a2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4138a6:	bf06      	itte	eq
  4138a8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  4138ac:	ea91 0f03 	teqeq	r1, r3
  4138b0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  4138b4:	bd30      	pop	{r4, r5, pc}
  4138b6:	bf00      	nop

004138b8 <__aeabi_ui2d>:
  4138b8:	f090 0f00 	teq	r0, #0
  4138bc:	bf04      	itt	eq
  4138be:	2100      	moveq	r1, #0
  4138c0:	4770      	bxeq	lr
  4138c2:	b530      	push	{r4, r5, lr}
  4138c4:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4138c8:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4138cc:	f04f 0500 	mov.w	r5, #0
  4138d0:	f04f 0100 	mov.w	r1, #0
  4138d4:	e750      	b.n	413778 <__adddf3+0x138>
  4138d6:	bf00      	nop

004138d8 <__aeabi_i2d>:
  4138d8:	f090 0f00 	teq	r0, #0
  4138dc:	bf04      	itt	eq
  4138de:	2100      	moveq	r1, #0
  4138e0:	4770      	bxeq	lr
  4138e2:	b530      	push	{r4, r5, lr}
  4138e4:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4138e8:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4138ec:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  4138f0:	bf48      	it	mi
  4138f2:	4240      	negmi	r0, r0
  4138f4:	f04f 0100 	mov.w	r1, #0
  4138f8:	e73e      	b.n	413778 <__adddf3+0x138>
  4138fa:	bf00      	nop

004138fc <__aeabi_f2d>:
  4138fc:	0042      	lsls	r2, r0, #1
  4138fe:	ea4f 01e2 	mov.w	r1, r2, asr #3
  413902:	ea4f 0131 	mov.w	r1, r1, rrx
  413906:	ea4f 7002 	mov.w	r0, r2, lsl #28
  41390a:	bf1f      	itttt	ne
  41390c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  413910:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  413914:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  413918:	4770      	bxne	lr
  41391a:	f092 0f00 	teq	r2, #0
  41391e:	bf14      	ite	ne
  413920:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  413924:	4770      	bxeq	lr
  413926:	b530      	push	{r4, r5, lr}
  413928:	f44f 7460 	mov.w	r4, #896	; 0x380
  41392c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  413930:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  413934:	e720      	b.n	413778 <__adddf3+0x138>
  413936:	bf00      	nop

00413938 <__aeabi_ul2d>:
  413938:	ea50 0201 	orrs.w	r2, r0, r1
  41393c:	bf08      	it	eq
  41393e:	4770      	bxeq	lr
  413940:	b530      	push	{r4, r5, lr}
  413942:	f04f 0500 	mov.w	r5, #0
  413946:	e00a      	b.n	41395e <__aeabi_l2d+0x16>

00413948 <__aeabi_l2d>:
  413948:	ea50 0201 	orrs.w	r2, r0, r1
  41394c:	bf08      	it	eq
  41394e:	4770      	bxeq	lr
  413950:	b530      	push	{r4, r5, lr}
  413952:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  413956:	d502      	bpl.n	41395e <__aeabi_l2d+0x16>
  413958:	4240      	negs	r0, r0
  41395a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  41395e:	f44f 6480 	mov.w	r4, #1024	; 0x400
  413962:	f104 0432 	add.w	r4, r4, #50	; 0x32
  413966:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  41396a:	f43f aedc 	beq.w	413726 <__adddf3+0xe6>
  41396e:	f04f 0203 	mov.w	r2, #3
  413972:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  413976:	bf18      	it	ne
  413978:	3203      	addne	r2, #3
  41397a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  41397e:	bf18      	it	ne
  413980:	3203      	addne	r2, #3
  413982:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  413986:	f1c2 0320 	rsb	r3, r2, #32
  41398a:	fa00 fc03 	lsl.w	ip, r0, r3
  41398e:	fa20 f002 	lsr.w	r0, r0, r2
  413992:	fa01 fe03 	lsl.w	lr, r1, r3
  413996:	ea40 000e 	orr.w	r0, r0, lr
  41399a:	fa21 f102 	lsr.w	r1, r1, r2
  41399e:	4414      	add	r4, r2
  4139a0:	e6c1      	b.n	413726 <__adddf3+0xe6>
  4139a2:	bf00      	nop

004139a4 <__aeabi_dmul>:
  4139a4:	b570      	push	{r4, r5, r6, lr}
  4139a6:	f04f 0cff 	mov.w	ip, #255	; 0xff
  4139aa:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  4139ae:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  4139b2:	bf1d      	ittte	ne
  4139b4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  4139b8:	ea94 0f0c 	teqne	r4, ip
  4139bc:	ea95 0f0c 	teqne	r5, ip
  4139c0:	f000 f8de 	bleq	413b80 <__aeabi_dmul+0x1dc>
  4139c4:	442c      	add	r4, r5
  4139c6:	ea81 0603 	eor.w	r6, r1, r3
  4139ca:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  4139ce:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  4139d2:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  4139d6:	bf18      	it	ne
  4139d8:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  4139dc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4139e0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4139e4:	d038      	beq.n	413a58 <__aeabi_dmul+0xb4>
  4139e6:	fba0 ce02 	umull	ip, lr, r0, r2
  4139ea:	f04f 0500 	mov.w	r5, #0
  4139ee:	fbe1 e502 	umlal	lr, r5, r1, r2
  4139f2:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  4139f6:	fbe0 e503 	umlal	lr, r5, r0, r3
  4139fa:	f04f 0600 	mov.w	r6, #0
  4139fe:	fbe1 5603 	umlal	r5, r6, r1, r3
  413a02:	f09c 0f00 	teq	ip, #0
  413a06:	bf18      	it	ne
  413a08:	f04e 0e01 	orrne.w	lr, lr, #1
  413a0c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  413a10:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  413a14:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  413a18:	d204      	bcs.n	413a24 <__aeabi_dmul+0x80>
  413a1a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  413a1e:	416d      	adcs	r5, r5
  413a20:	eb46 0606 	adc.w	r6, r6, r6
  413a24:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  413a28:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  413a2c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  413a30:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  413a34:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  413a38:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  413a3c:	bf88      	it	hi
  413a3e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  413a42:	d81e      	bhi.n	413a82 <__aeabi_dmul+0xde>
  413a44:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  413a48:	bf08      	it	eq
  413a4a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  413a4e:	f150 0000 	adcs.w	r0, r0, #0
  413a52:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  413a56:	bd70      	pop	{r4, r5, r6, pc}
  413a58:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  413a5c:	ea46 0101 	orr.w	r1, r6, r1
  413a60:	ea40 0002 	orr.w	r0, r0, r2
  413a64:	ea81 0103 	eor.w	r1, r1, r3
  413a68:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  413a6c:	bfc2      	ittt	gt
  413a6e:	ebd4 050c 	rsbsgt	r5, r4, ip
  413a72:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  413a76:	bd70      	popgt	{r4, r5, r6, pc}
  413a78:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  413a7c:	f04f 0e00 	mov.w	lr, #0
  413a80:	3c01      	subs	r4, #1
  413a82:	f300 80ab 	bgt.w	413bdc <__aeabi_dmul+0x238>
  413a86:	f114 0f36 	cmn.w	r4, #54	; 0x36
  413a8a:	bfde      	ittt	le
  413a8c:	2000      	movle	r0, #0
  413a8e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  413a92:	bd70      	pople	{r4, r5, r6, pc}
  413a94:	f1c4 0400 	rsb	r4, r4, #0
  413a98:	3c20      	subs	r4, #32
  413a9a:	da35      	bge.n	413b08 <__aeabi_dmul+0x164>
  413a9c:	340c      	adds	r4, #12
  413a9e:	dc1b      	bgt.n	413ad8 <__aeabi_dmul+0x134>
  413aa0:	f104 0414 	add.w	r4, r4, #20
  413aa4:	f1c4 0520 	rsb	r5, r4, #32
  413aa8:	fa00 f305 	lsl.w	r3, r0, r5
  413aac:	fa20 f004 	lsr.w	r0, r0, r4
  413ab0:	fa01 f205 	lsl.w	r2, r1, r5
  413ab4:	ea40 0002 	orr.w	r0, r0, r2
  413ab8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  413abc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  413ac0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  413ac4:	fa21 f604 	lsr.w	r6, r1, r4
  413ac8:	eb42 0106 	adc.w	r1, r2, r6
  413acc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  413ad0:	bf08      	it	eq
  413ad2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  413ad6:	bd70      	pop	{r4, r5, r6, pc}
  413ad8:	f1c4 040c 	rsb	r4, r4, #12
  413adc:	f1c4 0520 	rsb	r5, r4, #32
  413ae0:	fa00 f304 	lsl.w	r3, r0, r4
  413ae4:	fa20 f005 	lsr.w	r0, r0, r5
  413ae8:	fa01 f204 	lsl.w	r2, r1, r4
  413aec:	ea40 0002 	orr.w	r0, r0, r2
  413af0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  413af4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  413af8:	f141 0100 	adc.w	r1, r1, #0
  413afc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  413b00:	bf08      	it	eq
  413b02:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  413b06:	bd70      	pop	{r4, r5, r6, pc}
  413b08:	f1c4 0520 	rsb	r5, r4, #32
  413b0c:	fa00 f205 	lsl.w	r2, r0, r5
  413b10:	ea4e 0e02 	orr.w	lr, lr, r2
  413b14:	fa20 f304 	lsr.w	r3, r0, r4
  413b18:	fa01 f205 	lsl.w	r2, r1, r5
  413b1c:	ea43 0302 	orr.w	r3, r3, r2
  413b20:	fa21 f004 	lsr.w	r0, r1, r4
  413b24:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  413b28:	fa21 f204 	lsr.w	r2, r1, r4
  413b2c:	ea20 0002 	bic.w	r0, r0, r2
  413b30:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  413b34:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  413b38:	bf08      	it	eq
  413b3a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  413b3e:	bd70      	pop	{r4, r5, r6, pc}
  413b40:	f094 0f00 	teq	r4, #0
  413b44:	d10f      	bne.n	413b66 <__aeabi_dmul+0x1c2>
  413b46:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  413b4a:	0040      	lsls	r0, r0, #1
  413b4c:	eb41 0101 	adc.w	r1, r1, r1
  413b50:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413b54:	bf08      	it	eq
  413b56:	3c01      	subeq	r4, #1
  413b58:	d0f7      	beq.n	413b4a <__aeabi_dmul+0x1a6>
  413b5a:	ea41 0106 	orr.w	r1, r1, r6
  413b5e:	f095 0f00 	teq	r5, #0
  413b62:	bf18      	it	ne
  413b64:	4770      	bxne	lr
  413b66:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  413b6a:	0052      	lsls	r2, r2, #1
  413b6c:	eb43 0303 	adc.w	r3, r3, r3
  413b70:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  413b74:	bf08      	it	eq
  413b76:	3d01      	subeq	r5, #1
  413b78:	d0f7      	beq.n	413b6a <__aeabi_dmul+0x1c6>
  413b7a:	ea43 0306 	orr.w	r3, r3, r6
  413b7e:	4770      	bx	lr
  413b80:	ea94 0f0c 	teq	r4, ip
  413b84:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  413b88:	bf18      	it	ne
  413b8a:	ea95 0f0c 	teqne	r5, ip
  413b8e:	d00c      	beq.n	413baa <__aeabi_dmul+0x206>
  413b90:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  413b94:	bf18      	it	ne
  413b96:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  413b9a:	d1d1      	bne.n	413b40 <__aeabi_dmul+0x19c>
  413b9c:	ea81 0103 	eor.w	r1, r1, r3
  413ba0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  413ba4:	f04f 0000 	mov.w	r0, #0
  413ba8:	bd70      	pop	{r4, r5, r6, pc}
  413baa:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  413bae:	bf06      	itte	eq
  413bb0:	4610      	moveq	r0, r2
  413bb2:	4619      	moveq	r1, r3
  413bb4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  413bb8:	d019      	beq.n	413bee <__aeabi_dmul+0x24a>
  413bba:	ea94 0f0c 	teq	r4, ip
  413bbe:	d102      	bne.n	413bc6 <__aeabi_dmul+0x222>
  413bc0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  413bc4:	d113      	bne.n	413bee <__aeabi_dmul+0x24a>
  413bc6:	ea95 0f0c 	teq	r5, ip
  413bca:	d105      	bne.n	413bd8 <__aeabi_dmul+0x234>
  413bcc:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  413bd0:	bf1c      	itt	ne
  413bd2:	4610      	movne	r0, r2
  413bd4:	4619      	movne	r1, r3
  413bd6:	d10a      	bne.n	413bee <__aeabi_dmul+0x24a>
  413bd8:	ea81 0103 	eor.w	r1, r1, r3
  413bdc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  413be0:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  413be4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  413be8:	f04f 0000 	mov.w	r0, #0
  413bec:	bd70      	pop	{r4, r5, r6, pc}
  413bee:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  413bf2:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  413bf6:	bd70      	pop	{r4, r5, r6, pc}

00413bf8 <__aeabi_ddiv>:
  413bf8:	b570      	push	{r4, r5, r6, lr}
  413bfa:	f04f 0cff 	mov.w	ip, #255	; 0xff
  413bfe:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  413c02:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  413c06:	bf1d      	ittte	ne
  413c08:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  413c0c:	ea94 0f0c 	teqne	r4, ip
  413c10:	ea95 0f0c 	teqne	r5, ip
  413c14:	f000 f8a7 	bleq	413d66 <__aeabi_ddiv+0x16e>
  413c18:	eba4 0405 	sub.w	r4, r4, r5
  413c1c:	ea81 0e03 	eor.w	lr, r1, r3
  413c20:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  413c24:	ea4f 3101 	mov.w	r1, r1, lsl #12
  413c28:	f000 8088 	beq.w	413d3c <__aeabi_ddiv+0x144>
  413c2c:	ea4f 3303 	mov.w	r3, r3, lsl #12
  413c30:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  413c34:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  413c38:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  413c3c:	ea4f 2202 	mov.w	r2, r2, lsl #8
  413c40:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  413c44:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  413c48:	ea4f 2600 	mov.w	r6, r0, lsl #8
  413c4c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  413c50:	429d      	cmp	r5, r3
  413c52:	bf08      	it	eq
  413c54:	4296      	cmpeq	r6, r2
  413c56:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  413c5a:	f504 7440 	add.w	r4, r4, #768	; 0x300
  413c5e:	d202      	bcs.n	413c66 <__aeabi_ddiv+0x6e>
  413c60:	085b      	lsrs	r3, r3, #1
  413c62:	ea4f 0232 	mov.w	r2, r2, rrx
  413c66:	1ab6      	subs	r6, r6, r2
  413c68:	eb65 0503 	sbc.w	r5, r5, r3
  413c6c:	085b      	lsrs	r3, r3, #1
  413c6e:	ea4f 0232 	mov.w	r2, r2, rrx
  413c72:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  413c76:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  413c7a:	ebb6 0e02 	subs.w	lr, r6, r2
  413c7e:	eb75 0e03 	sbcs.w	lr, r5, r3
  413c82:	bf22      	ittt	cs
  413c84:	1ab6      	subcs	r6, r6, r2
  413c86:	4675      	movcs	r5, lr
  413c88:	ea40 000c 	orrcs.w	r0, r0, ip
  413c8c:	085b      	lsrs	r3, r3, #1
  413c8e:	ea4f 0232 	mov.w	r2, r2, rrx
  413c92:	ebb6 0e02 	subs.w	lr, r6, r2
  413c96:	eb75 0e03 	sbcs.w	lr, r5, r3
  413c9a:	bf22      	ittt	cs
  413c9c:	1ab6      	subcs	r6, r6, r2
  413c9e:	4675      	movcs	r5, lr
  413ca0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  413ca4:	085b      	lsrs	r3, r3, #1
  413ca6:	ea4f 0232 	mov.w	r2, r2, rrx
  413caa:	ebb6 0e02 	subs.w	lr, r6, r2
  413cae:	eb75 0e03 	sbcs.w	lr, r5, r3
  413cb2:	bf22      	ittt	cs
  413cb4:	1ab6      	subcs	r6, r6, r2
  413cb6:	4675      	movcs	r5, lr
  413cb8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  413cbc:	085b      	lsrs	r3, r3, #1
  413cbe:	ea4f 0232 	mov.w	r2, r2, rrx
  413cc2:	ebb6 0e02 	subs.w	lr, r6, r2
  413cc6:	eb75 0e03 	sbcs.w	lr, r5, r3
  413cca:	bf22      	ittt	cs
  413ccc:	1ab6      	subcs	r6, r6, r2
  413cce:	4675      	movcs	r5, lr
  413cd0:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  413cd4:	ea55 0e06 	orrs.w	lr, r5, r6
  413cd8:	d018      	beq.n	413d0c <__aeabi_ddiv+0x114>
  413cda:	ea4f 1505 	mov.w	r5, r5, lsl #4
  413cde:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  413ce2:	ea4f 1606 	mov.w	r6, r6, lsl #4
  413ce6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  413cea:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  413cee:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  413cf2:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  413cf6:	d1c0      	bne.n	413c7a <__aeabi_ddiv+0x82>
  413cf8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413cfc:	d10b      	bne.n	413d16 <__aeabi_ddiv+0x11e>
  413cfe:	ea41 0100 	orr.w	r1, r1, r0
  413d02:	f04f 0000 	mov.w	r0, #0
  413d06:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  413d0a:	e7b6      	b.n	413c7a <__aeabi_ddiv+0x82>
  413d0c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413d10:	bf04      	itt	eq
  413d12:	4301      	orreq	r1, r0
  413d14:	2000      	moveq	r0, #0
  413d16:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  413d1a:	bf88      	it	hi
  413d1c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  413d20:	f63f aeaf 	bhi.w	413a82 <__aeabi_dmul+0xde>
  413d24:	ebb5 0c03 	subs.w	ip, r5, r3
  413d28:	bf04      	itt	eq
  413d2a:	ebb6 0c02 	subseq.w	ip, r6, r2
  413d2e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  413d32:	f150 0000 	adcs.w	r0, r0, #0
  413d36:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  413d3a:	bd70      	pop	{r4, r5, r6, pc}
  413d3c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  413d40:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  413d44:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  413d48:	bfc2      	ittt	gt
  413d4a:	ebd4 050c 	rsbsgt	r5, r4, ip
  413d4e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  413d52:	bd70      	popgt	{r4, r5, r6, pc}
  413d54:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  413d58:	f04f 0e00 	mov.w	lr, #0
  413d5c:	3c01      	subs	r4, #1
  413d5e:	e690      	b.n	413a82 <__aeabi_dmul+0xde>
  413d60:	ea45 0e06 	orr.w	lr, r5, r6
  413d64:	e68d      	b.n	413a82 <__aeabi_dmul+0xde>
  413d66:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  413d6a:	ea94 0f0c 	teq	r4, ip
  413d6e:	bf08      	it	eq
  413d70:	ea95 0f0c 	teqeq	r5, ip
  413d74:	f43f af3b 	beq.w	413bee <__aeabi_dmul+0x24a>
  413d78:	ea94 0f0c 	teq	r4, ip
  413d7c:	d10a      	bne.n	413d94 <__aeabi_ddiv+0x19c>
  413d7e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  413d82:	f47f af34 	bne.w	413bee <__aeabi_dmul+0x24a>
  413d86:	ea95 0f0c 	teq	r5, ip
  413d8a:	f47f af25 	bne.w	413bd8 <__aeabi_dmul+0x234>
  413d8e:	4610      	mov	r0, r2
  413d90:	4619      	mov	r1, r3
  413d92:	e72c      	b.n	413bee <__aeabi_dmul+0x24a>
  413d94:	ea95 0f0c 	teq	r5, ip
  413d98:	d106      	bne.n	413da8 <__aeabi_ddiv+0x1b0>
  413d9a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  413d9e:	f43f aefd 	beq.w	413b9c <__aeabi_dmul+0x1f8>
  413da2:	4610      	mov	r0, r2
  413da4:	4619      	mov	r1, r3
  413da6:	e722      	b.n	413bee <__aeabi_dmul+0x24a>
  413da8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  413dac:	bf18      	it	ne
  413dae:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  413db2:	f47f aec5 	bne.w	413b40 <__aeabi_dmul+0x19c>
  413db6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  413dba:	f47f af0d 	bne.w	413bd8 <__aeabi_dmul+0x234>
  413dbe:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  413dc2:	f47f aeeb 	bne.w	413b9c <__aeabi_dmul+0x1f8>
  413dc6:	e712      	b.n	413bee <__aeabi_dmul+0x24a>

00413dc8 <__aeabi_d2f>:
  413dc8:	ea4f 0241 	mov.w	r2, r1, lsl #1
  413dcc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  413dd0:	bf24      	itt	cs
  413dd2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  413dd6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  413dda:	d90d      	bls.n	413df8 <__aeabi_d2f+0x30>
  413ddc:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  413de0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  413de4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  413de8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  413dec:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  413df0:	bf08      	it	eq
  413df2:	f020 0001 	biceq.w	r0, r0, #1
  413df6:	4770      	bx	lr
  413df8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  413dfc:	d121      	bne.n	413e42 <__aeabi_d2f+0x7a>
  413dfe:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  413e02:	bfbc      	itt	lt
  413e04:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  413e08:	4770      	bxlt	lr
  413e0a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  413e0e:	ea4f 5252 	mov.w	r2, r2, lsr #21
  413e12:	f1c2 0218 	rsb	r2, r2, #24
  413e16:	f1c2 0c20 	rsb	ip, r2, #32
  413e1a:	fa10 f30c 	lsls.w	r3, r0, ip
  413e1e:	fa20 f002 	lsr.w	r0, r0, r2
  413e22:	bf18      	it	ne
  413e24:	f040 0001 	orrne.w	r0, r0, #1
  413e28:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  413e2c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  413e30:	fa03 fc0c 	lsl.w	ip, r3, ip
  413e34:	ea40 000c 	orr.w	r0, r0, ip
  413e38:	fa23 f302 	lsr.w	r3, r3, r2
  413e3c:	ea4f 0343 	mov.w	r3, r3, lsl #1
  413e40:	e7cc      	b.n	413ddc <__aeabi_d2f+0x14>
  413e42:	ea7f 5362 	mvns.w	r3, r2, asr #21
  413e46:	d107      	bne.n	413e58 <__aeabi_d2f+0x90>
  413e48:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  413e4c:	bf1e      	ittt	ne
  413e4e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  413e52:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  413e56:	4770      	bxne	lr
  413e58:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  413e5c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  413e60:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  413e64:	4770      	bx	lr
  413e66:	bf00      	nop

00413e68 <__aeabi_uldivmod>:
  413e68:	b953      	cbnz	r3, 413e80 <__aeabi_uldivmod+0x18>
  413e6a:	b94a      	cbnz	r2, 413e80 <__aeabi_uldivmod+0x18>
  413e6c:	2900      	cmp	r1, #0
  413e6e:	bf08      	it	eq
  413e70:	2800      	cmpeq	r0, #0
  413e72:	bf1c      	itt	ne
  413e74:	f04f 31ff 	movne.w	r1, #4294967295
  413e78:	f04f 30ff 	movne.w	r0, #4294967295
  413e7c:	f000 b97a 	b.w	414174 <__aeabi_idiv0>
  413e80:	f1ad 0c08 	sub.w	ip, sp, #8
  413e84:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  413e88:	f000 f806 	bl	413e98 <__udivmoddi4>
  413e8c:	f8dd e004 	ldr.w	lr, [sp, #4]
  413e90:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  413e94:	b004      	add	sp, #16
  413e96:	4770      	bx	lr

00413e98 <__udivmoddi4>:
  413e98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  413e9c:	468c      	mov	ip, r1
  413e9e:	460d      	mov	r5, r1
  413ea0:	4604      	mov	r4, r0
  413ea2:	9e08      	ldr	r6, [sp, #32]
  413ea4:	2b00      	cmp	r3, #0
  413ea6:	d151      	bne.n	413f4c <__udivmoddi4+0xb4>
  413ea8:	428a      	cmp	r2, r1
  413eaa:	4617      	mov	r7, r2
  413eac:	d96d      	bls.n	413f8a <__udivmoddi4+0xf2>
  413eae:	fab2 fe82 	clz	lr, r2
  413eb2:	f1be 0f00 	cmp.w	lr, #0
  413eb6:	d00b      	beq.n	413ed0 <__udivmoddi4+0x38>
  413eb8:	f1ce 0c20 	rsb	ip, lr, #32
  413ebc:	fa01 f50e 	lsl.w	r5, r1, lr
  413ec0:	fa20 fc0c 	lsr.w	ip, r0, ip
  413ec4:	fa02 f70e 	lsl.w	r7, r2, lr
  413ec8:	ea4c 0c05 	orr.w	ip, ip, r5
  413ecc:	fa00 f40e 	lsl.w	r4, r0, lr
  413ed0:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  413ed4:	0c25      	lsrs	r5, r4, #16
  413ed6:	fbbc f8fa 	udiv	r8, ip, sl
  413eda:	fa1f f987 	uxth.w	r9, r7
  413ede:	fb0a cc18 	mls	ip, sl, r8, ip
  413ee2:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  413ee6:	fb08 f309 	mul.w	r3, r8, r9
  413eea:	42ab      	cmp	r3, r5
  413eec:	d90a      	bls.n	413f04 <__udivmoddi4+0x6c>
  413eee:	19ed      	adds	r5, r5, r7
  413ef0:	f108 32ff 	add.w	r2, r8, #4294967295
  413ef4:	f080 8123 	bcs.w	41413e <__udivmoddi4+0x2a6>
  413ef8:	42ab      	cmp	r3, r5
  413efa:	f240 8120 	bls.w	41413e <__udivmoddi4+0x2a6>
  413efe:	f1a8 0802 	sub.w	r8, r8, #2
  413f02:	443d      	add	r5, r7
  413f04:	1aed      	subs	r5, r5, r3
  413f06:	b2a4      	uxth	r4, r4
  413f08:	fbb5 f0fa 	udiv	r0, r5, sl
  413f0c:	fb0a 5510 	mls	r5, sl, r0, r5
  413f10:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  413f14:	fb00 f909 	mul.w	r9, r0, r9
  413f18:	45a1      	cmp	r9, r4
  413f1a:	d909      	bls.n	413f30 <__udivmoddi4+0x98>
  413f1c:	19e4      	adds	r4, r4, r7
  413f1e:	f100 33ff 	add.w	r3, r0, #4294967295
  413f22:	f080 810a 	bcs.w	41413a <__udivmoddi4+0x2a2>
  413f26:	45a1      	cmp	r9, r4
  413f28:	f240 8107 	bls.w	41413a <__udivmoddi4+0x2a2>
  413f2c:	3802      	subs	r0, #2
  413f2e:	443c      	add	r4, r7
  413f30:	eba4 0409 	sub.w	r4, r4, r9
  413f34:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  413f38:	2100      	movs	r1, #0
  413f3a:	2e00      	cmp	r6, #0
  413f3c:	d061      	beq.n	414002 <__udivmoddi4+0x16a>
  413f3e:	fa24 f40e 	lsr.w	r4, r4, lr
  413f42:	2300      	movs	r3, #0
  413f44:	6034      	str	r4, [r6, #0]
  413f46:	6073      	str	r3, [r6, #4]
  413f48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413f4c:	428b      	cmp	r3, r1
  413f4e:	d907      	bls.n	413f60 <__udivmoddi4+0xc8>
  413f50:	2e00      	cmp	r6, #0
  413f52:	d054      	beq.n	413ffe <__udivmoddi4+0x166>
  413f54:	2100      	movs	r1, #0
  413f56:	e886 0021 	stmia.w	r6, {r0, r5}
  413f5a:	4608      	mov	r0, r1
  413f5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413f60:	fab3 f183 	clz	r1, r3
  413f64:	2900      	cmp	r1, #0
  413f66:	f040 808e 	bne.w	414086 <__udivmoddi4+0x1ee>
  413f6a:	42ab      	cmp	r3, r5
  413f6c:	d302      	bcc.n	413f74 <__udivmoddi4+0xdc>
  413f6e:	4282      	cmp	r2, r0
  413f70:	f200 80fa 	bhi.w	414168 <__udivmoddi4+0x2d0>
  413f74:	1a84      	subs	r4, r0, r2
  413f76:	eb65 0503 	sbc.w	r5, r5, r3
  413f7a:	2001      	movs	r0, #1
  413f7c:	46ac      	mov	ip, r5
  413f7e:	2e00      	cmp	r6, #0
  413f80:	d03f      	beq.n	414002 <__udivmoddi4+0x16a>
  413f82:	e886 1010 	stmia.w	r6, {r4, ip}
  413f86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413f8a:	b912      	cbnz	r2, 413f92 <__udivmoddi4+0xfa>
  413f8c:	2701      	movs	r7, #1
  413f8e:	fbb7 f7f2 	udiv	r7, r7, r2
  413f92:	fab7 fe87 	clz	lr, r7
  413f96:	f1be 0f00 	cmp.w	lr, #0
  413f9a:	d134      	bne.n	414006 <__udivmoddi4+0x16e>
  413f9c:	1beb      	subs	r3, r5, r7
  413f9e:	0c3a      	lsrs	r2, r7, #16
  413fa0:	fa1f fc87 	uxth.w	ip, r7
  413fa4:	2101      	movs	r1, #1
  413fa6:	fbb3 f8f2 	udiv	r8, r3, r2
  413faa:	0c25      	lsrs	r5, r4, #16
  413fac:	fb02 3318 	mls	r3, r2, r8, r3
  413fb0:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  413fb4:	fb0c f308 	mul.w	r3, ip, r8
  413fb8:	42ab      	cmp	r3, r5
  413fba:	d907      	bls.n	413fcc <__udivmoddi4+0x134>
  413fbc:	19ed      	adds	r5, r5, r7
  413fbe:	f108 30ff 	add.w	r0, r8, #4294967295
  413fc2:	d202      	bcs.n	413fca <__udivmoddi4+0x132>
  413fc4:	42ab      	cmp	r3, r5
  413fc6:	f200 80d1 	bhi.w	41416c <__udivmoddi4+0x2d4>
  413fca:	4680      	mov	r8, r0
  413fcc:	1aed      	subs	r5, r5, r3
  413fce:	b2a3      	uxth	r3, r4
  413fd0:	fbb5 f0f2 	udiv	r0, r5, r2
  413fd4:	fb02 5510 	mls	r5, r2, r0, r5
  413fd8:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  413fdc:	fb0c fc00 	mul.w	ip, ip, r0
  413fe0:	45a4      	cmp	ip, r4
  413fe2:	d907      	bls.n	413ff4 <__udivmoddi4+0x15c>
  413fe4:	19e4      	adds	r4, r4, r7
  413fe6:	f100 33ff 	add.w	r3, r0, #4294967295
  413fea:	d202      	bcs.n	413ff2 <__udivmoddi4+0x15a>
  413fec:	45a4      	cmp	ip, r4
  413fee:	f200 80b8 	bhi.w	414162 <__udivmoddi4+0x2ca>
  413ff2:	4618      	mov	r0, r3
  413ff4:	eba4 040c 	sub.w	r4, r4, ip
  413ff8:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  413ffc:	e79d      	b.n	413f3a <__udivmoddi4+0xa2>
  413ffe:	4631      	mov	r1, r6
  414000:	4630      	mov	r0, r6
  414002:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  414006:	f1ce 0420 	rsb	r4, lr, #32
  41400a:	fa05 f30e 	lsl.w	r3, r5, lr
  41400e:	fa07 f70e 	lsl.w	r7, r7, lr
  414012:	fa20 f804 	lsr.w	r8, r0, r4
  414016:	0c3a      	lsrs	r2, r7, #16
  414018:	fa25 f404 	lsr.w	r4, r5, r4
  41401c:	ea48 0803 	orr.w	r8, r8, r3
  414020:	fbb4 f1f2 	udiv	r1, r4, r2
  414024:	ea4f 4518 	mov.w	r5, r8, lsr #16
  414028:	fb02 4411 	mls	r4, r2, r1, r4
  41402c:	fa1f fc87 	uxth.w	ip, r7
  414030:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  414034:	fb01 f30c 	mul.w	r3, r1, ip
  414038:	42ab      	cmp	r3, r5
  41403a:	fa00 f40e 	lsl.w	r4, r0, lr
  41403e:	d909      	bls.n	414054 <__udivmoddi4+0x1bc>
  414040:	19ed      	adds	r5, r5, r7
  414042:	f101 30ff 	add.w	r0, r1, #4294967295
  414046:	f080 808a 	bcs.w	41415e <__udivmoddi4+0x2c6>
  41404a:	42ab      	cmp	r3, r5
  41404c:	f240 8087 	bls.w	41415e <__udivmoddi4+0x2c6>
  414050:	3902      	subs	r1, #2
  414052:	443d      	add	r5, r7
  414054:	1aeb      	subs	r3, r5, r3
  414056:	fa1f f588 	uxth.w	r5, r8
  41405a:	fbb3 f0f2 	udiv	r0, r3, r2
  41405e:	fb02 3310 	mls	r3, r2, r0, r3
  414062:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  414066:	fb00 f30c 	mul.w	r3, r0, ip
  41406a:	42ab      	cmp	r3, r5
  41406c:	d907      	bls.n	41407e <__udivmoddi4+0x1e6>
  41406e:	19ed      	adds	r5, r5, r7
  414070:	f100 38ff 	add.w	r8, r0, #4294967295
  414074:	d26f      	bcs.n	414156 <__udivmoddi4+0x2be>
  414076:	42ab      	cmp	r3, r5
  414078:	d96d      	bls.n	414156 <__udivmoddi4+0x2be>
  41407a:	3802      	subs	r0, #2
  41407c:	443d      	add	r5, r7
  41407e:	1aeb      	subs	r3, r5, r3
  414080:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  414084:	e78f      	b.n	413fa6 <__udivmoddi4+0x10e>
  414086:	f1c1 0720 	rsb	r7, r1, #32
  41408a:	fa22 f807 	lsr.w	r8, r2, r7
  41408e:	408b      	lsls	r3, r1
  414090:	fa05 f401 	lsl.w	r4, r5, r1
  414094:	ea48 0303 	orr.w	r3, r8, r3
  414098:	fa20 fe07 	lsr.w	lr, r0, r7
  41409c:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  4140a0:	40fd      	lsrs	r5, r7
  4140a2:	ea4e 0e04 	orr.w	lr, lr, r4
  4140a6:	fbb5 f9fc 	udiv	r9, r5, ip
  4140aa:	ea4f 441e 	mov.w	r4, lr, lsr #16
  4140ae:	fb0c 5519 	mls	r5, ip, r9, r5
  4140b2:	fa1f f883 	uxth.w	r8, r3
  4140b6:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  4140ba:	fb09 f408 	mul.w	r4, r9, r8
  4140be:	42ac      	cmp	r4, r5
  4140c0:	fa02 f201 	lsl.w	r2, r2, r1
  4140c4:	fa00 fa01 	lsl.w	sl, r0, r1
  4140c8:	d908      	bls.n	4140dc <__udivmoddi4+0x244>
  4140ca:	18ed      	adds	r5, r5, r3
  4140cc:	f109 30ff 	add.w	r0, r9, #4294967295
  4140d0:	d243      	bcs.n	41415a <__udivmoddi4+0x2c2>
  4140d2:	42ac      	cmp	r4, r5
  4140d4:	d941      	bls.n	41415a <__udivmoddi4+0x2c2>
  4140d6:	f1a9 0902 	sub.w	r9, r9, #2
  4140da:	441d      	add	r5, r3
  4140dc:	1b2d      	subs	r5, r5, r4
  4140de:	fa1f fe8e 	uxth.w	lr, lr
  4140e2:	fbb5 f0fc 	udiv	r0, r5, ip
  4140e6:	fb0c 5510 	mls	r5, ip, r0, r5
  4140ea:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  4140ee:	fb00 f808 	mul.w	r8, r0, r8
  4140f2:	45a0      	cmp	r8, r4
  4140f4:	d907      	bls.n	414106 <__udivmoddi4+0x26e>
  4140f6:	18e4      	adds	r4, r4, r3
  4140f8:	f100 35ff 	add.w	r5, r0, #4294967295
  4140fc:	d229      	bcs.n	414152 <__udivmoddi4+0x2ba>
  4140fe:	45a0      	cmp	r8, r4
  414100:	d927      	bls.n	414152 <__udivmoddi4+0x2ba>
  414102:	3802      	subs	r0, #2
  414104:	441c      	add	r4, r3
  414106:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  41410a:	eba4 0408 	sub.w	r4, r4, r8
  41410e:	fba0 8902 	umull	r8, r9, r0, r2
  414112:	454c      	cmp	r4, r9
  414114:	46c6      	mov	lr, r8
  414116:	464d      	mov	r5, r9
  414118:	d315      	bcc.n	414146 <__udivmoddi4+0x2ae>
  41411a:	d012      	beq.n	414142 <__udivmoddi4+0x2aa>
  41411c:	b156      	cbz	r6, 414134 <__udivmoddi4+0x29c>
  41411e:	ebba 030e 	subs.w	r3, sl, lr
  414122:	eb64 0405 	sbc.w	r4, r4, r5
  414126:	fa04 f707 	lsl.w	r7, r4, r7
  41412a:	40cb      	lsrs	r3, r1
  41412c:	431f      	orrs	r7, r3
  41412e:	40cc      	lsrs	r4, r1
  414130:	6037      	str	r7, [r6, #0]
  414132:	6074      	str	r4, [r6, #4]
  414134:	2100      	movs	r1, #0
  414136:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41413a:	4618      	mov	r0, r3
  41413c:	e6f8      	b.n	413f30 <__udivmoddi4+0x98>
  41413e:	4690      	mov	r8, r2
  414140:	e6e0      	b.n	413f04 <__udivmoddi4+0x6c>
  414142:	45c2      	cmp	sl, r8
  414144:	d2ea      	bcs.n	41411c <__udivmoddi4+0x284>
  414146:	ebb8 0e02 	subs.w	lr, r8, r2
  41414a:	eb69 0503 	sbc.w	r5, r9, r3
  41414e:	3801      	subs	r0, #1
  414150:	e7e4      	b.n	41411c <__udivmoddi4+0x284>
  414152:	4628      	mov	r0, r5
  414154:	e7d7      	b.n	414106 <__udivmoddi4+0x26e>
  414156:	4640      	mov	r0, r8
  414158:	e791      	b.n	41407e <__udivmoddi4+0x1e6>
  41415a:	4681      	mov	r9, r0
  41415c:	e7be      	b.n	4140dc <__udivmoddi4+0x244>
  41415e:	4601      	mov	r1, r0
  414160:	e778      	b.n	414054 <__udivmoddi4+0x1bc>
  414162:	3802      	subs	r0, #2
  414164:	443c      	add	r4, r7
  414166:	e745      	b.n	413ff4 <__udivmoddi4+0x15c>
  414168:	4608      	mov	r0, r1
  41416a:	e708      	b.n	413f7e <__udivmoddi4+0xe6>
  41416c:	f1a8 0802 	sub.w	r8, r8, #2
  414170:	443d      	add	r5, r7
  414172:	e72b      	b.n	413fcc <__udivmoddi4+0x134>

00414174 <__aeabi_idiv0>:
  414174:	4770      	bx	lr
  414176:	bf00      	nop

00414178 <__errno>:
  414178:	4b01      	ldr	r3, [pc, #4]	; (414180 <__errno+0x8>)
  41417a:	6818      	ldr	r0, [r3, #0]
  41417c:	4770      	bx	lr
  41417e:	bf00      	nop
  414180:	20000358 	.word	0x20000358

00414184 <__libc_init_array>:
  414184:	b570      	push	{r4, r5, r6, lr}
  414186:	4e0f      	ldr	r6, [pc, #60]	; (4141c4 <__libc_init_array+0x40>)
  414188:	4d0f      	ldr	r5, [pc, #60]	; (4141c8 <__libc_init_array+0x44>)
  41418a:	1b76      	subs	r6, r6, r5
  41418c:	10b6      	asrs	r6, r6, #2
  41418e:	bf18      	it	ne
  414190:	2400      	movne	r4, #0
  414192:	d005      	beq.n	4141a0 <__libc_init_array+0x1c>
  414194:	3401      	adds	r4, #1
  414196:	f855 3b04 	ldr.w	r3, [r5], #4
  41419a:	4798      	blx	r3
  41419c:	42a6      	cmp	r6, r4
  41419e:	d1f9      	bne.n	414194 <__libc_init_array+0x10>
  4141a0:	4e0a      	ldr	r6, [pc, #40]	; (4141cc <__libc_init_array+0x48>)
  4141a2:	4d0b      	ldr	r5, [pc, #44]	; (4141d0 <__libc_init_array+0x4c>)
  4141a4:	1b76      	subs	r6, r6, r5
  4141a6:	f009 fc6f 	bl	41da88 <_init>
  4141aa:	10b6      	asrs	r6, r6, #2
  4141ac:	bf18      	it	ne
  4141ae:	2400      	movne	r4, #0
  4141b0:	d006      	beq.n	4141c0 <__libc_init_array+0x3c>
  4141b2:	3401      	adds	r4, #1
  4141b4:	f855 3b04 	ldr.w	r3, [r5], #4
  4141b8:	4798      	blx	r3
  4141ba:	42a6      	cmp	r6, r4
  4141bc:	d1f9      	bne.n	4141b2 <__libc_init_array+0x2e>
  4141be:	bd70      	pop	{r4, r5, r6, pc}
  4141c0:	bd70      	pop	{r4, r5, r6, pc}
  4141c2:	bf00      	nop
  4141c4:	0041da94 	.word	0x0041da94
  4141c8:	0041da94 	.word	0x0041da94
  4141cc:	0041da9c 	.word	0x0041da9c
  4141d0:	0041da94 	.word	0x0041da94

004141d4 <memcmp>:
  4141d4:	2a03      	cmp	r2, #3
  4141d6:	b470      	push	{r4, r5, r6}
  4141d8:	d922      	bls.n	414220 <memcmp+0x4c>
  4141da:	ea40 0301 	orr.w	r3, r0, r1
  4141de:	079b      	lsls	r3, r3, #30
  4141e0:	d011      	beq.n	414206 <memcmp+0x32>
  4141e2:	7803      	ldrb	r3, [r0, #0]
  4141e4:	780c      	ldrb	r4, [r1, #0]
  4141e6:	42a3      	cmp	r3, r4
  4141e8:	d11d      	bne.n	414226 <memcmp+0x52>
  4141ea:	440a      	add	r2, r1
  4141ec:	3101      	adds	r1, #1
  4141ee:	e005      	b.n	4141fc <memcmp+0x28>
  4141f0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  4141f4:	f811 4b01 	ldrb.w	r4, [r1], #1
  4141f8:	42a3      	cmp	r3, r4
  4141fa:	d114      	bne.n	414226 <memcmp+0x52>
  4141fc:	4291      	cmp	r1, r2
  4141fe:	d1f7      	bne.n	4141f0 <memcmp+0x1c>
  414200:	2000      	movs	r0, #0
  414202:	bc70      	pop	{r4, r5, r6}
  414204:	4770      	bx	lr
  414206:	680d      	ldr	r5, [r1, #0]
  414208:	6806      	ldr	r6, [r0, #0]
  41420a:	42ae      	cmp	r6, r5
  41420c:	460c      	mov	r4, r1
  41420e:	4603      	mov	r3, r0
  414210:	f101 0104 	add.w	r1, r1, #4
  414214:	f100 0004 	add.w	r0, r0, #4
  414218:	d108      	bne.n	41422c <memcmp+0x58>
  41421a:	3a04      	subs	r2, #4
  41421c:	2a03      	cmp	r2, #3
  41421e:	d8f2      	bhi.n	414206 <memcmp+0x32>
  414220:	2a00      	cmp	r2, #0
  414222:	d1de      	bne.n	4141e2 <memcmp+0xe>
  414224:	e7ec      	b.n	414200 <memcmp+0x2c>
  414226:	1b18      	subs	r0, r3, r4
  414228:	bc70      	pop	{r4, r5, r6}
  41422a:	4770      	bx	lr
  41422c:	4621      	mov	r1, r4
  41422e:	4618      	mov	r0, r3
  414230:	e7d7      	b.n	4141e2 <memcmp+0xe>
  414232:	bf00      	nop

00414234 <memcpy>:
  414234:	4684      	mov	ip, r0
  414236:	ea41 0300 	orr.w	r3, r1, r0
  41423a:	f013 0303 	ands.w	r3, r3, #3
  41423e:	d16d      	bne.n	41431c <memcpy+0xe8>
  414240:	3a40      	subs	r2, #64	; 0x40
  414242:	d341      	bcc.n	4142c8 <memcpy+0x94>
  414244:	f851 3b04 	ldr.w	r3, [r1], #4
  414248:	f840 3b04 	str.w	r3, [r0], #4
  41424c:	f851 3b04 	ldr.w	r3, [r1], #4
  414250:	f840 3b04 	str.w	r3, [r0], #4
  414254:	f851 3b04 	ldr.w	r3, [r1], #4
  414258:	f840 3b04 	str.w	r3, [r0], #4
  41425c:	f851 3b04 	ldr.w	r3, [r1], #4
  414260:	f840 3b04 	str.w	r3, [r0], #4
  414264:	f851 3b04 	ldr.w	r3, [r1], #4
  414268:	f840 3b04 	str.w	r3, [r0], #4
  41426c:	f851 3b04 	ldr.w	r3, [r1], #4
  414270:	f840 3b04 	str.w	r3, [r0], #4
  414274:	f851 3b04 	ldr.w	r3, [r1], #4
  414278:	f840 3b04 	str.w	r3, [r0], #4
  41427c:	f851 3b04 	ldr.w	r3, [r1], #4
  414280:	f840 3b04 	str.w	r3, [r0], #4
  414284:	f851 3b04 	ldr.w	r3, [r1], #4
  414288:	f840 3b04 	str.w	r3, [r0], #4
  41428c:	f851 3b04 	ldr.w	r3, [r1], #4
  414290:	f840 3b04 	str.w	r3, [r0], #4
  414294:	f851 3b04 	ldr.w	r3, [r1], #4
  414298:	f840 3b04 	str.w	r3, [r0], #4
  41429c:	f851 3b04 	ldr.w	r3, [r1], #4
  4142a0:	f840 3b04 	str.w	r3, [r0], #4
  4142a4:	f851 3b04 	ldr.w	r3, [r1], #4
  4142a8:	f840 3b04 	str.w	r3, [r0], #4
  4142ac:	f851 3b04 	ldr.w	r3, [r1], #4
  4142b0:	f840 3b04 	str.w	r3, [r0], #4
  4142b4:	f851 3b04 	ldr.w	r3, [r1], #4
  4142b8:	f840 3b04 	str.w	r3, [r0], #4
  4142bc:	f851 3b04 	ldr.w	r3, [r1], #4
  4142c0:	f840 3b04 	str.w	r3, [r0], #4
  4142c4:	3a40      	subs	r2, #64	; 0x40
  4142c6:	d2bd      	bcs.n	414244 <memcpy+0x10>
  4142c8:	3230      	adds	r2, #48	; 0x30
  4142ca:	d311      	bcc.n	4142f0 <memcpy+0xbc>
  4142cc:	f851 3b04 	ldr.w	r3, [r1], #4
  4142d0:	f840 3b04 	str.w	r3, [r0], #4
  4142d4:	f851 3b04 	ldr.w	r3, [r1], #4
  4142d8:	f840 3b04 	str.w	r3, [r0], #4
  4142dc:	f851 3b04 	ldr.w	r3, [r1], #4
  4142e0:	f840 3b04 	str.w	r3, [r0], #4
  4142e4:	f851 3b04 	ldr.w	r3, [r1], #4
  4142e8:	f840 3b04 	str.w	r3, [r0], #4
  4142ec:	3a10      	subs	r2, #16
  4142ee:	d2ed      	bcs.n	4142cc <memcpy+0x98>
  4142f0:	320c      	adds	r2, #12
  4142f2:	d305      	bcc.n	414300 <memcpy+0xcc>
  4142f4:	f851 3b04 	ldr.w	r3, [r1], #4
  4142f8:	f840 3b04 	str.w	r3, [r0], #4
  4142fc:	3a04      	subs	r2, #4
  4142fe:	d2f9      	bcs.n	4142f4 <memcpy+0xc0>
  414300:	3204      	adds	r2, #4
  414302:	d008      	beq.n	414316 <memcpy+0xe2>
  414304:	07d2      	lsls	r2, r2, #31
  414306:	bf1c      	itt	ne
  414308:	f811 3b01 	ldrbne.w	r3, [r1], #1
  41430c:	f800 3b01 	strbne.w	r3, [r0], #1
  414310:	d301      	bcc.n	414316 <memcpy+0xe2>
  414312:	880b      	ldrh	r3, [r1, #0]
  414314:	8003      	strh	r3, [r0, #0]
  414316:	4660      	mov	r0, ip
  414318:	4770      	bx	lr
  41431a:	bf00      	nop
  41431c:	2a08      	cmp	r2, #8
  41431e:	d313      	bcc.n	414348 <memcpy+0x114>
  414320:	078b      	lsls	r3, r1, #30
  414322:	d08d      	beq.n	414240 <memcpy+0xc>
  414324:	f010 0303 	ands.w	r3, r0, #3
  414328:	d08a      	beq.n	414240 <memcpy+0xc>
  41432a:	f1c3 0304 	rsb	r3, r3, #4
  41432e:	1ad2      	subs	r2, r2, r3
  414330:	07db      	lsls	r3, r3, #31
  414332:	bf1c      	itt	ne
  414334:	f811 3b01 	ldrbne.w	r3, [r1], #1
  414338:	f800 3b01 	strbne.w	r3, [r0], #1
  41433c:	d380      	bcc.n	414240 <memcpy+0xc>
  41433e:	f831 3b02 	ldrh.w	r3, [r1], #2
  414342:	f820 3b02 	strh.w	r3, [r0], #2
  414346:	e77b      	b.n	414240 <memcpy+0xc>
  414348:	3a04      	subs	r2, #4
  41434a:	d3d9      	bcc.n	414300 <memcpy+0xcc>
  41434c:	3a01      	subs	r2, #1
  41434e:	f811 3b01 	ldrb.w	r3, [r1], #1
  414352:	f800 3b01 	strb.w	r3, [r0], #1
  414356:	d2f9      	bcs.n	41434c <memcpy+0x118>
  414358:	780b      	ldrb	r3, [r1, #0]
  41435a:	7003      	strb	r3, [r0, #0]
  41435c:	784b      	ldrb	r3, [r1, #1]
  41435e:	7043      	strb	r3, [r0, #1]
  414360:	788b      	ldrb	r3, [r1, #2]
  414362:	7083      	strb	r3, [r0, #2]
  414364:	4660      	mov	r0, ip
  414366:	4770      	bx	lr

00414368 <memmove>:
  414368:	4288      	cmp	r0, r1
  41436a:	b5f0      	push	{r4, r5, r6, r7, lr}
  41436c:	d90d      	bls.n	41438a <memmove+0x22>
  41436e:	188b      	adds	r3, r1, r2
  414370:	4298      	cmp	r0, r3
  414372:	d20a      	bcs.n	41438a <memmove+0x22>
  414374:	1884      	adds	r4, r0, r2
  414376:	2a00      	cmp	r2, #0
  414378:	d051      	beq.n	41441e <memmove+0xb6>
  41437a:	4622      	mov	r2, r4
  41437c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  414380:	f802 4d01 	strb.w	r4, [r2, #-1]!
  414384:	4299      	cmp	r1, r3
  414386:	d1f9      	bne.n	41437c <memmove+0x14>
  414388:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41438a:	2a0f      	cmp	r2, #15
  41438c:	d948      	bls.n	414420 <memmove+0xb8>
  41438e:	ea41 0300 	orr.w	r3, r1, r0
  414392:	079b      	lsls	r3, r3, #30
  414394:	d146      	bne.n	414424 <memmove+0xbc>
  414396:	f100 0410 	add.w	r4, r0, #16
  41439a:	f101 0310 	add.w	r3, r1, #16
  41439e:	4615      	mov	r5, r2
  4143a0:	f853 6c10 	ldr.w	r6, [r3, #-16]
  4143a4:	f844 6c10 	str.w	r6, [r4, #-16]
  4143a8:	f853 6c0c 	ldr.w	r6, [r3, #-12]
  4143ac:	f844 6c0c 	str.w	r6, [r4, #-12]
  4143b0:	f853 6c08 	ldr.w	r6, [r3, #-8]
  4143b4:	f844 6c08 	str.w	r6, [r4, #-8]
  4143b8:	3d10      	subs	r5, #16
  4143ba:	f853 6c04 	ldr.w	r6, [r3, #-4]
  4143be:	f844 6c04 	str.w	r6, [r4, #-4]
  4143c2:	2d0f      	cmp	r5, #15
  4143c4:	f103 0310 	add.w	r3, r3, #16
  4143c8:	f104 0410 	add.w	r4, r4, #16
  4143cc:	d8e8      	bhi.n	4143a0 <memmove+0x38>
  4143ce:	f1a2 0310 	sub.w	r3, r2, #16
  4143d2:	f023 030f 	bic.w	r3, r3, #15
  4143d6:	f002 0e0f 	and.w	lr, r2, #15
  4143da:	3310      	adds	r3, #16
  4143dc:	f1be 0f03 	cmp.w	lr, #3
  4143e0:	4419      	add	r1, r3
  4143e2:	4403      	add	r3, r0
  4143e4:	d921      	bls.n	41442a <memmove+0xc2>
  4143e6:	1f1e      	subs	r6, r3, #4
  4143e8:	460d      	mov	r5, r1
  4143ea:	4674      	mov	r4, lr
  4143ec:	3c04      	subs	r4, #4
  4143ee:	f855 7b04 	ldr.w	r7, [r5], #4
  4143f2:	f846 7f04 	str.w	r7, [r6, #4]!
  4143f6:	2c03      	cmp	r4, #3
  4143f8:	d8f8      	bhi.n	4143ec <memmove+0x84>
  4143fa:	f1ae 0404 	sub.w	r4, lr, #4
  4143fe:	f024 0403 	bic.w	r4, r4, #3
  414402:	3404      	adds	r4, #4
  414404:	4421      	add	r1, r4
  414406:	4423      	add	r3, r4
  414408:	f002 0203 	and.w	r2, r2, #3
  41440c:	b162      	cbz	r2, 414428 <memmove+0xc0>
  41440e:	3b01      	subs	r3, #1
  414410:	440a      	add	r2, r1
  414412:	f811 4b01 	ldrb.w	r4, [r1], #1
  414416:	f803 4f01 	strb.w	r4, [r3, #1]!
  41441a:	428a      	cmp	r2, r1
  41441c:	d1f9      	bne.n	414412 <memmove+0xaa>
  41441e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  414420:	4603      	mov	r3, r0
  414422:	e7f3      	b.n	41440c <memmove+0xa4>
  414424:	4603      	mov	r3, r0
  414426:	e7f2      	b.n	41440e <memmove+0xa6>
  414428:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41442a:	4672      	mov	r2, lr
  41442c:	e7ee      	b.n	41440c <memmove+0xa4>
  41442e:	bf00      	nop

00414430 <memset>:
  414430:	b470      	push	{r4, r5, r6}
  414432:	0786      	lsls	r6, r0, #30
  414434:	d046      	beq.n	4144c4 <memset+0x94>
  414436:	1e54      	subs	r4, r2, #1
  414438:	2a00      	cmp	r2, #0
  41443a:	d041      	beq.n	4144c0 <memset+0x90>
  41443c:	b2ca      	uxtb	r2, r1
  41443e:	4603      	mov	r3, r0
  414440:	e002      	b.n	414448 <memset+0x18>
  414442:	f114 34ff 	adds.w	r4, r4, #4294967295
  414446:	d33b      	bcc.n	4144c0 <memset+0x90>
  414448:	f803 2b01 	strb.w	r2, [r3], #1
  41444c:	079d      	lsls	r5, r3, #30
  41444e:	d1f8      	bne.n	414442 <memset+0x12>
  414450:	2c03      	cmp	r4, #3
  414452:	d92e      	bls.n	4144b2 <memset+0x82>
  414454:	b2cd      	uxtb	r5, r1
  414456:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  41445a:	2c0f      	cmp	r4, #15
  41445c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  414460:	d919      	bls.n	414496 <memset+0x66>
  414462:	f103 0210 	add.w	r2, r3, #16
  414466:	4626      	mov	r6, r4
  414468:	3e10      	subs	r6, #16
  41446a:	2e0f      	cmp	r6, #15
  41446c:	f842 5c10 	str.w	r5, [r2, #-16]
  414470:	f842 5c0c 	str.w	r5, [r2, #-12]
  414474:	f842 5c08 	str.w	r5, [r2, #-8]
  414478:	f842 5c04 	str.w	r5, [r2, #-4]
  41447c:	f102 0210 	add.w	r2, r2, #16
  414480:	d8f2      	bhi.n	414468 <memset+0x38>
  414482:	f1a4 0210 	sub.w	r2, r4, #16
  414486:	f022 020f 	bic.w	r2, r2, #15
  41448a:	f004 040f 	and.w	r4, r4, #15
  41448e:	3210      	adds	r2, #16
  414490:	2c03      	cmp	r4, #3
  414492:	4413      	add	r3, r2
  414494:	d90d      	bls.n	4144b2 <memset+0x82>
  414496:	461e      	mov	r6, r3
  414498:	4622      	mov	r2, r4
  41449a:	3a04      	subs	r2, #4
  41449c:	2a03      	cmp	r2, #3
  41449e:	f846 5b04 	str.w	r5, [r6], #4
  4144a2:	d8fa      	bhi.n	41449a <memset+0x6a>
  4144a4:	1f22      	subs	r2, r4, #4
  4144a6:	f022 0203 	bic.w	r2, r2, #3
  4144aa:	3204      	adds	r2, #4
  4144ac:	4413      	add	r3, r2
  4144ae:	f004 0403 	and.w	r4, r4, #3
  4144b2:	b12c      	cbz	r4, 4144c0 <memset+0x90>
  4144b4:	b2c9      	uxtb	r1, r1
  4144b6:	441c      	add	r4, r3
  4144b8:	f803 1b01 	strb.w	r1, [r3], #1
  4144bc:	429c      	cmp	r4, r3
  4144be:	d1fb      	bne.n	4144b8 <memset+0x88>
  4144c0:	bc70      	pop	{r4, r5, r6}
  4144c2:	4770      	bx	lr
  4144c4:	4614      	mov	r4, r2
  4144c6:	4603      	mov	r3, r0
  4144c8:	e7c2      	b.n	414450 <memset+0x20>
  4144ca:	bf00      	nop

004144cc <snprintf>:
  4144cc:	b40c      	push	{r2, r3}
  4144ce:	b5f0      	push	{r4, r5, r6, r7, lr}
  4144d0:	4b23      	ldr	r3, [pc, #140]	; (414560 <snprintf+0x94>)
  4144d2:	1e0c      	subs	r4, r1, #0
  4144d4:	b09d      	sub	sp, #116	; 0x74
  4144d6:	681d      	ldr	r5, [r3, #0]
  4144d8:	db3d      	blt.n	414556 <snprintf+0x8a>
  4144da:	f44f 7302 	mov.w	r3, #520	; 0x208
  4144de:	9002      	str	r0, [sp, #8]
  4144e0:	9006      	str	r0, [sp, #24]
  4144e2:	f8ad 3014 	strh.w	r3, [sp, #20]
  4144e6:	ae23      	add	r6, sp, #140	; 0x8c
  4144e8:	d017      	beq.n	41451a <snprintf+0x4e>
  4144ea:	3c01      	subs	r4, #1
  4144ec:	9a22      	ldr	r2, [sp, #136]	; 0x88
  4144ee:	9404      	str	r4, [sp, #16]
  4144f0:	4633      	mov	r3, r6
  4144f2:	f64f 77ff 	movw	r7, #65535	; 0xffff
  4144f6:	a902      	add	r1, sp, #8
  4144f8:	4628      	mov	r0, r5
  4144fa:	9407      	str	r4, [sp, #28]
  4144fc:	9601      	str	r6, [sp, #4]
  4144fe:	f8ad 7016 	strh.w	r7, [sp, #22]
  414502:	f000 f831 	bl	414568 <_svfprintf_r>
  414506:	1c42      	adds	r2, r0, #1
  414508:	db1b      	blt.n	414542 <snprintf+0x76>
  41450a:	9b02      	ldr	r3, [sp, #8]
  41450c:	2200      	movs	r2, #0
  41450e:	701a      	strb	r2, [r3, #0]
  414510:	b01d      	add	sp, #116	; 0x74
  414512:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  414516:	b002      	add	sp, #8
  414518:	4770      	bx	lr
  41451a:	4633      	mov	r3, r6
  41451c:	f64f 77ff 	movw	r7, #65535	; 0xffff
  414520:	9a22      	ldr	r2, [sp, #136]	; 0x88
  414522:	9404      	str	r4, [sp, #16]
  414524:	a902      	add	r1, sp, #8
  414526:	4628      	mov	r0, r5
  414528:	9407      	str	r4, [sp, #28]
  41452a:	9601      	str	r6, [sp, #4]
  41452c:	f8ad 7016 	strh.w	r7, [sp, #22]
  414530:	f000 f81a 	bl	414568 <_svfprintf_r>
  414534:	1c43      	adds	r3, r0, #1
  414536:	db07      	blt.n	414548 <snprintf+0x7c>
  414538:	b01d      	add	sp, #116	; 0x74
  41453a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  41453e:	b002      	add	sp, #8
  414540:	4770      	bx	lr
  414542:	238b      	movs	r3, #139	; 0x8b
  414544:	602b      	str	r3, [r5, #0]
  414546:	e7e0      	b.n	41450a <snprintf+0x3e>
  414548:	238b      	movs	r3, #139	; 0x8b
  41454a:	602b      	str	r3, [r5, #0]
  41454c:	b01d      	add	sp, #116	; 0x74
  41454e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  414552:	b002      	add	sp, #8
  414554:	4770      	bx	lr
  414556:	238b      	movs	r3, #139	; 0x8b
  414558:	602b      	str	r3, [r5, #0]
  41455a:	f04f 30ff 	mov.w	r0, #4294967295
  41455e:	e7eb      	b.n	414538 <snprintf+0x6c>
  414560:	20000358 	.word	0x20000358
  414564:	00000000 	.word	0x00000000

00414568 <_svfprintf_r>:
  414568:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41456c:	b0c1      	sub	sp, #260	; 0x104
  41456e:	460c      	mov	r4, r1
  414570:	9107      	str	r1, [sp, #28]
  414572:	4692      	mov	sl, r2
  414574:	930b      	str	r3, [sp, #44]	; 0x2c
  414576:	9008      	str	r0, [sp, #32]
  414578:	f002 fa6e 	bl	416a58 <_localeconv_r>
  41457c:	6803      	ldr	r3, [r0, #0]
  41457e:	9314      	str	r3, [sp, #80]	; 0x50
  414580:	4618      	mov	r0, r3
  414582:	f003 f89d 	bl	4176c0 <strlen>
  414586:	89a3      	ldrh	r3, [r4, #12]
  414588:	9013      	str	r0, [sp, #76]	; 0x4c
  41458a:	0619      	lsls	r1, r3, #24
  41458c:	d503      	bpl.n	414596 <_svfprintf_r+0x2e>
  41458e:	6923      	ldr	r3, [r4, #16]
  414590:	2b00      	cmp	r3, #0
  414592:	f001 801b 	beq.w	4155cc <_svfprintf_r+0x1064>
  414596:	ed9f 7b94 	vldr	d7, [pc, #592]	; 4147e8 <_svfprintf_r+0x280>
  41459a:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
  41459e:	2300      	movs	r3, #0
  4145a0:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  4145a4:	930f      	str	r3, [sp, #60]	; 0x3c
  4145a6:	9325      	str	r3, [sp, #148]	; 0x94
  4145a8:	9324      	str	r3, [sp, #144]	; 0x90
  4145aa:	9312      	str	r3, [sp, #72]	; 0x48
  4145ac:	9315      	str	r3, [sp, #84]	; 0x54
  4145ae:	9305      	str	r3, [sp, #20]
  4145b0:	f8cd 908c 	str.w	r9, [sp, #140]	; 0x8c
  4145b4:	46c8      	mov	r8, r9
  4145b6:	f89a 3000 	ldrb.w	r3, [sl]
  4145ba:	4654      	mov	r4, sl
  4145bc:	b1e3      	cbz	r3, 4145f8 <_svfprintf_r+0x90>
  4145be:	2b25      	cmp	r3, #37	; 0x25
  4145c0:	d102      	bne.n	4145c8 <_svfprintf_r+0x60>
  4145c2:	e019      	b.n	4145f8 <_svfprintf_r+0x90>
  4145c4:	2b25      	cmp	r3, #37	; 0x25
  4145c6:	d003      	beq.n	4145d0 <_svfprintf_r+0x68>
  4145c8:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  4145cc:	2b00      	cmp	r3, #0
  4145ce:	d1f9      	bne.n	4145c4 <_svfprintf_r+0x5c>
  4145d0:	eba4 050a 	sub.w	r5, r4, sl
  4145d4:	b185      	cbz	r5, 4145f8 <_svfprintf_r+0x90>
  4145d6:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4145d8:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4145da:	f8c8 a000 	str.w	sl, [r8]
  4145de:	3301      	adds	r3, #1
  4145e0:	442a      	add	r2, r5
  4145e2:	2b07      	cmp	r3, #7
  4145e4:	f8c8 5004 	str.w	r5, [r8, #4]
  4145e8:	9225      	str	r2, [sp, #148]	; 0x94
  4145ea:	9324      	str	r3, [sp, #144]	; 0x90
  4145ec:	dc7f      	bgt.n	4146ee <_svfprintf_r+0x186>
  4145ee:	f108 0808 	add.w	r8, r8, #8
  4145f2:	9b05      	ldr	r3, [sp, #20]
  4145f4:	442b      	add	r3, r5
  4145f6:	9305      	str	r3, [sp, #20]
  4145f8:	7823      	ldrb	r3, [r4, #0]
  4145fa:	2b00      	cmp	r3, #0
  4145fc:	d07f      	beq.n	4146fe <_svfprintf_r+0x196>
  4145fe:	2300      	movs	r3, #0
  414600:	461a      	mov	r2, r3
  414602:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  414606:	4619      	mov	r1, r3
  414608:	9309      	str	r3, [sp, #36]	; 0x24
  41460a:	469b      	mov	fp, r3
  41460c:	f04f 30ff 	mov.w	r0, #4294967295
  414610:	7863      	ldrb	r3, [r4, #1]
  414612:	9006      	str	r0, [sp, #24]
  414614:	f104 0a01 	add.w	sl, r4, #1
  414618:	f10a 0a01 	add.w	sl, sl, #1
  41461c:	f1a3 0020 	sub.w	r0, r3, #32
  414620:	2858      	cmp	r0, #88	; 0x58
  414622:	f200 83d3 	bhi.w	414dcc <_svfprintf_r+0x864>
  414626:	e8df f010 	tbh	[pc, r0, lsl #1]
  41462a:	023f      	.short	0x023f
  41462c:	03d103d1 	.word	0x03d103d1
  414630:	03d10247 	.word	0x03d10247
  414634:	03d103d1 	.word	0x03d103d1
  414638:	03d103d1 	.word	0x03d103d1
  41463c:	024c03d1 	.word	0x024c03d1
  414640:	03d1020a 	.word	0x03d1020a
  414644:	0273005d 	.word	0x0273005d
  414648:	028e03d1 	.word	0x028e03d1
  41464c:	03c103c1 	.word	0x03c103c1
  414650:	03c103c1 	.word	0x03c103c1
  414654:	03c103c1 	.word	0x03c103c1
  414658:	03c103c1 	.word	0x03c103c1
  41465c:	03d103c1 	.word	0x03d103c1
  414660:	03d103d1 	.word	0x03d103d1
  414664:	03d103d1 	.word	0x03d103d1
  414668:	03d103d1 	.word	0x03d103d1
  41466c:	03d103d1 	.word	0x03d103d1
  414670:	033f03d1 	.word	0x033f03d1
  414674:	03d1035f 	.word	0x03d1035f
  414678:	03d1035f 	.word	0x03d1035f
  41467c:	03d103d1 	.word	0x03d103d1
  414680:	03aa03d1 	.word	0x03aa03d1
  414684:	03d103d1 	.word	0x03d103d1
  414688:	03d103af 	.word	0x03d103af
  41468c:	03d103d1 	.word	0x03d103d1
  414690:	03d103d1 	.word	0x03d103d1
  414694:	03d10261 	.word	0x03d10261
  414698:	032603d1 	.word	0x032603d1
  41469c:	03d103d1 	.word	0x03d103d1
  4146a0:	03d103d1 	.word	0x03d103d1
  4146a4:	03d103d1 	.word	0x03d103d1
  4146a8:	03d103d1 	.word	0x03d103d1
  4146ac:	03d103d1 	.word	0x03d103d1
  4146b0:	02e302ce 	.word	0x02e302ce
  4146b4:	035f035f 	.word	0x035f035f
  4146b8:	0293035f 	.word	0x0293035f
  4146bc:	03d102e3 	.word	0x03d102e3
  4146c0:	029803d1 	.word	0x029803d1
  4146c4:	02a503d1 	.word	0x02a503d1
  4146c8:	02bc01d3 	.word	0x02bc01d3
  4146cc:	03d1020f 	.word	0x03d1020f
  4146d0:	03d101e8 	.word	0x03d101e8
  4146d4:	03d1007e 	.word	0x03d1007e
  4146d8:	021403d1 	.word	0x021403d1
  4146dc:	9809      	ldr	r0, [sp, #36]	; 0x24
  4146de:	930b      	str	r3, [sp, #44]	; 0x2c
  4146e0:	4240      	negs	r0, r0
  4146e2:	9009      	str	r0, [sp, #36]	; 0x24
  4146e4:	f04b 0b04 	orr.w	fp, fp, #4
  4146e8:	f89a 3000 	ldrb.w	r3, [sl]
  4146ec:	e794      	b.n	414618 <_svfprintf_r+0xb0>
  4146ee:	aa23      	add	r2, sp, #140	; 0x8c
  4146f0:	9907      	ldr	r1, [sp, #28]
  4146f2:	9808      	ldr	r0, [sp, #32]
  4146f4:	f003 f852 	bl	41779c <__ssprint_r>
  4146f8:	b940      	cbnz	r0, 41470c <_svfprintf_r+0x1a4>
  4146fa:	46c8      	mov	r8, r9
  4146fc:	e779      	b.n	4145f2 <_svfprintf_r+0x8a>
  4146fe:	9b25      	ldr	r3, [sp, #148]	; 0x94
  414700:	b123      	cbz	r3, 41470c <_svfprintf_r+0x1a4>
  414702:	9808      	ldr	r0, [sp, #32]
  414704:	9907      	ldr	r1, [sp, #28]
  414706:	aa23      	add	r2, sp, #140	; 0x8c
  414708:	f003 f848 	bl	41779c <__ssprint_r>
  41470c:	9b07      	ldr	r3, [sp, #28]
  41470e:	899b      	ldrh	r3, [r3, #12]
  414710:	f013 0f40 	tst.w	r3, #64	; 0x40
  414714:	9b05      	ldr	r3, [sp, #20]
  414716:	bf18      	it	ne
  414718:	f04f 33ff 	movne.w	r3, #4294967295
  41471c:	9305      	str	r3, [sp, #20]
  41471e:	9805      	ldr	r0, [sp, #20]
  414720:	b041      	add	sp, #260	; 0x104
  414722:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  414726:	f01b 0f20 	tst.w	fp, #32
  41472a:	930d      	str	r3, [sp, #52]	; 0x34
  41472c:	f040 81e5 	bne.w	414afa <_svfprintf_r+0x592>
  414730:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  414732:	f01b 0f10 	tst.w	fp, #16
  414736:	4613      	mov	r3, r2
  414738:	f040 8588 	bne.w	41524c <_svfprintf_r+0xce4>
  41473c:	f01b 0f40 	tst.w	fp, #64	; 0x40
  414740:	f000 8584 	beq.w	41524c <_svfprintf_r+0xce4>
  414744:	8814      	ldrh	r4, [r2, #0]
  414746:	3204      	adds	r2, #4
  414748:	2500      	movs	r5, #0
  41474a:	2301      	movs	r3, #1
  41474c:	920b      	str	r2, [sp, #44]	; 0x2c
  41474e:	2700      	movs	r7, #0
  414750:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  414754:	9906      	ldr	r1, [sp, #24]
  414756:	1c4a      	adds	r2, r1, #1
  414758:	f000 826d 	beq.w	414c36 <_svfprintf_r+0x6ce>
  41475c:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
  414760:	9203      	str	r2, [sp, #12]
  414762:	ea54 0205 	orrs.w	r2, r4, r5
  414766:	f040 826c 	bne.w	414c42 <_svfprintf_r+0x6da>
  41476a:	2900      	cmp	r1, #0
  41476c:	f040 8451 	bne.w	415012 <_svfprintf_r+0xaaa>
  414770:	2b00      	cmp	r3, #0
  414772:	f040 850b 	bne.w	41518c <_svfprintf_r+0xc24>
  414776:	f01b 0301 	ands.w	r3, fp, #1
  41477a:	930a      	str	r3, [sp, #40]	; 0x28
  41477c:	f000 861a 	beq.w	4153b4 <_svfprintf_r+0xe4c>
  414780:	ae40      	add	r6, sp, #256	; 0x100
  414782:	2330      	movs	r3, #48	; 0x30
  414784:	f806 3d41 	strb.w	r3, [r6, #-65]!
  414788:	9b06      	ldr	r3, [sp, #24]
  41478a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  41478c:	4293      	cmp	r3, r2
  41478e:	bfb8      	it	lt
  414790:	4613      	movlt	r3, r2
  414792:	9304      	str	r3, [sp, #16]
  414794:	2300      	movs	r3, #0
  414796:	930e      	str	r3, [sp, #56]	; 0x38
  414798:	b117      	cbz	r7, 4147a0 <_svfprintf_r+0x238>
  41479a:	9b04      	ldr	r3, [sp, #16]
  41479c:	3301      	adds	r3, #1
  41479e:	9304      	str	r3, [sp, #16]
  4147a0:	9b03      	ldr	r3, [sp, #12]
  4147a2:	f013 0302 	ands.w	r3, r3, #2
  4147a6:	930c      	str	r3, [sp, #48]	; 0x30
  4147a8:	d002      	beq.n	4147b0 <_svfprintf_r+0x248>
  4147aa:	9b04      	ldr	r3, [sp, #16]
  4147ac:	3302      	adds	r3, #2
  4147ae:	9304      	str	r3, [sp, #16]
  4147b0:	9b03      	ldr	r3, [sp, #12]
  4147b2:	f013 0584 	ands.w	r5, r3, #132	; 0x84
  4147b6:	f040 8320 	bne.w	414dfa <_svfprintf_r+0x892>
  4147ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4147bc:	9a04      	ldr	r2, [sp, #16]
  4147be:	eba3 0b02 	sub.w	fp, r3, r2
  4147c2:	f1bb 0f00 	cmp.w	fp, #0
  4147c6:	f340 8318 	ble.w	414dfa <_svfprintf_r+0x892>
  4147ca:	f1bb 0f10 	cmp.w	fp, #16
  4147ce:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4147d0:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4147d2:	dd30      	ble.n	414836 <_svfprintf_r+0x2ce>
  4147d4:	4643      	mov	r3, r8
  4147d6:	4621      	mov	r1, r4
  4147d8:	46a8      	mov	r8, r5
  4147da:	2710      	movs	r7, #16
  4147dc:	9c08      	ldr	r4, [sp, #32]
  4147de:	9d07      	ldr	r5, [sp, #28]
  4147e0:	e00d      	b.n	4147fe <_svfprintf_r+0x296>
  4147e2:	bf00      	nop
  4147e4:	f3af 8000 	nop.w
	...
  4147f0:	f1ab 0b10 	sub.w	fp, fp, #16
  4147f4:	f1bb 0f10 	cmp.w	fp, #16
  4147f8:	f103 0308 	add.w	r3, r3, #8
  4147fc:	dd18      	ble.n	414830 <_svfprintf_r+0x2c8>
  4147fe:	3201      	adds	r2, #1
  414800:	48b7      	ldr	r0, [pc, #732]	; (414ae0 <_svfprintf_r+0x578>)
  414802:	9224      	str	r2, [sp, #144]	; 0x90
  414804:	3110      	adds	r1, #16
  414806:	2a07      	cmp	r2, #7
  414808:	9125      	str	r1, [sp, #148]	; 0x94
  41480a:	e883 0081 	stmia.w	r3, {r0, r7}
  41480e:	ddef      	ble.n	4147f0 <_svfprintf_r+0x288>
  414810:	aa23      	add	r2, sp, #140	; 0x8c
  414812:	4629      	mov	r1, r5
  414814:	4620      	mov	r0, r4
  414816:	f002 ffc1 	bl	41779c <__ssprint_r>
  41481a:	2800      	cmp	r0, #0
  41481c:	f47f af76 	bne.w	41470c <_svfprintf_r+0x1a4>
  414820:	f1ab 0b10 	sub.w	fp, fp, #16
  414824:	f1bb 0f10 	cmp.w	fp, #16
  414828:	9925      	ldr	r1, [sp, #148]	; 0x94
  41482a:	9a24      	ldr	r2, [sp, #144]	; 0x90
  41482c:	464b      	mov	r3, r9
  41482e:	dce6      	bgt.n	4147fe <_svfprintf_r+0x296>
  414830:	4645      	mov	r5, r8
  414832:	460c      	mov	r4, r1
  414834:	4698      	mov	r8, r3
  414836:	3201      	adds	r2, #1
  414838:	4ba9      	ldr	r3, [pc, #676]	; (414ae0 <_svfprintf_r+0x578>)
  41483a:	9224      	str	r2, [sp, #144]	; 0x90
  41483c:	445c      	add	r4, fp
  41483e:	2a07      	cmp	r2, #7
  414840:	9425      	str	r4, [sp, #148]	; 0x94
  414842:	e888 0808 	stmia.w	r8, {r3, fp}
  414846:	f300 84a6 	bgt.w	415196 <_svfprintf_r+0xc2e>
  41484a:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  41484e:	f108 0808 	add.w	r8, r8, #8
  414852:	b177      	cbz	r7, 414872 <_svfprintf_r+0x30a>
  414854:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414856:	3301      	adds	r3, #1
  414858:	3401      	adds	r4, #1
  41485a:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
  41485e:	2201      	movs	r2, #1
  414860:	2b07      	cmp	r3, #7
  414862:	9425      	str	r4, [sp, #148]	; 0x94
  414864:	9324      	str	r3, [sp, #144]	; 0x90
  414866:	e888 0006 	stmia.w	r8, {r1, r2}
  41486a:	f300 83f4 	bgt.w	415056 <_svfprintf_r+0xaee>
  41486e:	f108 0808 	add.w	r8, r8, #8
  414872:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  414874:	b16b      	cbz	r3, 414892 <_svfprintf_r+0x32a>
  414876:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414878:	3301      	adds	r3, #1
  41487a:	3402      	adds	r4, #2
  41487c:	a91c      	add	r1, sp, #112	; 0x70
  41487e:	2202      	movs	r2, #2
  414880:	2b07      	cmp	r3, #7
  414882:	9425      	str	r4, [sp, #148]	; 0x94
  414884:	9324      	str	r3, [sp, #144]	; 0x90
  414886:	e888 0006 	stmia.w	r8, {r1, r2}
  41488a:	f300 83d9 	bgt.w	415040 <_svfprintf_r+0xad8>
  41488e:	f108 0808 	add.w	r8, r8, #8
  414892:	2d80      	cmp	r5, #128	; 0x80
  414894:	f000 8322 	beq.w	414edc <_svfprintf_r+0x974>
  414898:	9b06      	ldr	r3, [sp, #24]
  41489a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  41489c:	1a9f      	subs	r7, r3, r2
  41489e:	2f00      	cmp	r7, #0
  4148a0:	dd36      	ble.n	414910 <_svfprintf_r+0x3a8>
  4148a2:	2f10      	cmp	r7, #16
  4148a4:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4148a6:	4d8f      	ldr	r5, [pc, #572]	; (414ae4 <_svfprintf_r+0x57c>)
  4148a8:	dd27      	ble.n	4148fa <_svfprintf_r+0x392>
  4148aa:	4642      	mov	r2, r8
  4148ac:	4621      	mov	r1, r4
  4148ae:	46b0      	mov	r8, r6
  4148b0:	f04f 0b10 	mov.w	fp, #16
  4148b4:	462e      	mov	r6, r5
  4148b6:	9c08      	ldr	r4, [sp, #32]
  4148b8:	9d07      	ldr	r5, [sp, #28]
  4148ba:	e004      	b.n	4148c6 <_svfprintf_r+0x35e>
  4148bc:	3f10      	subs	r7, #16
  4148be:	2f10      	cmp	r7, #16
  4148c0:	f102 0208 	add.w	r2, r2, #8
  4148c4:	dd15      	ble.n	4148f2 <_svfprintf_r+0x38a>
  4148c6:	3301      	adds	r3, #1
  4148c8:	3110      	adds	r1, #16
  4148ca:	2b07      	cmp	r3, #7
  4148cc:	9125      	str	r1, [sp, #148]	; 0x94
  4148ce:	9324      	str	r3, [sp, #144]	; 0x90
  4148d0:	e882 0840 	stmia.w	r2, {r6, fp}
  4148d4:	ddf2      	ble.n	4148bc <_svfprintf_r+0x354>
  4148d6:	aa23      	add	r2, sp, #140	; 0x8c
  4148d8:	4629      	mov	r1, r5
  4148da:	4620      	mov	r0, r4
  4148dc:	f002 ff5e 	bl	41779c <__ssprint_r>
  4148e0:	2800      	cmp	r0, #0
  4148e2:	f47f af13 	bne.w	41470c <_svfprintf_r+0x1a4>
  4148e6:	3f10      	subs	r7, #16
  4148e8:	2f10      	cmp	r7, #16
  4148ea:	9925      	ldr	r1, [sp, #148]	; 0x94
  4148ec:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4148ee:	464a      	mov	r2, r9
  4148f0:	dce9      	bgt.n	4148c6 <_svfprintf_r+0x35e>
  4148f2:	4635      	mov	r5, r6
  4148f4:	460c      	mov	r4, r1
  4148f6:	4646      	mov	r6, r8
  4148f8:	4690      	mov	r8, r2
  4148fa:	3301      	adds	r3, #1
  4148fc:	443c      	add	r4, r7
  4148fe:	2b07      	cmp	r3, #7
  414900:	9425      	str	r4, [sp, #148]	; 0x94
  414902:	9324      	str	r3, [sp, #144]	; 0x90
  414904:	e888 00a0 	stmia.w	r8, {r5, r7}
  414908:	f300 838f 	bgt.w	41502a <_svfprintf_r+0xac2>
  41490c:	f108 0808 	add.w	r8, r8, #8
  414910:	9b03      	ldr	r3, [sp, #12]
  414912:	05df      	lsls	r7, r3, #23
  414914:	f100 8273 	bmi.w	414dfe <_svfprintf_r+0x896>
  414918:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41491a:	990a      	ldr	r1, [sp, #40]	; 0x28
  41491c:	f8c8 6000 	str.w	r6, [r8]
  414920:	3301      	adds	r3, #1
  414922:	440c      	add	r4, r1
  414924:	2b07      	cmp	r3, #7
  414926:	9425      	str	r4, [sp, #148]	; 0x94
  414928:	f8c8 1004 	str.w	r1, [r8, #4]
  41492c:	9324      	str	r3, [sp, #144]	; 0x90
  41492e:	f300 835b 	bgt.w	414fe8 <_svfprintf_r+0xa80>
  414932:	f108 0808 	add.w	r8, r8, #8
  414936:	9b03      	ldr	r3, [sp, #12]
  414938:	075b      	lsls	r3, r3, #29
  41493a:	d53a      	bpl.n	4149b2 <_svfprintf_r+0x44a>
  41493c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  41493e:	9a04      	ldr	r2, [sp, #16]
  414940:	1a9d      	subs	r5, r3, r2
  414942:	2d00      	cmp	r5, #0
  414944:	dd35      	ble.n	4149b2 <_svfprintf_r+0x44a>
  414946:	2d10      	cmp	r5, #16
  414948:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41494a:	dd20      	ble.n	41498e <_svfprintf_r+0x426>
  41494c:	2610      	movs	r6, #16
  41494e:	9f08      	ldr	r7, [sp, #32]
  414950:	f8dd b01c 	ldr.w	fp, [sp, #28]
  414954:	e004      	b.n	414960 <_svfprintf_r+0x3f8>
  414956:	3d10      	subs	r5, #16
  414958:	2d10      	cmp	r5, #16
  41495a:	f108 0808 	add.w	r8, r8, #8
  41495e:	dd16      	ble.n	41498e <_svfprintf_r+0x426>
  414960:	3301      	adds	r3, #1
  414962:	4a5f      	ldr	r2, [pc, #380]	; (414ae0 <_svfprintf_r+0x578>)
  414964:	9324      	str	r3, [sp, #144]	; 0x90
  414966:	3410      	adds	r4, #16
  414968:	2b07      	cmp	r3, #7
  41496a:	9425      	str	r4, [sp, #148]	; 0x94
  41496c:	e888 0044 	stmia.w	r8, {r2, r6}
  414970:	ddf1      	ble.n	414956 <_svfprintf_r+0x3ee>
  414972:	aa23      	add	r2, sp, #140	; 0x8c
  414974:	4659      	mov	r1, fp
  414976:	4638      	mov	r0, r7
  414978:	f002 ff10 	bl	41779c <__ssprint_r>
  41497c:	2800      	cmp	r0, #0
  41497e:	f47f aec5 	bne.w	41470c <_svfprintf_r+0x1a4>
  414982:	3d10      	subs	r5, #16
  414984:	2d10      	cmp	r5, #16
  414986:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414988:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41498a:	46c8      	mov	r8, r9
  41498c:	dce8      	bgt.n	414960 <_svfprintf_r+0x3f8>
  41498e:	3301      	adds	r3, #1
  414990:	4a53      	ldr	r2, [pc, #332]	; (414ae0 <_svfprintf_r+0x578>)
  414992:	9324      	str	r3, [sp, #144]	; 0x90
  414994:	442c      	add	r4, r5
  414996:	2b07      	cmp	r3, #7
  414998:	9425      	str	r4, [sp, #148]	; 0x94
  41499a:	e888 0024 	stmia.w	r8, {r2, r5}
  41499e:	dd08      	ble.n	4149b2 <_svfprintf_r+0x44a>
  4149a0:	aa23      	add	r2, sp, #140	; 0x8c
  4149a2:	9907      	ldr	r1, [sp, #28]
  4149a4:	9808      	ldr	r0, [sp, #32]
  4149a6:	f002 fef9 	bl	41779c <__ssprint_r>
  4149aa:	2800      	cmp	r0, #0
  4149ac:	f47f aeae 	bne.w	41470c <_svfprintf_r+0x1a4>
  4149b0:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4149b2:	9b05      	ldr	r3, [sp, #20]
  4149b4:	9a09      	ldr	r2, [sp, #36]	; 0x24
  4149b6:	9904      	ldr	r1, [sp, #16]
  4149b8:	428a      	cmp	r2, r1
  4149ba:	bfac      	ite	ge
  4149bc:	189b      	addge	r3, r3, r2
  4149be:	185b      	addlt	r3, r3, r1
  4149c0:	9305      	str	r3, [sp, #20]
  4149c2:	2c00      	cmp	r4, #0
  4149c4:	f040 831b 	bne.w	414ffe <_svfprintf_r+0xa96>
  4149c8:	2300      	movs	r3, #0
  4149ca:	9324      	str	r3, [sp, #144]	; 0x90
  4149cc:	46c8      	mov	r8, r9
  4149ce:	e5f2      	b.n	4145b6 <_svfprintf_r+0x4e>
  4149d0:	930d      	str	r3, [sp, #52]	; 0x34
  4149d2:	f01b 0320 	ands.w	r3, fp, #32
  4149d6:	f040 81de 	bne.w	414d96 <_svfprintf_r+0x82e>
  4149da:	f01b 0210 	ands.w	r2, fp, #16
  4149de:	f040 842d 	bne.w	41523c <_svfprintf_r+0xcd4>
  4149e2:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
  4149e6:	f000 8429 	beq.w	41523c <_svfprintf_r+0xcd4>
  4149ea:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4149ec:	4613      	mov	r3, r2
  4149ee:	460a      	mov	r2, r1
  4149f0:	3204      	adds	r2, #4
  4149f2:	880c      	ldrh	r4, [r1, #0]
  4149f4:	920b      	str	r2, [sp, #44]	; 0x2c
  4149f6:	2500      	movs	r5, #0
  4149f8:	e6a9      	b.n	41474e <_svfprintf_r+0x1e6>
  4149fa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4149fc:	930d      	str	r3, [sp, #52]	; 0x34
  4149fe:	6816      	ldr	r6, [r2, #0]
  414a00:	2400      	movs	r4, #0
  414a02:	f88d 406f 	strb.w	r4, [sp, #111]	; 0x6f
  414a06:	1d15      	adds	r5, r2, #4
  414a08:	2e00      	cmp	r6, #0
  414a0a:	f000 86b5 	beq.w	415778 <_svfprintf_r+0x1210>
  414a0e:	9a06      	ldr	r2, [sp, #24]
  414a10:	1c53      	adds	r3, r2, #1
  414a12:	f000 8617 	beq.w	415644 <_svfprintf_r+0x10dc>
  414a16:	4621      	mov	r1, r4
  414a18:	4630      	mov	r0, r6
  414a1a:	f002 fae1 	bl	416fe0 <memchr>
  414a1e:	2800      	cmp	r0, #0
  414a20:	f000 8708 	beq.w	415834 <_svfprintf_r+0x12cc>
  414a24:	1b83      	subs	r3, r0, r6
  414a26:	930a      	str	r3, [sp, #40]	; 0x28
  414a28:	9406      	str	r4, [sp, #24]
  414a2a:	950b      	str	r5, [sp, #44]	; 0x2c
  414a2c:	f8cd b00c 	str.w	fp, [sp, #12]
  414a30:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  414a34:	9304      	str	r3, [sp, #16]
  414a36:	940e      	str	r4, [sp, #56]	; 0x38
  414a38:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  414a3c:	e6ac      	b.n	414798 <_svfprintf_r+0x230>
  414a3e:	f89a 3000 	ldrb.w	r3, [sl]
  414a42:	2201      	movs	r2, #1
  414a44:	212b      	movs	r1, #43	; 0x2b
  414a46:	e5e7      	b.n	414618 <_svfprintf_r+0xb0>
  414a48:	f04b 0b20 	orr.w	fp, fp, #32
  414a4c:	f89a 3000 	ldrb.w	r3, [sl]
  414a50:	e5e2      	b.n	414618 <_svfprintf_r+0xb0>
  414a52:	930d      	str	r3, [sp, #52]	; 0x34
  414a54:	2a00      	cmp	r2, #0
  414a56:	f040 87aa 	bne.w	4159ae <_svfprintf_r+0x1446>
  414a5a:	4b23      	ldr	r3, [pc, #140]	; (414ae8 <_svfprintf_r+0x580>)
  414a5c:	9312      	str	r3, [sp, #72]	; 0x48
  414a5e:	f01b 0f20 	tst.w	fp, #32
  414a62:	f040 8112 	bne.w	414c8a <_svfprintf_r+0x722>
  414a66:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  414a68:	f01b 0f10 	tst.w	fp, #16
  414a6c:	4613      	mov	r3, r2
  414a6e:	f040 83e0 	bne.w	415232 <_svfprintf_r+0xcca>
  414a72:	f01b 0f40 	tst.w	fp, #64	; 0x40
  414a76:	f000 83dc 	beq.w	415232 <_svfprintf_r+0xcca>
  414a7a:	3304      	adds	r3, #4
  414a7c:	8814      	ldrh	r4, [r2, #0]
  414a7e:	930b      	str	r3, [sp, #44]	; 0x2c
  414a80:	2500      	movs	r5, #0
  414a82:	f01b 0f01 	tst.w	fp, #1
  414a86:	f000 810d 	beq.w	414ca4 <_svfprintf_r+0x73c>
  414a8a:	ea54 0305 	orrs.w	r3, r4, r5
  414a8e:	f000 8109 	beq.w	414ca4 <_svfprintf_r+0x73c>
  414a92:	2330      	movs	r3, #48	; 0x30
  414a94:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
  414a98:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
  414a9c:	f88d 2071 	strb.w	r2, [sp, #113]	; 0x71
  414aa0:	f04b 0b02 	orr.w	fp, fp, #2
  414aa4:	2302      	movs	r3, #2
  414aa6:	e652      	b.n	41474e <_svfprintf_r+0x1e6>
  414aa8:	f89a 3000 	ldrb.w	r3, [sl]
  414aac:	2900      	cmp	r1, #0
  414aae:	f47f adb3 	bne.w	414618 <_svfprintf_r+0xb0>
  414ab2:	2201      	movs	r2, #1
  414ab4:	2120      	movs	r1, #32
  414ab6:	e5af      	b.n	414618 <_svfprintf_r+0xb0>
  414ab8:	f04b 0b01 	orr.w	fp, fp, #1
  414abc:	f89a 3000 	ldrb.w	r3, [sl]
  414ac0:	e5aa      	b.n	414618 <_svfprintf_r+0xb0>
  414ac2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  414ac4:	6823      	ldr	r3, [r4, #0]
  414ac6:	9309      	str	r3, [sp, #36]	; 0x24
  414ac8:	4618      	mov	r0, r3
  414aca:	2800      	cmp	r0, #0
  414acc:	4623      	mov	r3, r4
  414ace:	f103 0304 	add.w	r3, r3, #4
  414ad2:	f6ff ae03 	blt.w	4146dc <_svfprintf_r+0x174>
  414ad6:	930b      	str	r3, [sp, #44]	; 0x2c
  414ad8:	f89a 3000 	ldrb.w	r3, [sl]
  414adc:	e59c      	b.n	414618 <_svfprintf_r+0xb0>
  414ade:	bf00      	nop
  414ae0:	0041d848 	.word	0x0041d848
  414ae4:	0041d858 	.word	0x0041d858
  414ae8:	0041d828 	.word	0x0041d828
  414aec:	f04b 0b10 	orr.w	fp, fp, #16
  414af0:	f01b 0f20 	tst.w	fp, #32
  414af4:	930d      	str	r3, [sp, #52]	; 0x34
  414af6:	f43f ae1b 	beq.w	414730 <_svfprintf_r+0x1c8>
  414afa:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414afc:	3507      	adds	r5, #7
  414afe:	f025 0307 	bic.w	r3, r5, #7
  414b02:	f103 0208 	add.w	r2, r3, #8
  414b06:	e9d3 4500 	ldrd	r4, r5, [r3]
  414b0a:	920b      	str	r2, [sp, #44]	; 0x2c
  414b0c:	2301      	movs	r3, #1
  414b0e:	e61e      	b.n	41474e <_svfprintf_r+0x1e6>
  414b10:	f89a 3000 	ldrb.w	r3, [sl]
  414b14:	2b2a      	cmp	r3, #42	; 0x2a
  414b16:	f10a 0401 	add.w	r4, sl, #1
  414b1a:	f000 873b 	beq.w	415994 <_svfprintf_r+0x142c>
  414b1e:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  414b22:	2809      	cmp	r0, #9
  414b24:	46a2      	mov	sl, r4
  414b26:	f200 8691 	bhi.w	41584c <_svfprintf_r+0x12e4>
  414b2a:	2300      	movs	r3, #0
  414b2c:	461c      	mov	r4, r3
  414b2e:	f81a 3b01 	ldrb.w	r3, [sl], #1
  414b32:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  414b36:	eb00 0444 	add.w	r4, r0, r4, lsl #1
  414b3a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  414b3e:	2809      	cmp	r0, #9
  414b40:	d9f5      	bls.n	414b2e <_svfprintf_r+0x5c6>
  414b42:	9406      	str	r4, [sp, #24]
  414b44:	e56a      	b.n	41461c <_svfprintf_r+0xb4>
  414b46:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
  414b4a:	f89a 3000 	ldrb.w	r3, [sl]
  414b4e:	e563      	b.n	414618 <_svfprintf_r+0xb0>
  414b50:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
  414b54:	f89a 3000 	ldrb.w	r3, [sl]
  414b58:	e55e      	b.n	414618 <_svfprintf_r+0xb0>
  414b5a:	f89a 3000 	ldrb.w	r3, [sl]
  414b5e:	2b6c      	cmp	r3, #108	; 0x6c
  414b60:	bf03      	ittte	eq
  414b62:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
  414b66:	f04b 0b20 	orreq.w	fp, fp, #32
  414b6a:	f10a 0a01 	addeq.w	sl, sl, #1
  414b6e:	f04b 0b10 	orrne.w	fp, fp, #16
  414b72:	e551      	b.n	414618 <_svfprintf_r+0xb0>
  414b74:	2a00      	cmp	r2, #0
  414b76:	f040 871e 	bne.w	4159b6 <_svfprintf_r+0x144e>
  414b7a:	f01b 0f20 	tst.w	fp, #32
  414b7e:	f040 8509 	bne.w	415594 <_svfprintf_r+0x102c>
  414b82:	f01b 0f10 	tst.w	fp, #16
  414b86:	f040 84bc 	bne.w	415502 <_svfprintf_r+0xf9a>
  414b8a:	f01b 0f40 	tst.w	fp, #64	; 0x40
  414b8e:	f000 84b8 	beq.w	415502 <_svfprintf_r+0xf9a>
  414b92:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  414b94:	6813      	ldr	r3, [r2, #0]
  414b96:	3204      	adds	r2, #4
  414b98:	920b      	str	r2, [sp, #44]	; 0x2c
  414b9a:	f8bd 2014 	ldrh.w	r2, [sp, #20]
  414b9e:	801a      	strh	r2, [r3, #0]
  414ba0:	e509      	b.n	4145b6 <_svfprintf_r+0x4e>
  414ba2:	990b      	ldr	r1, [sp, #44]	; 0x2c
  414ba4:	4bb9      	ldr	r3, [pc, #740]	; (414e8c <_svfprintf_r+0x924>)
  414ba6:	680c      	ldr	r4, [r1, #0]
  414ba8:	9312      	str	r3, [sp, #72]	; 0x48
  414baa:	2230      	movs	r2, #48	; 0x30
  414bac:	2378      	movs	r3, #120	; 0x78
  414bae:	3104      	adds	r1, #4
  414bb0:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
  414bb4:	930d      	str	r3, [sp, #52]	; 0x34
  414bb6:	f04b 0b02 	orr.w	fp, fp, #2
  414bba:	910b      	str	r1, [sp, #44]	; 0x2c
  414bbc:	2500      	movs	r5, #0
  414bbe:	f88d 2070 	strb.w	r2, [sp, #112]	; 0x70
  414bc2:	2302      	movs	r3, #2
  414bc4:	e5c3      	b.n	41474e <_svfprintf_r+0x1e6>
  414bc6:	990b      	ldr	r1, [sp, #44]	; 0x2c
  414bc8:	930d      	str	r3, [sp, #52]	; 0x34
  414bca:	680a      	ldr	r2, [r1, #0]
  414bcc:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  414bd0:	2300      	movs	r3, #0
  414bd2:	460a      	mov	r2, r1
  414bd4:	461f      	mov	r7, r3
  414bd6:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  414bda:	3204      	adds	r2, #4
  414bdc:	2301      	movs	r3, #1
  414bde:	9304      	str	r3, [sp, #16]
  414be0:	f8cd b00c 	str.w	fp, [sp, #12]
  414be4:	9706      	str	r7, [sp, #24]
  414be6:	970e      	str	r7, [sp, #56]	; 0x38
  414be8:	920b      	str	r2, [sp, #44]	; 0x2c
  414bea:	930a      	str	r3, [sp, #40]	; 0x28
  414bec:	ae26      	add	r6, sp, #152	; 0x98
  414bee:	e5d7      	b.n	4147a0 <_svfprintf_r+0x238>
  414bf0:	930d      	str	r3, [sp, #52]	; 0x34
  414bf2:	2a00      	cmp	r2, #0
  414bf4:	f040 86fe 	bne.w	4159f4 <_svfprintf_r+0x148c>
  414bf8:	f01b 0f20 	tst.w	fp, #32
  414bfc:	d15d      	bne.n	414cba <_svfprintf_r+0x752>
  414bfe:	f01b 0f10 	tst.w	fp, #16
  414c02:	f040 8335 	bne.w	415270 <_svfprintf_r+0xd08>
  414c06:	f01b 0f40 	tst.w	fp, #64	; 0x40
  414c0a:	f000 8331 	beq.w	415270 <_svfprintf_r+0xd08>
  414c0e:	990b      	ldr	r1, [sp, #44]	; 0x2c
  414c10:	f9b1 4000 	ldrsh.w	r4, [r1]
  414c14:	3104      	adds	r1, #4
  414c16:	17e5      	asrs	r5, r4, #31
  414c18:	4622      	mov	r2, r4
  414c1a:	462b      	mov	r3, r5
  414c1c:	910b      	str	r1, [sp, #44]	; 0x2c
  414c1e:	2a00      	cmp	r2, #0
  414c20:	f173 0300 	sbcs.w	r3, r3, #0
  414c24:	db58      	blt.n	414cd8 <_svfprintf_r+0x770>
  414c26:	9906      	ldr	r1, [sp, #24]
  414c28:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  414c2c:	1c4a      	adds	r2, r1, #1
  414c2e:	f04f 0301 	mov.w	r3, #1
  414c32:	f47f ad93 	bne.w	41475c <_svfprintf_r+0x1f4>
  414c36:	ea54 0205 	orrs.w	r2, r4, r5
  414c3a:	f000 81ec 	beq.w	415016 <_svfprintf_r+0xaae>
  414c3e:	f8cd b00c 	str.w	fp, [sp, #12]
  414c42:	2b01      	cmp	r3, #1
  414c44:	f000 8283 	beq.w	41514e <_svfprintf_r+0xbe6>
  414c48:	2b02      	cmp	r3, #2
  414c4a:	f040 8213 	bne.w	415074 <_svfprintf_r+0xb0c>
  414c4e:	9812      	ldr	r0, [sp, #72]	; 0x48
  414c50:	464e      	mov	r6, r9
  414c52:	0923      	lsrs	r3, r4, #4
  414c54:	f004 010f 	and.w	r1, r4, #15
  414c58:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
  414c5c:	092a      	lsrs	r2, r5, #4
  414c5e:	461c      	mov	r4, r3
  414c60:	4615      	mov	r5, r2
  414c62:	5c43      	ldrb	r3, [r0, r1]
  414c64:	f806 3d01 	strb.w	r3, [r6, #-1]!
  414c68:	ea54 0305 	orrs.w	r3, r4, r5
  414c6c:	d1f1      	bne.n	414c52 <_svfprintf_r+0x6ea>
  414c6e:	eba9 0306 	sub.w	r3, r9, r6
  414c72:	930a      	str	r3, [sp, #40]	; 0x28
  414c74:	e588      	b.n	414788 <_svfprintf_r+0x220>
  414c76:	930d      	str	r3, [sp, #52]	; 0x34
  414c78:	2a00      	cmp	r2, #0
  414c7a:	f040 86b7 	bne.w	4159ec <_svfprintf_r+0x1484>
  414c7e:	4b84      	ldr	r3, [pc, #528]	; (414e90 <_svfprintf_r+0x928>)
  414c80:	9312      	str	r3, [sp, #72]	; 0x48
  414c82:	f01b 0f20 	tst.w	fp, #32
  414c86:	f43f aeee 	beq.w	414a66 <_svfprintf_r+0x4fe>
  414c8a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414c8c:	3507      	adds	r5, #7
  414c8e:	f025 0307 	bic.w	r3, r5, #7
  414c92:	f103 0208 	add.w	r2, r3, #8
  414c96:	f01b 0f01 	tst.w	fp, #1
  414c9a:	920b      	str	r2, [sp, #44]	; 0x2c
  414c9c:	e9d3 4500 	ldrd	r4, r5, [r3]
  414ca0:	f47f aef3 	bne.w	414a8a <_svfprintf_r+0x522>
  414ca4:	2302      	movs	r3, #2
  414ca6:	e552      	b.n	41474e <_svfprintf_r+0x1e6>
  414ca8:	930d      	str	r3, [sp, #52]	; 0x34
  414caa:	2a00      	cmp	r2, #0
  414cac:	f040 869a 	bne.w	4159e4 <_svfprintf_r+0x147c>
  414cb0:	f04b 0b10 	orr.w	fp, fp, #16
  414cb4:	f01b 0f20 	tst.w	fp, #32
  414cb8:	d0a1      	beq.n	414bfe <_svfprintf_r+0x696>
  414cba:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414cbc:	3507      	adds	r5, #7
  414cbe:	f025 0507 	bic.w	r5, r5, #7
  414cc2:	e9d5 2300 	ldrd	r2, r3, [r5]
  414cc6:	2a00      	cmp	r2, #0
  414cc8:	f105 0108 	add.w	r1, r5, #8
  414ccc:	461d      	mov	r5, r3
  414cce:	f173 0300 	sbcs.w	r3, r3, #0
  414cd2:	910b      	str	r1, [sp, #44]	; 0x2c
  414cd4:	4614      	mov	r4, r2
  414cd6:	daa6      	bge.n	414c26 <_svfprintf_r+0x6be>
  414cd8:	272d      	movs	r7, #45	; 0x2d
  414cda:	4264      	negs	r4, r4
  414cdc:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  414ce0:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  414ce4:	2301      	movs	r3, #1
  414ce6:	e535      	b.n	414754 <_svfprintf_r+0x1ec>
  414ce8:	930d      	str	r3, [sp, #52]	; 0x34
  414cea:	2a00      	cmp	r2, #0
  414cec:	f040 8676 	bne.w	4159dc <_svfprintf_r+0x1474>
  414cf0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414cf2:	f01b 0f08 	tst.w	fp, #8
  414cf6:	f105 0507 	add.w	r5, r5, #7
  414cfa:	f000 83e8 	beq.w	4154ce <_svfprintf_r+0xf66>
  414cfe:	f025 0307 	bic.w	r3, r5, #7
  414d02:	ed93 7b00 	vldr	d7, [r3]
  414d06:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
  414d0a:	f103 0208 	add.w	r2, r3, #8
  414d0e:	920b      	str	r2, [sp, #44]	; 0x2c
  414d10:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
  414d14:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
  414d18:	9116      	str	r1, [sp, #88]	; 0x58
  414d1a:	9317      	str	r3, [sp, #92]	; 0x5c
  414d1c:	e9dd 4516 	ldrd	r4, r5, [sp, #88]	; 0x58
  414d20:	f04f 32ff 	mov.w	r2, #4294967295
  414d24:	4620      	mov	r0, r4
  414d26:	4629      	mov	r1, r5
  414d28:	4b5a      	ldr	r3, [pc, #360]	; (414e94 <_svfprintf_r+0x92c>)
  414d2a:	f003 f9cf 	bl	4180cc <__aeabi_dcmpun>
  414d2e:	2800      	cmp	r0, #0
  414d30:	f040 834f 	bne.w	4153d2 <_svfprintf_r+0xe6a>
  414d34:	f04f 32ff 	mov.w	r2, #4294967295
  414d38:	4b56      	ldr	r3, [pc, #344]	; (414e94 <_svfprintf_r+0x92c>)
  414d3a:	4620      	mov	r0, r4
  414d3c:	4629      	mov	r1, r5
  414d3e:	f003 f9a7 	bl	418090 <__aeabi_dcmple>
  414d42:	2800      	cmp	r0, #0
  414d44:	f040 8345 	bne.w	4153d2 <_svfprintf_r+0xe6a>
  414d48:	2200      	movs	r2, #0
  414d4a:	2300      	movs	r3, #0
  414d4c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  414d50:	f003 f994 	bl	41807c <__aeabi_dcmplt>
  414d54:	2800      	cmp	r0, #0
  414d56:	f040 8533 	bne.w	4157c0 <_svfprintf_r+0x1258>
  414d5a:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  414d5e:	4e4e      	ldr	r6, [pc, #312]	; (414e98 <_svfprintf_r+0x930>)
  414d60:	4b4e      	ldr	r3, [pc, #312]	; (414e9c <_svfprintf_r+0x934>)
  414d62:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
  414d66:	9003      	str	r0, [sp, #12]
  414d68:	980d      	ldr	r0, [sp, #52]	; 0x34
  414d6a:	2203      	movs	r2, #3
  414d6c:	2100      	movs	r1, #0
  414d6e:	9204      	str	r2, [sp, #16]
  414d70:	9106      	str	r1, [sp, #24]
  414d72:	2847      	cmp	r0, #71	; 0x47
  414d74:	bfd8      	it	le
  414d76:	461e      	movle	r6, r3
  414d78:	920a      	str	r2, [sp, #40]	; 0x28
  414d7a:	910e      	str	r1, [sp, #56]	; 0x38
  414d7c:	e50c      	b.n	414798 <_svfprintf_r+0x230>
  414d7e:	f04b 0b08 	orr.w	fp, fp, #8
  414d82:	f89a 3000 	ldrb.w	r3, [sl]
  414d86:	e447      	b.n	414618 <_svfprintf_r+0xb0>
  414d88:	f04b 0b10 	orr.w	fp, fp, #16
  414d8c:	930d      	str	r3, [sp, #52]	; 0x34
  414d8e:	f01b 0320 	ands.w	r3, fp, #32
  414d92:	f43f ae22 	beq.w	4149da <_svfprintf_r+0x472>
  414d96:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414d98:	3507      	adds	r5, #7
  414d9a:	f025 0307 	bic.w	r3, r5, #7
  414d9e:	f103 0208 	add.w	r2, r3, #8
  414da2:	e9d3 4500 	ldrd	r4, r5, [r3]
  414da6:	920b      	str	r2, [sp, #44]	; 0x2c
  414da8:	2300      	movs	r3, #0
  414daa:	e4d0      	b.n	41474e <_svfprintf_r+0x1e6>
  414dac:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  414db0:	2300      	movs	r3, #0
  414db2:	461c      	mov	r4, r3
  414db4:	f81a 3b01 	ldrb.w	r3, [sl], #1
  414db8:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  414dbc:	eb00 0444 	add.w	r4, r0, r4, lsl #1
  414dc0:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  414dc4:	2809      	cmp	r0, #9
  414dc6:	d9f5      	bls.n	414db4 <_svfprintf_r+0x84c>
  414dc8:	9409      	str	r4, [sp, #36]	; 0x24
  414dca:	e427      	b.n	41461c <_svfprintf_r+0xb4>
  414dcc:	930d      	str	r3, [sp, #52]	; 0x34
  414dce:	2a00      	cmp	r2, #0
  414dd0:	f040 85f5 	bne.w	4159be <_svfprintf_r+0x1456>
  414dd4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  414dd6:	2a00      	cmp	r2, #0
  414dd8:	f43f ac91 	beq.w	4146fe <_svfprintf_r+0x196>
  414ddc:	2300      	movs	r3, #0
  414dde:	2101      	movs	r1, #1
  414de0:	461f      	mov	r7, r3
  414de2:	9104      	str	r1, [sp, #16]
  414de4:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  414de8:	f8cd b00c 	str.w	fp, [sp, #12]
  414dec:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  414df0:	9306      	str	r3, [sp, #24]
  414df2:	930e      	str	r3, [sp, #56]	; 0x38
  414df4:	910a      	str	r1, [sp, #40]	; 0x28
  414df6:	ae26      	add	r6, sp, #152	; 0x98
  414df8:	e4d2      	b.n	4147a0 <_svfprintf_r+0x238>
  414dfa:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414dfc:	e529      	b.n	414852 <_svfprintf_r+0x2ea>
  414dfe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  414e00:	2b65      	cmp	r3, #101	; 0x65
  414e02:	f340 80a9 	ble.w	414f58 <_svfprintf_r+0x9f0>
  414e06:	2200      	movs	r2, #0
  414e08:	2300      	movs	r3, #0
  414e0a:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  414e0e:	f003 f92b 	bl	418068 <__aeabi_dcmpeq>
  414e12:	2800      	cmp	r0, #0
  414e14:	f000 8152 	beq.w	4150bc <_svfprintf_r+0xb54>
  414e18:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414e1a:	4a21      	ldr	r2, [pc, #132]	; (414ea0 <_svfprintf_r+0x938>)
  414e1c:	f8c8 2000 	str.w	r2, [r8]
  414e20:	3301      	adds	r3, #1
  414e22:	3401      	adds	r4, #1
  414e24:	2201      	movs	r2, #1
  414e26:	2b07      	cmp	r3, #7
  414e28:	9425      	str	r4, [sp, #148]	; 0x94
  414e2a:	9324      	str	r3, [sp, #144]	; 0x90
  414e2c:	f8c8 2004 	str.w	r2, [r8, #4]
  414e30:	f300 836f 	bgt.w	415512 <_svfprintf_r+0xfaa>
  414e34:	f108 0808 	add.w	r8, r8, #8
  414e38:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  414e3a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  414e3c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414e3e:	4293      	cmp	r3, r2
  414e40:	db03      	blt.n	414e4a <_svfprintf_r+0x8e2>
  414e42:	9b03      	ldr	r3, [sp, #12]
  414e44:	07dd      	lsls	r5, r3, #31
  414e46:	f57f ad76 	bpl.w	414936 <_svfprintf_r+0x3ce>
  414e4a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414e4c:	9913      	ldr	r1, [sp, #76]	; 0x4c
  414e4e:	9a14      	ldr	r2, [sp, #80]	; 0x50
  414e50:	f8c8 2000 	str.w	r2, [r8]
  414e54:	3301      	adds	r3, #1
  414e56:	440c      	add	r4, r1
  414e58:	2b07      	cmp	r3, #7
  414e5a:	f8c8 1004 	str.w	r1, [r8, #4]
  414e5e:	9425      	str	r4, [sp, #148]	; 0x94
  414e60:	9324      	str	r3, [sp, #144]	; 0x90
  414e62:	f300 83a3 	bgt.w	4155ac <_svfprintf_r+0x1044>
  414e66:	f108 0808 	add.w	r8, r8, #8
  414e6a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  414e6c:	1e5e      	subs	r6, r3, #1
  414e6e:	2e00      	cmp	r6, #0
  414e70:	f77f ad61 	ble.w	414936 <_svfprintf_r+0x3ce>
  414e74:	2e10      	cmp	r6, #16
  414e76:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414e78:	4d0a      	ldr	r5, [pc, #40]	; (414ea4 <_svfprintf_r+0x93c>)
  414e7a:	f340 81ef 	ble.w	41525c <_svfprintf_r+0xcf4>
  414e7e:	4622      	mov	r2, r4
  414e80:	2710      	movs	r7, #16
  414e82:	f8dd b020 	ldr.w	fp, [sp, #32]
  414e86:	9c07      	ldr	r4, [sp, #28]
  414e88:	e014      	b.n	414eb4 <_svfprintf_r+0x94c>
  414e8a:	bf00      	nop
  414e8c:	0041d828 	.word	0x0041d828
  414e90:	0041d814 	.word	0x0041d814
  414e94:	7fefffff 	.word	0x7fefffff
  414e98:	0041d808 	.word	0x0041d808
  414e9c:	0041d804 	.word	0x0041d804
  414ea0:	0041d844 	.word	0x0041d844
  414ea4:	0041d858 	.word	0x0041d858
  414ea8:	f108 0808 	add.w	r8, r8, #8
  414eac:	3e10      	subs	r6, #16
  414eae:	2e10      	cmp	r6, #16
  414eb0:	f340 81d3 	ble.w	41525a <_svfprintf_r+0xcf2>
  414eb4:	3301      	adds	r3, #1
  414eb6:	3210      	adds	r2, #16
  414eb8:	2b07      	cmp	r3, #7
  414eba:	9225      	str	r2, [sp, #148]	; 0x94
  414ebc:	9324      	str	r3, [sp, #144]	; 0x90
  414ebe:	e888 00a0 	stmia.w	r8, {r5, r7}
  414ec2:	ddf1      	ble.n	414ea8 <_svfprintf_r+0x940>
  414ec4:	aa23      	add	r2, sp, #140	; 0x8c
  414ec6:	4621      	mov	r1, r4
  414ec8:	4658      	mov	r0, fp
  414eca:	f002 fc67 	bl	41779c <__ssprint_r>
  414ece:	2800      	cmp	r0, #0
  414ed0:	f47f ac1c 	bne.w	41470c <_svfprintf_r+0x1a4>
  414ed4:	9a25      	ldr	r2, [sp, #148]	; 0x94
  414ed6:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414ed8:	46c8      	mov	r8, r9
  414eda:	e7e7      	b.n	414eac <_svfprintf_r+0x944>
  414edc:	9b09      	ldr	r3, [sp, #36]	; 0x24
  414ede:	9a04      	ldr	r2, [sp, #16]
  414ee0:	1a9f      	subs	r7, r3, r2
  414ee2:	2f00      	cmp	r7, #0
  414ee4:	f77f acd8 	ble.w	414898 <_svfprintf_r+0x330>
  414ee8:	2f10      	cmp	r7, #16
  414eea:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414eec:	4db7      	ldr	r5, [pc, #732]	; (4151cc <_svfprintf_r+0xc64>)
  414eee:	dd27      	ble.n	414f40 <_svfprintf_r+0x9d8>
  414ef0:	4642      	mov	r2, r8
  414ef2:	4621      	mov	r1, r4
  414ef4:	46b0      	mov	r8, r6
  414ef6:	f04f 0b10 	mov.w	fp, #16
  414efa:	462e      	mov	r6, r5
  414efc:	9c08      	ldr	r4, [sp, #32]
  414efe:	9d07      	ldr	r5, [sp, #28]
  414f00:	e004      	b.n	414f0c <_svfprintf_r+0x9a4>
  414f02:	3f10      	subs	r7, #16
  414f04:	2f10      	cmp	r7, #16
  414f06:	f102 0208 	add.w	r2, r2, #8
  414f0a:	dd15      	ble.n	414f38 <_svfprintf_r+0x9d0>
  414f0c:	3301      	adds	r3, #1
  414f0e:	3110      	adds	r1, #16
  414f10:	2b07      	cmp	r3, #7
  414f12:	9125      	str	r1, [sp, #148]	; 0x94
  414f14:	9324      	str	r3, [sp, #144]	; 0x90
  414f16:	e882 0840 	stmia.w	r2, {r6, fp}
  414f1a:	ddf2      	ble.n	414f02 <_svfprintf_r+0x99a>
  414f1c:	aa23      	add	r2, sp, #140	; 0x8c
  414f1e:	4629      	mov	r1, r5
  414f20:	4620      	mov	r0, r4
  414f22:	f002 fc3b 	bl	41779c <__ssprint_r>
  414f26:	2800      	cmp	r0, #0
  414f28:	f47f abf0 	bne.w	41470c <_svfprintf_r+0x1a4>
  414f2c:	3f10      	subs	r7, #16
  414f2e:	2f10      	cmp	r7, #16
  414f30:	9925      	ldr	r1, [sp, #148]	; 0x94
  414f32:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414f34:	464a      	mov	r2, r9
  414f36:	dce9      	bgt.n	414f0c <_svfprintf_r+0x9a4>
  414f38:	4635      	mov	r5, r6
  414f3a:	460c      	mov	r4, r1
  414f3c:	4646      	mov	r6, r8
  414f3e:	4690      	mov	r8, r2
  414f40:	3301      	adds	r3, #1
  414f42:	443c      	add	r4, r7
  414f44:	2b07      	cmp	r3, #7
  414f46:	9425      	str	r4, [sp, #148]	; 0x94
  414f48:	9324      	str	r3, [sp, #144]	; 0x90
  414f4a:	e888 00a0 	stmia.w	r8, {r5, r7}
  414f4e:	f300 8234 	bgt.w	4153ba <_svfprintf_r+0xe52>
  414f52:	f108 0808 	add.w	r8, r8, #8
  414f56:	e49f      	b.n	414898 <_svfprintf_r+0x330>
  414f58:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  414f5a:	9f24      	ldr	r7, [sp, #144]	; 0x90
  414f5c:	2b01      	cmp	r3, #1
  414f5e:	f340 8200 	ble.w	415362 <_svfprintf_r+0xdfa>
  414f62:	3701      	adds	r7, #1
  414f64:	3401      	adds	r4, #1
  414f66:	2301      	movs	r3, #1
  414f68:	2f07      	cmp	r7, #7
  414f6a:	9425      	str	r4, [sp, #148]	; 0x94
  414f6c:	9724      	str	r7, [sp, #144]	; 0x90
  414f6e:	f8c8 6000 	str.w	r6, [r8]
  414f72:	f8c8 3004 	str.w	r3, [r8, #4]
  414f76:	f300 8205 	bgt.w	415384 <_svfprintf_r+0xe1c>
  414f7a:	f108 0808 	add.w	r8, r8, #8
  414f7e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  414f80:	9b14      	ldr	r3, [sp, #80]	; 0x50
  414f82:	f8c8 3000 	str.w	r3, [r8]
  414f86:	3701      	adds	r7, #1
  414f88:	4414      	add	r4, r2
  414f8a:	2f07      	cmp	r7, #7
  414f8c:	9425      	str	r4, [sp, #148]	; 0x94
  414f8e:	9724      	str	r7, [sp, #144]	; 0x90
  414f90:	f8c8 2004 	str.w	r2, [r8, #4]
  414f94:	f300 8202 	bgt.w	41539c <_svfprintf_r+0xe34>
  414f98:	f108 0808 	add.w	r8, r8, #8
  414f9c:	2300      	movs	r3, #0
  414f9e:	2200      	movs	r2, #0
  414fa0:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  414fa4:	f003 f860 	bl	418068 <__aeabi_dcmpeq>
  414fa8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  414faa:	2800      	cmp	r0, #0
  414fac:	f040 8101 	bne.w	4151b2 <_svfprintf_r+0xc4a>
  414fb0:	3b01      	subs	r3, #1
  414fb2:	3701      	adds	r7, #1
  414fb4:	3601      	adds	r6, #1
  414fb6:	441c      	add	r4, r3
  414fb8:	2f07      	cmp	r7, #7
  414fba:	9724      	str	r7, [sp, #144]	; 0x90
  414fbc:	9425      	str	r4, [sp, #148]	; 0x94
  414fbe:	f8c8 6000 	str.w	r6, [r8]
  414fc2:	f8c8 3004 	str.w	r3, [r8, #4]
  414fc6:	f300 8128 	bgt.w	41521a <_svfprintf_r+0xcb2>
  414fca:	f108 0808 	add.w	r8, r8, #8
  414fce:	9a15      	ldr	r2, [sp, #84]	; 0x54
  414fd0:	f8c8 2004 	str.w	r2, [r8, #4]
  414fd4:	3701      	adds	r7, #1
  414fd6:	4414      	add	r4, r2
  414fd8:	ab1f      	add	r3, sp, #124	; 0x7c
  414fda:	2f07      	cmp	r7, #7
  414fdc:	9425      	str	r4, [sp, #148]	; 0x94
  414fde:	9724      	str	r7, [sp, #144]	; 0x90
  414fe0:	f8c8 3000 	str.w	r3, [r8]
  414fe4:	f77f aca5 	ble.w	414932 <_svfprintf_r+0x3ca>
  414fe8:	aa23      	add	r2, sp, #140	; 0x8c
  414fea:	9907      	ldr	r1, [sp, #28]
  414fec:	9808      	ldr	r0, [sp, #32]
  414fee:	f002 fbd5 	bl	41779c <__ssprint_r>
  414ff2:	2800      	cmp	r0, #0
  414ff4:	f47f ab8a 	bne.w	41470c <_svfprintf_r+0x1a4>
  414ff8:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414ffa:	46c8      	mov	r8, r9
  414ffc:	e49b      	b.n	414936 <_svfprintf_r+0x3ce>
  414ffe:	aa23      	add	r2, sp, #140	; 0x8c
  415000:	9907      	ldr	r1, [sp, #28]
  415002:	9808      	ldr	r0, [sp, #32]
  415004:	f002 fbca 	bl	41779c <__ssprint_r>
  415008:	2800      	cmp	r0, #0
  41500a:	f43f acdd 	beq.w	4149c8 <_svfprintf_r+0x460>
  41500e:	f7ff bb7d 	b.w	41470c <_svfprintf_r+0x1a4>
  415012:	f8dd b00c 	ldr.w	fp, [sp, #12]
  415016:	2b01      	cmp	r3, #1
  415018:	f000 8135 	beq.w	415286 <_svfprintf_r+0xd1e>
  41501c:	2b02      	cmp	r3, #2
  41501e:	d125      	bne.n	41506c <_svfprintf_r+0xb04>
  415020:	f8cd b00c 	str.w	fp, [sp, #12]
  415024:	2400      	movs	r4, #0
  415026:	2500      	movs	r5, #0
  415028:	e611      	b.n	414c4e <_svfprintf_r+0x6e6>
  41502a:	aa23      	add	r2, sp, #140	; 0x8c
  41502c:	9907      	ldr	r1, [sp, #28]
  41502e:	9808      	ldr	r0, [sp, #32]
  415030:	f002 fbb4 	bl	41779c <__ssprint_r>
  415034:	2800      	cmp	r0, #0
  415036:	f47f ab69 	bne.w	41470c <_svfprintf_r+0x1a4>
  41503a:	9c25      	ldr	r4, [sp, #148]	; 0x94
  41503c:	46c8      	mov	r8, r9
  41503e:	e467      	b.n	414910 <_svfprintf_r+0x3a8>
  415040:	aa23      	add	r2, sp, #140	; 0x8c
  415042:	9907      	ldr	r1, [sp, #28]
  415044:	9808      	ldr	r0, [sp, #32]
  415046:	f002 fba9 	bl	41779c <__ssprint_r>
  41504a:	2800      	cmp	r0, #0
  41504c:	f47f ab5e 	bne.w	41470c <_svfprintf_r+0x1a4>
  415050:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415052:	46c8      	mov	r8, r9
  415054:	e41d      	b.n	414892 <_svfprintf_r+0x32a>
  415056:	aa23      	add	r2, sp, #140	; 0x8c
  415058:	9907      	ldr	r1, [sp, #28]
  41505a:	9808      	ldr	r0, [sp, #32]
  41505c:	f002 fb9e 	bl	41779c <__ssprint_r>
  415060:	2800      	cmp	r0, #0
  415062:	f47f ab53 	bne.w	41470c <_svfprintf_r+0x1a4>
  415066:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415068:	46c8      	mov	r8, r9
  41506a:	e402      	b.n	414872 <_svfprintf_r+0x30a>
  41506c:	f8cd b00c 	str.w	fp, [sp, #12]
  415070:	2400      	movs	r4, #0
  415072:	2500      	movs	r5, #0
  415074:	4649      	mov	r1, r9
  415076:	e000      	b.n	41507a <_svfprintf_r+0xb12>
  415078:	4631      	mov	r1, r6
  41507a:	08e2      	lsrs	r2, r4, #3
  41507c:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
  415080:	08e8      	lsrs	r0, r5, #3
  415082:	f004 0307 	and.w	r3, r4, #7
  415086:	4605      	mov	r5, r0
  415088:	4614      	mov	r4, r2
  41508a:	3330      	adds	r3, #48	; 0x30
  41508c:	ea54 0205 	orrs.w	r2, r4, r5
  415090:	f801 3c01 	strb.w	r3, [r1, #-1]
  415094:	f101 36ff 	add.w	r6, r1, #4294967295
  415098:	d1ee      	bne.n	415078 <_svfprintf_r+0xb10>
  41509a:	9a03      	ldr	r2, [sp, #12]
  41509c:	07d2      	lsls	r2, r2, #31
  41509e:	f57f ade6 	bpl.w	414c6e <_svfprintf_r+0x706>
  4150a2:	2b30      	cmp	r3, #48	; 0x30
  4150a4:	f43f ade3 	beq.w	414c6e <_svfprintf_r+0x706>
  4150a8:	3902      	subs	r1, #2
  4150aa:	2330      	movs	r3, #48	; 0x30
  4150ac:	f806 3c01 	strb.w	r3, [r6, #-1]
  4150b0:	eba9 0301 	sub.w	r3, r9, r1
  4150b4:	930a      	str	r3, [sp, #40]	; 0x28
  4150b6:	460e      	mov	r6, r1
  4150b8:	f7ff bb66 	b.w	414788 <_svfprintf_r+0x220>
  4150bc:	991d      	ldr	r1, [sp, #116]	; 0x74
  4150be:	2900      	cmp	r1, #0
  4150c0:	f340 8231 	ble.w	415526 <_svfprintf_r+0xfbe>
  4150c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4150c6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  4150c8:	4293      	cmp	r3, r2
  4150ca:	bfa8      	it	ge
  4150cc:	4613      	movge	r3, r2
  4150ce:	2b00      	cmp	r3, #0
  4150d0:	461f      	mov	r7, r3
  4150d2:	dd0d      	ble.n	4150f0 <_svfprintf_r+0xb88>
  4150d4:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4150d6:	f8c8 6000 	str.w	r6, [r8]
  4150da:	3301      	adds	r3, #1
  4150dc:	443c      	add	r4, r7
  4150de:	2b07      	cmp	r3, #7
  4150e0:	9425      	str	r4, [sp, #148]	; 0x94
  4150e2:	f8c8 7004 	str.w	r7, [r8, #4]
  4150e6:	9324      	str	r3, [sp, #144]	; 0x90
  4150e8:	f300 8321 	bgt.w	41572e <_svfprintf_r+0x11c6>
  4150ec:	f108 0808 	add.w	r8, r8, #8
  4150f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4150f2:	2f00      	cmp	r7, #0
  4150f4:	bfa8      	it	ge
  4150f6:	1bdb      	subge	r3, r3, r7
  4150f8:	2b00      	cmp	r3, #0
  4150fa:	461f      	mov	r7, r3
  4150fc:	f340 80d7 	ble.w	4152ae <_svfprintf_r+0xd46>
  415100:	2f10      	cmp	r7, #16
  415102:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415104:	4d31      	ldr	r5, [pc, #196]	; (4151cc <_svfprintf_r+0xc64>)
  415106:	f340 81f0 	ble.w	4154ea <_svfprintf_r+0xf82>
  41510a:	4642      	mov	r2, r8
  41510c:	4621      	mov	r1, r4
  41510e:	46b0      	mov	r8, r6
  415110:	f04f 0b10 	mov.w	fp, #16
  415114:	462e      	mov	r6, r5
  415116:	9c08      	ldr	r4, [sp, #32]
  415118:	9d07      	ldr	r5, [sp, #28]
  41511a:	e004      	b.n	415126 <_svfprintf_r+0xbbe>
  41511c:	3208      	adds	r2, #8
  41511e:	3f10      	subs	r7, #16
  415120:	2f10      	cmp	r7, #16
  415122:	f340 81de 	ble.w	4154e2 <_svfprintf_r+0xf7a>
  415126:	3301      	adds	r3, #1
  415128:	3110      	adds	r1, #16
  41512a:	2b07      	cmp	r3, #7
  41512c:	9125      	str	r1, [sp, #148]	; 0x94
  41512e:	9324      	str	r3, [sp, #144]	; 0x90
  415130:	e882 0840 	stmia.w	r2, {r6, fp}
  415134:	ddf2      	ble.n	41511c <_svfprintf_r+0xbb4>
  415136:	aa23      	add	r2, sp, #140	; 0x8c
  415138:	4629      	mov	r1, r5
  41513a:	4620      	mov	r0, r4
  41513c:	f002 fb2e 	bl	41779c <__ssprint_r>
  415140:	2800      	cmp	r0, #0
  415142:	f47f aae3 	bne.w	41470c <_svfprintf_r+0x1a4>
  415146:	9925      	ldr	r1, [sp, #148]	; 0x94
  415148:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41514a:	464a      	mov	r2, r9
  41514c:	e7e7      	b.n	41511e <_svfprintf_r+0xbb6>
  41514e:	2d00      	cmp	r5, #0
  415150:	bf08      	it	eq
  415152:	2c0a      	cmpeq	r4, #10
  415154:	f0c0 8095 	bcc.w	415282 <_svfprintf_r+0xd1a>
  415158:	464e      	mov	r6, r9
  41515a:	4620      	mov	r0, r4
  41515c:	4629      	mov	r1, r5
  41515e:	220a      	movs	r2, #10
  415160:	2300      	movs	r3, #0
  415162:	f7fe fe81 	bl	413e68 <__aeabi_uldivmod>
  415166:	3230      	adds	r2, #48	; 0x30
  415168:	f806 2d01 	strb.w	r2, [r6, #-1]!
  41516c:	4620      	mov	r0, r4
  41516e:	4629      	mov	r1, r5
  415170:	2300      	movs	r3, #0
  415172:	220a      	movs	r2, #10
  415174:	f7fe fe78 	bl	413e68 <__aeabi_uldivmod>
  415178:	4604      	mov	r4, r0
  41517a:	460d      	mov	r5, r1
  41517c:	ea54 0305 	orrs.w	r3, r4, r5
  415180:	d1eb      	bne.n	41515a <_svfprintf_r+0xbf2>
  415182:	eba9 0306 	sub.w	r3, r9, r6
  415186:	930a      	str	r3, [sp, #40]	; 0x28
  415188:	f7ff bafe 	b.w	414788 <_svfprintf_r+0x220>
  41518c:	9b06      	ldr	r3, [sp, #24]
  41518e:	930a      	str	r3, [sp, #40]	; 0x28
  415190:	464e      	mov	r6, r9
  415192:	f7ff baf9 	b.w	414788 <_svfprintf_r+0x220>
  415196:	aa23      	add	r2, sp, #140	; 0x8c
  415198:	9907      	ldr	r1, [sp, #28]
  41519a:	9808      	ldr	r0, [sp, #32]
  41519c:	f002 fafe 	bl	41779c <__ssprint_r>
  4151a0:	2800      	cmp	r0, #0
  4151a2:	f47f aab3 	bne.w	41470c <_svfprintf_r+0x1a4>
  4151a6:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  4151aa:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4151ac:	46c8      	mov	r8, r9
  4151ae:	f7ff bb50 	b.w	414852 <_svfprintf_r+0x2ea>
  4151b2:	1e5e      	subs	r6, r3, #1
  4151b4:	2e00      	cmp	r6, #0
  4151b6:	f77f af0a 	ble.w	414fce <_svfprintf_r+0xa66>
  4151ba:	2e10      	cmp	r6, #16
  4151bc:	4d03      	ldr	r5, [pc, #12]	; (4151cc <_svfprintf_r+0xc64>)
  4151be:	dd23      	ble.n	415208 <_svfprintf_r+0xca0>
  4151c0:	4622      	mov	r2, r4
  4151c2:	f04f 0b10 	mov.w	fp, #16
  4151c6:	9c08      	ldr	r4, [sp, #32]
  4151c8:	e007      	b.n	4151da <_svfprintf_r+0xc72>
  4151ca:	bf00      	nop
  4151cc:	0041d858 	.word	0x0041d858
  4151d0:	3e10      	subs	r6, #16
  4151d2:	2e10      	cmp	r6, #16
  4151d4:	f108 0808 	add.w	r8, r8, #8
  4151d8:	dd15      	ble.n	415206 <_svfprintf_r+0xc9e>
  4151da:	3701      	adds	r7, #1
  4151dc:	3210      	adds	r2, #16
  4151de:	2f07      	cmp	r7, #7
  4151e0:	9225      	str	r2, [sp, #148]	; 0x94
  4151e2:	9724      	str	r7, [sp, #144]	; 0x90
  4151e4:	e888 0820 	stmia.w	r8, {r5, fp}
  4151e8:	ddf2      	ble.n	4151d0 <_svfprintf_r+0xc68>
  4151ea:	aa23      	add	r2, sp, #140	; 0x8c
  4151ec:	9907      	ldr	r1, [sp, #28]
  4151ee:	4620      	mov	r0, r4
  4151f0:	f002 fad4 	bl	41779c <__ssprint_r>
  4151f4:	2800      	cmp	r0, #0
  4151f6:	f47f aa89 	bne.w	41470c <_svfprintf_r+0x1a4>
  4151fa:	3e10      	subs	r6, #16
  4151fc:	2e10      	cmp	r6, #16
  4151fe:	9a25      	ldr	r2, [sp, #148]	; 0x94
  415200:	9f24      	ldr	r7, [sp, #144]	; 0x90
  415202:	46c8      	mov	r8, r9
  415204:	dce9      	bgt.n	4151da <_svfprintf_r+0xc72>
  415206:	4614      	mov	r4, r2
  415208:	3701      	adds	r7, #1
  41520a:	4434      	add	r4, r6
  41520c:	2f07      	cmp	r7, #7
  41520e:	9425      	str	r4, [sp, #148]	; 0x94
  415210:	9724      	str	r7, [sp, #144]	; 0x90
  415212:	e888 0060 	stmia.w	r8, {r5, r6}
  415216:	f77f aed8 	ble.w	414fca <_svfprintf_r+0xa62>
  41521a:	aa23      	add	r2, sp, #140	; 0x8c
  41521c:	9907      	ldr	r1, [sp, #28]
  41521e:	9808      	ldr	r0, [sp, #32]
  415220:	f002 fabc 	bl	41779c <__ssprint_r>
  415224:	2800      	cmp	r0, #0
  415226:	f47f aa71 	bne.w	41470c <_svfprintf_r+0x1a4>
  41522a:	9c25      	ldr	r4, [sp, #148]	; 0x94
  41522c:	9f24      	ldr	r7, [sp, #144]	; 0x90
  41522e:	46c8      	mov	r8, r9
  415230:	e6cd      	b.n	414fce <_svfprintf_r+0xa66>
  415232:	681c      	ldr	r4, [r3, #0]
  415234:	3304      	adds	r3, #4
  415236:	930b      	str	r3, [sp, #44]	; 0x2c
  415238:	2500      	movs	r5, #0
  41523a:	e422      	b.n	414a82 <_svfprintf_r+0x51a>
  41523c:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41523e:	460a      	mov	r2, r1
  415240:	3204      	adds	r2, #4
  415242:	680c      	ldr	r4, [r1, #0]
  415244:	920b      	str	r2, [sp, #44]	; 0x2c
  415246:	2500      	movs	r5, #0
  415248:	f7ff ba81 	b.w	41474e <_svfprintf_r+0x1e6>
  41524c:	3204      	adds	r2, #4
  41524e:	681c      	ldr	r4, [r3, #0]
  415250:	920b      	str	r2, [sp, #44]	; 0x2c
  415252:	2301      	movs	r3, #1
  415254:	2500      	movs	r5, #0
  415256:	f7ff ba7a 	b.w	41474e <_svfprintf_r+0x1e6>
  41525a:	4614      	mov	r4, r2
  41525c:	3301      	adds	r3, #1
  41525e:	4434      	add	r4, r6
  415260:	2b07      	cmp	r3, #7
  415262:	9425      	str	r4, [sp, #148]	; 0x94
  415264:	9324      	str	r3, [sp, #144]	; 0x90
  415266:	e888 0060 	stmia.w	r8, {r5, r6}
  41526a:	f77f ab62 	ble.w	414932 <_svfprintf_r+0x3ca>
  41526e:	e6bb      	b.n	414fe8 <_svfprintf_r+0xa80>
  415270:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  415272:	6814      	ldr	r4, [r2, #0]
  415274:	4613      	mov	r3, r2
  415276:	3304      	adds	r3, #4
  415278:	17e5      	asrs	r5, r4, #31
  41527a:	930b      	str	r3, [sp, #44]	; 0x2c
  41527c:	4622      	mov	r2, r4
  41527e:	462b      	mov	r3, r5
  415280:	e4cd      	b.n	414c1e <_svfprintf_r+0x6b6>
  415282:	f8dd b00c 	ldr.w	fp, [sp, #12]
  415286:	f8cd b00c 	str.w	fp, [sp, #12]
  41528a:	ae40      	add	r6, sp, #256	; 0x100
  41528c:	3430      	adds	r4, #48	; 0x30
  41528e:	2301      	movs	r3, #1
  415290:	f806 4d41 	strb.w	r4, [r6, #-65]!
  415294:	930a      	str	r3, [sp, #40]	; 0x28
  415296:	f7ff ba77 	b.w	414788 <_svfprintf_r+0x220>
  41529a:	aa23      	add	r2, sp, #140	; 0x8c
  41529c:	9907      	ldr	r1, [sp, #28]
  41529e:	9808      	ldr	r0, [sp, #32]
  4152a0:	f002 fa7c 	bl	41779c <__ssprint_r>
  4152a4:	2800      	cmp	r0, #0
  4152a6:	f47f aa31 	bne.w	41470c <_svfprintf_r+0x1a4>
  4152aa:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4152ac:	46c8      	mov	r8, r9
  4152ae:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  4152b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4152b2:	429a      	cmp	r2, r3
  4152b4:	db44      	blt.n	415340 <_svfprintf_r+0xdd8>
  4152b6:	9b03      	ldr	r3, [sp, #12]
  4152b8:	07d9      	lsls	r1, r3, #31
  4152ba:	d441      	bmi.n	415340 <_svfprintf_r+0xdd8>
  4152bc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4152be:	980e      	ldr	r0, [sp, #56]	; 0x38
  4152c0:	1a9a      	subs	r2, r3, r2
  4152c2:	1a1d      	subs	r5, r3, r0
  4152c4:	4295      	cmp	r5, r2
  4152c6:	bfa8      	it	ge
  4152c8:	4615      	movge	r5, r2
  4152ca:	2d00      	cmp	r5, #0
  4152cc:	dd0e      	ble.n	4152ec <_svfprintf_r+0xd84>
  4152ce:	9924      	ldr	r1, [sp, #144]	; 0x90
  4152d0:	f8c8 5004 	str.w	r5, [r8, #4]
  4152d4:	3101      	adds	r1, #1
  4152d6:	4406      	add	r6, r0
  4152d8:	442c      	add	r4, r5
  4152da:	2907      	cmp	r1, #7
  4152dc:	f8c8 6000 	str.w	r6, [r8]
  4152e0:	9425      	str	r4, [sp, #148]	; 0x94
  4152e2:	9124      	str	r1, [sp, #144]	; 0x90
  4152e4:	f300 823a 	bgt.w	41575c <_svfprintf_r+0x11f4>
  4152e8:	f108 0808 	add.w	r8, r8, #8
  4152ec:	2d00      	cmp	r5, #0
  4152ee:	bfac      	ite	ge
  4152f0:	1b56      	subge	r6, r2, r5
  4152f2:	4616      	movlt	r6, r2
  4152f4:	2e00      	cmp	r6, #0
  4152f6:	f77f ab1e 	ble.w	414936 <_svfprintf_r+0x3ce>
  4152fa:	2e10      	cmp	r6, #16
  4152fc:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4152fe:	4db1      	ldr	r5, [pc, #708]	; (4155c4 <_svfprintf_r+0x105c>)
  415300:	ddac      	ble.n	41525c <_svfprintf_r+0xcf4>
  415302:	4622      	mov	r2, r4
  415304:	2710      	movs	r7, #16
  415306:	f8dd b020 	ldr.w	fp, [sp, #32]
  41530a:	9c07      	ldr	r4, [sp, #28]
  41530c:	e004      	b.n	415318 <_svfprintf_r+0xdb0>
  41530e:	f108 0808 	add.w	r8, r8, #8
  415312:	3e10      	subs	r6, #16
  415314:	2e10      	cmp	r6, #16
  415316:	dda0      	ble.n	41525a <_svfprintf_r+0xcf2>
  415318:	3301      	adds	r3, #1
  41531a:	3210      	adds	r2, #16
  41531c:	2b07      	cmp	r3, #7
  41531e:	9225      	str	r2, [sp, #148]	; 0x94
  415320:	9324      	str	r3, [sp, #144]	; 0x90
  415322:	e888 00a0 	stmia.w	r8, {r5, r7}
  415326:	ddf2      	ble.n	41530e <_svfprintf_r+0xda6>
  415328:	aa23      	add	r2, sp, #140	; 0x8c
  41532a:	4621      	mov	r1, r4
  41532c:	4658      	mov	r0, fp
  41532e:	f002 fa35 	bl	41779c <__ssprint_r>
  415332:	2800      	cmp	r0, #0
  415334:	f47f a9ea 	bne.w	41470c <_svfprintf_r+0x1a4>
  415338:	9a25      	ldr	r2, [sp, #148]	; 0x94
  41533a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41533c:	46c8      	mov	r8, r9
  41533e:	e7e8      	b.n	415312 <_svfprintf_r+0xdaa>
  415340:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415342:	9813      	ldr	r0, [sp, #76]	; 0x4c
  415344:	9914      	ldr	r1, [sp, #80]	; 0x50
  415346:	f8c8 1000 	str.w	r1, [r8]
  41534a:	3301      	adds	r3, #1
  41534c:	4404      	add	r4, r0
  41534e:	2b07      	cmp	r3, #7
  415350:	9425      	str	r4, [sp, #148]	; 0x94
  415352:	f8c8 0004 	str.w	r0, [r8, #4]
  415356:	9324      	str	r3, [sp, #144]	; 0x90
  415358:	f300 81f4 	bgt.w	415744 <_svfprintf_r+0x11dc>
  41535c:	f108 0808 	add.w	r8, r8, #8
  415360:	e7ac      	b.n	4152bc <_svfprintf_r+0xd54>
  415362:	9b03      	ldr	r3, [sp, #12]
  415364:	07da      	lsls	r2, r3, #31
  415366:	f53f adfc 	bmi.w	414f62 <_svfprintf_r+0x9fa>
  41536a:	3701      	adds	r7, #1
  41536c:	3401      	adds	r4, #1
  41536e:	2301      	movs	r3, #1
  415370:	2f07      	cmp	r7, #7
  415372:	9425      	str	r4, [sp, #148]	; 0x94
  415374:	9724      	str	r7, [sp, #144]	; 0x90
  415376:	f8c8 6000 	str.w	r6, [r8]
  41537a:	f8c8 3004 	str.w	r3, [r8, #4]
  41537e:	f77f ae24 	ble.w	414fca <_svfprintf_r+0xa62>
  415382:	e74a      	b.n	41521a <_svfprintf_r+0xcb2>
  415384:	aa23      	add	r2, sp, #140	; 0x8c
  415386:	9907      	ldr	r1, [sp, #28]
  415388:	9808      	ldr	r0, [sp, #32]
  41538a:	f002 fa07 	bl	41779c <__ssprint_r>
  41538e:	2800      	cmp	r0, #0
  415390:	f47f a9bc 	bne.w	41470c <_svfprintf_r+0x1a4>
  415394:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415396:	9f24      	ldr	r7, [sp, #144]	; 0x90
  415398:	46c8      	mov	r8, r9
  41539a:	e5f0      	b.n	414f7e <_svfprintf_r+0xa16>
  41539c:	aa23      	add	r2, sp, #140	; 0x8c
  41539e:	9907      	ldr	r1, [sp, #28]
  4153a0:	9808      	ldr	r0, [sp, #32]
  4153a2:	f002 f9fb 	bl	41779c <__ssprint_r>
  4153a6:	2800      	cmp	r0, #0
  4153a8:	f47f a9b0 	bne.w	41470c <_svfprintf_r+0x1a4>
  4153ac:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4153ae:	9f24      	ldr	r7, [sp, #144]	; 0x90
  4153b0:	46c8      	mov	r8, r9
  4153b2:	e5f3      	b.n	414f9c <_svfprintf_r+0xa34>
  4153b4:	464e      	mov	r6, r9
  4153b6:	f7ff b9e7 	b.w	414788 <_svfprintf_r+0x220>
  4153ba:	aa23      	add	r2, sp, #140	; 0x8c
  4153bc:	9907      	ldr	r1, [sp, #28]
  4153be:	9808      	ldr	r0, [sp, #32]
  4153c0:	f002 f9ec 	bl	41779c <__ssprint_r>
  4153c4:	2800      	cmp	r0, #0
  4153c6:	f47f a9a1 	bne.w	41470c <_svfprintf_r+0x1a4>
  4153ca:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4153cc:	46c8      	mov	r8, r9
  4153ce:	f7ff ba63 	b.w	414898 <_svfprintf_r+0x330>
  4153d2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  4153d6:	4602      	mov	r2, r0
  4153d8:	460b      	mov	r3, r1
  4153da:	f002 fe77 	bl	4180cc <__aeabi_dcmpun>
  4153de:	2800      	cmp	r0, #0
  4153e0:	f040 8298 	bne.w	415914 <_svfprintf_r+0x13ac>
  4153e4:	9b06      	ldr	r3, [sp, #24]
  4153e6:	3301      	adds	r3, #1
  4153e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4153ea:	f023 0720 	bic.w	r7, r3, #32
  4153ee:	f000 81d2 	beq.w	415796 <_svfprintf_r+0x122e>
  4153f2:	2f47      	cmp	r7, #71	; 0x47
  4153f4:	f000 8120 	beq.w	415638 <_svfprintf_r+0x10d0>
  4153f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4153fa:	f44b 7280 	orr.w	r2, fp, #256	; 0x100
  4153fe:	2b00      	cmp	r3, #0
  415400:	9203      	str	r2, [sp, #12]
  415402:	f2c0 81f0 	blt.w	4157e6 <_svfprintf_r+0x127e>
  415406:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
  41540a:	ed8d 7b18 	vstr	d7, [sp, #96]	; 0x60
  41540e:	2300      	movs	r3, #0
  415410:	930c      	str	r3, [sp, #48]	; 0x30
  415412:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  415414:	2b66      	cmp	r3, #102	; 0x66
  415416:	f000 81c1 	beq.w	41579c <_svfprintf_r+0x1234>
  41541a:	2b46      	cmp	r3, #70	; 0x46
  41541c:	f000 80f1 	beq.w	415602 <_svfprintf_r+0x109a>
  415420:	2f45      	cmp	r7, #69	; 0x45
  415422:	bf0c      	ite	eq
  415424:	9b06      	ldreq	r3, [sp, #24]
  415426:	9d06      	ldrne	r5, [sp, #24]
  415428:	9808      	ldr	r0, [sp, #32]
  41542a:	bf08      	it	eq
  41542c:	1c5d      	addeq	r5, r3, #1
  41542e:	aa21      	add	r2, sp, #132	; 0x84
  415430:	ab1e      	add	r3, sp, #120	; 0x78
  415432:	9201      	str	r2, [sp, #4]
  415434:	9300      	str	r3, [sp, #0]
  415436:	462a      	mov	r2, r5
  415438:	ab1d      	add	r3, sp, #116	; 0x74
  41543a:	2102      	movs	r1, #2
  41543c:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
  415440:	f000 fbca 	bl	415bd8 <_dtoa_r>
  415444:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  415446:	2b67      	cmp	r3, #103	; 0x67
  415448:	4606      	mov	r6, r0
  41544a:	f040 81d5 	bne.w	4157f8 <_svfprintf_r+0x1290>
  41544e:	f01b 0f01 	tst.w	fp, #1
  415452:	f000 824e 	beq.w	4158f2 <_svfprintf_r+0x138a>
  415456:	1974      	adds	r4, r6, r5
  415458:	2200      	movs	r2, #0
  41545a:	2300      	movs	r3, #0
  41545c:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
  415460:	f002 fe02 	bl	418068 <__aeabi_dcmpeq>
  415464:	2800      	cmp	r0, #0
  415466:	f040 8160 	bne.w	41572a <_svfprintf_r+0x11c2>
  41546a:	9b21      	ldr	r3, [sp, #132]	; 0x84
  41546c:	42a3      	cmp	r3, r4
  41546e:	d206      	bcs.n	41547e <_svfprintf_r+0xf16>
  415470:	2130      	movs	r1, #48	; 0x30
  415472:	1c5a      	adds	r2, r3, #1
  415474:	9221      	str	r2, [sp, #132]	; 0x84
  415476:	7019      	strb	r1, [r3, #0]
  415478:	9b21      	ldr	r3, [sp, #132]	; 0x84
  41547a:	429c      	cmp	r4, r3
  41547c:	d8f9      	bhi.n	415472 <_svfprintf_r+0xf0a>
  41547e:	1b9b      	subs	r3, r3, r6
  415480:	2f47      	cmp	r7, #71	; 0x47
  415482:	930f      	str	r3, [sp, #60]	; 0x3c
  415484:	f000 80f0 	beq.w	415668 <_svfprintf_r+0x1100>
  415488:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  41548a:	2b65      	cmp	r3, #101	; 0x65
  41548c:	f340 81c3 	ble.w	415816 <_svfprintf_r+0x12ae>
  415490:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  415492:	2b66      	cmp	r3, #102	; 0x66
  415494:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  415496:	930e      	str	r3, [sp, #56]	; 0x38
  415498:	f000 81c0 	beq.w	41581c <_svfprintf_r+0x12b4>
  41549c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  41549e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4154a0:	4619      	mov	r1, r3
  4154a2:	4291      	cmp	r1, r2
  4154a4:	f300 8191 	bgt.w	4157ca <_svfprintf_r+0x1262>
  4154a8:	f01b 0f01 	tst.w	fp, #1
  4154ac:	f040 8223 	bne.w	4158f6 <_svfprintf_r+0x138e>
  4154b0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  4154b4:	9304      	str	r3, [sp, #16]
  4154b6:	2367      	movs	r3, #103	; 0x67
  4154b8:	920a      	str	r2, [sp, #40]	; 0x28
  4154ba:	930d      	str	r3, [sp, #52]	; 0x34
  4154bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4154be:	2b00      	cmp	r3, #0
  4154c0:	f040 80cb 	bne.w	41565a <_svfprintf_r+0x10f2>
  4154c4:	9306      	str	r3, [sp, #24]
  4154c6:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  4154ca:	f7ff b965 	b.w	414798 <_svfprintf_r+0x230>
  4154ce:	f025 0507 	bic.w	r5, r5, #7
  4154d2:	ed95 7b00 	vldr	d7, [r5]
  4154d6:	f105 0308 	add.w	r3, r5, #8
  4154da:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
  4154de:	930b      	str	r3, [sp, #44]	; 0x2c
  4154e0:	e416      	b.n	414d10 <_svfprintf_r+0x7a8>
  4154e2:	4635      	mov	r5, r6
  4154e4:	460c      	mov	r4, r1
  4154e6:	4646      	mov	r6, r8
  4154e8:	4690      	mov	r8, r2
  4154ea:	3301      	adds	r3, #1
  4154ec:	443c      	add	r4, r7
  4154ee:	2b07      	cmp	r3, #7
  4154f0:	9425      	str	r4, [sp, #148]	; 0x94
  4154f2:	9324      	str	r3, [sp, #144]	; 0x90
  4154f4:	e888 00a0 	stmia.w	r8, {r5, r7}
  4154f8:	f73f aecf 	bgt.w	41529a <_svfprintf_r+0xd32>
  4154fc:	f108 0808 	add.w	r8, r8, #8
  415500:	e6d5      	b.n	4152ae <_svfprintf_r+0xd46>
  415502:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  415504:	6813      	ldr	r3, [r2, #0]
  415506:	3204      	adds	r2, #4
  415508:	920b      	str	r2, [sp, #44]	; 0x2c
  41550a:	9a05      	ldr	r2, [sp, #20]
  41550c:	601a      	str	r2, [r3, #0]
  41550e:	f7ff b852 	b.w	4145b6 <_svfprintf_r+0x4e>
  415512:	aa23      	add	r2, sp, #140	; 0x8c
  415514:	9907      	ldr	r1, [sp, #28]
  415516:	9808      	ldr	r0, [sp, #32]
  415518:	f002 f940 	bl	41779c <__ssprint_r>
  41551c:	2800      	cmp	r0, #0
  41551e:	f47f a8f5 	bne.w	41470c <_svfprintf_r+0x1a4>
  415522:	46c8      	mov	r8, r9
  415524:	e488      	b.n	414e38 <_svfprintf_r+0x8d0>
  415526:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415528:	4a27      	ldr	r2, [pc, #156]	; (4155c8 <_svfprintf_r+0x1060>)
  41552a:	f8c8 2000 	str.w	r2, [r8]
  41552e:	3301      	adds	r3, #1
  415530:	3401      	adds	r4, #1
  415532:	2201      	movs	r2, #1
  415534:	2b07      	cmp	r3, #7
  415536:	9425      	str	r4, [sp, #148]	; 0x94
  415538:	9324      	str	r3, [sp, #144]	; 0x90
  41553a:	f8c8 2004 	str.w	r2, [r8, #4]
  41553e:	dc54      	bgt.n	4155ea <_svfprintf_r+0x1082>
  415540:	f108 0808 	add.w	r8, r8, #8
  415544:	b929      	cbnz	r1, 415552 <_svfprintf_r+0xfea>
  415546:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  415548:	b91b      	cbnz	r3, 415552 <_svfprintf_r+0xfea>
  41554a:	9b03      	ldr	r3, [sp, #12]
  41554c:	07d8      	lsls	r0, r3, #31
  41554e:	f57f a9f2 	bpl.w	414936 <_svfprintf_r+0x3ce>
  415552:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415554:	9813      	ldr	r0, [sp, #76]	; 0x4c
  415556:	9a14      	ldr	r2, [sp, #80]	; 0x50
  415558:	f8c8 2000 	str.w	r2, [r8]
  41555c:	3301      	adds	r3, #1
  41555e:	4602      	mov	r2, r0
  415560:	4422      	add	r2, r4
  415562:	2b07      	cmp	r3, #7
  415564:	9225      	str	r2, [sp, #148]	; 0x94
  415566:	f8c8 0004 	str.w	r0, [r8, #4]
  41556a:	9324      	str	r3, [sp, #144]	; 0x90
  41556c:	f300 8195 	bgt.w	41589a <_svfprintf_r+0x1332>
  415570:	f108 0808 	add.w	r8, r8, #8
  415574:	2900      	cmp	r1, #0
  415576:	f2c0 816d 	blt.w	415854 <_svfprintf_r+0x12ec>
  41557a:	990f      	ldr	r1, [sp, #60]	; 0x3c
  41557c:	f8c8 6000 	str.w	r6, [r8]
  415580:	3301      	adds	r3, #1
  415582:	188c      	adds	r4, r1, r2
  415584:	2b07      	cmp	r3, #7
  415586:	9425      	str	r4, [sp, #148]	; 0x94
  415588:	9324      	str	r3, [sp, #144]	; 0x90
  41558a:	f8c8 1004 	str.w	r1, [r8, #4]
  41558e:	f77f a9d0 	ble.w	414932 <_svfprintf_r+0x3ca>
  415592:	e529      	b.n	414fe8 <_svfprintf_r+0xa80>
  415594:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  415596:	9905      	ldr	r1, [sp, #20]
  415598:	6813      	ldr	r3, [r2, #0]
  41559a:	17cd      	asrs	r5, r1, #31
  41559c:	4608      	mov	r0, r1
  41559e:	3204      	adds	r2, #4
  4155a0:	4629      	mov	r1, r5
  4155a2:	920b      	str	r2, [sp, #44]	; 0x2c
  4155a4:	e9c3 0100 	strd	r0, r1, [r3]
  4155a8:	f7ff b805 	b.w	4145b6 <_svfprintf_r+0x4e>
  4155ac:	aa23      	add	r2, sp, #140	; 0x8c
  4155ae:	9907      	ldr	r1, [sp, #28]
  4155b0:	9808      	ldr	r0, [sp, #32]
  4155b2:	f002 f8f3 	bl	41779c <__ssprint_r>
  4155b6:	2800      	cmp	r0, #0
  4155b8:	f47f a8a8 	bne.w	41470c <_svfprintf_r+0x1a4>
  4155bc:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4155be:	46c8      	mov	r8, r9
  4155c0:	e453      	b.n	414e6a <_svfprintf_r+0x902>
  4155c2:	bf00      	nop
  4155c4:	0041d858 	.word	0x0041d858
  4155c8:	0041d844 	.word	0x0041d844
  4155cc:	2140      	movs	r1, #64	; 0x40
  4155ce:	9808      	ldr	r0, [sp, #32]
  4155d0:	f001 fa54 	bl	416a7c <_malloc_r>
  4155d4:	9a07      	ldr	r2, [sp, #28]
  4155d6:	6010      	str	r0, [r2, #0]
  4155d8:	6110      	str	r0, [r2, #16]
  4155da:	2800      	cmp	r0, #0
  4155dc:	f000 81f6 	beq.w	4159cc <_svfprintf_r+0x1464>
  4155e0:	9a07      	ldr	r2, [sp, #28]
  4155e2:	2340      	movs	r3, #64	; 0x40
  4155e4:	6153      	str	r3, [r2, #20]
  4155e6:	f7fe bfd6 	b.w	414596 <_svfprintf_r+0x2e>
  4155ea:	aa23      	add	r2, sp, #140	; 0x8c
  4155ec:	9907      	ldr	r1, [sp, #28]
  4155ee:	9808      	ldr	r0, [sp, #32]
  4155f0:	f002 f8d4 	bl	41779c <__ssprint_r>
  4155f4:	2800      	cmp	r0, #0
  4155f6:	f47f a889 	bne.w	41470c <_svfprintf_r+0x1a4>
  4155fa:	991d      	ldr	r1, [sp, #116]	; 0x74
  4155fc:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4155fe:	46c8      	mov	r8, r9
  415600:	e7a0      	b.n	415544 <_svfprintf_r+0xfdc>
  415602:	9d06      	ldr	r5, [sp, #24]
  415604:	9808      	ldr	r0, [sp, #32]
  415606:	aa21      	add	r2, sp, #132	; 0x84
  415608:	ab1e      	add	r3, sp, #120	; 0x78
  41560a:	9201      	str	r2, [sp, #4]
  41560c:	9300      	str	r3, [sp, #0]
  41560e:	462a      	mov	r2, r5
  415610:	ab1d      	add	r3, sp, #116	; 0x74
  415612:	2103      	movs	r1, #3
  415614:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
  415618:	f000 fade 	bl	415bd8 <_dtoa_r>
  41561c:	4606      	mov	r6, r0
  41561e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  415620:	2b46      	cmp	r3, #70	; 0x46
  415622:	eb06 0405 	add.w	r4, r6, r5
  415626:	f47f af17 	bne.w	415458 <_svfprintf_r+0xef0>
  41562a:	7833      	ldrb	r3, [r6, #0]
  41562c:	2b30      	cmp	r3, #48	; 0x30
  41562e:	f000 817d 	beq.w	41592c <_svfprintf_r+0x13c4>
  415632:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  415634:	442c      	add	r4, r5
  415636:	e70f      	b.n	415458 <_svfprintf_r+0xef0>
  415638:	9b06      	ldr	r3, [sp, #24]
  41563a:	2b00      	cmp	r3, #0
  41563c:	bf08      	it	eq
  41563e:	2301      	moveq	r3, #1
  415640:	9306      	str	r3, [sp, #24]
  415642:	e6d9      	b.n	4153f8 <_svfprintf_r+0xe90>
  415644:	4630      	mov	r0, r6
  415646:	9406      	str	r4, [sp, #24]
  415648:	f002 f83a 	bl	4176c0 <strlen>
  41564c:	950b      	str	r5, [sp, #44]	; 0x2c
  41564e:	900a      	str	r0, [sp, #40]	; 0x28
  415650:	f8cd b00c 	str.w	fp, [sp, #12]
  415654:	4603      	mov	r3, r0
  415656:	f7ff b9eb 	b.w	414a30 <_svfprintf_r+0x4c8>
  41565a:	272d      	movs	r7, #45	; 0x2d
  41565c:	2300      	movs	r3, #0
  41565e:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  415662:	9306      	str	r3, [sp, #24]
  415664:	f7ff b899 	b.w	41479a <_svfprintf_r+0x232>
  415668:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  41566a:	930e      	str	r3, [sp, #56]	; 0x38
  41566c:	461a      	mov	r2, r3
  41566e:	3303      	adds	r3, #3
  415670:	db04      	blt.n	41567c <_svfprintf_r+0x1114>
  415672:	9b06      	ldr	r3, [sp, #24]
  415674:	4619      	mov	r1, r3
  415676:	4291      	cmp	r1, r2
  415678:	f6bf af10 	bge.w	41549c <_svfprintf_r+0xf34>
  41567c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  41567e:	3b02      	subs	r3, #2
  415680:	930d      	str	r3, [sp, #52]	; 0x34
  415682:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
  415686:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
  41568a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  41568c:	3b01      	subs	r3, #1
  41568e:	2b00      	cmp	r3, #0
  415690:	931d      	str	r3, [sp, #116]	; 0x74
  415692:	bfbd      	ittte	lt
  415694:	9b0e      	ldrlt	r3, [sp, #56]	; 0x38
  415696:	f1c3 0301 	rsblt	r3, r3, #1
  41569a:	222d      	movlt	r2, #45	; 0x2d
  41569c:	222b      	movge	r2, #43	; 0x2b
  41569e:	2b09      	cmp	r3, #9
  4156a0:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
  4156a4:	f340 811d 	ble.w	4158e2 <_svfprintf_r+0x137a>
  4156a8:	f10d 048b 	add.w	r4, sp, #139	; 0x8b
  4156ac:	4620      	mov	r0, r4
  4156ae:	4daf      	ldr	r5, [pc, #700]	; (41596c <_svfprintf_r+0x1404>)
  4156b0:	e000      	b.n	4156b4 <_svfprintf_r+0x114c>
  4156b2:	4610      	mov	r0, r2
  4156b4:	fb85 1203 	smull	r1, r2, r5, r3
  4156b8:	17d9      	asrs	r1, r3, #31
  4156ba:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
  4156be:	eb01 0281 	add.w	r2, r1, r1, lsl #2
  4156c2:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
  4156c6:	3230      	adds	r2, #48	; 0x30
  4156c8:	2909      	cmp	r1, #9
  4156ca:	f800 2c01 	strb.w	r2, [r0, #-1]
  4156ce:	460b      	mov	r3, r1
  4156d0:	f100 32ff 	add.w	r2, r0, #4294967295
  4156d4:	dced      	bgt.n	4156b2 <_svfprintf_r+0x114a>
  4156d6:	3330      	adds	r3, #48	; 0x30
  4156d8:	3802      	subs	r0, #2
  4156da:	b2d9      	uxtb	r1, r3
  4156dc:	4284      	cmp	r4, r0
  4156de:	f802 1c01 	strb.w	r1, [r2, #-1]
  4156e2:	f240 8170 	bls.w	4159c6 <_svfprintf_r+0x145e>
  4156e6:	f10d 007e 	add.w	r0, sp, #126	; 0x7e
  4156ea:	4613      	mov	r3, r2
  4156ec:	e001      	b.n	4156f2 <_svfprintf_r+0x118a>
  4156ee:	f813 1b01 	ldrb.w	r1, [r3], #1
  4156f2:	f800 1b01 	strb.w	r1, [r0], #1
  4156f6:	42a3      	cmp	r3, r4
  4156f8:	d1f9      	bne.n	4156ee <_svfprintf_r+0x1186>
  4156fa:	3301      	adds	r3, #1
  4156fc:	1a9b      	subs	r3, r3, r2
  4156fe:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
  415702:	4413      	add	r3, r2
  415704:	aa1f      	add	r2, sp, #124	; 0x7c
  415706:	1a9b      	subs	r3, r3, r2
  415708:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  41570a:	9315      	str	r3, [sp, #84]	; 0x54
  41570c:	2a01      	cmp	r2, #1
  41570e:	4413      	add	r3, r2
  415710:	930a      	str	r3, [sp, #40]	; 0x28
  415712:	f340 8120 	ble.w	415956 <_svfprintf_r+0x13ee>
  415716:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  415718:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  41571a:	4413      	add	r3, r2
  41571c:	930a      	str	r3, [sp, #40]	; 0x28
  41571e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  415722:	9304      	str	r3, [sp, #16]
  415724:	2300      	movs	r3, #0
  415726:	930e      	str	r3, [sp, #56]	; 0x38
  415728:	e6c8      	b.n	4154bc <_svfprintf_r+0xf54>
  41572a:	4623      	mov	r3, r4
  41572c:	e6a7      	b.n	41547e <_svfprintf_r+0xf16>
  41572e:	aa23      	add	r2, sp, #140	; 0x8c
  415730:	9907      	ldr	r1, [sp, #28]
  415732:	9808      	ldr	r0, [sp, #32]
  415734:	f002 f832 	bl	41779c <__ssprint_r>
  415738:	2800      	cmp	r0, #0
  41573a:	f47e afe7 	bne.w	41470c <_svfprintf_r+0x1a4>
  41573e:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415740:	46c8      	mov	r8, r9
  415742:	e4d5      	b.n	4150f0 <_svfprintf_r+0xb88>
  415744:	aa23      	add	r2, sp, #140	; 0x8c
  415746:	9907      	ldr	r1, [sp, #28]
  415748:	9808      	ldr	r0, [sp, #32]
  41574a:	f002 f827 	bl	41779c <__ssprint_r>
  41574e:	2800      	cmp	r0, #0
  415750:	f47e afdc 	bne.w	41470c <_svfprintf_r+0x1a4>
  415754:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  415756:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415758:	46c8      	mov	r8, r9
  41575a:	e5af      	b.n	4152bc <_svfprintf_r+0xd54>
  41575c:	aa23      	add	r2, sp, #140	; 0x8c
  41575e:	9907      	ldr	r1, [sp, #28]
  415760:	9808      	ldr	r0, [sp, #32]
  415762:	f002 f81b 	bl	41779c <__ssprint_r>
  415766:	2800      	cmp	r0, #0
  415768:	f47e afd0 	bne.w	41470c <_svfprintf_r+0x1a4>
  41576c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  41576e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  415770:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415772:	1a9a      	subs	r2, r3, r2
  415774:	46c8      	mov	r8, r9
  415776:	e5b9      	b.n	4152ec <_svfprintf_r+0xd84>
  415778:	9b06      	ldr	r3, [sp, #24]
  41577a:	960e      	str	r6, [sp, #56]	; 0x38
  41577c:	2b06      	cmp	r3, #6
  41577e:	bf28      	it	cs
  415780:	2306      	movcs	r3, #6
  415782:	9606      	str	r6, [sp, #24]
  415784:	4637      	mov	r7, r6
  415786:	9304      	str	r3, [sp, #16]
  415788:	950b      	str	r5, [sp, #44]	; 0x2c
  41578a:	f8cd b00c 	str.w	fp, [sp, #12]
  41578e:	930a      	str	r3, [sp, #40]	; 0x28
  415790:	4e77      	ldr	r6, [pc, #476]	; (415970 <_svfprintf_r+0x1408>)
  415792:	f7ff b801 	b.w	414798 <_svfprintf_r+0x230>
  415796:	2306      	movs	r3, #6
  415798:	9306      	str	r3, [sp, #24]
  41579a:	e62d      	b.n	4153f8 <_svfprintf_r+0xe90>
  41579c:	9c06      	ldr	r4, [sp, #24]
  41579e:	9808      	ldr	r0, [sp, #32]
  4157a0:	aa21      	add	r2, sp, #132	; 0x84
  4157a2:	ab1e      	add	r3, sp, #120	; 0x78
  4157a4:	9201      	str	r2, [sp, #4]
  4157a6:	9300      	str	r3, [sp, #0]
  4157a8:	4622      	mov	r2, r4
  4157aa:	ab1d      	add	r3, sp, #116	; 0x74
  4157ac:	2103      	movs	r1, #3
  4157ae:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
  4157b2:	f000 fa11 	bl	415bd8 <_dtoa_r>
  4157b6:	4623      	mov	r3, r4
  4157b8:	4606      	mov	r6, r0
  4157ba:	1904      	adds	r4, r0, r4
  4157bc:	461d      	mov	r5, r3
  4157be:	e734      	b.n	41562a <_svfprintf_r+0x10c2>
  4157c0:	272d      	movs	r7, #45	; 0x2d
  4157c2:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  4157c6:	f7ff baca 	b.w	414d5e <_svfprintf_r+0x7f6>
  4157ca:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  4157cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4157ce:	4413      	add	r3, r2
  4157d0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4157d2:	930a      	str	r3, [sp, #40]	; 0x28
  4157d4:	2a00      	cmp	r2, #0
  4157d6:	f340 80b7 	ble.w	415948 <_svfprintf_r+0x13e0>
  4157da:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4157de:	9304      	str	r3, [sp, #16]
  4157e0:	2367      	movs	r3, #103	; 0x67
  4157e2:	930d      	str	r3, [sp, #52]	; 0x34
  4157e4:	e66a      	b.n	4154bc <_svfprintf_r+0xf54>
  4157e6:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
  4157ea:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
  4157ee:	9319      	str	r3, [sp, #100]	; 0x64
  4157f0:	232d      	movs	r3, #45	; 0x2d
  4157f2:	9118      	str	r1, [sp, #96]	; 0x60
  4157f4:	930c      	str	r3, [sp, #48]	; 0x30
  4157f6:	e60c      	b.n	415412 <_svfprintf_r+0xeaa>
  4157f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4157fa:	2b47      	cmp	r3, #71	; 0x47
  4157fc:	f47f ae2b 	bne.w	415456 <_svfprintf_r+0xeee>
  415800:	f01b 0f01 	tst.w	fp, #1
  415804:	f47f af0b 	bne.w	41561e <_svfprintf_r+0x10b6>
  415808:	9b21      	ldr	r3, [sp, #132]	; 0x84
  41580a:	2f47      	cmp	r7, #71	; 0x47
  41580c:	eba3 0306 	sub.w	r3, r3, r6
  415810:	930f      	str	r3, [sp, #60]	; 0x3c
  415812:	f43f af29 	beq.w	415668 <_svfprintf_r+0x1100>
  415816:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  415818:	930e      	str	r3, [sp, #56]	; 0x38
  41581a:	e732      	b.n	415682 <_svfprintf_r+0x111a>
  41581c:	2b00      	cmp	r3, #0
  41581e:	f340 80af 	ble.w	415980 <_svfprintf_r+0x1418>
  415822:	9a06      	ldr	r2, [sp, #24]
  415824:	2a00      	cmp	r2, #0
  415826:	d16b      	bne.n	415900 <_svfprintf_r+0x1398>
  415828:	f01b 0f01 	tst.w	fp, #1
  41582c:	d168      	bne.n	415900 <_svfprintf_r+0x1398>
  41582e:	9304      	str	r3, [sp, #16]
  415830:	930a      	str	r3, [sp, #40]	; 0x28
  415832:	e643      	b.n	4154bc <_svfprintf_r+0xf54>
  415834:	9b06      	ldr	r3, [sp, #24]
  415836:	9304      	str	r3, [sp, #16]
  415838:	930a      	str	r3, [sp, #40]	; 0x28
  41583a:	9006      	str	r0, [sp, #24]
  41583c:	950b      	str	r5, [sp, #44]	; 0x2c
  41583e:	f8cd b00c 	str.w	fp, [sp, #12]
  415842:	900e      	str	r0, [sp, #56]	; 0x38
  415844:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  415848:	f7fe bfa6 	b.w	414798 <_svfprintf_r+0x230>
  41584c:	2000      	movs	r0, #0
  41584e:	9006      	str	r0, [sp, #24]
  415850:	f7fe bee4 	b.w	41461c <_svfprintf_r+0xb4>
  415854:	424f      	negs	r7, r1
  415856:	3110      	adds	r1, #16
  415858:	4d46      	ldr	r5, [pc, #280]	; (415974 <_svfprintf_r+0x140c>)
  41585a:	da2b      	bge.n	4158b4 <_svfprintf_r+0x134c>
  41585c:	2410      	movs	r4, #16
  41585e:	f8dd b020 	ldr.w	fp, [sp, #32]
  415862:	e004      	b.n	41586e <_svfprintf_r+0x1306>
  415864:	f108 0808 	add.w	r8, r8, #8
  415868:	3f10      	subs	r7, #16
  41586a:	2f10      	cmp	r7, #16
  41586c:	dd22      	ble.n	4158b4 <_svfprintf_r+0x134c>
  41586e:	3301      	adds	r3, #1
  415870:	3210      	adds	r2, #16
  415872:	2b07      	cmp	r3, #7
  415874:	9225      	str	r2, [sp, #148]	; 0x94
  415876:	9324      	str	r3, [sp, #144]	; 0x90
  415878:	f8c8 5000 	str.w	r5, [r8]
  41587c:	f8c8 4004 	str.w	r4, [r8, #4]
  415880:	ddf0      	ble.n	415864 <_svfprintf_r+0x12fc>
  415882:	aa23      	add	r2, sp, #140	; 0x8c
  415884:	9907      	ldr	r1, [sp, #28]
  415886:	4658      	mov	r0, fp
  415888:	f001 ff88 	bl	41779c <__ssprint_r>
  41588c:	2800      	cmp	r0, #0
  41588e:	f47e af3d 	bne.w	41470c <_svfprintf_r+0x1a4>
  415892:	9a25      	ldr	r2, [sp, #148]	; 0x94
  415894:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415896:	46c8      	mov	r8, r9
  415898:	e7e6      	b.n	415868 <_svfprintf_r+0x1300>
  41589a:	aa23      	add	r2, sp, #140	; 0x8c
  41589c:	9907      	ldr	r1, [sp, #28]
  41589e:	9808      	ldr	r0, [sp, #32]
  4158a0:	f001 ff7c 	bl	41779c <__ssprint_r>
  4158a4:	2800      	cmp	r0, #0
  4158a6:	f47e af31 	bne.w	41470c <_svfprintf_r+0x1a4>
  4158aa:	991d      	ldr	r1, [sp, #116]	; 0x74
  4158ac:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4158ae:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4158b0:	46c8      	mov	r8, r9
  4158b2:	e65f      	b.n	415574 <_svfprintf_r+0x100c>
  4158b4:	3301      	adds	r3, #1
  4158b6:	443a      	add	r2, r7
  4158b8:	2b07      	cmp	r3, #7
  4158ba:	e888 00a0 	stmia.w	r8, {r5, r7}
  4158be:	9225      	str	r2, [sp, #148]	; 0x94
  4158c0:	9324      	str	r3, [sp, #144]	; 0x90
  4158c2:	f108 0808 	add.w	r8, r8, #8
  4158c6:	f77f ae58 	ble.w	41557a <_svfprintf_r+0x1012>
  4158ca:	aa23      	add	r2, sp, #140	; 0x8c
  4158cc:	9907      	ldr	r1, [sp, #28]
  4158ce:	9808      	ldr	r0, [sp, #32]
  4158d0:	f001 ff64 	bl	41779c <__ssprint_r>
  4158d4:	2800      	cmp	r0, #0
  4158d6:	f47e af19 	bne.w	41470c <_svfprintf_r+0x1a4>
  4158da:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4158dc:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4158de:	46c8      	mov	r8, r9
  4158e0:	e64b      	b.n	41557a <_svfprintf_r+0x1012>
  4158e2:	3330      	adds	r3, #48	; 0x30
  4158e4:	2230      	movs	r2, #48	; 0x30
  4158e6:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
  4158ea:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
  4158ee:	ab20      	add	r3, sp, #128	; 0x80
  4158f0:	e708      	b.n	415704 <_svfprintf_r+0x119c>
  4158f2:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4158f4:	e5c3      	b.n	41547e <_svfprintf_r+0xf16>
  4158f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4158f8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  4158fa:	4413      	add	r3, r2
  4158fc:	930a      	str	r3, [sp, #40]	; 0x28
  4158fe:	e76c      	b.n	4157da <_svfprintf_r+0x1272>
  415900:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  415902:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  415904:	4413      	add	r3, r2
  415906:	9a06      	ldr	r2, [sp, #24]
  415908:	441a      	add	r2, r3
  41590a:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  41590e:	920a      	str	r2, [sp, #40]	; 0x28
  415910:	9304      	str	r3, [sp, #16]
  415912:	e5d3      	b.n	4154bc <_svfprintf_r+0xf54>
  415914:	9b11      	ldr	r3, [sp, #68]	; 0x44
  415916:	4e18      	ldr	r6, [pc, #96]	; (415978 <_svfprintf_r+0x1410>)
  415918:	2b00      	cmp	r3, #0
  41591a:	bfb6      	itet	lt
  41591c:	272d      	movlt	r7, #45	; 0x2d
  41591e:	f89d 706f 	ldrbge.w	r7, [sp, #111]	; 0x6f
  415922:	f88d 706f 	strblt.w	r7, [sp, #111]	; 0x6f
  415926:	4b15      	ldr	r3, [pc, #84]	; (41597c <_svfprintf_r+0x1414>)
  415928:	f7ff ba1b 	b.w	414d62 <_svfprintf_r+0x7fa>
  41592c:	2200      	movs	r2, #0
  41592e:	2300      	movs	r3, #0
  415930:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
  415934:	f002 fb98 	bl	418068 <__aeabi_dcmpeq>
  415938:	2800      	cmp	r0, #0
  41593a:	f47f ae7a 	bne.w	415632 <_svfprintf_r+0x10ca>
  41593e:	f1c5 0501 	rsb	r5, r5, #1
  415942:	951d      	str	r5, [sp, #116]	; 0x74
  415944:	442c      	add	r4, r5
  415946:	e587      	b.n	415458 <_svfprintf_r+0xef0>
  415948:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  41594a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  41594c:	f1c3 0301 	rsb	r3, r3, #1
  415950:	441a      	add	r2, r3
  415952:	4613      	mov	r3, r2
  415954:	e7d2      	b.n	4158fc <_svfprintf_r+0x1394>
  415956:	f01b 0301 	ands.w	r3, fp, #1
  41595a:	930e      	str	r3, [sp, #56]	; 0x38
  41595c:	f47f aedb 	bne.w	415716 <_svfprintf_r+0x11ae>
  415960:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  415962:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  415966:	9304      	str	r3, [sp, #16]
  415968:	e5a8      	b.n	4154bc <_svfprintf_r+0xf54>
  41596a:	bf00      	nop
  41596c:	66666667 	.word	0x66666667
  415970:	0041d83c 	.word	0x0041d83c
  415974:	0041d858 	.word	0x0041d858
  415978:	0041d810 	.word	0x0041d810
  41597c:	0041d80c 	.word	0x0041d80c
  415980:	9b06      	ldr	r3, [sp, #24]
  415982:	b913      	cbnz	r3, 41598a <_svfprintf_r+0x1422>
  415984:	f01b 0f01 	tst.w	fp, #1
  415988:	d002      	beq.n	415990 <_svfprintf_r+0x1428>
  41598a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  41598c:	3301      	adds	r3, #1
  41598e:	e7ba      	b.n	415906 <_svfprintf_r+0x139e>
  415990:	2301      	movs	r3, #1
  415992:	e74c      	b.n	41582e <_svfprintf_r+0x12c6>
  415994:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  415996:	f89a 3001 	ldrb.w	r3, [sl, #1]
  41599a:	6828      	ldr	r0, [r5, #0]
  41599c:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
  4159a0:	9006      	str	r0, [sp, #24]
  4159a2:	4628      	mov	r0, r5
  4159a4:	3004      	adds	r0, #4
  4159a6:	46a2      	mov	sl, r4
  4159a8:	900b      	str	r0, [sp, #44]	; 0x2c
  4159aa:	f7fe be35 	b.w	414618 <_svfprintf_r+0xb0>
  4159ae:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4159b2:	f7ff b852 	b.w	414a5a <_svfprintf_r+0x4f2>
  4159b6:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4159ba:	f7ff b8de 	b.w	414b7a <_svfprintf_r+0x612>
  4159be:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4159c2:	f7ff ba07 	b.w	414dd4 <_svfprintf_r+0x86c>
  4159c6:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
  4159ca:	e69b      	b.n	415704 <_svfprintf_r+0x119c>
  4159cc:	9a08      	ldr	r2, [sp, #32]
  4159ce:	230c      	movs	r3, #12
  4159d0:	6013      	str	r3, [r2, #0]
  4159d2:	f04f 33ff 	mov.w	r3, #4294967295
  4159d6:	9305      	str	r3, [sp, #20]
  4159d8:	f7fe bea1 	b.w	41471e <_svfprintf_r+0x1b6>
  4159dc:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4159e0:	f7ff b986 	b.w	414cf0 <_svfprintf_r+0x788>
  4159e4:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4159e8:	f7ff b962 	b.w	414cb0 <_svfprintf_r+0x748>
  4159ec:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4159f0:	f7ff b945 	b.w	414c7e <_svfprintf_r+0x716>
  4159f4:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4159f8:	f7ff b8fe 	b.w	414bf8 <_svfprintf_r+0x690>

004159fc <_vsnprintf_r>:
  4159fc:	b570      	push	{r4, r5, r6, lr}
  4159fe:	1e14      	subs	r4, r2, #0
  415a00:	b09a      	sub	sp, #104	; 0x68
  415a02:	4605      	mov	r5, r0
  415a04:	db2e      	blt.n	415a64 <_vsnprintf_r+0x68>
  415a06:	461a      	mov	r2, r3
  415a08:	f44f 7302 	mov.w	r3, #520	; 0x208
  415a0c:	9100      	str	r1, [sp, #0]
  415a0e:	9104      	str	r1, [sp, #16]
  415a10:	f8ad 300c 	strh.w	r3, [sp, #12]
  415a14:	d011      	beq.n	415a3a <_vsnprintf_r+0x3e>
  415a16:	3c01      	subs	r4, #1
  415a18:	f64f 76ff 	movw	r6, #65535	; 0xffff
  415a1c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  415a1e:	9402      	str	r4, [sp, #8]
  415a20:	4669      	mov	r1, sp
  415a22:	9405      	str	r4, [sp, #20]
  415a24:	f8ad 600e 	strh.w	r6, [sp, #14]
  415a28:	f7fe fd9e 	bl	414568 <_svfprintf_r>
  415a2c:	1c42      	adds	r2, r0, #1
  415a2e:	db12      	blt.n	415a56 <_vsnprintf_r+0x5a>
  415a30:	9b00      	ldr	r3, [sp, #0]
  415a32:	2200      	movs	r2, #0
  415a34:	701a      	strb	r2, [r3, #0]
  415a36:	b01a      	add	sp, #104	; 0x68
  415a38:	bd70      	pop	{r4, r5, r6, pc}
  415a3a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  415a3c:	9402      	str	r4, [sp, #8]
  415a3e:	f64f 76ff 	movw	r6, #65535	; 0xffff
  415a42:	4669      	mov	r1, sp
  415a44:	9405      	str	r4, [sp, #20]
  415a46:	f8ad 600e 	strh.w	r6, [sp, #14]
  415a4a:	f7fe fd8d 	bl	414568 <_svfprintf_r>
  415a4e:	1c43      	adds	r3, r0, #1
  415a50:	db04      	blt.n	415a5c <_vsnprintf_r+0x60>
  415a52:	b01a      	add	sp, #104	; 0x68
  415a54:	bd70      	pop	{r4, r5, r6, pc}
  415a56:	238b      	movs	r3, #139	; 0x8b
  415a58:	602b      	str	r3, [r5, #0]
  415a5a:	e7e9      	b.n	415a30 <_vsnprintf_r+0x34>
  415a5c:	238b      	movs	r3, #139	; 0x8b
  415a5e:	602b      	str	r3, [r5, #0]
  415a60:	b01a      	add	sp, #104	; 0x68
  415a62:	bd70      	pop	{r4, r5, r6, pc}
  415a64:	238b      	movs	r3, #139	; 0x8b
  415a66:	6003      	str	r3, [r0, #0]
  415a68:	f04f 30ff 	mov.w	r0, #4294967295
  415a6c:	e7f1      	b.n	415a52 <_vsnprintf_r+0x56>
  415a6e:	bf00      	nop

00415a70 <vsnprintf>:
  415a70:	b510      	push	{r4, lr}
  415a72:	b082      	sub	sp, #8
  415a74:	4c05      	ldr	r4, [pc, #20]	; (415a8c <vsnprintf+0x1c>)
  415a76:	9300      	str	r3, [sp, #0]
  415a78:	6824      	ldr	r4, [r4, #0]
  415a7a:	4613      	mov	r3, r2
  415a7c:	460a      	mov	r2, r1
  415a7e:	4601      	mov	r1, r0
  415a80:	4620      	mov	r0, r4
  415a82:	f7ff ffbb 	bl	4159fc <_vsnprintf_r>
  415a86:	b002      	add	sp, #8
  415a88:	bd10      	pop	{r4, pc}
  415a8a:	bf00      	nop
  415a8c:	20000358 	.word	0x20000358

00415a90 <register_fini>:
  415a90:	4b02      	ldr	r3, [pc, #8]	; (415a9c <register_fini+0xc>)
  415a92:	b113      	cbz	r3, 415a9a <register_fini+0xa>
  415a94:	4802      	ldr	r0, [pc, #8]	; (415aa0 <register_fini+0x10>)
  415a96:	f000 b805 	b.w	415aa4 <atexit>
  415a9a:	4770      	bx	lr
  415a9c:	00000000 	.word	0x00000000
  415aa0:	00416a25 	.word	0x00416a25

00415aa4 <atexit>:
  415aa4:	2300      	movs	r3, #0
  415aa6:	4601      	mov	r1, r0
  415aa8:	461a      	mov	r2, r3
  415aaa:	4618      	mov	r0, r3
  415aac:	f001 bef4 	b.w	417898 <__register_exitproc>

00415ab0 <quorem>:
  415ab0:	6902      	ldr	r2, [r0, #16]
  415ab2:	690b      	ldr	r3, [r1, #16]
  415ab4:	4293      	cmp	r3, r2
  415ab6:	f300 808d 	bgt.w	415bd4 <quorem+0x124>
  415aba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  415abe:	f103 38ff 	add.w	r8, r3, #4294967295
  415ac2:	f101 0714 	add.w	r7, r1, #20
  415ac6:	f100 0b14 	add.w	fp, r0, #20
  415aca:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
  415ace:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
  415ad2:	ea4f 0488 	mov.w	r4, r8, lsl #2
  415ad6:	b083      	sub	sp, #12
  415ad8:	3201      	adds	r2, #1
  415ada:	fbb3 f9f2 	udiv	r9, r3, r2
  415ade:	eb0b 0304 	add.w	r3, fp, r4
  415ae2:	9400      	str	r4, [sp, #0]
  415ae4:	eb07 0a04 	add.w	sl, r7, r4
  415ae8:	9301      	str	r3, [sp, #4]
  415aea:	f1b9 0f00 	cmp.w	r9, #0
  415aee:	d039      	beq.n	415b64 <quorem+0xb4>
  415af0:	2500      	movs	r5, #0
  415af2:	462e      	mov	r6, r5
  415af4:	46bc      	mov	ip, r7
  415af6:	46de      	mov	lr, fp
  415af8:	f85c 4b04 	ldr.w	r4, [ip], #4
  415afc:	f8de 3000 	ldr.w	r3, [lr]
  415b00:	b2a2      	uxth	r2, r4
  415b02:	fb09 5502 	mla	r5, r9, r2, r5
  415b06:	0c22      	lsrs	r2, r4, #16
  415b08:	0c2c      	lsrs	r4, r5, #16
  415b0a:	fb09 4202 	mla	r2, r9, r2, r4
  415b0e:	b2ad      	uxth	r5, r5
  415b10:	1b75      	subs	r5, r6, r5
  415b12:	b296      	uxth	r6, r2
  415b14:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
  415b18:	fa15 f383 	uxtah	r3, r5, r3
  415b1c:	eb06 4623 	add.w	r6, r6, r3, asr #16
  415b20:	b29b      	uxth	r3, r3
  415b22:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
  415b26:	45e2      	cmp	sl, ip
  415b28:	ea4f 4512 	mov.w	r5, r2, lsr #16
  415b2c:	f84e 3b04 	str.w	r3, [lr], #4
  415b30:	ea4f 4626 	mov.w	r6, r6, asr #16
  415b34:	d2e0      	bcs.n	415af8 <quorem+0x48>
  415b36:	9b00      	ldr	r3, [sp, #0]
  415b38:	f85b 3003 	ldr.w	r3, [fp, r3]
  415b3c:	b993      	cbnz	r3, 415b64 <quorem+0xb4>
  415b3e:	9c01      	ldr	r4, [sp, #4]
  415b40:	1f23      	subs	r3, r4, #4
  415b42:	459b      	cmp	fp, r3
  415b44:	d20c      	bcs.n	415b60 <quorem+0xb0>
  415b46:	f854 3c04 	ldr.w	r3, [r4, #-4]
  415b4a:	b94b      	cbnz	r3, 415b60 <quorem+0xb0>
  415b4c:	f1a4 0308 	sub.w	r3, r4, #8
  415b50:	e002      	b.n	415b58 <quorem+0xa8>
  415b52:	681a      	ldr	r2, [r3, #0]
  415b54:	3b04      	subs	r3, #4
  415b56:	b91a      	cbnz	r2, 415b60 <quorem+0xb0>
  415b58:	459b      	cmp	fp, r3
  415b5a:	f108 38ff 	add.w	r8, r8, #4294967295
  415b5e:	d3f8      	bcc.n	415b52 <quorem+0xa2>
  415b60:	f8c0 8010 	str.w	r8, [r0, #16]
  415b64:	4604      	mov	r4, r0
  415b66:	f001 fc95 	bl	417494 <__mcmp>
  415b6a:	2800      	cmp	r0, #0
  415b6c:	db2e      	blt.n	415bcc <quorem+0x11c>
  415b6e:	f109 0901 	add.w	r9, r9, #1
  415b72:	465d      	mov	r5, fp
  415b74:	2300      	movs	r3, #0
  415b76:	f857 1b04 	ldr.w	r1, [r7], #4
  415b7a:	6828      	ldr	r0, [r5, #0]
  415b7c:	b28a      	uxth	r2, r1
  415b7e:	1a9a      	subs	r2, r3, r2
  415b80:	0c0b      	lsrs	r3, r1, #16
  415b82:	fa12 f280 	uxtah	r2, r2, r0
  415b86:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
  415b8a:	eb03 4322 	add.w	r3, r3, r2, asr #16
  415b8e:	b292      	uxth	r2, r2
  415b90:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  415b94:	45ba      	cmp	sl, r7
  415b96:	f845 2b04 	str.w	r2, [r5], #4
  415b9a:	ea4f 4323 	mov.w	r3, r3, asr #16
  415b9e:	d2ea      	bcs.n	415b76 <quorem+0xc6>
  415ba0:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
  415ba4:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
  415ba8:	b982      	cbnz	r2, 415bcc <quorem+0x11c>
  415baa:	1f1a      	subs	r2, r3, #4
  415bac:	4593      	cmp	fp, r2
  415bae:	d20b      	bcs.n	415bc8 <quorem+0x118>
  415bb0:	f853 2c04 	ldr.w	r2, [r3, #-4]
  415bb4:	b942      	cbnz	r2, 415bc8 <quorem+0x118>
  415bb6:	3b08      	subs	r3, #8
  415bb8:	e002      	b.n	415bc0 <quorem+0x110>
  415bba:	681a      	ldr	r2, [r3, #0]
  415bbc:	3b04      	subs	r3, #4
  415bbe:	b91a      	cbnz	r2, 415bc8 <quorem+0x118>
  415bc0:	459b      	cmp	fp, r3
  415bc2:	f108 38ff 	add.w	r8, r8, #4294967295
  415bc6:	d3f8      	bcc.n	415bba <quorem+0x10a>
  415bc8:	f8c4 8010 	str.w	r8, [r4, #16]
  415bcc:	4648      	mov	r0, r9
  415bce:	b003      	add	sp, #12
  415bd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415bd4:	2000      	movs	r0, #0
  415bd6:	4770      	bx	lr

00415bd8 <_dtoa_r>:
  415bd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  415bdc:	ec57 6b10 	vmov	r6, r7, d0
  415be0:	b097      	sub	sp, #92	; 0x5c
  415be2:	6c05      	ldr	r5, [r0, #64]	; 0x40
  415be4:	9102      	str	r1, [sp, #8]
  415be6:	4604      	mov	r4, r0
  415be8:	4693      	mov	fp, r2
  415bea:	9303      	str	r3, [sp, #12]
  415bec:	e9cd 6700 	strd	r6, r7, [sp]
  415bf0:	b14d      	cbz	r5, 415c06 <_dtoa_r+0x2e>
  415bf2:	6c42      	ldr	r2, [r0, #68]	; 0x44
  415bf4:	606a      	str	r2, [r5, #4]
  415bf6:	2301      	movs	r3, #1
  415bf8:	4093      	lsls	r3, r2
  415bfa:	60ab      	str	r3, [r5, #8]
  415bfc:	4629      	mov	r1, r5
  415bfe:	f001 fa71 	bl	4170e4 <_Bfree>
  415c02:	2300      	movs	r3, #0
  415c04:	6423      	str	r3, [r4, #64]	; 0x40
  415c06:	e9dd 2300 	ldrd	r2, r3, [sp]
  415c0a:	2b00      	cmp	r3, #0
  415c0c:	4699      	mov	r9, r3
  415c0e:	db38      	blt.n	415c82 <_dtoa_r+0xaa>
  415c10:	9a20      	ldr	r2, [sp, #128]	; 0x80
  415c12:	2300      	movs	r3, #0
  415c14:	6013      	str	r3, [r2, #0]
  415c16:	4ba0      	ldr	r3, [pc, #640]	; (415e98 <_dtoa_r+0x2c0>)
  415c18:	ea33 0309 	bics.w	r3, r3, r9
  415c1c:	d017      	beq.n	415c4e <_dtoa_r+0x76>
  415c1e:	e9dd 6700 	ldrd	r6, r7, [sp]
  415c22:	2200      	movs	r2, #0
  415c24:	2300      	movs	r3, #0
  415c26:	4630      	mov	r0, r6
  415c28:	4639      	mov	r1, r7
  415c2a:	f002 fa1d 	bl	418068 <__aeabi_dcmpeq>
  415c2e:	4680      	mov	r8, r0
  415c30:	2800      	cmp	r0, #0
  415c32:	d02f      	beq.n	415c94 <_dtoa_r+0xbc>
  415c34:	9a03      	ldr	r2, [sp, #12]
  415c36:	2301      	movs	r3, #1
  415c38:	6013      	str	r3, [r2, #0]
  415c3a:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415c3c:	2b00      	cmp	r3, #0
  415c3e:	f000 80c4 	beq.w	415dca <_dtoa_r+0x1f2>
  415c42:	4896      	ldr	r0, [pc, #600]	; (415e9c <_dtoa_r+0x2c4>)
  415c44:	6018      	str	r0, [r3, #0]
  415c46:	3801      	subs	r0, #1
  415c48:	b017      	add	sp, #92	; 0x5c
  415c4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415c4e:	9a03      	ldr	r2, [sp, #12]
  415c50:	f242 730f 	movw	r3, #9999	; 0x270f
  415c54:	6013      	str	r3, [r2, #0]
  415c56:	9b00      	ldr	r3, [sp, #0]
  415c58:	b96b      	cbnz	r3, 415c76 <_dtoa_r+0x9e>
  415c5a:	f3c9 0313 	ubfx	r3, r9, #0, #20
  415c5e:	b953      	cbnz	r3, 415c76 <_dtoa_r+0x9e>
  415c60:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415c62:	488f      	ldr	r0, [pc, #572]	; (415ea0 <_dtoa_r+0x2c8>)
  415c64:	2b00      	cmp	r3, #0
  415c66:	d0ef      	beq.n	415c48 <_dtoa_r+0x70>
  415c68:	f100 0308 	add.w	r3, r0, #8
  415c6c:	9a21      	ldr	r2, [sp, #132]	; 0x84
  415c6e:	6013      	str	r3, [r2, #0]
  415c70:	b017      	add	sp, #92	; 0x5c
  415c72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415c76:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415c78:	488a      	ldr	r0, [pc, #552]	; (415ea4 <_dtoa_r+0x2cc>)
  415c7a:	2b00      	cmp	r3, #0
  415c7c:	d0e4      	beq.n	415c48 <_dtoa_r+0x70>
  415c7e:	1cc3      	adds	r3, r0, #3
  415c80:	e7f4      	b.n	415c6c <_dtoa_r+0x94>
  415c82:	9a01      	ldr	r2, [sp, #4]
  415c84:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
  415c88:	9a20      	ldr	r2, [sp, #128]	; 0x80
  415c8a:	f8cd 9004 	str.w	r9, [sp, #4]
  415c8e:	2301      	movs	r3, #1
  415c90:	6013      	str	r3, [r2, #0]
  415c92:	e7c0      	b.n	415c16 <_dtoa_r+0x3e>
  415c94:	aa14      	add	r2, sp, #80	; 0x50
  415c96:	a915      	add	r1, sp, #84	; 0x54
  415c98:	ec47 6b10 	vmov	d0, r6, r7
  415c9c:	4620      	mov	r0, r4
  415c9e:	f001 fc99 	bl	4175d4 <__d2b>
  415ca2:	ea5f 5519 	movs.w	r5, r9, lsr #20
  415ca6:	4682      	mov	sl, r0
  415ca8:	d073      	beq.n	415d92 <_dtoa_r+0x1ba>
  415caa:	f3c7 0313 	ubfx	r3, r7, #0, #20
  415cae:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
  415cb2:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
  415cb6:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  415cba:	4630      	mov	r0, r6
  415cbc:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
  415cc0:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  415cc4:	2200      	movs	r2, #0
  415cc6:	4b78      	ldr	r3, [pc, #480]	; (415ea8 <_dtoa_r+0x2d0>)
  415cc8:	f7fd fcb8 	bl	41363c <__aeabi_dsub>
  415ccc:	a36c      	add	r3, pc, #432	; (adr r3, 415e80 <_dtoa_r+0x2a8>)
  415cce:	e9d3 2300 	ldrd	r2, r3, [r3]
  415cd2:	f7fd fe67 	bl	4139a4 <__aeabi_dmul>
  415cd6:	a36c      	add	r3, pc, #432	; (adr r3, 415e88 <_dtoa_r+0x2b0>)
  415cd8:	e9d3 2300 	ldrd	r2, r3, [r3]
  415cdc:	f7fd fcb0 	bl	413640 <__adddf3>
  415ce0:	4606      	mov	r6, r0
  415ce2:	4628      	mov	r0, r5
  415ce4:	460f      	mov	r7, r1
  415ce6:	f7fd fdf7 	bl	4138d8 <__aeabi_i2d>
  415cea:	a369      	add	r3, pc, #420	; (adr r3, 415e90 <_dtoa_r+0x2b8>)
  415cec:	e9d3 2300 	ldrd	r2, r3, [r3]
  415cf0:	f7fd fe58 	bl	4139a4 <__aeabi_dmul>
  415cf4:	4602      	mov	r2, r0
  415cf6:	460b      	mov	r3, r1
  415cf8:	4630      	mov	r0, r6
  415cfa:	4639      	mov	r1, r7
  415cfc:	f7fd fca0 	bl	413640 <__adddf3>
  415d00:	4606      	mov	r6, r0
  415d02:	460f      	mov	r7, r1
  415d04:	f002 f9f8 	bl	4180f8 <__aeabi_d2iz>
  415d08:	2200      	movs	r2, #0
  415d0a:	9004      	str	r0, [sp, #16]
  415d0c:	2300      	movs	r3, #0
  415d0e:	4630      	mov	r0, r6
  415d10:	4639      	mov	r1, r7
  415d12:	f002 f9b3 	bl	41807c <__aeabi_dcmplt>
  415d16:	2800      	cmp	r0, #0
  415d18:	f040 816f 	bne.w	415ffa <_dtoa_r+0x422>
  415d1c:	9e04      	ldr	r6, [sp, #16]
  415d1e:	2e16      	cmp	r6, #22
  415d20:	f200 8159 	bhi.w	415fd6 <_dtoa_r+0x3fe>
  415d24:	4b61      	ldr	r3, [pc, #388]	; (415eac <_dtoa_r+0x2d4>)
  415d26:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
  415d2a:	e9d3 0100 	ldrd	r0, r1, [r3]
  415d2e:	e9dd 2300 	ldrd	r2, r3, [sp]
  415d32:	f002 f9c1 	bl	4180b8 <__aeabi_dcmpgt>
  415d36:	2800      	cmp	r0, #0
  415d38:	f000 81c4 	beq.w	4160c4 <_dtoa_r+0x4ec>
  415d3c:	1e73      	subs	r3, r6, #1
  415d3e:	9304      	str	r3, [sp, #16]
  415d40:	2300      	movs	r3, #0
  415d42:	930c      	str	r3, [sp, #48]	; 0x30
  415d44:	eba8 0505 	sub.w	r5, r8, r5
  415d48:	1e6b      	subs	r3, r5, #1
  415d4a:	9305      	str	r3, [sp, #20]
  415d4c:	f100 814f 	bmi.w	415fee <_dtoa_r+0x416>
  415d50:	2300      	movs	r3, #0
  415d52:	9306      	str	r3, [sp, #24]
  415d54:	9b04      	ldr	r3, [sp, #16]
  415d56:	2b00      	cmp	r3, #0
  415d58:	f2c0 8140 	blt.w	415fdc <_dtoa_r+0x404>
  415d5c:	9a05      	ldr	r2, [sp, #20]
  415d5e:	930b      	str	r3, [sp, #44]	; 0x2c
  415d60:	4611      	mov	r1, r2
  415d62:	4419      	add	r1, r3
  415d64:	2300      	movs	r3, #0
  415d66:	9105      	str	r1, [sp, #20]
  415d68:	930a      	str	r3, [sp, #40]	; 0x28
  415d6a:	9b02      	ldr	r3, [sp, #8]
  415d6c:	2b09      	cmp	r3, #9
  415d6e:	d82e      	bhi.n	415dce <_dtoa_r+0x1f6>
  415d70:	2b05      	cmp	r3, #5
  415d72:	f340 8651 	ble.w	416a18 <_dtoa_r+0xe40>
  415d76:	3b04      	subs	r3, #4
  415d78:	9302      	str	r3, [sp, #8]
  415d7a:	2700      	movs	r7, #0
  415d7c:	9b02      	ldr	r3, [sp, #8]
  415d7e:	3b02      	subs	r3, #2
  415d80:	2b03      	cmp	r3, #3
  415d82:	f200 8633 	bhi.w	4169ec <_dtoa_r+0xe14>
  415d86:	e8df f013 	tbh	[pc, r3, lsl #1]
  415d8a:	03d6      	.short	0x03d6
  415d8c:	03e302cb 	.word	0x03e302cb
  415d90:	0464      	.short	0x0464
  415d92:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  415d96:	9d15      	ldr	r5, [sp, #84]	; 0x54
  415d98:	4445      	add	r5, r8
  415d9a:	f205 4332 	addw	r3, r5, #1074	; 0x432
  415d9e:	2b20      	cmp	r3, #32
  415da0:	f340 818a 	ble.w	4160b8 <_dtoa_r+0x4e0>
  415da4:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  415da8:	fa09 f903 	lsl.w	r9, r9, r3
  415dac:	9b00      	ldr	r3, [sp, #0]
  415dae:	f205 4012 	addw	r0, r5, #1042	; 0x412
  415db2:	fa23 f000 	lsr.w	r0, r3, r0
  415db6:	ea40 0009 	orr.w	r0, r0, r9
  415dba:	f7fd fd7d 	bl	4138b8 <__aeabi_ui2d>
  415dbe:	2301      	movs	r3, #1
  415dc0:	3d01      	subs	r5, #1
  415dc2:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  415dc6:	9310      	str	r3, [sp, #64]	; 0x40
  415dc8:	e77c      	b.n	415cc4 <_dtoa_r+0xec>
  415dca:	4839      	ldr	r0, [pc, #228]	; (415eb0 <_dtoa_r+0x2d8>)
  415dcc:	e73c      	b.n	415c48 <_dtoa_r+0x70>
  415dce:	2100      	movs	r1, #0
  415dd0:	6461      	str	r1, [r4, #68]	; 0x44
  415dd2:	4620      	mov	r0, r4
  415dd4:	468b      	mov	fp, r1
  415dd6:	f001 f95f 	bl	417098 <_Balloc>
  415dda:	f04f 33ff 	mov.w	r3, #4294967295
  415dde:	9308      	str	r3, [sp, #32]
  415de0:	930d      	str	r3, [sp, #52]	; 0x34
  415de2:	2301      	movs	r3, #1
  415de4:	9007      	str	r0, [sp, #28]
  415de6:	6420      	str	r0, [r4, #64]	; 0x40
  415de8:	f8cd b008 	str.w	fp, [sp, #8]
  415dec:	9309      	str	r3, [sp, #36]	; 0x24
  415dee:	9b15      	ldr	r3, [sp, #84]	; 0x54
  415df0:	2b00      	cmp	r3, #0
  415df2:	f2c0 80d0 	blt.w	415f96 <_dtoa_r+0x3be>
  415df6:	9a04      	ldr	r2, [sp, #16]
  415df8:	2a0e      	cmp	r2, #14
  415dfa:	f300 80cc 	bgt.w	415f96 <_dtoa_r+0x3be>
  415dfe:	4b2b      	ldr	r3, [pc, #172]	; (415eac <_dtoa_r+0x2d4>)
  415e00:	f1bb 0f00 	cmp.w	fp, #0
  415e04:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  415e08:	e9d3 8900 	ldrd	r8, r9, [r3]
  415e0c:	f2c0 83be 	blt.w	41658c <_dtoa_r+0x9b4>
  415e10:	e9dd 6700 	ldrd	r6, r7, [sp]
  415e14:	4642      	mov	r2, r8
  415e16:	464b      	mov	r3, r9
  415e18:	4630      	mov	r0, r6
  415e1a:	4639      	mov	r1, r7
  415e1c:	f7fd feec 	bl	413bf8 <__aeabi_ddiv>
  415e20:	f002 f96a 	bl	4180f8 <__aeabi_d2iz>
  415e24:	4683      	mov	fp, r0
  415e26:	f7fd fd57 	bl	4138d8 <__aeabi_i2d>
  415e2a:	4642      	mov	r2, r8
  415e2c:	464b      	mov	r3, r9
  415e2e:	f7fd fdb9 	bl	4139a4 <__aeabi_dmul>
  415e32:	460b      	mov	r3, r1
  415e34:	4602      	mov	r2, r0
  415e36:	4639      	mov	r1, r7
  415e38:	4630      	mov	r0, r6
  415e3a:	f7fd fbff 	bl	41363c <__aeabi_dsub>
  415e3e:	9d07      	ldr	r5, [sp, #28]
  415e40:	f10b 0330 	add.w	r3, fp, #48	; 0x30
  415e44:	702b      	strb	r3, [r5, #0]
  415e46:	9b08      	ldr	r3, [sp, #32]
  415e48:	2b01      	cmp	r3, #1
  415e4a:	4606      	mov	r6, r0
  415e4c:	460f      	mov	r7, r1
  415e4e:	f105 0501 	add.w	r5, r5, #1
  415e52:	d061      	beq.n	415f18 <_dtoa_r+0x340>
  415e54:	2200      	movs	r2, #0
  415e56:	4b17      	ldr	r3, [pc, #92]	; (415eb4 <_dtoa_r+0x2dc>)
  415e58:	f7fd fda4 	bl	4139a4 <__aeabi_dmul>
  415e5c:	2200      	movs	r2, #0
  415e5e:	2300      	movs	r3, #0
  415e60:	4606      	mov	r6, r0
  415e62:	460f      	mov	r7, r1
  415e64:	f002 f900 	bl	418068 <__aeabi_dcmpeq>
  415e68:	2800      	cmp	r0, #0
  415e6a:	f040 8081 	bne.w	415f70 <_dtoa_r+0x398>
  415e6e:	f8cd a000 	str.w	sl, [sp]
  415e72:	9402      	str	r4, [sp, #8]
  415e74:	f8dd a01c 	ldr.w	sl, [sp, #28]
  415e78:	9c08      	ldr	r4, [sp, #32]
  415e7a:	e028      	b.n	415ece <_dtoa_r+0x2f6>
  415e7c:	f3af 8000 	nop.w
  415e80:	636f4361 	.word	0x636f4361
  415e84:	3fd287a7 	.word	0x3fd287a7
  415e88:	8b60c8b3 	.word	0x8b60c8b3
  415e8c:	3fc68a28 	.word	0x3fc68a28
  415e90:	509f79fb 	.word	0x509f79fb
  415e94:	3fd34413 	.word	0x3fd34413
  415e98:	7ff00000 	.word	0x7ff00000
  415e9c:	0041d845 	.word	0x0041d845
  415ea0:	0041d868 	.word	0x0041d868
  415ea4:	0041d874 	.word	0x0041d874
  415ea8:	3ff80000 	.word	0x3ff80000
  415eac:	0041d8a0 	.word	0x0041d8a0
  415eb0:	0041d844 	.word	0x0041d844
  415eb4:	40240000 	.word	0x40240000
  415eb8:	f7fd fd74 	bl	4139a4 <__aeabi_dmul>
  415ebc:	2200      	movs	r2, #0
  415ebe:	2300      	movs	r3, #0
  415ec0:	4606      	mov	r6, r0
  415ec2:	460f      	mov	r7, r1
  415ec4:	f002 f8d0 	bl	418068 <__aeabi_dcmpeq>
  415ec8:	2800      	cmp	r0, #0
  415eca:	f040 83c5 	bne.w	416658 <_dtoa_r+0xa80>
  415ece:	4642      	mov	r2, r8
  415ed0:	464b      	mov	r3, r9
  415ed2:	4630      	mov	r0, r6
  415ed4:	4639      	mov	r1, r7
  415ed6:	f7fd fe8f 	bl	413bf8 <__aeabi_ddiv>
  415eda:	f002 f90d 	bl	4180f8 <__aeabi_d2iz>
  415ede:	4683      	mov	fp, r0
  415ee0:	f7fd fcfa 	bl	4138d8 <__aeabi_i2d>
  415ee4:	4642      	mov	r2, r8
  415ee6:	464b      	mov	r3, r9
  415ee8:	f7fd fd5c 	bl	4139a4 <__aeabi_dmul>
  415eec:	4602      	mov	r2, r0
  415eee:	460b      	mov	r3, r1
  415ef0:	4630      	mov	r0, r6
  415ef2:	4639      	mov	r1, r7
  415ef4:	f7fd fba2 	bl	41363c <__aeabi_dsub>
  415ef8:	f10b 0e30 	add.w	lr, fp, #48	; 0x30
  415efc:	f805 eb01 	strb.w	lr, [r5], #1
  415f00:	eba5 0e0a 	sub.w	lr, r5, sl
  415f04:	45a6      	cmp	lr, r4
  415f06:	4606      	mov	r6, r0
  415f08:	460f      	mov	r7, r1
  415f0a:	f04f 0200 	mov.w	r2, #0
  415f0e:	4b6e      	ldr	r3, [pc, #440]	; (4160c8 <_dtoa_r+0x4f0>)
  415f10:	d1d2      	bne.n	415eb8 <_dtoa_r+0x2e0>
  415f12:	f8dd a000 	ldr.w	sl, [sp]
  415f16:	9c02      	ldr	r4, [sp, #8]
  415f18:	4632      	mov	r2, r6
  415f1a:	463b      	mov	r3, r7
  415f1c:	4630      	mov	r0, r6
  415f1e:	4639      	mov	r1, r7
  415f20:	f7fd fb8e 	bl	413640 <__adddf3>
  415f24:	4606      	mov	r6, r0
  415f26:	460f      	mov	r7, r1
  415f28:	4602      	mov	r2, r0
  415f2a:	460b      	mov	r3, r1
  415f2c:	4640      	mov	r0, r8
  415f2e:	4649      	mov	r1, r9
  415f30:	f002 f8a4 	bl	41807c <__aeabi_dcmplt>
  415f34:	b948      	cbnz	r0, 415f4a <_dtoa_r+0x372>
  415f36:	4632      	mov	r2, r6
  415f38:	463b      	mov	r3, r7
  415f3a:	4640      	mov	r0, r8
  415f3c:	4649      	mov	r1, r9
  415f3e:	f002 f893 	bl	418068 <__aeabi_dcmpeq>
  415f42:	b1a8      	cbz	r0, 415f70 <_dtoa_r+0x398>
  415f44:	f01b 0f01 	tst.w	fp, #1
  415f48:	d012      	beq.n	415f70 <_dtoa_r+0x398>
  415f4a:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  415f4e:	9a07      	ldr	r2, [sp, #28]
  415f50:	1e6b      	subs	r3, r5, #1
  415f52:	e004      	b.n	415f5e <_dtoa_r+0x386>
  415f54:	429a      	cmp	r2, r3
  415f56:	f000 842d 	beq.w	4167b4 <_dtoa_r+0xbdc>
  415f5a:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
  415f5e:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
  415f62:	f103 0501 	add.w	r5, r3, #1
  415f66:	d0f5      	beq.n	415f54 <_dtoa_r+0x37c>
  415f68:	f108 0801 	add.w	r8, r8, #1
  415f6c:	f883 8000 	strb.w	r8, [r3]
  415f70:	4651      	mov	r1, sl
  415f72:	4620      	mov	r0, r4
  415f74:	f001 f8b6 	bl	4170e4 <_Bfree>
  415f78:	2200      	movs	r2, #0
  415f7a:	9b04      	ldr	r3, [sp, #16]
  415f7c:	702a      	strb	r2, [r5, #0]
  415f7e:	9a03      	ldr	r2, [sp, #12]
  415f80:	3301      	adds	r3, #1
  415f82:	6013      	str	r3, [r2, #0]
  415f84:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415f86:	2b00      	cmp	r3, #0
  415f88:	f000 83a3 	beq.w	4166d2 <_dtoa_r+0xafa>
  415f8c:	9807      	ldr	r0, [sp, #28]
  415f8e:	601d      	str	r5, [r3, #0]
  415f90:	b017      	add	sp, #92	; 0x5c
  415f92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415f96:	9a09      	ldr	r2, [sp, #36]	; 0x24
  415f98:	2a00      	cmp	r2, #0
  415f9a:	d040      	beq.n	41601e <_dtoa_r+0x446>
  415f9c:	9a02      	ldr	r2, [sp, #8]
  415f9e:	2a01      	cmp	r2, #1
  415fa0:	f340 831c 	ble.w	4165dc <_dtoa_r+0xa04>
  415fa4:	9b08      	ldr	r3, [sp, #32]
  415fa6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  415fa8:	1e5f      	subs	r7, r3, #1
  415faa:	42ba      	cmp	r2, r7
  415fac:	f2c0 8394 	blt.w	4166d8 <_dtoa_r+0xb00>
  415fb0:	1bd7      	subs	r7, r2, r7
  415fb2:	9b08      	ldr	r3, [sp, #32]
  415fb4:	2b00      	cmp	r3, #0
  415fb6:	f2c0 847e 	blt.w	4168b6 <_dtoa_r+0xcde>
  415fba:	9d06      	ldr	r5, [sp, #24]
  415fbc:	9b08      	ldr	r3, [sp, #32]
  415fbe:	9a06      	ldr	r2, [sp, #24]
  415fc0:	441a      	add	r2, r3
  415fc2:	9206      	str	r2, [sp, #24]
  415fc4:	9a05      	ldr	r2, [sp, #20]
  415fc6:	2101      	movs	r1, #1
  415fc8:	441a      	add	r2, r3
  415fca:	4620      	mov	r0, r4
  415fcc:	9205      	str	r2, [sp, #20]
  415fce:	f001 f923 	bl	417218 <__i2b>
  415fd2:	4606      	mov	r6, r0
  415fd4:	e026      	b.n	416024 <_dtoa_r+0x44c>
  415fd6:	2301      	movs	r3, #1
  415fd8:	930c      	str	r3, [sp, #48]	; 0x30
  415fda:	e6b3      	b.n	415d44 <_dtoa_r+0x16c>
  415fdc:	9a06      	ldr	r2, [sp, #24]
  415fde:	9b04      	ldr	r3, [sp, #16]
  415fe0:	1ad2      	subs	r2, r2, r3
  415fe2:	425b      	negs	r3, r3
  415fe4:	930a      	str	r3, [sp, #40]	; 0x28
  415fe6:	2300      	movs	r3, #0
  415fe8:	9206      	str	r2, [sp, #24]
  415fea:	930b      	str	r3, [sp, #44]	; 0x2c
  415fec:	e6bd      	b.n	415d6a <_dtoa_r+0x192>
  415fee:	f1c5 0301 	rsb	r3, r5, #1
  415ff2:	9306      	str	r3, [sp, #24]
  415ff4:	2300      	movs	r3, #0
  415ff6:	9305      	str	r3, [sp, #20]
  415ff8:	e6ac      	b.n	415d54 <_dtoa_r+0x17c>
  415ffa:	f8dd 9010 	ldr.w	r9, [sp, #16]
  415ffe:	4648      	mov	r0, r9
  416000:	f7fd fc6a 	bl	4138d8 <__aeabi_i2d>
  416004:	4602      	mov	r2, r0
  416006:	460b      	mov	r3, r1
  416008:	4630      	mov	r0, r6
  41600a:	4639      	mov	r1, r7
  41600c:	f002 f82c 	bl	418068 <__aeabi_dcmpeq>
  416010:	2800      	cmp	r0, #0
  416012:	f47f ae83 	bne.w	415d1c <_dtoa_r+0x144>
  416016:	f109 33ff 	add.w	r3, r9, #4294967295
  41601a:	9304      	str	r3, [sp, #16]
  41601c:	e67e      	b.n	415d1c <_dtoa_r+0x144>
  41601e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  416020:	9d06      	ldr	r5, [sp, #24]
  416022:	9e09      	ldr	r6, [sp, #36]	; 0x24
  416024:	2d00      	cmp	r5, #0
  416026:	dd0c      	ble.n	416042 <_dtoa_r+0x46a>
  416028:	9905      	ldr	r1, [sp, #20]
  41602a:	2900      	cmp	r1, #0
  41602c:	460b      	mov	r3, r1
  41602e:	dd08      	ble.n	416042 <_dtoa_r+0x46a>
  416030:	42a9      	cmp	r1, r5
  416032:	9a06      	ldr	r2, [sp, #24]
  416034:	bfa8      	it	ge
  416036:	462b      	movge	r3, r5
  416038:	1ad2      	subs	r2, r2, r3
  41603a:	1aed      	subs	r5, r5, r3
  41603c:	1acb      	subs	r3, r1, r3
  41603e:	9206      	str	r2, [sp, #24]
  416040:	9305      	str	r3, [sp, #20]
  416042:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  416044:	b1d3      	cbz	r3, 41607c <_dtoa_r+0x4a4>
  416046:	9b09      	ldr	r3, [sp, #36]	; 0x24
  416048:	2b00      	cmp	r3, #0
  41604a:	f000 82c0 	beq.w	4165ce <_dtoa_r+0x9f6>
  41604e:	2f00      	cmp	r7, #0
  416050:	dd10      	ble.n	416074 <_dtoa_r+0x49c>
  416052:	4631      	mov	r1, r6
  416054:	463a      	mov	r2, r7
  416056:	4620      	mov	r0, r4
  416058:	f001 f97a 	bl	417350 <__pow5mult>
  41605c:	4652      	mov	r2, sl
  41605e:	4601      	mov	r1, r0
  416060:	4606      	mov	r6, r0
  416062:	4620      	mov	r0, r4
  416064:	f001 f8e2 	bl	41722c <__multiply>
  416068:	4651      	mov	r1, sl
  41606a:	4680      	mov	r8, r0
  41606c:	4620      	mov	r0, r4
  41606e:	f001 f839 	bl	4170e4 <_Bfree>
  416072:	46c2      	mov	sl, r8
  416074:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  416076:	1bda      	subs	r2, r3, r7
  416078:	f040 82aa 	bne.w	4165d0 <_dtoa_r+0x9f8>
  41607c:	2101      	movs	r1, #1
  41607e:	4620      	mov	r0, r4
  416080:	f001 f8ca 	bl	417218 <__i2b>
  416084:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  416086:	2b00      	cmp	r3, #0
  416088:	4681      	mov	r9, r0
  41608a:	dd1f      	ble.n	4160cc <_dtoa_r+0x4f4>
  41608c:	4601      	mov	r1, r0
  41608e:	461a      	mov	r2, r3
  416090:	4620      	mov	r0, r4
  416092:	f001 f95d 	bl	417350 <__pow5mult>
  416096:	9b02      	ldr	r3, [sp, #8]
  416098:	2b01      	cmp	r3, #1
  41609a:	4681      	mov	r9, r0
  41609c:	f340 825b 	ble.w	416556 <_dtoa_r+0x97e>
  4160a0:	f04f 0800 	mov.w	r8, #0
  4160a4:	f8d9 3010 	ldr.w	r3, [r9, #16]
  4160a8:	eb09 0383 	add.w	r3, r9, r3, lsl #2
  4160ac:	6918      	ldr	r0, [r3, #16]
  4160ae:	f001 f863 	bl	417178 <__hi0bits>
  4160b2:	f1c0 0020 	rsb	r0, r0, #32
  4160b6:	e013      	b.n	4160e0 <_dtoa_r+0x508>
  4160b8:	f1c3 0920 	rsb	r9, r3, #32
  4160bc:	9b00      	ldr	r3, [sp, #0]
  4160be:	fa03 f009 	lsl.w	r0, r3, r9
  4160c2:	e67a      	b.n	415dba <_dtoa_r+0x1e2>
  4160c4:	900c      	str	r0, [sp, #48]	; 0x30
  4160c6:	e63d      	b.n	415d44 <_dtoa_r+0x16c>
  4160c8:	40240000 	.word	0x40240000
  4160cc:	9b02      	ldr	r3, [sp, #8]
  4160ce:	2b01      	cmp	r3, #1
  4160d0:	f340 828d 	ble.w	4165ee <_dtoa_r+0xa16>
  4160d4:	f04f 0800 	mov.w	r8, #0
  4160d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4160da:	2001      	movs	r0, #1
  4160dc:	2b00      	cmp	r3, #0
  4160de:	d1e1      	bne.n	4160a4 <_dtoa_r+0x4cc>
  4160e0:	9a05      	ldr	r2, [sp, #20]
  4160e2:	4410      	add	r0, r2
  4160e4:	f010 001f 	ands.w	r0, r0, #31
  4160e8:	f000 80a1 	beq.w	41622e <_dtoa_r+0x656>
  4160ec:	f1c0 0320 	rsb	r3, r0, #32
  4160f0:	2b04      	cmp	r3, #4
  4160f2:	f340 848c 	ble.w	416a0e <_dtoa_r+0xe36>
  4160f6:	9b06      	ldr	r3, [sp, #24]
  4160f8:	f1c0 001c 	rsb	r0, r0, #28
  4160fc:	4403      	add	r3, r0
  4160fe:	9306      	str	r3, [sp, #24]
  416100:	4613      	mov	r3, r2
  416102:	4403      	add	r3, r0
  416104:	4405      	add	r5, r0
  416106:	9305      	str	r3, [sp, #20]
  416108:	9b06      	ldr	r3, [sp, #24]
  41610a:	2b00      	cmp	r3, #0
  41610c:	dd05      	ble.n	41611a <_dtoa_r+0x542>
  41610e:	4651      	mov	r1, sl
  416110:	461a      	mov	r2, r3
  416112:	4620      	mov	r0, r4
  416114:	f001 f96c 	bl	4173f0 <__lshift>
  416118:	4682      	mov	sl, r0
  41611a:	9b05      	ldr	r3, [sp, #20]
  41611c:	2b00      	cmp	r3, #0
  41611e:	dd05      	ble.n	41612c <_dtoa_r+0x554>
  416120:	4649      	mov	r1, r9
  416122:	461a      	mov	r2, r3
  416124:	4620      	mov	r0, r4
  416126:	f001 f963 	bl	4173f0 <__lshift>
  41612a:	4681      	mov	r9, r0
  41612c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  41612e:	2b00      	cmp	r3, #0
  416130:	f040 8086 	bne.w	416240 <_dtoa_r+0x668>
  416134:	9b08      	ldr	r3, [sp, #32]
  416136:	2b00      	cmp	r3, #0
  416138:	f340 8269 	ble.w	41660e <_dtoa_r+0xa36>
  41613c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  41613e:	2b00      	cmp	r3, #0
  416140:	f000 8098 	beq.w	416274 <_dtoa_r+0x69c>
  416144:	2d00      	cmp	r5, #0
  416146:	dd05      	ble.n	416154 <_dtoa_r+0x57c>
  416148:	4631      	mov	r1, r6
  41614a:	462a      	mov	r2, r5
  41614c:	4620      	mov	r0, r4
  41614e:	f001 f94f 	bl	4173f0 <__lshift>
  416152:	4606      	mov	r6, r0
  416154:	f1b8 0f00 	cmp.w	r8, #0
  416158:	f040 8336 	bne.w	4167c8 <_dtoa_r+0xbf0>
  41615c:	46b0      	mov	r8, r6
  41615e:	9b08      	ldr	r3, [sp, #32]
  416160:	9a07      	ldr	r2, [sp, #28]
  416162:	3b01      	subs	r3, #1
  416164:	18d3      	adds	r3, r2, r3
  416166:	9308      	str	r3, [sp, #32]
  416168:	9b00      	ldr	r3, [sp, #0]
  41616a:	f003 0301 	and.w	r3, r3, #1
  41616e:	9309      	str	r3, [sp, #36]	; 0x24
  416170:	4617      	mov	r7, r2
  416172:	4649      	mov	r1, r9
  416174:	4650      	mov	r0, sl
  416176:	f7ff fc9b 	bl	415ab0 <quorem>
  41617a:	4631      	mov	r1, r6
  41617c:	4605      	mov	r5, r0
  41617e:	4650      	mov	r0, sl
  416180:	f001 f988 	bl	417494 <__mcmp>
  416184:	4642      	mov	r2, r8
  416186:	4649      	mov	r1, r9
  416188:	4683      	mov	fp, r0
  41618a:	4620      	mov	r0, r4
  41618c:	f001 f99e 	bl	4174cc <__mdiff>
  416190:	f105 0230 	add.w	r2, r5, #48	; 0x30
  416194:	9200      	str	r2, [sp, #0]
  416196:	68c2      	ldr	r2, [r0, #12]
  416198:	4601      	mov	r1, r0
  41619a:	2a00      	cmp	r2, #0
  41619c:	f040 8232 	bne.w	416604 <_dtoa_r+0xa2c>
  4161a0:	9006      	str	r0, [sp, #24]
  4161a2:	4650      	mov	r0, sl
  4161a4:	f001 f976 	bl	417494 <__mcmp>
  4161a8:	9b06      	ldr	r3, [sp, #24]
  4161aa:	9005      	str	r0, [sp, #20]
  4161ac:	4619      	mov	r1, r3
  4161ae:	4620      	mov	r0, r4
  4161b0:	f000 ff98 	bl	4170e4 <_Bfree>
  4161b4:	9a05      	ldr	r2, [sp, #20]
  4161b6:	b932      	cbnz	r2, 4161c6 <_dtoa_r+0x5ee>
  4161b8:	9b02      	ldr	r3, [sp, #8]
  4161ba:	b923      	cbnz	r3, 4161c6 <_dtoa_r+0x5ee>
  4161bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4161be:	2b00      	cmp	r3, #0
  4161c0:	f000 83de 	beq.w	416980 <_dtoa_r+0xda8>
  4161c4:	9a02      	ldr	r2, [sp, #8]
  4161c6:	f1bb 0f00 	cmp.w	fp, #0
  4161ca:	f2c0 82a2 	blt.w	416712 <_dtoa_r+0xb3a>
  4161ce:	d105      	bne.n	4161dc <_dtoa_r+0x604>
  4161d0:	9b02      	ldr	r3, [sp, #8]
  4161d2:	b91b      	cbnz	r3, 4161dc <_dtoa_r+0x604>
  4161d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4161d6:	2b00      	cmp	r3, #0
  4161d8:	f000 829b 	beq.w	416712 <_dtoa_r+0xb3a>
  4161dc:	2a00      	cmp	r2, #0
  4161de:	f300 8307 	bgt.w	4167f0 <_dtoa_r+0xc18>
  4161e2:	f89d 3000 	ldrb.w	r3, [sp]
  4161e6:	703b      	strb	r3, [r7, #0]
  4161e8:	9b08      	ldr	r3, [sp, #32]
  4161ea:	f107 0b01 	add.w	fp, r7, #1
  4161ee:	429f      	cmp	r7, r3
  4161f0:	465d      	mov	r5, fp
  4161f2:	f000 8308 	beq.w	416806 <_dtoa_r+0xc2e>
  4161f6:	4651      	mov	r1, sl
  4161f8:	2300      	movs	r3, #0
  4161fa:	220a      	movs	r2, #10
  4161fc:	4620      	mov	r0, r4
  4161fe:	f000 ff7b 	bl	4170f8 <__multadd>
  416202:	4546      	cmp	r6, r8
  416204:	4682      	mov	sl, r0
  416206:	4631      	mov	r1, r6
  416208:	f04f 0300 	mov.w	r3, #0
  41620c:	f04f 020a 	mov.w	r2, #10
  416210:	4620      	mov	r0, r4
  416212:	f000 81f1 	beq.w	4165f8 <_dtoa_r+0xa20>
  416216:	f000 ff6f 	bl	4170f8 <__multadd>
  41621a:	4641      	mov	r1, r8
  41621c:	4606      	mov	r6, r0
  41621e:	2300      	movs	r3, #0
  416220:	220a      	movs	r2, #10
  416222:	4620      	mov	r0, r4
  416224:	f000 ff68 	bl	4170f8 <__multadd>
  416228:	465f      	mov	r7, fp
  41622a:	4680      	mov	r8, r0
  41622c:	e7a1      	b.n	416172 <_dtoa_r+0x59a>
  41622e:	201c      	movs	r0, #28
  416230:	9b06      	ldr	r3, [sp, #24]
  416232:	4403      	add	r3, r0
  416234:	9306      	str	r3, [sp, #24]
  416236:	9b05      	ldr	r3, [sp, #20]
  416238:	4403      	add	r3, r0
  41623a:	4405      	add	r5, r0
  41623c:	9305      	str	r3, [sp, #20]
  41623e:	e763      	b.n	416108 <_dtoa_r+0x530>
  416240:	4649      	mov	r1, r9
  416242:	4650      	mov	r0, sl
  416244:	f001 f926 	bl	417494 <__mcmp>
  416248:	2800      	cmp	r0, #0
  41624a:	f6bf af73 	bge.w	416134 <_dtoa_r+0x55c>
  41624e:	9f04      	ldr	r7, [sp, #16]
  416250:	4651      	mov	r1, sl
  416252:	2300      	movs	r3, #0
  416254:	220a      	movs	r2, #10
  416256:	4620      	mov	r0, r4
  416258:	3f01      	subs	r7, #1
  41625a:	9704      	str	r7, [sp, #16]
  41625c:	f000 ff4c 	bl	4170f8 <__multadd>
  416260:	9b09      	ldr	r3, [sp, #36]	; 0x24
  416262:	4682      	mov	sl, r0
  416264:	2b00      	cmp	r3, #0
  416266:	f040 83a7 	bne.w	4169b8 <_dtoa_r+0xde0>
  41626a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  41626c:	2b00      	cmp	r3, #0
  41626e:	f340 83b0 	ble.w	4169d2 <_dtoa_r+0xdfa>
  416272:	9308      	str	r3, [sp, #32]
  416274:	f8dd b01c 	ldr.w	fp, [sp, #28]
  416278:	f8dd 8020 	ldr.w	r8, [sp, #32]
  41627c:	465d      	mov	r5, fp
  41627e:	e002      	b.n	416286 <_dtoa_r+0x6ae>
  416280:	f000 ff3a 	bl	4170f8 <__multadd>
  416284:	4682      	mov	sl, r0
  416286:	4649      	mov	r1, r9
  416288:	4650      	mov	r0, sl
  41628a:	f7ff fc11 	bl	415ab0 <quorem>
  41628e:	f100 0730 	add.w	r7, r0, #48	; 0x30
  416292:	f805 7b01 	strb.w	r7, [r5], #1
  416296:	eba5 030b 	sub.w	r3, r5, fp
  41629a:	4543      	cmp	r3, r8
  41629c:	f04f 020a 	mov.w	r2, #10
  4162a0:	f04f 0300 	mov.w	r3, #0
  4162a4:	4651      	mov	r1, sl
  4162a6:	4620      	mov	r0, r4
  4162a8:	dbea      	blt.n	416280 <_dtoa_r+0x6a8>
  4162aa:	9b07      	ldr	r3, [sp, #28]
  4162ac:	9a08      	ldr	r2, [sp, #32]
  4162ae:	9700      	str	r7, [sp, #0]
  4162b0:	2a01      	cmp	r2, #1
  4162b2:	bfac      	ite	ge
  4162b4:	189b      	addge	r3, r3, r2
  4162b6:	3301      	addlt	r3, #1
  4162b8:	461d      	mov	r5, r3
  4162ba:	f04f 0b00 	mov.w	fp, #0
  4162be:	4651      	mov	r1, sl
  4162c0:	2201      	movs	r2, #1
  4162c2:	4620      	mov	r0, r4
  4162c4:	f001 f894 	bl	4173f0 <__lshift>
  4162c8:	4649      	mov	r1, r9
  4162ca:	4682      	mov	sl, r0
  4162cc:	f001 f8e2 	bl	417494 <__mcmp>
  4162d0:	2800      	cmp	r0, #0
  4162d2:	f340 823a 	ble.w	41674a <_dtoa_r+0xb72>
  4162d6:	f815 2c01 	ldrb.w	r2, [r5, #-1]
  4162da:	9907      	ldr	r1, [sp, #28]
  4162dc:	1e6b      	subs	r3, r5, #1
  4162de:	e004      	b.n	4162ea <_dtoa_r+0x712>
  4162e0:	428b      	cmp	r3, r1
  4162e2:	f000 81af 	beq.w	416644 <_dtoa_r+0xa6c>
  4162e6:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  4162ea:	2a39      	cmp	r2, #57	; 0x39
  4162ec:	f103 0501 	add.w	r5, r3, #1
  4162f0:	d0f6      	beq.n	4162e0 <_dtoa_r+0x708>
  4162f2:	3201      	adds	r2, #1
  4162f4:	701a      	strb	r2, [r3, #0]
  4162f6:	4649      	mov	r1, r9
  4162f8:	4620      	mov	r0, r4
  4162fa:	f000 fef3 	bl	4170e4 <_Bfree>
  4162fe:	2e00      	cmp	r6, #0
  416300:	f43f ae36 	beq.w	415f70 <_dtoa_r+0x398>
  416304:	f1bb 0f00 	cmp.w	fp, #0
  416308:	d005      	beq.n	416316 <_dtoa_r+0x73e>
  41630a:	45b3      	cmp	fp, r6
  41630c:	d003      	beq.n	416316 <_dtoa_r+0x73e>
  41630e:	4659      	mov	r1, fp
  416310:	4620      	mov	r0, r4
  416312:	f000 fee7 	bl	4170e4 <_Bfree>
  416316:	4631      	mov	r1, r6
  416318:	4620      	mov	r0, r4
  41631a:	f000 fee3 	bl	4170e4 <_Bfree>
  41631e:	e627      	b.n	415f70 <_dtoa_r+0x398>
  416320:	2300      	movs	r3, #0
  416322:	9309      	str	r3, [sp, #36]	; 0x24
  416324:	9b04      	ldr	r3, [sp, #16]
  416326:	445b      	add	r3, fp
  416328:	930d      	str	r3, [sp, #52]	; 0x34
  41632a:	3301      	adds	r3, #1
  41632c:	2b01      	cmp	r3, #1
  41632e:	461e      	mov	r6, r3
  416330:	461d      	mov	r5, r3
  416332:	9308      	str	r3, [sp, #32]
  416334:	bfb8      	it	lt
  416336:	2601      	movlt	r6, #1
  416338:	2100      	movs	r1, #0
  41633a:	2e17      	cmp	r6, #23
  41633c:	6461      	str	r1, [r4, #68]	; 0x44
  41633e:	d90a      	bls.n	416356 <_dtoa_r+0x77e>
  416340:	2201      	movs	r2, #1
  416342:	2304      	movs	r3, #4
  416344:	005b      	lsls	r3, r3, #1
  416346:	f103 0014 	add.w	r0, r3, #20
  41634a:	4286      	cmp	r6, r0
  41634c:	4611      	mov	r1, r2
  41634e:	f102 0201 	add.w	r2, r2, #1
  416352:	d2f7      	bcs.n	416344 <_dtoa_r+0x76c>
  416354:	6461      	str	r1, [r4, #68]	; 0x44
  416356:	4620      	mov	r0, r4
  416358:	f000 fe9e 	bl	417098 <_Balloc>
  41635c:	2d0e      	cmp	r5, #14
  41635e:	9007      	str	r0, [sp, #28]
  416360:	6420      	str	r0, [r4, #64]	; 0x40
  416362:	f63f ad44 	bhi.w	415dee <_dtoa_r+0x216>
  416366:	2f00      	cmp	r7, #0
  416368:	f43f ad41 	beq.w	415dee <_dtoa_r+0x216>
  41636c:	9904      	ldr	r1, [sp, #16]
  41636e:	2900      	cmp	r1, #0
  416370:	ed9d 7b00 	vldr	d7, [sp]
  416374:	f340 81f6 	ble.w	416764 <_dtoa_r+0xb8c>
  416378:	4bb9      	ldr	r3, [pc, #740]	; (416660 <_dtoa_r+0xa88>)
  41637a:	f001 020f 	and.w	r2, r1, #15
  41637e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  416382:	110d      	asrs	r5, r1, #4
  416384:	e9d3 6700 	ldrd	r6, r7, [r3]
  416388:	06eb      	lsls	r3, r5, #27
  41638a:	f140 81ad 	bpl.w	4166e8 <_dtoa_r+0xb10>
  41638e:	4bb5      	ldr	r3, [pc, #724]	; (416664 <_dtoa_r+0xa8c>)
  416390:	ec51 0b17 	vmov	r0, r1, d7
  416394:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  416398:	f7fd fc2e 	bl	413bf8 <__aeabi_ddiv>
  41639c:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  4163a0:	f005 050f 	and.w	r5, r5, #15
  4163a4:	f04f 0903 	mov.w	r9, #3
  4163a8:	b18d      	cbz	r5, 4163ce <_dtoa_r+0x7f6>
  4163aa:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 416664 <_dtoa_r+0xa8c>
  4163ae:	07e8      	lsls	r0, r5, #31
  4163b0:	d509      	bpl.n	4163c6 <_dtoa_r+0x7ee>
  4163b2:	4630      	mov	r0, r6
  4163b4:	4639      	mov	r1, r7
  4163b6:	e9d8 2300 	ldrd	r2, r3, [r8]
  4163ba:	f7fd faf3 	bl	4139a4 <__aeabi_dmul>
  4163be:	f109 0901 	add.w	r9, r9, #1
  4163c2:	4606      	mov	r6, r0
  4163c4:	460f      	mov	r7, r1
  4163c6:	106d      	asrs	r5, r5, #1
  4163c8:	f108 0808 	add.w	r8, r8, #8
  4163cc:	d1ef      	bne.n	4163ae <_dtoa_r+0x7d6>
  4163ce:	463b      	mov	r3, r7
  4163d0:	4632      	mov	r2, r6
  4163d2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  4163d6:	f7fd fc0f 	bl	413bf8 <__aeabi_ddiv>
  4163da:	4607      	mov	r7, r0
  4163dc:	4688      	mov	r8, r1
  4163de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4163e0:	b143      	cbz	r3, 4163f4 <_dtoa_r+0x81c>
  4163e2:	2200      	movs	r2, #0
  4163e4:	4ba0      	ldr	r3, [pc, #640]	; (416668 <_dtoa_r+0xa90>)
  4163e6:	4638      	mov	r0, r7
  4163e8:	4641      	mov	r1, r8
  4163ea:	f001 fe47 	bl	41807c <__aeabi_dcmplt>
  4163ee:	2800      	cmp	r0, #0
  4163f0:	f040 8273 	bne.w	4168da <_dtoa_r+0xd02>
  4163f4:	4648      	mov	r0, r9
  4163f6:	f7fd fa6f 	bl	4138d8 <__aeabi_i2d>
  4163fa:	463a      	mov	r2, r7
  4163fc:	4643      	mov	r3, r8
  4163fe:	f7fd fad1 	bl	4139a4 <__aeabi_dmul>
  416402:	4b9a      	ldr	r3, [pc, #616]	; (41666c <_dtoa_r+0xa94>)
  416404:	2200      	movs	r2, #0
  416406:	f7fd f91b 	bl	413640 <__adddf3>
  41640a:	9b08      	ldr	r3, [sp, #32]
  41640c:	4605      	mov	r5, r0
  41640e:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  416412:	2b00      	cmp	r3, #0
  416414:	f000 8140 	beq.w	416698 <_dtoa_r+0xac0>
  416418:	9b04      	ldr	r3, [sp, #16]
  41641a:	f8dd 9020 	ldr.w	r9, [sp, #32]
  41641e:	9311      	str	r3, [sp, #68]	; 0x44
  416420:	9b09      	ldr	r3, [sp, #36]	; 0x24
  416422:	2b00      	cmp	r3, #0
  416424:	f000 81f6 	beq.w	416814 <_dtoa_r+0xc3c>
  416428:	4b8d      	ldr	r3, [pc, #564]	; (416660 <_dtoa_r+0xa88>)
  41642a:	4991      	ldr	r1, [pc, #580]	; (416670 <_dtoa_r+0xa98>)
  41642c:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
  416430:	e953 2302 	ldrd	r2, r3, [r3, #-8]
  416434:	2000      	movs	r0, #0
  416436:	f7fd fbdf 	bl	413bf8 <__aeabi_ddiv>
  41643a:	462a      	mov	r2, r5
  41643c:	4633      	mov	r3, r6
  41643e:	f7fd f8fd 	bl	41363c <__aeabi_dsub>
  416442:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  416446:	4641      	mov	r1, r8
  416448:	4638      	mov	r0, r7
  41644a:	f001 fe55 	bl	4180f8 <__aeabi_d2iz>
  41644e:	4605      	mov	r5, r0
  416450:	f7fd fa42 	bl	4138d8 <__aeabi_i2d>
  416454:	4602      	mov	r2, r0
  416456:	460b      	mov	r3, r1
  416458:	4638      	mov	r0, r7
  41645a:	4641      	mov	r1, r8
  41645c:	f7fd f8ee 	bl	41363c <__aeabi_dsub>
  416460:	3530      	adds	r5, #48	; 0x30
  416462:	fa5f f885 	uxtb.w	r8, r5
  416466:	9d07      	ldr	r5, [sp, #28]
  416468:	4606      	mov	r6, r0
  41646a:	460f      	mov	r7, r1
  41646c:	f885 8000 	strb.w	r8, [r5]
  416470:	4602      	mov	r2, r0
  416472:	460b      	mov	r3, r1
  416474:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  416478:	3501      	adds	r5, #1
  41647a:	f001 fe1d 	bl	4180b8 <__aeabi_dcmpgt>
  41647e:	2800      	cmp	r0, #0
  416480:	d156      	bne.n	416530 <_dtoa_r+0x958>
  416482:	4632      	mov	r2, r6
  416484:	463b      	mov	r3, r7
  416486:	2000      	movs	r0, #0
  416488:	4977      	ldr	r1, [pc, #476]	; (416668 <_dtoa_r+0xa90>)
  41648a:	f7fd f8d7 	bl	41363c <__aeabi_dsub>
  41648e:	4602      	mov	r2, r0
  416490:	460b      	mov	r3, r1
  416492:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  416496:	f001 fe0f 	bl	4180b8 <__aeabi_dcmpgt>
  41649a:	2800      	cmp	r0, #0
  41649c:	f040 8262 	bne.w	416964 <_dtoa_r+0xd8c>
  4164a0:	f1b9 0f01 	cmp.w	r9, #1
  4164a4:	f43f aca3 	beq.w	415dee <_dtoa_r+0x216>
  4164a8:	9b07      	ldr	r3, [sp, #28]
  4164aa:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
  4164ae:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
  4164b2:	4499      	add	r9, r3
  4164b4:	46a0      	mov	r8, r4
  4164b6:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
  4164ba:	e00d      	b.n	4164d8 <_dtoa_r+0x900>
  4164bc:	2000      	movs	r0, #0
  4164be:	496a      	ldr	r1, [pc, #424]	; (416668 <_dtoa_r+0xa90>)
  4164c0:	f7fd f8bc 	bl	41363c <__aeabi_dsub>
  4164c4:	4652      	mov	r2, sl
  4164c6:	465b      	mov	r3, fp
  4164c8:	f001 fdd8 	bl	41807c <__aeabi_dcmplt>
  4164cc:	2800      	cmp	r0, #0
  4164ce:	f040 8244 	bne.w	41695a <_dtoa_r+0xd82>
  4164d2:	454d      	cmp	r5, r9
  4164d4:	f000 824a 	beq.w	41696c <_dtoa_r+0xd94>
  4164d8:	4650      	mov	r0, sl
  4164da:	4659      	mov	r1, fp
  4164dc:	2200      	movs	r2, #0
  4164de:	4b65      	ldr	r3, [pc, #404]	; (416674 <_dtoa_r+0xa9c>)
  4164e0:	f7fd fa60 	bl	4139a4 <__aeabi_dmul>
  4164e4:	2200      	movs	r2, #0
  4164e6:	4b63      	ldr	r3, [pc, #396]	; (416674 <_dtoa_r+0xa9c>)
  4164e8:	4682      	mov	sl, r0
  4164ea:	468b      	mov	fp, r1
  4164ec:	4630      	mov	r0, r6
  4164ee:	4639      	mov	r1, r7
  4164f0:	f7fd fa58 	bl	4139a4 <__aeabi_dmul>
  4164f4:	460f      	mov	r7, r1
  4164f6:	4606      	mov	r6, r0
  4164f8:	f001 fdfe 	bl	4180f8 <__aeabi_d2iz>
  4164fc:	4604      	mov	r4, r0
  4164fe:	f7fd f9eb 	bl	4138d8 <__aeabi_i2d>
  416502:	4602      	mov	r2, r0
  416504:	460b      	mov	r3, r1
  416506:	4630      	mov	r0, r6
  416508:	4639      	mov	r1, r7
  41650a:	f7fd f897 	bl	41363c <__aeabi_dsub>
  41650e:	3430      	adds	r4, #48	; 0x30
  416510:	b2e4      	uxtb	r4, r4
  416512:	4652      	mov	r2, sl
  416514:	465b      	mov	r3, fp
  416516:	f805 4b01 	strb.w	r4, [r5], #1
  41651a:	4606      	mov	r6, r0
  41651c:	460f      	mov	r7, r1
  41651e:	f001 fdad 	bl	41807c <__aeabi_dcmplt>
  416522:	4632      	mov	r2, r6
  416524:	463b      	mov	r3, r7
  416526:	2800      	cmp	r0, #0
  416528:	d0c8      	beq.n	4164bc <_dtoa_r+0x8e4>
  41652a:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
  41652e:	4644      	mov	r4, r8
  416530:	9b11      	ldr	r3, [sp, #68]	; 0x44
  416532:	9304      	str	r3, [sp, #16]
  416534:	e51c      	b.n	415f70 <_dtoa_r+0x398>
  416536:	2300      	movs	r3, #0
  416538:	9309      	str	r3, [sp, #36]	; 0x24
  41653a:	f1bb 0f00 	cmp.w	fp, #0
  41653e:	f340 80da 	ble.w	4166f6 <_dtoa_r+0xb1e>
  416542:	465e      	mov	r6, fp
  416544:	465d      	mov	r5, fp
  416546:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
  41654a:	f8cd b020 	str.w	fp, [sp, #32]
  41654e:	e6f3      	b.n	416338 <_dtoa_r+0x760>
  416550:	2301      	movs	r3, #1
  416552:	9309      	str	r3, [sp, #36]	; 0x24
  416554:	e7f1      	b.n	41653a <_dtoa_r+0x962>
  416556:	9b00      	ldr	r3, [sp, #0]
  416558:	2b00      	cmp	r3, #0
  41655a:	f47f ada1 	bne.w	4160a0 <_dtoa_r+0x4c8>
  41655e:	e9dd 1200 	ldrd	r1, r2, [sp]
  416562:	f3c2 0313 	ubfx	r3, r2, #0, #20
  416566:	2b00      	cmp	r3, #0
  416568:	f47f adb4 	bne.w	4160d4 <_dtoa_r+0x4fc>
  41656c:	f022 4700 	bic.w	r7, r2, #2147483648	; 0x80000000
  416570:	0d3f      	lsrs	r7, r7, #20
  416572:	053f      	lsls	r7, r7, #20
  416574:	2f00      	cmp	r7, #0
  416576:	f000 8200 	beq.w	41697a <_dtoa_r+0xda2>
  41657a:	9b06      	ldr	r3, [sp, #24]
  41657c:	3301      	adds	r3, #1
  41657e:	9306      	str	r3, [sp, #24]
  416580:	9b05      	ldr	r3, [sp, #20]
  416582:	3301      	adds	r3, #1
  416584:	9305      	str	r3, [sp, #20]
  416586:	f04f 0801 	mov.w	r8, #1
  41658a:	e5a5      	b.n	4160d8 <_dtoa_r+0x500>
  41658c:	9b08      	ldr	r3, [sp, #32]
  41658e:	2b00      	cmp	r3, #0
  416590:	f73f ac3e 	bgt.w	415e10 <_dtoa_r+0x238>
  416594:	f040 8099 	bne.w	4166ca <_dtoa_r+0xaf2>
  416598:	4649      	mov	r1, r9
  41659a:	2200      	movs	r2, #0
  41659c:	4b36      	ldr	r3, [pc, #216]	; (416678 <_dtoa_r+0xaa0>)
  41659e:	4640      	mov	r0, r8
  4165a0:	f7fd fa00 	bl	4139a4 <__aeabi_dmul>
  4165a4:	e9dd 2300 	ldrd	r2, r3, [sp]
  4165a8:	f001 fd7c 	bl	4180a4 <__aeabi_dcmpge>
  4165ac:	f8dd 9020 	ldr.w	r9, [sp, #32]
  4165b0:	464e      	mov	r6, r9
  4165b2:	2800      	cmp	r0, #0
  4165b4:	d03e      	beq.n	416634 <_dtoa_r+0xa5c>
  4165b6:	ea6f 030b 	mvn.w	r3, fp
  4165ba:	9d07      	ldr	r5, [sp, #28]
  4165bc:	9304      	str	r3, [sp, #16]
  4165be:	4649      	mov	r1, r9
  4165c0:	4620      	mov	r0, r4
  4165c2:	f000 fd8f 	bl	4170e4 <_Bfree>
  4165c6:	2e00      	cmp	r6, #0
  4165c8:	f43f acd2 	beq.w	415f70 <_dtoa_r+0x398>
  4165cc:	e6a3      	b.n	416316 <_dtoa_r+0x73e>
  4165ce:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4165d0:	4651      	mov	r1, sl
  4165d2:	4620      	mov	r0, r4
  4165d4:	f000 febc 	bl	417350 <__pow5mult>
  4165d8:	4682      	mov	sl, r0
  4165da:	e54f      	b.n	41607c <_dtoa_r+0x4a4>
  4165dc:	9a10      	ldr	r2, [sp, #64]	; 0x40
  4165de:	2a00      	cmp	r2, #0
  4165e0:	f000 816f 	beq.w	4168c2 <_dtoa_r+0xcea>
  4165e4:	f203 4333 	addw	r3, r3, #1075	; 0x433
  4165e8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  4165ea:	9d06      	ldr	r5, [sp, #24]
  4165ec:	e4e7      	b.n	415fbe <_dtoa_r+0x3e6>
  4165ee:	9b00      	ldr	r3, [sp, #0]
  4165f0:	2b00      	cmp	r3, #0
  4165f2:	f47f ad6f 	bne.w	4160d4 <_dtoa_r+0x4fc>
  4165f6:	e7b2      	b.n	41655e <_dtoa_r+0x986>
  4165f8:	f000 fd7e 	bl	4170f8 <__multadd>
  4165fc:	465f      	mov	r7, fp
  4165fe:	4606      	mov	r6, r0
  416600:	4680      	mov	r8, r0
  416602:	e5b6      	b.n	416172 <_dtoa_r+0x59a>
  416604:	4620      	mov	r0, r4
  416606:	f000 fd6d 	bl	4170e4 <_Bfree>
  41660a:	2201      	movs	r2, #1
  41660c:	e5db      	b.n	4161c6 <_dtoa_r+0x5ee>
  41660e:	9b02      	ldr	r3, [sp, #8]
  416610:	2b02      	cmp	r3, #2
  416612:	f77f ad93 	ble.w	41613c <_dtoa_r+0x564>
  416616:	9b08      	ldr	r3, [sp, #32]
  416618:	2b00      	cmp	r3, #0
  41661a:	d1cc      	bne.n	4165b6 <_dtoa_r+0x9de>
  41661c:	4649      	mov	r1, r9
  41661e:	2205      	movs	r2, #5
  416620:	4620      	mov	r0, r4
  416622:	f000 fd69 	bl	4170f8 <__multadd>
  416626:	4601      	mov	r1, r0
  416628:	4681      	mov	r9, r0
  41662a:	4650      	mov	r0, sl
  41662c:	f000 ff32 	bl	417494 <__mcmp>
  416630:	2800      	cmp	r0, #0
  416632:	ddc0      	ble.n	4165b6 <_dtoa_r+0x9de>
  416634:	9a04      	ldr	r2, [sp, #16]
  416636:	9907      	ldr	r1, [sp, #28]
  416638:	2331      	movs	r3, #49	; 0x31
  41663a:	3201      	adds	r2, #1
  41663c:	9204      	str	r2, [sp, #16]
  41663e:	700b      	strb	r3, [r1, #0]
  416640:	1c4d      	adds	r5, r1, #1
  416642:	e7bc      	b.n	4165be <_dtoa_r+0x9e6>
  416644:	9a04      	ldr	r2, [sp, #16]
  416646:	3201      	adds	r2, #1
  416648:	9204      	str	r2, [sp, #16]
  41664a:	9a07      	ldr	r2, [sp, #28]
  41664c:	2331      	movs	r3, #49	; 0x31
  41664e:	7013      	strb	r3, [r2, #0]
  416650:	e651      	b.n	4162f6 <_dtoa_r+0x71e>
  416652:	2301      	movs	r3, #1
  416654:	9309      	str	r3, [sp, #36]	; 0x24
  416656:	e665      	b.n	416324 <_dtoa_r+0x74c>
  416658:	f8dd a000 	ldr.w	sl, [sp]
  41665c:	9c02      	ldr	r4, [sp, #8]
  41665e:	e487      	b.n	415f70 <_dtoa_r+0x398>
  416660:	0041d8a0 	.word	0x0041d8a0
  416664:	0041d878 	.word	0x0041d878
  416668:	3ff00000 	.word	0x3ff00000
  41666c:	401c0000 	.word	0x401c0000
  416670:	3fe00000 	.word	0x3fe00000
  416674:	40240000 	.word	0x40240000
  416678:	40140000 	.word	0x40140000
  41667c:	4648      	mov	r0, r9
  41667e:	f7fd f92b 	bl	4138d8 <__aeabi_i2d>
  416682:	463a      	mov	r2, r7
  416684:	4643      	mov	r3, r8
  416686:	f7fd f98d 	bl	4139a4 <__aeabi_dmul>
  41668a:	2200      	movs	r2, #0
  41668c:	4bc4      	ldr	r3, [pc, #784]	; (4169a0 <_dtoa_r+0xdc8>)
  41668e:	f7fc ffd7 	bl	413640 <__adddf3>
  416692:	4605      	mov	r5, r0
  416694:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  416698:	4641      	mov	r1, r8
  41669a:	2200      	movs	r2, #0
  41669c:	4bc1      	ldr	r3, [pc, #772]	; (4169a4 <_dtoa_r+0xdcc>)
  41669e:	4638      	mov	r0, r7
  4166a0:	f7fc ffcc 	bl	41363c <__aeabi_dsub>
  4166a4:	462a      	mov	r2, r5
  4166a6:	4633      	mov	r3, r6
  4166a8:	4680      	mov	r8, r0
  4166aa:	4689      	mov	r9, r1
  4166ac:	f001 fd04 	bl	4180b8 <__aeabi_dcmpgt>
  4166b0:	2800      	cmp	r0, #0
  4166b2:	f040 80ab 	bne.w	41680c <_dtoa_r+0xc34>
  4166b6:	462a      	mov	r2, r5
  4166b8:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
  4166bc:	4640      	mov	r0, r8
  4166be:	4649      	mov	r1, r9
  4166c0:	f001 fcdc 	bl	41807c <__aeabi_dcmplt>
  4166c4:	2800      	cmp	r0, #0
  4166c6:	f43f ab92 	beq.w	415dee <_dtoa_r+0x216>
  4166ca:	f04f 0900 	mov.w	r9, #0
  4166ce:	464e      	mov	r6, r9
  4166d0:	e771      	b.n	4165b6 <_dtoa_r+0x9de>
  4166d2:	9807      	ldr	r0, [sp, #28]
  4166d4:	f7ff bab8 	b.w	415c48 <_dtoa_r+0x70>
  4166d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4166da:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4166dc:	970a      	str	r7, [sp, #40]	; 0x28
  4166de:	1afb      	subs	r3, r7, r3
  4166e0:	441a      	add	r2, r3
  4166e2:	920b      	str	r2, [sp, #44]	; 0x2c
  4166e4:	2700      	movs	r7, #0
  4166e6:	e464      	b.n	415fb2 <_dtoa_r+0x3da>
  4166e8:	ed9d 7b00 	vldr	d7, [sp]
  4166ec:	f04f 0902 	mov.w	r9, #2
  4166f0:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
  4166f4:	e658      	b.n	4163a8 <_dtoa_r+0x7d0>
  4166f6:	2100      	movs	r1, #0
  4166f8:	6461      	str	r1, [r4, #68]	; 0x44
  4166fa:	4620      	mov	r0, r4
  4166fc:	f000 fccc 	bl	417098 <_Balloc>
  416700:	f04f 0b01 	mov.w	fp, #1
  416704:	9007      	str	r0, [sp, #28]
  416706:	6420      	str	r0, [r4, #64]	; 0x40
  416708:	f8cd b020 	str.w	fp, [sp, #32]
  41670c:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
  416710:	e629      	b.n	416366 <_dtoa_r+0x78e>
  416712:	2a00      	cmp	r2, #0
  416714:	dd12      	ble.n	41673c <_dtoa_r+0xb64>
  416716:	4651      	mov	r1, sl
  416718:	2201      	movs	r2, #1
  41671a:	4620      	mov	r0, r4
  41671c:	f000 fe68 	bl	4173f0 <__lshift>
  416720:	4649      	mov	r1, r9
  416722:	4682      	mov	sl, r0
  416724:	f000 feb6 	bl	417494 <__mcmp>
  416728:	2800      	cmp	r0, #0
  41672a:	f340 8131 	ble.w	416990 <_dtoa_r+0xdb8>
  41672e:	9b00      	ldr	r3, [sp, #0]
  416730:	2b39      	cmp	r3, #57	; 0x39
  416732:	f000 80f7 	beq.w	416924 <_dtoa_r+0xd4c>
  416736:	f105 0331 	add.w	r3, r5, #49	; 0x31
  41673a:	9300      	str	r3, [sp, #0]
  41673c:	f89d 3000 	ldrb.w	r3, [sp]
  416740:	703b      	strb	r3, [r7, #0]
  416742:	46b3      	mov	fp, r6
  416744:	1c7d      	adds	r5, r7, #1
  416746:	4646      	mov	r6, r8
  416748:	e5d5      	b.n	4162f6 <_dtoa_r+0x71e>
  41674a:	d104      	bne.n	416756 <_dtoa_r+0xb7e>
  41674c:	9b00      	ldr	r3, [sp, #0]
  41674e:	07db      	lsls	r3, r3, #31
  416750:	d501      	bpl.n	416756 <_dtoa_r+0xb7e>
  416752:	e5c0      	b.n	4162d6 <_dtoa_r+0x6fe>
  416754:	4615      	mov	r5, r2
  416756:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  41675a:	2b30      	cmp	r3, #48	; 0x30
  41675c:	f105 32ff 	add.w	r2, r5, #4294967295
  416760:	d0f8      	beq.n	416754 <_dtoa_r+0xb7c>
  416762:	e5c8      	b.n	4162f6 <_dtoa_r+0x71e>
  416764:	f000 80b4 	beq.w	4168d0 <_dtoa_r+0xcf8>
  416768:	9b04      	ldr	r3, [sp, #16]
  41676a:	425d      	negs	r5, r3
  41676c:	4b8e      	ldr	r3, [pc, #568]	; (4169a8 <_dtoa_r+0xdd0>)
  41676e:	f005 020f 	and.w	r2, r5, #15
  416772:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  416776:	e9d3 2300 	ldrd	r2, r3, [r3]
  41677a:	e9dd 0100 	ldrd	r0, r1, [sp]
  41677e:	f7fd f911 	bl	4139a4 <__aeabi_dmul>
  416782:	112d      	asrs	r5, r5, #4
  416784:	4607      	mov	r7, r0
  416786:	4688      	mov	r8, r1
  416788:	f000 8128 	beq.w	4169dc <_dtoa_r+0xe04>
  41678c:	4e87      	ldr	r6, [pc, #540]	; (4169ac <_dtoa_r+0xdd4>)
  41678e:	f04f 0902 	mov.w	r9, #2
  416792:	07e9      	lsls	r1, r5, #31
  416794:	d509      	bpl.n	4167aa <_dtoa_r+0xbd2>
  416796:	4638      	mov	r0, r7
  416798:	4641      	mov	r1, r8
  41679a:	e9d6 2300 	ldrd	r2, r3, [r6]
  41679e:	f7fd f901 	bl	4139a4 <__aeabi_dmul>
  4167a2:	f109 0901 	add.w	r9, r9, #1
  4167a6:	4607      	mov	r7, r0
  4167a8:	4688      	mov	r8, r1
  4167aa:	106d      	asrs	r5, r5, #1
  4167ac:	f106 0608 	add.w	r6, r6, #8
  4167b0:	d1ef      	bne.n	416792 <_dtoa_r+0xbba>
  4167b2:	e614      	b.n	4163de <_dtoa_r+0x806>
  4167b4:	9907      	ldr	r1, [sp, #28]
  4167b6:	2230      	movs	r2, #48	; 0x30
  4167b8:	700a      	strb	r2, [r1, #0]
  4167ba:	9a04      	ldr	r2, [sp, #16]
  4167bc:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  4167c0:	3201      	adds	r2, #1
  4167c2:	9204      	str	r2, [sp, #16]
  4167c4:	f7ff bbd0 	b.w	415f68 <_dtoa_r+0x390>
  4167c8:	6871      	ldr	r1, [r6, #4]
  4167ca:	4620      	mov	r0, r4
  4167cc:	f000 fc64 	bl	417098 <_Balloc>
  4167d0:	6933      	ldr	r3, [r6, #16]
  4167d2:	3302      	adds	r3, #2
  4167d4:	009a      	lsls	r2, r3, #2
  4167d6:	4605      	mov	r5, r0
  4167d8:	f106 010c 	add.w	r1, r6, #12
  4167dc:	300c      	adds	r0, #12
  4167de:	f7fd fd29 	bl	414234 <memcpy>
  4167e2:	4629      	mov	r1, r5
  4167e4:	2201      	movs	r2, #1
  4167e6:	4620      	mov	r0, r4
  4167e8:	f000 fe02 	bl	4173f0 <__lshift>
  4167ec:	4680      	mov	r8, r0
  4167ee:	e4b6      	b.n	41615e <_dtoa_r+0x586>
  4167f0:	9b00      	ldr	r3, [sp, #0]
  4167f2:	2b39      	cmp	r3, #57	; 0x39
  4167f4:	f000 8096 	beq.w	416924 <_dtoa_r+0xd4c>
  4167f8:	9b00      	ldr	r3, [sp, #0]
  4167fa:	3301      	adds	r3, #1
  4167fc:	46b3      	mov	fp, r6
  4167fe:	703b      	strb	r3, [r7, #0]
  416800:	1c7d      	adds	r5, r7, #1
  416802:	4646      	mov	r6, r8
  416804:	e577      	b.n	4162f6 <_dtoa_r+0x71e>
  416806:	46b3      	mov	fp, r6
  416808:	4646      	mov	r6, r8
  41680a:	e558      	b.n	4162be <_dtoa_r+0x6e6>
  41680c:	f04f 0900 	mov.w	r9, #0
  416810:	464e      	mov	r6, r9
  416812:	e70f      	b.n	416634 <_dtoa_r+0xa5c>
  416814:	4964      	ldr	r1, [pc, #400]	; (4169a8 <_dtoa_r+0xdd0>)
  416816:	eb01 01c9 	add.w	r1, r1, r9, lsl #3
  41681a:	462a      	mov	r2, r5
  41681c:	4633      	mov	r3, r6
  41681e:	e951 0102 	ldrd	r0, r1, [r1, #-8]
  416822:	f7fd f8bf 	bl	4139a4 <__aeabi_dmul>
  416826:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  41682a:	4638      	mov	r0, r7
  41682c:	4641      	mov	r1, r8
  41682e:	f001 fc63 	bl	4180f8 <__aeabi_d2iz>
  416832:	4605      	mov	r5, r0
  416834:	f7fd f850 	bl	4138d8 <__aeabi_i2d>
  416838:	4602      	mov	r2, r0
  41683a:	460b      	mov	r3, r1
  41683c:	4638      	mov	r0, r7
  41683e:	4641      	mov	r1, r8
  416840:	f7fc fefc 	bl	41363c <__aeabi_dsub>
  416844:	9a07      	ldr	r2, [sp, #28]
  416846:	3530      	adds	r5, #48	; 0x30
  416848:	f1b9 0f01 	cmp.w	r9, #1
  41684c:	7015      	strb	r5, [r2, #0]
  41684e:	4606      	mov	r6, r0
  416850:	460f      	mov	r7, r1
  416852:	f102 0501 	add.w	r5, r2, #1
  416856:	d01c      	beq.n	416892 <_dtoa_r+0xcba>
  416858:	9b07      	ldr	r3, [sp, #28]
  41685a:	4499      	add	r9, r3
  41685c:	2200      	movs	r2, #0
  41685e:	4b54      	ldr	r3, [pc, #336]	; (4169b0 <_dtoa_r+0xdd8>)
  416860:	4630      	mov	r0, r6
  416862:	4639      	mov	r1, r7
  416864:	f7fd f89e 	bl	4139a4 <__aeabi_dmul>
  416868:	460f      	mov	r7, r1
  41686a:	4606      	mov	r6, r0
  41686c:	f001 fc44 	bl	4180f8 <__aeabi_d2iz>
  416870:	4680      	mov	r8, r0
  416872:	f7fd f831 	bl	4138d8 <__aeabi_i2d>
  416876:	f108 0830 	add.w	r8, r8, #48	; 0x30
  41687a:	4602      	mov	r2, r0
  41687c:	460b      	mov	r3, r1
  41687e:	4630      	mov	r0, r6
  416880:	4639      	mov	r1, r7
  416882:	f7fc fedb 	bl	41363c <__aeabi_dsub>
  416886:	f805 8b01 	strb.w	r8, [r5], #1
  41688a:	454d      	cmp	r5, r9
  41688c:	4606      	mov	r6, r0
  41688e:	460f      	mov	r7, r1
  416890:	d1e4      	bne.n	41685c <_dtoa_r+0xc84>
  416892:	2200      	movs	r2, #0
  416894:	4b47      	ldr	r3, [pc, #284]	; (4169b4 <_dtoa_r+0xddc>)
  416896:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  41689a:	f7fc fed1 	bl	413640 <__adddf3>
  41689e:	4632      	mov	r2, r6
  4168a0:	463b      	mov	r3, r7
  4168a2:	f001 fbeb 	bl	41807c <__aeabi_dcmplt>
  4168a6:	2800      	cmp	r0, #0
  4168a8:	d042      	beq.n	416930 <_dtoa_r+0xd58>
  4168aa:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4168ac:	9304      	str	r3, [sp, #16]
  4168ae:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  4168b2:	f7ff bb4c 	b.w	415f4e <_dtoa_r+0x376>
  4168b6:	9b06      	ldr	r3, [sp, #24]
  4168b8:	9a08      	ldr	r2, [sp, #32]
  4168ba:	1a9d      	subs	r5, r3, r2
  4168bc:	2300      	movs	r3, #0
  4168be:	f7ff bb7e 	b.w	415fbe <_dtoa_r+0x3e6>
  4168c2:	9b14      	ldr	r3, [sp, #80]	; 0x50
  4168c4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  4168c6:	9d06      	ldr	r5, [sp, #24]
  4168c8:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  4168cc:	f7ff bb77 	b.w	415fbe <_dtoa_r+0x3e6>
  4168d0:	e9dd 7800 	ldrd	r7, r8, [sp]
  4168d4:	f04f 0902 	mov.w	r9, #2
  4168d8:	e581      	b.n	4163de <_dtoa_r+0x806>
  4168da:	9b08      	ldr	r3, [sp, #32]
  4168dc:	2b00      	cmp	r3, #0
  4168de:	f43f aecd 	beq.w	41667c <_dtoa_r+0xaa4>
  4168e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4168e4:	2b00      	cmp	r3, #0
  4168e6:	f77f aa82 	ble.w	415dee <_dtoa_r+0x216>
  4168ea:	2200      	movs	r2, #0
  4168ec:	4b30      	ldr	r3, [pc, #192]	; (4169b0 <_dtoa_r+0xdd8>)
  4168ee:	4638      	mov	r0, r7
  4168f0:	4641      	mov	r1, r8
  4168f2:	f7fd f857 	bl	4139a4 <__aeabi_dmul>
  4168f6:	4607      	mov	r7, r0
  4168f8:	4688      	mov	r8, r1
  4168fa:	f109 0001 	add.w	r0, r9, #1
  4168fe:	f7fc ffeb 	bl	4138d8 <__aeabi_i2d>
  416902:	463a      	mov	r2, r7
  416904:	4643      	mov	r3, r8
  416906:	f7fd f84d 	bl	4139a4 <__aeabi_dmul>
  41690a:	2200      	movs	r2, #0
  41690c:	4b24      	ldr	r3, [pc, #144]	; (4169a0 <_dtoa_r+0xdc8>)
  41690e:	f7fc fe97 	bl	413640 <__adddf3>
  416912:	9a04      	ldr	r2, [sp, #16]
  416914:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  416918:	3a01      	subs	r2, #1
  41691a:	4605      	mov	r5, r0
  41691c:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  416920:	9211      	str	r2, [sp, #68]	; 0x44
  416922:	e57d      	b.n	416420 <_dtoa_r+0x848>
  416924:	2239      	movs	r2, #57	; 0x39
  416926:	46b3      	mov	fp, r6
  416928:	703a      	strb	r2, [r7, #0]
  41692a:	4646      	mov	r6, r8
  41692c:	1c7d      	adds	r5, r7, #1
  41692e:	e4d4      	b.n	4162da <_dtoa_r+0x702>
  416930:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  416934:	2000      	movs	r0, #0
  416936:	491f      	ldr	r1, [pc, #124]	; (4169b4 <_dtoa_r+0xddc>)
  416938:	f7fc fe80 	bl	41363c <__aeabi_dsub>
  41693c:	4632      	mov	r2, r6
  41693e:	463b      	mov	r3, r7
  416940:	f001 fbba 	bl	4180b8 <__aeabi_dcmpgt>
  416944:	b910      	cbnz	r0, 41694c <_dtoa_r+0xd74>
  416946:	f7ff ba52 	b.w	415dee <_dtoa_r+0x216>
  41694a:	4615      	mov	r5, r2
  41694c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  416950:	2b30      	cmp	r3, #48	; 0x30
  416952:	f105 32ff 	add.w	r2, r5, #4294967295
  416956:	d0f8      	beq.n	41694a <_dtoa_r+0xd72>
  416958:	e5ea      	b.n	416530 <_dtoa_r+0x958>
  41695a:	4643      	mov	r3, r8
  41695c:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
  416960:	46a0      	mov	r8, r4
  416962:	461c      	mov	r4, r3
  416964:	9b11      	ldr	r3, [sp, #68]	; 0x44
  416966:	9304      	str	r3, [sp, #16]
  416968:	f7ff baf1 	b.w	415f4e <_dtoa_r+0x376>
  41696c:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
  416970:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
  416974:	4644      	mov	r4, r8
  416976:	f7ff ba3a 	b.w	415dee <_dtoa_r+0x216>
  41697a:	46b8      	mov	r8, r7
  41697c:	f7ff bbac 	b.w	4160d8 <_dtoa_r+0x500>
  416980:	9b00      	ldr	r3, [sp, #0]
  416982:	2b39      	cmp	r3, #57	; 0x39
  416984:	d0ce      	beq.n	416924 <_dtoa_r+0xd4c>
  416986:	f1bb 0f00 	cmp.w	fp, #0
  41698a:	f73f aed4 	bgt.w	416736 <_dtoa_r+0xb5e>
  41698e:	e6d5      	b.n	41673c <_dtoa_r+0xb64>
  416990:	f47f aed4 	bne.w	41673c <_dtoa_r+0xb64>
  416994:	9b00      	ldr	r3, [sp, #0]
  416996:	07da      	lsls	r2, r3, #31
  416998:	f57f aed0 	bpl.w	41673c <_dtoa_r+0xb64>
  41699c:	e6c7      	b.n	41672e <_dtoa_r+0xb56>
  41699e:	bf00      	nop
  4169a0:	401c0000 	.word	0x401c0000
  4169a4:	40140000 	.word	0x40140000
  4169a8:	0041d8a0 	.word	0x0041d8a0
  4169ac:	0041d878 	.word	0x0041d878
  4169b0:	40240000 	.word	0x40240000
  4169b4:	3fe00000 	.word	0x3fe00000
  4169b8:	4631      	mov	r1, r6
  4169ba:	2300      	movs	r3, #0
  4169bc:	220a      	movs	r2, #10
  4169be:	4620      	mov	r0, r4
  4169c0:	f000 fb9a 	bl	4170f8 <__multadd>
  4169c4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4169c6:	2b00      	cmp	r3, #0
  4169c8:	4606      	mov	r6, r0
  4169ca:	dd0a      	ble.n	4169e2 <_dtoa_r+0xe0a>
  4169cc:	9308      	str	r3, [sp, #32]
  4169ce:	f7ff bbb9 	b.w	416144 <_dtoa_r+0x56c>
  4169d2:	9b02      	ldr	r3, [sp, #8]
  4169d4:	2b02      	cmp	r3, #2
  4169d6:	dc22      	bgt.n	416a1e <_dtoa_r+0xe46>
  4169d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4169da:	e44a      	b.n	416272 <_dtoa_r+0x69a>
  4169dc:	f04f 0902 	mov.w	r9, #2
  4169e0:	e4fd      	b.n	4163de <_dtoa_r+0x806>
  4169e2:	9b02      	ldr	r3, [sp, #8]
  4169e4:	2b02      	cmp	r3, #2
  4169e6:	dc1a      	bgt.n	416a1e <_dtoa_r+0xe46>
  4169e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4169ea:	e7ef      	b.n	4169cc <_dtoa_r+0xdf4>
  4169ec:	2500      	movs	r5, #0
  4169ee:	6465      	str	r5, [r4, #68]	; 0x44
  4169f0:	4629      	mov	r1, r5
  4169f2:	4620      	mov	r0, r4
  4169f4:	f000 fb50 	bl	417098 <_Balloc>
  4169f8:	f04f 33ff 	mov.w	r3, #4294967295
  4169fc:	9308      	str	r3, [sp, #32]
  4169fe:	930d      	str	r3, [sp, #52]	; 0x34
  416a00:	2301      	movs	r3, #1
  416a02:	9007      	str	r0, [sp, #28]
  416a04:	46ab      	mov	fp, r5
  416a06:	6420      	str	r0, [r4, #64]	; 0x40
  416a08:	9309      	str	r3, [sp, #36]	; 0x24
  416a0a:	f7ff b9f0 	b.w	415dee <_dtoa_r+0x216>
  416a0e:	f43f ab7b 	beq.w	416108 <_dtoa_r+0x530>
  416a12:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
  416a16:	e40b      	b.n	416230 <_dtoa_r+0x658>
  416a18:	2701      	movs	r7, #1
  416a1a:	f7ff b9af 	b.w	415d7c <_dtoa_r+0x1a4>
  416a1e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  416a20:	9308      	str	r3, [sp, #32]
  416a22:	e5f8      	b.n	416616 <_dtoa_r+0xa3e>

00416a24 <__libc_fini_array>:
  416a24:	b538      	push	{r3, r4, r5, lr}
  416a26:	4c0a      	ldr	r4, [pc, #40]	; (416a50 <__libc_fini_array+0x2c>)
  416a28:	4d0a      	ldr	r5, [pc, #40]	; (416a54 <__libc_fini_array+0x30>)
  416a2a:	1b64      	subs	r4, r4, r5
  416a2c:	10a4      	asrs	r4, r4, #2
  416a2e:	d00a      	beq.n	416a46 <__libc_fini_array+0x22>
  416a30:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  416a34:	3b01      	subs	r3, #1
  416a36:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  416a3a:	3c01      	subs	r4, #1
  416a3c:	f855 3904 	ldr.w	r3, [r5], #-4
  416a40:	4798      	blx	r3
  416a42:	2c00      	cmp	r4, #0
  416a44:	d1f9      	bne.n	416a3a <__libc_fini_array+0x16>
  416a46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  416a4a:	f007 b827 	b.w	41da9c <_fini>
  416a4e:	bf00      	nop
  416a50:	0041daac 	.word	0x0041daac
  416a54:	0041daa8 	.word	0x0041daa8

00416a58 <_localeconv_r>:
  416a58:	4a04      	ldr	r2, [pc, #16]	; (416a6c <_localeconv_r+0x14>)
  416a5a:	4b05      	ldr	r3, [pc, #20]	; (416a70 <_localeconv_r+0x18>)
  416a5c:	6812      	ldr	r2, [r2, #0]
  416a5e:	6b50      	ldr	r0, [r2, #52]	; 0x34
  416a60:	2800      	cmp	r0, #0
  416a62:	bf08      	it	eq
  416a64:	4618      	moveq	r0, r3
  416a66:	30f0      	adds	r0, #240	; 0xf0
  416a68:	4770      	bx	lr
  416a6a:	bf00      	nop
  416a6c:	20000358 	.word	0x20000358
  416a70:	20000b9c 	.word	0x20000b9c

00416a74 <__retarget_lock_acquire_recursive>:
  416a74:	4770      	bx	lr
  416a76:	bf00      	nop

00416a78 <__retarget_lock_release_recursive>:
  416a78:	4770      	bx	lr
  416a7a:	bf00      	nop

00416a7c <_malloc_r>:
  416a7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  416a80:	f101 060b 	add.w	r6, r1, #11
  416a84:	2e16      	cmp	r6, #22
  416a86:	b083      	sub	sp, #12
  416a88:	4605      	mov	r5, r0
  416a8a:	f240 809e 	bls.w	416bca <_malloc_r+0x14e>
  416a8e:	f036 0607 	bics.w	r6, r6, #7
  416a92:	f100 80bd 	bmi.w	416c10 <_malloc_r+0x194>
  416a96:	42b1      	cmp	r1, r6
  416a98:	f200 80ba 	bhi.w	416c10 <_malloc_r+0x194>
  416a9c:	f000 faf0 	bl	417080 <__malloc_lock>
  416aa0:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
  416aa4:	f0c0 8293 	bcc.w	416fce <_malloc_r+0x552>
  416aa8:	0a73      	lsrs	r3, r6, #9
  416aaa:	f000 80b8 	beq.w	416c1e <_malloc_r+0x1a2>
  416aae:	2b04      	cmp	r3, #4
  416ab0:	f200 8179 	bhi.w	416da6 <_malloc_r+0x32a>
  416ab4:	09b3      	lsrs	r3, r6, #6
  416ab6:	f103 0039 	add.w	r0, r3, #57	; 0x39
  416aba:	f103 0e38 	add.w	lr, r3, #56	; 0x38
  416abe:	00c3      	lsls	r3, r0, #3
  416ac0:	4fbf      	ldr	r7, [pc, #764]	; (416dc0 <_malloc_r+0x344>)
  416ac2:	443b      	add	r3, r7
  416ac4:	f1a3 0108 	sub.w	r1, r3, #8
  416ac8:	685c      	ldr	r4, [r3, #4]
  416aca:	42a1      	cmp	r1, r4
  416acc:	d106      	bne.n	416adc <_malloc_r+0x60>
  416ace:	e00c      	b.n	416aea <_malloc_r+0x6e>
  416ad0:	2a00      	cmp	r2, #0
  416ad2:	f280 80aa 	bge.w	416c2a <_malloc_r+0x1ae>
  416ad6:	68e4      	ldr	r4, [r4, #12]
  416ad8:	42a1      	cmp	r1, r4
  416ada:	d006      	beq.n	416aea <_malloc_r+0x6e>
  416adc:	6863      	ldr	r3, [r4, #4]
  416ade:	f023 0303 	bic.w	r3, r3, #3
  416ae2:	1b9a      	subs	r2, r3, r6
  416ae4:	2a0f      	cmp	r2, #15
  416ae6:	ddf3      	ble.n	416ad0 <_malloc_r+0x54>
  416ae8:	4670      	mov	r0, lr
  416aea:	693c      	ldr	r4, [r7, #16]
  416aec:	f8df e2e4 	ldr.w	lr, [pc, #740]	; 416dd4 <_malloc_r+0x358>
  416af0:	4574      	cmp	r4, lr
  416af2:	f000 81ab 	beq.w	416e4c <_malloc_r+0x3d0>
  416af6:	6863      	ldr	r3, [r4, #4]
  416af8:	f023 0303 	bic.w	r3, r3, #3
  416afc:	1b9a      	subs	r2, r3, r6
  416afe:	2a0f      	cmp	r2, #15
  416b00:	f300 8190 	bgt.w	416e24 <_malloc_r+0x3a8>
  416b04:	2a00      	cmp	r2, #0
  416b06:	f8c7 e014 	str.w	lr, [r7, #20]
  416b0a:	f8c7 e010 	str.w	lr, [r7, #16]
  416b0e:	f280 809d 	bge.w	416c4c <_malloc_r+0x1d0>
  416b12:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  416b16:	f080 8161 	bcs.w	416ddc <_malloc_r+0x360>
  416b1a:	08db      	lsrs	r3, r3, #3
  416b1c:	f103 0c01 	add.w	ip, r3, #1
  416b20:	1099      	asrs	r1, r3, #2
  416b22:	687a      	ldr	r2, [r7, #4]
  416b24:	f857 803c 	ldr.w	r8, [r7, ip, lsl #3]
  416b28:	f8c4 8008 	str.w	r8, [r4, #8]
  416b2c:	2301      	movs	r3, #1
  416b2e:	408b      	lsls	r3, r1
  416b30:	eb07 01cc 	add.w	r1, r7, ip, lsl #3
  416b34:	4313      	orrs	r3, r2
  416b36:	3908      	subs	r1, #8
  416b38:	60e1      	str	r1, [r4, #12]
  416b3a:	607b      	str	r3, [r7, #4]
  416b3c:	f847 403c 	str.w	r4, [r7, ip, lsl #3]
  416b40:	f8c8 400c 	str.w	r4, [r8, #12]
  416b44:	1082      	asrs	r2, r0, #2
  416b46:	2401      	movs	r4, #1
  416b48:	4094      	lsls	r4, r2
  416b4a:	429c      	cmp	r4, r3
  416b4c:	f200 808b 	bhi.w	416c66 <_malloc_r+0x1ea>
  416b50:	421c      	tst	r4, r3
  416b52:	d106      	bne.n	416b62 <_malloc_r+0xe6>
  416b54:	f020 0003 	bic.w	r0, r0, #3
  416b58:	0064      	lsls	r4, r4, #1
  416b5a:	421c      	tst	r4, r3
  416b5c:	f100 0004 	add.w	r0, r0, #4
  416b60:	d0fa      	beq.n	416b58 <_malloc_r+0xdc>
  416b62:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
  416b66:	46cc      	mov	ip, r9
  416b68:	4680      	mov	r8, r0
  416b6a:	f8dc 300c 	ldr.w	r3, [ip, #12]
  416b6e:	459c      	cmp	ip, r3
  416b70:	d107      	bne.n	416b82 <_malloc_r+0x106>
  416b72:	e16d      	b.n	416e50 <_malloc_r+0x3d4>
  416b74:	2a00      	cmp	r2, #0
  416b76:	f280 817b 	bge.w	416e70 <_malloc_r+0x3f4>
  416b7a:	68db      	ldr	r3, [r3, #12]
  416b7c:	459c      	cmp	ip, r3
  416b7e:	f000 8167 	beq.w	416e50 <_malloc_r+0x3d4>
  416b82:	6859      	ldr	r1, [r3, #4]
  416b84:	f021 0103 	bic.w	r1, r1, #3
  416b88:	1b8a      	subs	r2, r1, r6
  416b8a:	2a0f      	cmp	r2, #15
  416b8c:	ddf2      	ble.n	416b74 <_malloc_r+0xf8>
  416b8e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  416b92:	f8d3 8008 	ldr.w	r8, [r3, #8]
  416b96:	9300      	str	r3, [sp, #0]
  416b98:	199c      	adds	r4, r3, r6
  416b9a:	4628      	mov	r0, r5
  416b9c:	f046 0601 	orr.w	r6, r6, #1
  416ba0:	f042 0501 	orr.w	r5, r2, #1
  416ba4:	605e      	str	r6, [r3, #4]
  416ba6:	f8c8 c00c 	str.w	ip, [r8, #12]
  416baa:	f8cc 8008 	str.w	r8, [ip, #8]
  416bae:	617c      	str	r4, [r7, #20]
  416bb0:	613c      	str	r4, [r7, #16]
  416bb2:	f8c4 e00c 	str.w	lr, [r4, #12]
  416bb6:	f8c4 e008 	str.w	lr, [r4, #8]
  416bba:	6065      	str	r5, [r4, #4]
  416bbc:	505a      	str	r2, [r3, r1]
  416bbe:	f000 fa65 	bl	41708c <__malloc_unlock>
  416bc2:	9b00      	ldr	r3, [sp, #0]
  416bc4:	f103 0408 	add.w	r4, r3, #8
  416bc8:	e01e      	b.n	416c08 <_malloc_r+0x18c>
  416bca:	2910      	cmp	r1, #16
  416bcc:	d820      	bhi.n	416c10 <_malloc_r+0x194>
  416bce:	f000 fa57 	bl	417080 <__malloc_lock>
  416bd2:	2610      	movs	r6, #16
  416bd4:	2318      	movs	r3, #24
  416bd6:	2002      	movs	r0, #2
  416bd8:	4f79      	ldr	r7, [pc, #484]	; (416dc0 <_malloc_r+0x344>)
  416bda:	443b      	add	r3, r7
  416bdc:	f1a3 0208 	sub.w	r2, r3, #8
  416be0:	685c      	ldr	r4, [r3, #4]
  416be2:	4294      	cmp	r4, r2
  416be4:	f000 813d 	beq.w	416e62 <_malloc_r+0x3e6>
  416be8:	6863      	ldr	r3, [r4, #4]
  416bea:	68e1      	ldr	r1, [r4, #12]
  416bec:	68a6      	ldr	r6, [r4, #8]
  416bee:	f023 0303 	bic.w	r3, r3, #3
  416bf2:	4423      	add	r3, r4
  416bf4:	4628      	mov	r0, r5
  416bf6:	685a      	ldr	r2, [r3, #4]
  416bf8:	60f1      	str	r1, [r6, #12]
  416bfa:	f042 0201 	orr.w	r2, r2, #1
  416bfe:	608e      	str	r6, [r1, #8]
  416c00:	605a      	str	r2, [r3, #4]
  416c02:	f000 fa43 	bl	41708c <__malloc_unlock>
  416c06:	3408      	adds	r4, #8
  416c08:	4620      	mov	r0, r4
  416c0a:	b003      	add	sp, #12
  416c0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416c10:	2400      	movs	r4, #0
  416c12:	230c      	movs	r3, #12
  416c14:	4620      	mov	r0, r4
  416c16:	602b      	str	r3, [r5, #0]
  416c18:	b003      	add	sp, #12
  416c1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416c1e:	2040      	movs	r0, #64	; 0x40
  416c20:	f44f 7300 	mov.w	r3, #512	; 0x200
  416c24:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
  416c28:	e74a      	b.n	416ac0 <_malloc_r+0x44>
  416c2a:	4423      	add	r3, r4
  416c2c:	68e1      	ldr	r1, [r4, #12]
  416c2e:	685a      	ldr	r2, [r3, #4]
  416c30:	68a6      	ldr	r6, [r4, #8]
  416c32:	f042 0201 	orr.w	r2, r2, #1
  416c36:	60f1      	str	r1, [r6, #12]
  416c38:	4628      	mov	r0, r5
  416c3a:	608e      	str	r6, [r1, #8]
  416c3c:	605a      	str	r2, [r3, #4]
  416c3e:	f000 fa25 	bl	41708c <__malloc_unlock>
  416c42:	3408      	adds	r4, #8
  416c44:	4620      	mov	r0, r4
  416c46:	b003      	add	sp, #12
  416c48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416c4c:	4423      	add	r3, r4
  416c4e:	4628      	mov	r0, r5
  416c50:	685a      	ldr	r2, [r3, #4]
  416c52:	f042 0201 	orr.w	r2, r2, #1
  416c56:	605a      	str	r2, [r3, #4]
  416c58:	f000 fa18 	bl	41708c <__malloc_unlock>
  416c5c:	3408      	adds	r4, #8
  416c5e:	4620      	mov	r0, r4
  416c60:	b003      	add	sp, #12
  416c62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416c66:	68bc      	ldr	r4, [r7, #8]
  416c68:	6863      	ldr	r3, [r4, #4]
  416c6a:	f023 0803 	bic.w	r8, r3, #3
  416c6e:	45b0      	cmp	r8, r6
  416c70:	d304      	bcc.n	416c7c <_malloc_r+0x200>
  416c72:	eba8 0306 	sub.w	r3, r8, r6
  416c76:	2b0f      	cmp	r3, #15
  416c78:	f300 8085 	bgt.w	416d86 <_malloc_r+0x30a>
  416c7c:	f8df 9158 	ldr.w	r9, [pc, #344]	; 416dd8 <_malloc_r+0x35c>
  416c80:	4b50      	ldr	r3, [pc, #320]	; (416dc4 <_malloc_r+0x348>)
  416c82:	f8d9 2000 	ldr.w	r2, [r9]
  416c86:	681b      	ldr	r3, [r3, #0]
  416c88:	3201      	adds	r2, #1
  416c8a:	4433      	add	r3, r6
  416c8c:	eb04 0a08 	add.w	sl, r4, r8
  416c90:	f000 8155 	beq.w	416f3e <_malloc_r+0x4c2>
  416c94:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  416c98:	330f      	adds	r3, #15
  416c9a:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
  416c9e:	f02b 0b0f 	bic.w	fp, fp, #15
  416ca2:	4659      	mov	r1, fp
  416ca4:	4628      	mov	r0, r5
  416ca6:	f000 fcf3 	bl	417690 <_sbrk_r>
  416caa:	1c41      	adds	r1, r0, #1
  416cac:	4602      	mov	r2, r0
  416cae:	f000 80fc 	beq.w	416eaa <_malloc_r+0x42e>
  416cb2:	4582      	cmp	sl, r0
  416cb4:	f200 80f7 	bhi.w	416ea6 <_malloc_r+0x42a>
  416cb8:	4b43      	ldr	r3, [pc, #268]	; (416dc8 <_malloc_r+0x34c>)
  416cba:	6819      	ldr	r1, [r3, #0]
  416cbc:	4459      	add	r1, fp
  416cbe:	6019      	str	r1, [r3, #0]
  416cc0:	f000 814d 	beq.w	416f5e <_malloc_r+0x4e2>
  416cc4:	f8d9 0000 	ldr.w	r0, [r9]
  416cc8:	3001      	adds	r0, #1
  416cca:	bf1b      	ittet	ne
  416ccc:	eba2 0a0a 	subne.w	sl, r2, sl
  416cd0:	4451      	addne	r1, sl
  416cd2:	f8c9 2000 	streq.w	r2, [r9]
  416cd6:	6019      	strne	r1, [r3, #0]
  416cd8:	f012 0107 	ands.w	r1, r2, #7
  416cdc:	f000 8115 	beq.w	416f0a <_malloc_r+0x48e>
  416ce0:	f1c1 0008 	rsb	r0, r1, #8
  416ce4:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
  416ce8:	4402      	add	r2, r0
  416cea:	3108      	adds	r1, #8
  416cec:	eb02 090b 	add.w	r9, r2, fp
  416cf0:	f3c9 090b 	ubfx	r9, r9, #0, #12
  416cf4:	eba1 0909 	sub.w	r9, r1, r9
  416cf8:	4649      	mov	r1, r9
  416cfa:	4628      	mov	r0, r5
  416cfc:	9301      	str	r3, [sp, #4]
  416cfe:	9200      	str	r2, [sp, #0]
  416d00:	f000 fcc6 	bl	417690 <_sbrk_r>
  416d04:	1c43      	adds	r3, r0, #1
  416d06:	e89d 000c 	ldmia.w	sp, {r2, r3}
  416d0a:	f000 8143 	beq.w	416f94 <_malloc_r+0x518>
  416d0e:	1a80      	subs	r0, r0, r2
  416d10:	4448      	add	r0, r9
  416d12:	f040 0001 	orr.w	r0, r0, #1
  416d16:	6819      	ldr	r1, [r3, #0]
  416d18:	60ba      	str	r2, [r7, #8]
  416d1a:	4449      	add	r1, r9
  416d1c:	42bc      	cmp	r4, r7
  416d1e:	6050      	str	r0, [r2, #4]
  416d20:	6019      	str	r1, [r3, #0]
  416d22:	d017      	beq.n	416d54 <_malloc_r+0x2d8>
  416d24:	f1b8 0f0f 	cmp.w	r8, #15
  416d28:	f240 80fb 	bls.w	416f22 <_malloc_r+0x4a6>
  416d2c:	6860      	ldr	r0, [r4, #4]
  416d2e:	f1a8 020c 	sub.w	r2, r8, #12
  416d32:	f022 0207 	bic.w	r2, r2, #7
  416d36:	eb04 0e02 	add.w	lr, r4, r2
  416d3a:	f000 0001 	and.w	r0, r0, #1
  416d3e:	f04f 0c05 	mov.w	ip, #5
  416d42:	4310      	orrs	r0, r2
  416d44:	2a0f      	cmp	r2, #15
  416d46:	6060      	str	r0, [r4, #4]
  416d48:	f8ce c004 	str.w	ip, [lr, #4]
  416d4c:	f8ce c008 	str.w	ip, [lr, #8]
  416d50:	f200 8117 	bhi.w	416f82 <_malloc_r+0x506>
  416d54:	4b1d      	ldr	r3, [pc, #116]	; (416dcc <_malloc_r+0x350>)
  416d56:	68bc      	ldr	r4, [r7, #8]
  416d58:	681a      	ldr	r2, [r3, #0]
  416d5a:	4291      	cmp	r1, r2
  416d5c:	bf88      	it	hi
  416d5e:	6019      	strhi	r1, [r3, #0]
  416d60:	4b1b      	ldr	r3, [pc, #108]	; (416dd0 <_malloc_r+0x354>)
  416d62:	681a      	ldr	r2, [r3, #0]
  416d64:	4291      	cmp	r1, r2
  416d66:	6862      	ldr	r2, [r4, #4]
  416d68:	bf88      	it	hi
  416d6a:	6019      	strhi	r1, [r3, #0]
  416d6c:	f022 0203 	bic.w	r2, r2, #3
  416d70:	4296      	cmp	r6, r2
  416d72:	eba2 0306 	sub.w	r3, r2, r6
  416d76:	d801      	bhi.n	416d7c <_malloc_r+0x300>
  416d78:	2b0f      	cmp	r3, #15
  416d7a:	dc04      	bgt.n	416d86 <_malloc_r+0x30a>
  416d7c:	4628      	mov	r0, r5
  416d7e:	f000 f985 	bl	41708c <__malloc_unlock>
  416d82:	2400      	movs	r4, #0
  416d84:	e740      	b.n	416c08 <_malloc_r+0x18c>
  416d86:	19a2      	adds	r2, r4, r6
  416d88:	f043 0301 	orr.w	r3, r3, #1
  416d8c:	f046 0601 	orr.w	r6, r6, #1
  416d90:	6066      	str	r6, [r4, #4]
  416d92:	4628      	mov	r0, r5
  416d94:	60ba      	str	r2, [r7, #8]
  416d96:	6053      	str	r3, [r2, #4]
  416d98:	f000 f978 	bl	41708c <__malloc_unlock>
  416d9c:	3408      	adds	r4, #8
  416d9e:	4620      	mov	r0, r4
  416da0:	b003      	add	sp, #12
  416da2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416da6:	2b14      	cmp	r3, #20
  416da8:	d971      	bls.n	416e8e <_malloc_r+0x412>
  416daa:	2b54      	cmp	r3, #84	; 0x54
  416dac:	f200 80a3 	bhi.w	416ef6 <_malloc_r+0x47a>
  416db0:	0b33      	lsrs	r3, r6, #12
  416db2:	f103 006f 	add.w	r0, r3, #111	; 0x6f
  416db6:	f103 0e6e 	add.w	lr, r3, #110	; 0x6e
  416dba:	00c3      	lsls	r3, r0, #3
  416dbc:	e680      	b.n	416ac0 <_malloc_r+0x44>
  416dbe:	bf00      	nop
  416dc0:	2000078c 	.word	0x2000078c
  416dc4:	20001864 	.word	0x20001864
  416dc8:	20001834 	.word	0x20001834
  416dcc:	2000185c 	.word	0x2000185c
  416dd0:	20001860 	.word	0x20001860
  416dd4:	20000794 	.word	0x20000794
  416dd8:	20000b94 	.word	0x20000b94
  416ddc:	0a5a      	lsrs	r2, r3, #9
  416dde:	2a04      	cmp	r2, #4
  416de0:	d95b      	bls.n	416e9a <_malloc_r+0x41e>
  416de2:	2a14      	cmp	r2, #20
  416de4:	f200 80ae 	bhi.w	416f44 <_malloc_r+0x4c8>
  416de8:	f102 015c 	add.w	r1, r2, #92	; 0x5c
  416dec:	00c9      	lsls	r1, r1, #3
  416dee:	325b      	adds	r2, #91	; 0x5b
  416df0:	eb07 0c01 	add.w	ip, r7, r1
  416df4:	5879      	ldr	r1, [r7, r1]
  416df6:	f1ac 0c08 	sub.w	ip, ip, #8
  416dfa:	458c      	cmp	ip, r1
  416dfc:	f000 8088 	beq.w	416f10 <_malloc_r+0x494>
  416e00:	684a      	ldr	r2, [r1, #4]
  416e02:	f022 0203 	bic.w	r2, r2, #3
  416e06:	4293      	cmp	r3, r2
  416e08:	d273      	bcs.n	416ef2 <_malloc_r+0x476>
  416e0a:	6889      	ldr	r1, [r1, #8]
  416e0c:	458c      	cmp	ip, r1
  416e0e:	d1f7      	bne.n	416e00 <_malloc_r+0x384>
  416e10:	f8dc 200c 	ldr.w	r2, [ip, #12]
  416e14:	687b      	ldr	r3, [r7, #4]
  416e16:	60e2      	str	r2, [r4, #12]
  416e18:	f8c4 c008 	str.w	ip, [r4, #8]
  416e1c:	6094      	str	r4, [r2, #8]
  416e1e:	f8cc 400c 	str.w	r4, [ip, #12]
  416e22:	e68f      	b.n	416b44 <_malloc_r+0xc8>
  416e24:	19a1      	adds	r1, r4, r6
  416e26:	f046 0c01 	orr.w	ip, r6, #1
  416e2a:	f042 0601 	orr.w	r6, r2, #1
  416e2e:	f8c4 c004 	str.w	ip, [r4, #4]
  416e32:	4628      	mov	r0, r5
  416e34:	6179      	str	r1, [r7, #20]
  416e36:	6139      	str	r1, [r7, #16]
  416e38:	f8c1 e00c 	str.w	lr, [r1, #12]
  416e3c:	f8c1 e008 	str.w	lr, [r1, #8]
  416e40:	604e      	str	r6, [r1, #4]
  416e42:	50e2      	str	r2, [r4, r3]
  416e44:	f000 f922 	bl	41708c <__malloc_unlock>
  416e48:	3408      	adds	r4, #8
  416e4a:	e6dd      	b.n	416c08 <_malloc_r+0x18c>
  416e4c:	687b      	ldr	r3, [r7, #4]
  416e4e:	e679      	b.n	416b44 <_malloc_r+0xc8>
  416e50:	f108 0801 	add.w	r8, r8, #1
  416e54:	f018 0f03 	tst.w	r8, #3
  416e58:	f10c 0c08 	add.w	ip, ip, #8
  416e5c:	f47f ae85 	bne.w	416b6a <_malloc_r+0xee>
  416e60:	e02d      	b.n	416ebe <_malloc_r+0x442>
  416e62:	68dc      	ldr	r4, [r3, #12]
  416e64:	42a3      	cmp	r3, r4
  416e66:	bf08      	it	eq
  416e68:	3002      	addeq	r0, #2
  416e6a:	f43f ae3e 	beq.w	416aea <_malloc_r+0x6e>
  416e6e:	e6bb      	b.n	416be8 <_malloc_r+0x16c>
  416e70:	4419      	add	r1, r3
  416e72:	461c      	mov	r4, r3
  416e74:	684a      	ldr	r2, [r1, #4]
  416e76:	68db      	ldr	r3, [r3, #12]
  416e78:	f854 6f08 	ldr.w	r6, [r4, #8]!
  416e7c:	f042 0201 	orr.w	r2, r2, #1
  416e80:	604a      	str	r2, [r1, #4]
  416e82:	4628      	mov	r0, r5
  416e84:	60f3      	str	r3, [r6, #12]
  416e86:	609e      	str	r6, [r3, #8]
  416e88:	f000 f900 	bl	41708c <__malloc_unlock>
  416e8c:	e6bc      	b.n	416c08 <_malloc_r+0x18c>
  416e8e:	f103 005c 	add.w	r0, r3, #92	; 0x5c
  416e92:	f103 0e5b 	add.w	lr, r3, #91	; 0x5b
  416e96:	00c3      	lsls	r3, r0, #3
  416e98:	e612      	b.n	416ac0 <_malloc_r+0x44>
  416e9a:	099a      	lsrs	r2, r3, #6
  416e9c:	f102 0139 	add.w	r1, r2, #57	; 0x39
  416ea0:	00c9      	lsls	r1, r1, #3
  416ea2:	3238      	adds	r2, #56	; 0x38
  416ea4:	e7a4      	b.n	416df0 <_malloc_r+0x374>
  416ea6:	42bc      	cmp	r4, r7
  416ea8:	d054      	beq.n	416f54 <_malloc_r+0x4d8>
  416eaa:	68bc      	ldr	r4, [r7, #8]
  416eac:	6862      	ldr	r2, [r4, #4]
  416eae:	f022 0203 	bic.w	r2, r2, #3
  416eb2:	e75d      	b.n	416d70 <_malloc_r+0x2f4>
  416eb4:	f859 3908 	ldr.w	r3, [r9], #-8
  416eb8:	4599      	cmp	r9, r3
  416eba:	f040 8086 	bne.w	416fca <_malloc_r+0x54e>
  416ebe:	f010 0f03 	tst.w	r0, #3
  416ec2:	f100 30ff 	add.w	r0, r0, #4294967295
  416ec6:	d1f5      	bne.n	416eb4 <_malloc_r+0x438>
  416ec8:	687b      	ldr	r3, [r7, #4]
  416eca:	ea23 0304 	bic.w	r3, r3, r4
  416ece:	607b      	str	r3, [r7, #4]
  416ed0:	0064      	lsls	r4, r4, #1
  416ed2:	429c      	cmp	r4, r3
  416ed4:	f63f aec7 	bhi.w	416c66 <_malloc_r+0x1ea>
  416ed8:	2c00      	cmp	r4, #0
  416eda:	f43f aec4 	beq.w	416c66 <_malloc_r+0x1ea>
  416ede:	421c      	tst	r4, r3
  416ee0:	4640      	mov	r0, r8
  416ee2:	f47f ae3e 	bne.w	416b62 <_malloc_r+0xe6>
  416ee6:	0064      	lsls	r4, r4, #1
  416ee8:	421c      	tst	r4, r3
  416eea:	f100 0004 	add.w	r0, r0, #4
  416eee:	d0fa      	beq.n	416ee6 <_malloc_r+0x46a>
  416ef0:	e637      	b.n	416b62 <_malloc_r+0xe6>
  416ef2:	468c      	mov	ip, r1
  416ef4:	e78c      	b.n	416e10 <_malloc_r+0x394>
  416ef6:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  416efa:	d815      	bhi.n	416f28 <_malloc_r+0x4ac>
  416efc:	0bf3      	lsrs	r3, r6, #15
  416efe:	f103 0078 	add.w	r0, r3, #120	; 0x78
  416f02:	f103 0e77 	add.w	lr, r3, #119	; 0x77
  416f06:	00c3      	lsls	r3, r0, #3
  416f08:	e5da      	b.n	416ac0 <_malloc_r+0x44>
  416f0a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  416f0e:	e6ed      	b.n	416cec <_malloc_r+0x270>
  416f10:	687b      	ldr	r3, [r7, #4]
  416f12:	1092      	asrs	r2, r2, #2
  416f14:	2101      	movs	r1, #1
  416f16:	fa01 f202 	lsl.w	r2, r1, r2
  416f1a:	4313      	orrs	r3, r2
  416f1c:	607b      	str	r3, [r7, #4]
  416f1e:	4662      	mov	r2, ip
  416f20:	e779      	b.n	416e16 <_malloc_r+0x39a>
  416f22:	2301      	movs	r3, #1
  416f24:	6053      	str	r3, [r2, #4]
  416f26:	e729      	b.n	416d7c <_malloc_r+0x300>
  416f28:	f240 5254 	movw	r2, #1364	; 0x554
  416f2c:	4293      	cmp	r3, r2
  416f2e:	d822      	bhi.n	416f76 <_malloc_r+0x4fa>
  416f30:	0cb3      	lsrs	r3, r6, #18
  416f32:	f103 007d 	add.w	r0, r3, #125	; 0x7d
  416f36:	f103 0e7c 	add.w	lr, r3, #124	; 0x7c
  416f3a:	00c3      	lsls	r3, r0, #3
  416f3c:	e5c0      	b.n	416ac0 <_malloc_r+0x44>
  416f3e:	f103 0b10 	add.w	fp, r3, #16
  416f42:	e6ae      	b.n	416ca2 <_malloc_r+0x226>
  416f44:	2a54      	cmp	r2, #84	; 0x54
  416f46:	d829      	bhi.n	416f9c <_malloc_r+0x520>
  416f48:	0b1a      	lsrs	r2, r3, #12
  416f4a:	f102 016f 	add.w	r1, r2, #111	; 0x6f
  416f4e:	00c9      	lsls	r1, r1, #3
  416f50:	326e      	adds	r2, #110	; 0x6e
  416f52:	e74d      	b.n	416df0 <_malloc_r+0x374>
  416f54:	4b20      	ldr	r3, [pc, #128]	; (416fd8 <_malloc_r+0x55c>)
  416f56:	6819      	ldr	r1, [r3, #0]
  416f58:	4459      	add	r1, fp
  416f5a:	6019      	str	r1, [r3, #0]
  416f5c:	e6b2      	b.n	416cc4 <_malloc_r+0x248>
  416f5e:	f3ca 000b 	ubfx	r0, sl, #0, #12
  416f62:	2800      	cmp	r0, #0
  416f64:	f47f aeae 	bne.w	416cc4 <_malloc_r+0x248>
  416f68:	eb08 030b 	add.w	r3, r8, fp
  416f6c:	68ba      	ldr	r2, [r7, #8]
  416f6e:	f043 0301 	orr.w	r3, r3, #1
  416f72:	6053      	str	r3, [r2, #4]
  416f74:	e6ee      	b.n	416d54 <_malloc_r+0x2d8>
  416f76:	207f      	movs	r0, #127	; 0x7f
  416f78:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
  416f7c:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
  416f80:	e59e      	b.n	416ac0 <_malloc_r+0x44>
  416f82:	f104 0108 	add.w	r1, r4, #8
  416f86:	4628      	mov	r0, r5
  416f88:	9300      	str	r3, [sp, #0]
  416f8a:	f000 fd67 	bl	417a5c <_free_r>
  416f8e:	9b00      	ldr	r3, [sp, #0]
  416f90:	6819      	ldr	r1, [r3, #0]
  416f92:	e6df      	b.n	416d54 <_malloc_r+0x2d8>
  416f94:	2001      	movs	r0, #1
  416f96:	f04f 0900 	mov.w	r9, #0
  416f9a:	e6bc      	b.n	416d16 <_malloc_r+0x29a>
  416f9c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  416fa0:	d805      	bhi.n	416fae <_malloc_r+0x532>
  416fa2:	0bda      	lsrs	r2, r3, #15
  416fa4:	f102 0178 	add.w	r1, r2, #120	; 0x78
  416fa8:	00c9      	lsls	r1, r1, #3
  416faa:	3277      	adds	r2, #119	; 0x77
  416fac:	e720      	b.n	416df0 <_malloc_r+0x374>
  416fae:	f240 5154 	movw	r1, #1364	; 0x554
  416fb2:	428a      	cmp	r2, r1
  416fb4:	d805      	bhi.n	416fc2 <_malloc_r+0x546>
  416fb6:	0c9a      	lsrs	r2, r3, #18
  416fb8:	f102 017d 	add.w	r1, r2, #125	; 0x7d
  416fbc:	00c9      	lsls	r1, r1, #3
  416fbe:	327c      	adds	r2, #124	; 0x7c
  416fc0:	e716      	b.n	416df0 <_malloc_r+0x374>
  416fc2:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
  416fc6:	227e      	movs	r2, #126	; 0x7e
  416fc8:	e712      	b.n	416df0 <_malloc_r+0x374>
  416fca:	687b      	ldr	r3, [r7, #4]
  416fcc:	e780      	b.n	416ed0 <_malloc_r+0x454>
  416fce:	08f0      	lsrs	r0, r6, #3
  416fd0:	f106 0308 	add.w	r3, r6, #8
  416fd4:	e600      	b.n	416bd8 <_malloc_r+0x15c>
  416fd6:	bf00      	nop
  416fd8:	20001834 	.word	0x20001834
  416fdc:	00000000 	.word	0x00000000

00416fe0 <memchr>:
  416fe0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  416fe4:	2a10      	cmp	r2, #16
  416fe6:	db2b      	blt.n	417040 <memchr+0x60>
  416fe8:	f010 0f07 	tst.w	r0, #7
  416fec:	d008      	beq.n	417000 <memchr+0x20>
  416fee:	f810 3b01 	ldrb.w	r3, [r0], #1
  416ff2:	3a01      	subs	r2, #1
  416ff4:	428b      	cmp	r3, r1
  416ff6:	d02d      	beq.n	417054 <memchr+0x74>
  416ff8:	f010 0f07 	tst.w	r0, #7
  416ffc:	b342      	cbz	r2, 417050 <memchr+0x70>
  416ffe:	d1f6      	bne.n	416fee <memchr+0xe>
  417000:	b4f0      	push	{r4, r5, r6, r7}
  417002:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  417006:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  41700a:	f022 0407 	bic.w	r4, r2, #7
  41700e:	f07f 0700 	mvns.w	r7, #0
  417012:	2300      	movs	r3, #0
  417014:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  417018:	3c08      	subs	r4, #8
  41701a:	ea85 0501 	eor.w	r5, r5, r1
  41701e:	ea86 0601 	eor.w	r6, r6, r1
  417022:	fa85 f547 	uadd8	r5, r5, r7
  417026:	faa3 f587 	sel	r5, r3, r7
  41702a:	fa86 f647 	uadd8	r6, r6, r7
  41702e:	faa5 f687 	sel	r6, r5, r7
  417032:	b98e      	cbnz	r6, 417058 <memchr+0x78>
  417034:	d1ee      	bne.n	417014 <memchr+0x34>
  417036:	bcf0      	pop	{r4, r5, r6, r7}
  417038:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  41703c:	f002 0207 	and.w	r2, r2, #7
  417040:	b132      	cbz	r2, 417050 <memchr+0x70>
  417042:	f810 3b01 	ldrb.w	r3, [r0], #1
  417046:	3a01      	subs	r2, #1
  417048:	ea83 0301 	eor.w	r3, r3, r1
  41704c:	b113      	cbz	r3, 417054 <memchr+0x74>
  41704e:	d1f8      	bne.n	417042 <memchr+0x62>
  417050:	2000      	movs	r0, #0
  417052:	4770      	bx	lr
  417054:	3801      	subs	r0, #1
  417056:	4770      	bx	lr
  417058:	2d00      	cmp	r5, #0
  41705a:	bf06      	itte	eq
  41705c:	4635      	moveq	r5, r6
  41705e:	3803      	subeq	r0, #3
  417060:	3807      	subne	r0, #7
  417062:	f015 0f01 	tst.w	r5, #1
  417066:	d107      	bne.n	417078 <memchr+0x98>
  417068:	3001      	adds	r0, #1
  41706a:	f415 7f80 	tst.w	r5, #256	; 0x100
  41706e:	bf02      	ittt	eq
  417070:	3001      	addeq	r0, #1
  417072:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  417076:	3001      	addeq	r0, #1
  417078:	bcf0      	pop	{r4, r5, r6, r7}
  41707a:	3801      	subs	r0, #1
  41707c:	4770      	bx	lr
  41707e:	bf00      	nop

00417080 <__malloc_lock>:
  417080:	4801      	ldr	r0, [pc, #4]	; (417088 <__malloc_lock+0x8>)
  417082:	f7ff bcf7 	b.w	416a74 <__retarget_lock_acquire_recursive>
  417086:	bf00      	nop
  417088:	20001f94 	.word	0x20001f94

0041708c <__malloc_unlock>:
  41708c:	4801      	ldr	r0, [pc, #4]	; (417094 <__malloc_unlock+0x8>)
  41708e:	f7ff bcf3 	b.w	416a78 <__retarget_lock_release_recursive>
  417092:	bf00      	nop
  417094:	20001f94 	.word	0x20001f94

00417098 <_Balloc>:
  417098:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  41709a:	b570      	push	{r4, r5, r6, lr}
  41709c:	4605      	mov	r5, r0
  41709e:	460c      	mov	r4, r1
  4170a0:	b14b      	cbz	r3, 4170b6 <_Balloc+0x1e>
  4170a2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  4170a6:	b180      	cbz	r0, 4170ca <_Balloc+0x32>
  4170a8:	6802      	ldr	r2, [r0, #0]
  4170aa:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  4170ae:	2300      	movs	r3, #0
  4170b0:	6103      	str	r3, [r0, #16]
  4170b2:	60c3      	str	r3, [r0, #12]
  4170b4:	bd70      	pop	{r4, r5, r6, pc}
  4170b6:	2221      	movs	r2, #33	; 0x21
  4170b8:	2104      	movs	r1, #4
  4170ba:	f000 fc4f 	bl	41795c <_calloc_r>
  4170be:	64e8      	str	r0, [r5, #76]	; 0x4c
  4170c0:	4603      	mov	r3, r0
  4170c2:	2800      	cmp	r0, #0
  4170c4:	d1ed      	bne.n	4170a2 <_Balloc+0xa>
  4170c6:	2000      	movs	r0, #0
  4170c8:	bd70      	pop	{r4, r5, r6, pc}
  4170ca:	2101      	movs	r1, #1
  4170cc:	fa01 f604 	lsl.w	r6, r1, r4
  4170d0:	1d72      	adds	r2, r6, #5
  4170d2:	4628      	mov	r0, r5
  4170d4:	0092      	lsls	r2, r2, #2
  4170d6:	f000 fc41 	bl	41795c <_calloc_r>
  4170da:	2800      	cmp	r0, #0
  4170dc:	d0f3      	beq.n	4170c6 <_Balloc+0x2e>
  4170de:	6044      	str	r4, [r0, #4]
  4170e0:	6086      	str	r6, [r0, #8]
  4170e2:	e7e4      	b.n	4170ae <_Balloc+0x16>

004170e4 <_Bfree>:
  4170e4:	b131      	cbz	r1, 4170f4 <_Bfree+0x10>
  4170e6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  4170e8:	684a      	ldr	r2, [r1, #4]
  4170ea:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
  4170ee:	6008      	str	r0, [r1, #0]
  4170f0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  4170f4:	4770      	bx	lr
  4170f6:	bf00      	nop

004170f8 <__multadd>:
  4170f8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4170fa:	690c      	ldr	r4, [r1, #16]
  4170fc:	b083      	sub	sp, #12
  4170fe:	460d      	mov	r5, r1
  417100:	4606      	mov	r6, r0
  417102:	f101 0e14 	add.w	lr, r1, #20
  417106:	2700      	movs	r7, #0
  417108:	f8de 0000 	ldr.w	r0, [lr]
  41710c:	b281      	uxth	r1, r0
  41710e:	fb02 3301 	mla	r3, r2, r1, r3
  417112:	0c01      	lsrs	r1, r0, #16
  417114:	0c18      	lsrs	r0, r3, #16
  417116:	fb02 0101 	mla	r1, r2, r1, r0
  41711a:	b29b      	uxth	r3, r3
  41711c:	3701      	adds	r7, #1
  41711e:	eb03 4301 	add.w	r3, r3, r1, lsl #16
  417122:	42bc      	cmp	r4, r7
  417124:	f84e 3b04 	str.w	r3, [lr], #4
  417128:	ea4f 4311 	mov.w	r3, r1, lsr #16
  41712c:	dcec      	bgt.n	417108 <__multadd+0x10>
  41712e:	b13b      	cbz	r3, 417140 <__multadd+0x48>
  417130:	68aa      	ldr	r2, [r5, #8]
  417132:	4294      	cmp	r4, r2
  417134:	da07      	bge.n	417146 <__multadd+0x4e>
  417136:	eb05 0284 	add.w	r2, r5, r4, lsl #2
  41713a:	3401      	adds	r4, #1
  41713c:	6153      	str	r3, [r2, #20]
  41713e:	612c      	str	r4, [r5, #16]
  417140:	4628      	mov	r0, r5
  417142:	b003      	add	sp, #12
  417144:	bdf0      	pop	{r4, r5, r6, r7, pc}
  417146:	6869      	ldr	r1, [r5, #4]
  417148:	9301      	str	r3, [sp, #4]
  41714a:	3101      	adds	r1, #1
  41714c:	4630      	mov	r0, r6
  41714e:	f7ff ffa3 	bl	417098 <_Balloc>
  417152:	692a      	ldr	r2, [r5, #16]
  417154:	3202      	adds	r2, #2
  417156:	f105 010c 	add.w	r1, r5, #12
  41715a:	4607      	mov	r7, r0
  41715c:	0092      	lsls	r2, r2, #2
  41715e:	300c      	adds	r0, #12
  417160:	f7fd f868 	bl	414234 <memcpy>
  417164:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
  417166:	6869      	ldr	r1, [r5, #4]
  417168:	9b01      	ldr	r3, [sp, #4]
  41716a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
  41716e:	6028      	str	r0, [r5, #0]
  417170:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  417174:	463d      	mov	r5, r7
  417176:	e7de      	b.n	417136 <__multadd+0x3e>

00417178 <__hi0bits>:
  417178:	0c02      	lsrs	r2, r0, #16
  41717a:	0412      	lsls	r2, r2, #16
  41717c:	4603      	mov	r3, r0
  41717e:	b9b2      	cbnz	r2, 4171ae <__hi0bits+0x36>
  417180:	0403      	lsls	r3, r0, #16
  417182:	2010      	movs	r0, #16
  417184:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
  417188:	bf04      	itt	eq
  41718a:	021b      	lsleq	r3, r3, #8
  41718c:	3008      	addeq	r0, #8
  41718e:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
  417192:	bf04      	itt	eq
  417194:	011b      	lsleq	r3, r3, #4
  417196:	3004      	addeq	r0, #4
  417198:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
  41719c:	bf04      	itt	eq
  41719e:	009b      	lsleq	r3, r3, #2
  4171a0:	3002      	addeq	r0, #2
  4171a2:	2b00      	cmp	r3, #0
  4171a4:	db02      	blt.n	4171ac <__hi0bits+0x34>
  4171a6:	005b      	lsls	r3, r3, #1
  4171a8:	d403      	bmi.n	4171b2 <__hi0bits+0x3a>
  4171aa:	2020      	movs	r0, #32
  4171ac:	4770      	bx	lr
  4171ae:	2000      	movs	r0, #0
  4171b0:	e7e8      	b.n	417184 <__hi0bits+0xc>
  4171b2:	3001      	adds	r0, #1
  4171b4:	4770      	bx	lr
  4171b6:	bf00      	nop

004171b8 <__lo0bits>:
  4171b8:	6803      	ldr	r3, [r0, #0]
  4171ba:	f013 0207 	ands.w	r2, r3, #7
  4171be:	4601      	mov	r1, r0
  4171c0:	d007      	beq.n	4171d2 <__lo0bits+0x1a>
  4171c2:	07da      	lsls	r2, r3, #31
  4171c4:	d421      	bmi.n	41720a <__lo0bits+0x52>
  4171c6:	0798      	lsls	r0, r3, #30
  4171c8:	d421      	bmi.n	41720e <__lo0bits+0x56>
  4171ca:	089b      	lsrs	r3, r3, #2
  4171cc:	600b      	str	r3, [r1, #0]
  4171ce:	2002      	movs	r0, #2
  4171d0:	4770      	bx	lr
  4171d2:	b298      	uxth	r0, r3
  4171d4:	b198      	cbz	r0, 4171fe <__lo0bits+0x46>
  4171d6:	4610      	mov	r0, r2
  4171d8:	f013 0fff 	tst.w	r3, #255	; 0xff
  4171dc:	bf04      	itt	eq
  4171de:	0a1b      	lsreq	r3, r3, #8
  4171e0:	3008      	addeq	r0, #8
  4171e2:	071a      	lsls	r2, r3, #28
  4171e4:	bf04      	itt	eq
  4171e6:	091b      	lsreq	r3, r3, #4
  4171e8:	3004      	addeq	r0, #4
  4171ea:	079a      	lsls	r2, r3, #30
  4171ec:	bf04      	itt	eq
  4171ee:	089b      	lsreq	r3, r3, #2
  4171f0:	3002      	addeq	r0, #2
  4171f2:	07da      	lsls	r2, r3, #31
  4171f4:	d407      	bmi.n	417206 <__lo0bits+0x4e>
  4171f6:	085b      	lsrs	r3, r3, #1
  4171f8:	d104      	bne.n	417204 <__lo0bits+0x4c>
  4171fa:	2020      	movs	r0, #32
  4171fc:	4770      	bx	lr
  4171fe:	0c1b      	lsrs	r3, r3, #16
  417200:	2010      	movs	r0, #16
  417202:	e7e9      	b.n	4171d8 <__lo0bits+0x20>
  417204:	3001      	adds	r0, #1
  417206:	600b      	str	r3, [r1, #0]
  417208:	4770      	bx	lr
  41720a:	2000      	movs	r0, #0
  41720c:	4770      	bx	lr
  41720e:	085b      	lsrs	r3, r3, #1
  417210:	600b      	str	r3, [r1, #0]
  417212:	2001      	movs	r0, #1
  417214:	4770      	bx	lr
  417216:	bf00      	nop

00417218 <__i2b>:
  417218:	b510      	push	{r4, lr}
  41721a:	460c      	mov	r4, r1
  41721c:	2101      	movs	r1, #1
  41721e:	f7ff ff3b 	bl	417098 <_Balloc>
  417222:	2201      	movs	r2, #1
  417224:	6144      	str	r4, [r0, #20]
  417226:	6102      	str	r2, [r0, #16]
  417228:	bd10      	pop	{r4, pc}
  41722a:	bf00      	nop

0041722c <__multiply>:
  41722c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  417230:	690c      	ldr	r4, [r1, #16]
  417232:	6915      	ldr	r5, [r2, #16]
  417234:	42ac      	cmp	r4, r5
  417236:	b083      	sub	sp, #12
  417238:	468b      	mov	fp, r1
  41723a:	4616      	mov	r6, r2
  41723c:	da04      	bge.n	417248 <__multiply+0x1c>
  41723e:	4622      	mov	r2, r4
  417240:	46b3      	mov	fp, r6
  417242:	462c      	mov	r4, r5
  417244:	460e      	mov	r6, r1
  417246:	4615      	mov	r5, r2
  417248:	f8db 3008 	ldr.w	r3, [fp, #8]
  41724c:	f8db 1004 	ldr.w	r1, [fp, #4]
  417250:	eb04 0805 	add.w	r8, r4, r5
  417254:	4598      	cmp	r8, r3
  417256:	bfc8      	it	gt
  417258:	3101      	addgt	r1, #1
  41725a:	f7ff ff1d 	bl	417098 <_Balloc>
  41725e:	f100 0914 	add.w	r9, r0, #20
  417262:	eb09 0a88 	add.w	sl, r9, r8, lsl #2
  417266:	45d1      	cmp	r9, sl
  417268:	9000      	str	r0, [sp, #0]
  41726a:	d205      	bcs.n	417278 <__multiply+0x4c>
  41726c:	464b      	mov	r3, r9
  41726e:	2100      	movs	r1, #0
  417270:	f843 1b04 	str.w	r1, [r3], #4
  417274:	459a      	cmp	sl, r3
  417276:	d8fb      	bhi.n	417270 <__multiply+0x44>
  417278:	f106 0c14 	add.w	ip, r6, #20
  41727c:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
  417280:	f10b 0b14 	add.w	fp, fp, #20
  417284:	459c      	cmp	ip, r3
  417286:	eb0b 0e84 	add.w	lr, fp, r4, lsl #2
  41728a:	d24c      	bcs.n	417326 <__multiply+0xfa>
  41728c:	f8cd a004 	str.w	sl, [sp, #4]
  417290:	469a      	mov	sl, r3
  417292:	f8dc 5000 	ldr.w	r5, [ip]
  417296:	b2af      	uxth	r7, r5
  417298:	b1ef      	cbz	r7, 4172d6 <__multiply+0xaa>
  41729a:	2100      	movs	r1, #0
  41729c:	464d      	mov	r5, r9
  41729e:	465e      	mov	r6, fp
  4172a0:	460c      	mov	r4, r1
  4172a2:	f856 2b04 	ldr.w	r2, [r6], #4
  4172a6:	6828      	ldr	r0, [r5, #0]
  4172a8:	b293      	uxth	r3, r2
  4172aa:	b281      	uxth	r1, r0
  4172ac:	fb07 1303 	mla	r3, r7, r3, r1
  4172b0:	0c12      	lsrs	r2, r2, #16
  4172b2:	0c01      	lsrs	r1, r0, #16
  4172b4:	4423      	add	r3, r4
  4172b6:	fb07 1102 	mla	r1, r7, r2, r1
  4172ba:	eb01 4113 	add.w	r1, r1, r3, lsr #16
  4172be:	b29b      	uxth	r3, r3
  4172c0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  4172c4:	45b6      	cmp	lr, r6
  4172c6:	f845 3b04 	str.w	r3, [r5], #4
  4172ca:	ea4f 4411 	mov.w	r4, r1, lsr #16
  4172ce:	d8e8      	bhi.n	4172a2 <__multiply+0x76>
  4172d0:	602c      	str	r4, [r5, #0]
  4172d2:	f8dc 5000 	ldr.w	r5, [ip]
  4172d6:	0c2d      	lsrs	r5, r5, #16
  4172d8:	d01d      	beq.n	417316 <__multiply+0xea>
  4172da:	f8d9 3000 	ldr.w	r3, [r9]
  4172de:	4648      	mov	r0, r9
  4172e0:	461c      	mov	r4, r3
  4172e2:	4659      	mov	r1, fp
  4172e4:	2200      	movs	r2, #0
  4172e6:	880e      	ldrh	r6, [r1, #0]
  4172e8:	0c24      	lsrs	r4, r4, #16
  4172ea:	fb05 4406 	mla	r4, r5, r6, r4
  4172ee:	4422      	add	r2, r4
  4172f0:	b29b      	uxth	r3, r3
  4172f2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  4172f6:	f840 3b04 	str.w	r3, [r0], #4
  4172fa:	f851 3b04 	ldr.w	r3, [r1], #4
  4172fe:	6804      	ldr	r4, [r0, #0]
  417300:	0c1b      	lsrs	r3, r3, #16
  417302:	b2a6      	uxth	r6, r4
  417304:	fb05 6303 	mla	r3, r5, r3, r6
  417308:	eb03 4312 	add.w	r3, r3, r2, lsr #16
  41730c:	458e      	cmp	lr, r1
  41730e:	ea4f 4213 	mov.w	r2, r3, lsr #16
  417312:	d8e8      	bhi.n	4172e6 <__multiply+0xba>
  417314:	6003      	str	r3, [r0, #0]
  417316:	f10c 0c04 	add.w	ip, ip, #4
  41731a:	45e2      	cmp	sl, ip
  41731c:	f109 0904 	add.w	r9, r9, #4
  417320:	d8b7      	bhi.n	417292 <__multiply+0x66>
  417322:	f8dd a004 	ldr.w	sl, [sp, #4]
  417326:	f1b8 0f00 	cmp.w	r8, #0
  41732a:	dd0b      	ble.n	417344 <__multiply+0x118>
  41732c:	f85a 3c04 	ldr.w	r3, [sl, #-4]
  417330:	f1aa 0a04 	sub.w	sl, sl, #4
  417334:	b11b      	cbz	r3, 41733e <__multiply+0x112>
  417336:	e005      	b.n	417344 <__multiply+0x118>
  417338:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
  41733c:	b913      	cbnz	r3, 417344 <__multiply+0x118>
  41733e:	f1b8 0801 	subs.w	r8, r8, #1
  417342:	d1f9      	bne.n	417338 <__multiply+0x10c>
  417344:	9800      	ldr	r0, [sp, #0]
  417346:	f8c0 8010 	str.w	r8, [r0, #16]
  41734a:	b003      	add	sp, #12
  41734c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00417350 <__pow5mult>:
  417350:	f012 0303 	ands.w	r3, r2, #3
  417354:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  417358:	4614      	mov	r4, r2
  41735a:	4607      	mov	r7, r0
  41735c:	d12e      	bne.n	4173bc <__pow5mult+0x6c>
  41735e:	460d      	mov	r5, r1
  417360:	10a4      	asrs	r4, r4, #2
  417362:	d01c      	beq.n	41739e <__pow5mult+0x4e>
  417364:	6cbe      	ldr	r6, [r7, #72]	; 0x48
  417366:	b396      	cbz	r6, 4173ce <__pow5mult+0x7e>
  417368:	07e3      	lsls	r3, r4, #31
  41736a:	f04f 0800 	mov.w	r8, #0
  41736e:	d406      	bmi.n	41737e <__pow5mult+0x2e>
  417370:	1064      	asrs	r4, r4, #1
  417372:	d014      	beq.n	41739e <__pow5mult+0x4e>
  417374:	6830      	ldr	r0, [r6, #0]
  417376:	b1a8      	cbz	r0, 4173a4 <__pow5mult+0x54>
  417378:	4606      	mov	r6, r0
  41737a:	07e3      	lsls	r3, r4, #31
  41737c:	d5f8      	bpl.n	417370 <__pow5mult+0x20>
  41737e:	4632      	mov	r2, r6
  417380:	4629      	mov	r1, r5
  417382:	4638      	mov	r0, r7
  417384:	f7ff ff52 	bl	41722c <__multiply>
  417388:	b1b5      	cbz	r5, 4173b8 <__pow5mult+0x68>
  41738a:	686a      	ldr	r2, [r5, #4]
  41738c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41738e:	1064      	asrs	r4, r4, #1
  417390:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  417394:	6029      	str	r1, [r5, #0]
  417396:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
  41739a:	4605      	mov	r5, r0
  41739c:	d1ea      	bne.n	417374 <__pow5mult+0x24>
  41739e:	4628      	mov	r0, r5
  4173a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4173a4:	4632      	mov	r2, r6
  4173a6:	4631      	mov	r1, r6
  4173a8:	4638      	mov	r0, r7
  4173aa:	f7ff ff3f 	bl	41722c <__multiply>
  4173ae:	6030      	str	r0, [r6, #0]
  4173b0:	f8c0 8000 	str.w	r8, [r0]
  4173b4:	4606      	mov	r6, r0
  4173b6:	e7e0      	b.n	41737a <__pow5mult+0x2a>
  4173b8:	4605      	mov	r5, r0
  4173ba:	e7d9      	b.n	417370 <__pow5mult+0x20>
  4173bc:	1e5a      	subs	r2, r3, #1
  4173be:	4d0b      	ldr	r5, [pc, #44]	; (4173ec <__pow5mult+0x9c>)
  4173c0:	2300      	movs	r3, #0
  4173c2:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
  4173c6:	f7ff fe97 	bl	4170f8 <__multadd>
  4173ca:	4605      	mov	r5, r0
  4173cc:	e7c8      	b.n	417360 <__pow5mult+0x10>
  4173ce:	2101      	movs	r1, #1
  4173d0:	4638      	mov	r0, r7
  4173d2:	f7ff fe61 	bl	417098 <_Balloc>
  4173d6:	f240 2171 	movw	r1, #625	; 0x271
  4173da:	2201      	movs	r2, #1
  4173dc:	2300      	movs	r3, #0
  4173de:	6141      	str	r1, [r0, #20]
  4173e0:	6102      	str	r2, [r0, #16]
  4173e2:	4606      	mov	r6, r0
  4173e4:	64b8      	str	r0, [r7, #72]	; 0x48
  4173e6:	6003      	str	r3, [r0, #0]
  4173e8:	e7be      	b.n	417368 <__pow5mult+0x18>
  4173ea:	bf00      	nop
  4173ec:	0041d968 	.word	0x0041d968

004173f0 <__lshift>:
  4173f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4173f4:	4691      	mov	r9, r2
  4173f6:	690a      	ldr	r2, [r1, #16]
  4173f8:	688b      	ldr	r3, [r1, #8]
  4173fa:	ea4f 1469 	mov.w	r4, r9, asr #5
  4173fe:	eb04 0802 	add.w	r8, r4, r2
  417402:	f108 0501 	add.w	r5, r8, #1
  417406:	429d      	cmp	r5, r3
  417408:	460e      	mov	r6, r1
  41740a:	4607      	mov	r7, r0
  41740c:	6849      	ldr	r1, [r1, #4]
  41740e:	dd04      	ble.n	41741a <__lshift+0x2a>
  417410:	005b      	lsls	r3, r3, #1
  417412:	429d      	cmp	r5, r3
  417414:	f101 0101 	add.w	r1, r1, #1
  417418:	dcfa      	bgt.n	417410 <__lshift+0x20>
  41741a:	4638      	mov	r0, r7
  41741c:	f7ff fe3c 	bl	417098 <_Balloc>
  417420:	2c00      	cmp	r4, #0
  417422:	f100 0314 	add.w	r3, r0, #20
  417426:	dd06      	ble.n	417436 <__lshift+0x46>
  417428:	eb03 0284 	add.w	r2, r3, r4, lsl #2
  41742c:	2100      	movs	r1, #0
  41742e:	f843 1b04 	str.w	r1, [r3], #4
  417432:	429a      	cmp	r2, r3
  417434:	d1fb      	bne.n	41742e <__lshift+0x3e>
  417436:	6934      	ldr	r4, [r6, #16]
  417438:	f106 0114 	add.w	r1, r6, #20
  41743c:	f019 091f 	ands.w	r9, r9, #31
  417440:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
  417444:	d01d      	beq.n	417482 <__lshift+0x92>
  417446:	f1c9 0c20 	rsb	ip, r9, #32
  41744a:	2200      	movs	r2, #0
  41744c:	680c      	ldr	r4, [r1, #0]
  41744e:	fa04 f409 	lsl.w	r4, r4, r9
  417452:	4314      	orrs	r4, r2
  417454:	f843 4b04 	str.w	r4, [r3], #4
  417458:	f851 2b04 	ldr.w	r2, [r1], #4
  41745c:	458e      	cmp	lr, r1
  41745e:	fa22 f20c 	lsr.w	r2, r2, ip
  417462:	d8f3      	bhi.n	41744c <__lshift+0x5c>
  417464:	601a      	str	r2, [r3, #0]
  417466:	b10a      	cbz	r2, 41746c <__lshift+0x7c>
  417468:	f108 0502 	add.w	r5, r8, #2
  41746c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41746e:	6872      	ldr	r2, [r6, #4]
  417470:	3d01      	subs	r5, #1
  417472:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  417476:	6105      	str	r5, [r0, #16]
  417478:	6031      	str	r1, [r6, #0]
  41747a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  41747e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  417482:	3b04      	subs	r3, #4
  417484:	f851 2b04 	ldr.w	r2, [r1], #4
  417488:	f843 2f04 	str.w	r2, [r3, #4]!
  41748c:	458e      	cmp	lr, r1
  41748e:	d8f9      	bhi.n	417484 <__lshift+0x94>
  417490:	e7ec      	b.n	41746c <__lshift+0x7c>
  417492:	bf00      	nop

00417494 <__mcmp>:
  417494:	b430      	push	{r4, r5}
  417496:	690b      	ldr	r3, [r1, #16]
  417498:	4605      	mov	r5, r0
  41749a:	6900      	ldr	r0, [r0, #16]
  41749c:	1ac0      	subs	r0, r0, r3
  41749e:	d10f      	bne.n	4174c0 <__mcmp+0x2c>
  4174a0:	009b      	lsls	r3, r3, #2
  4174a2:	3514      	adds	r5, #20
  4174a4:	3114      	adds	r1, #20
  4174a6:	4419      	add	r1, r3
  4174a8:	442b      	add	r3, r5
  4174aa:	e001      	b.n	4174b0 <__mcmp+0x1c>
  4174ac:	429d      	cmp	r5, r3
  4174ae:	d207      	bcs.n	4174c0 <__mcmp+0x2c>
  4174b0:	f853 4d04 	ldr.w	r4, [r3, #-4]!
  4174b4:	f851 2d04 	ldr.w	r2, [r1, #-4]!
  4174b8:	4294      	cmp	r4, r2
  4174ba:	d0f7      	beq.n	4174ac <__mcmp+0x18>
  4174bc:	d302      	bcc.n	4174c4 <__mcmp+0x30>
  4174be:	2001      	movs	r0, #1
  4174c0:	bc30      	pop	{r4, r5}
  4174c2:	4770      	bx	lr
  4174c4:	f04f 30ff 	mov.w	r0, #4294967295
  4174c8:	e7fa      	b.n	4174c0 <__mcmp+0x2c>
  4174ca:	bf00      	nop

004174cc <__mdiff>:
  4174cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4174d0:	690f      	ldr	r7, [r1, #16]
  4174d2:	460e      	mov	r6, r1
  4174d4:	6911      	ldr	r1, [r2, #16]
  4174d6:	1a7f      	subs	r7, r7, r1
  4174d8:	2f00      	cmp	r7, #0
  4174da:	4690      	mov	r8, r2
  4174dc:	d117      	bne.n	41750e <__mdiff+0x42>
  4174de:	0089      	lsls	r1, r1, #2
  4174e0:	f106 0514 	add.w	r5, r6, #20
  4174e4:	f102 0e14 	add.w	lr, r2, #20
  4174e8:	186b      	adds	r3, r5, r1
  4174ea:	4471      	add	r1, lr
  4174ec:	e001      	b.n	4174f2 <__mdiff+0x26>
  4174ee:	429d      	cmp	r5, r3
  4174f0:	d25c      	bcs.n	4175ac <__mdiff+0xe0>
  4174f2:	f853 2d04 	ldr.w	r2, [r3, #-4]!
  4174f6:	f851 4d04 	ldr.w	r4, [r1, #-4]!
  4174fa:	42a2      	cmp	r2, r4
  4174fc:	d0f7      	beq.n	4174ee <__mdiff+0x22>
  4174fe:	d25e      	bcs.n	4175be <__mdiff+0xf2>
  417500:	4633      	mov	r3, r6
  417502:	462c      	mov	r4, r5
  417504:	4646      	mov	r6, r8
  417506:	4675      	mov	r5, lr
  417508:	4698      	mov	r8, r3
  41750a:	2701      	movs	r7, #1
  41750c:	e005      	b.n	41751a <__mdiff+0x4e>
  41750e:	db58      	blt.n	4175c2 <__mdiff+0xf6>
  417510:	f106 0514 	add.w	r5, r6, #20
  417514:	f108 0414 	add.w	r4, r8, #20
  417518:	2700      	movs	r7, #0
  41751a:	6871      	ldr	r1, [r6, #4]
  41751c:	f7ff fdbc 	bl	417098 <_Balloc>
  417520:	f8d8 3010 	ldr.w	r3, [r8, #16]
  417524:	6936      	ldr	r6, [r6, #16]
  417526:	60c7      	str	r7, [r0, #12]
  417528:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
  41752c:	46a6      	mov	lr, r4
  41752e:	eb05 0786 	add.w	r7, r5, r6, lsl #2
  417532:	f100 0414 	add.w	r4, r0, #20
  417536:	2300      	movs	r3, #0
  417538:	f85e 1b04 	ldr.w	r1, [lr], #4
  41753c:	f855 8b04 	ldr.w	r8, [r5], #4
  417540:	b28a      	uxth	r2, r1
  417542:	fa13 f388 	uxtah	r3, r3, r8
  417546:	0c09      	lsrs	r1, r1, #16
  417548:	1a9a      	subs	r2, r3, r2
  41754a:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
  41754e:	eb03 4322 	add.w	r3, r3, r2, asr #16
  417552:	b292      	uxth	r2, r2
  417554:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  417558:	45f4      	cmp	ip, lr
  41755a:	f844 2b04 	str.w	r2, [r4], #4
  41755e:	ea4f 4323 	mov.w	r3, r3, asr #16
  417562:	d8e9      	bhi.n	417538 <__mdiff+0x6c>
  417564:	42af      	cmp	r7, r5
  417566:	d917      	bls.n	417598 <__mdiff+0xcc>
  417568:	46a4      	mov	ip, r4
  41756a:	46ae      	mov	lr, r5
  41756c:	f85e 2b04 	ldr.w	r2, [lr], #4
  417570:	fa13 f382 	uxtah	r3, r3, r2
  417574:	1419      	asrs	r1, r3, #16
  417576:	eb01 4112 	add.w	r1, r1, r2, lsr #16
  41757a:	b29b      	uxth	r3, r3
  41757c:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
  417580:	4577      	cmp	r7, lr
  417582:	f84c 2b04 	str.w	r2, [ip], #4
  417586:	ea4f 4321 	mov.w	r3, r1, asr #16
  41758a:	d8ef      	bhi.n	41756c <__mdiff+0xa0>
  41758c:	43ed      	mvns	r5, r5
  41758e:	442f      	add	r7, r5
  417590:	f027 0703 	bic.w	r7, r7, #3
  417594:	3704      	adds	r7, #4
  417596:	443c      	add	r4, r7
  417598:	3c04      	subs	r4, #4
  41759a:	b922      	cbnz	r2, 4175a6 <__mdiff+0xda>
  41759c:	f854 3d04 	ldr.w	r3, [r4, #-4]!
  4175a0:	3e01      	subs	r6, #1
  4175a2:	2b00      	cmp	r3, #0
  4175a4:	d0fa      	beq.n	41759c <__mdiff+0xd0>
  4175a6:	6106      	str	r6, [r0, #16]
  4175a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4175ac:	2100      	movs	r1, #0
  4175ae:	f7ff fd73 	bl	417098 <_Balloc>
  4175b2:	2201      	movs	r2, #1
  4175b4:	2300      	movs	r3, #0
  4175b6:	6102      	str	r2, [r0, #16]
  4175b8:	6143      	str	r3, [r0, #20]
  4175ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4175be:	4674      	mov	r4, lr
  4175c0:	e7ab      	b.n	41751a <__mdiff+0x4e>
  4175c2:	4633      	mov	r3, r6
  4175c4:	f106 0414 	add.w	r4, r6, #20
  4175c8:	f102 0514 	add.w	r5, r2, #20
  4175cc:	4616      	mov	r6, r2
  4175ce:	2701      	movs	r7, #1
  4175d0:	4698      	mov	r8, r3
  4175d2:	e7a2      	b.n	41751a <__mdiff+0x4e>

004175d4 <__d2b>:
  4175d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4175d8:	ec57 6b10 	vmov	r6, r7, d0
  4175dc:	b083      	sub	sp, #12
  4175de:	4688      	mov	r8, r1
  4175e0:	2101      	movs	r1, #1
  4175e2:	463c      	mov	r4, r7
  4175e4:	f3c7 550a 	ubfx	r5, r7, #20, #11
  4175e8:	4617      	mov	r7, r2
  4175ea:	f7ff fd55 	bl	417098 <_Balloc>
  4175ee:	f3c4 0413 	ubfx	r4, r4, #0, #20
  4175f2:	4681      	mov	r9, r0
  4175f4:	b10d      	cbz	r5, 4175fa <__d2b+0x26>
  4175f6:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
  4175fa:	9401      	str	r4, [sp, #4]
  4175fc:	b31e      	cbz	r6, 417646 <__d2b+0x72>
  4175fe:	a802      	add	r0, sp, #8
  417600:	f840 6d08 	str.w	r6, [r0, #-8]!
  417604:	f7ff fdd8 	bl	4171b8 <__lo0bits>
  417608:	2800      	cmp	r0, #0
  41760a:	d134      	bne.n	417676 <__d2b+0xa2>
  41760c:	e89d 000c 	ldmia.w	sp, {r2, r3}
  417610:	f8c9 2014 	str.w	r2, [r9, #20]
  417614:	2b00      	cmp	r3, #0
  417616:	bf0c      	ite	eq
  417618:	2101      	moveq	r1, #1
  41761a:	2102      	movne	r1, #2
  41761c:	f8c9 3018 	str.w	r3, [r9, #24]
  417620:	f8c9 1010 	str.w	r1, [r9, #16]
  417624:	b9dd      	cbnz	r5, 41765e <__d2b+0x8a>
  417626:	eb09 0381 	add.w	r3, r9, r1, lsl #2
  41762a:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  41762e:	f8c8 0000 	str.w	r0, [r8]
  417632:	6918      	ldr	r0, [r3, #16]
  417634:	f7ff fda0 	bl	417178 <__hi0bits>
  417638:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
  41763c:	6038      	str	r0, [r7, #0]
  41763e:	4648      	mov	r0, r9
  417640:	b003      	add	sp, #12
  417642:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  417646:	a801      	add	r0, sp, #4
  417648:	f7ff fdb6 	bl	4171b8 <__lo0bits>
  41764c:	9b01      	ldr	r3, [sp, #4]
  41764e:	f8c9 3014 	str.w	r3, [r9, #20]
  417652:	2101      	movs	r1, #1
  417654:	3020      	adds	r0, #32
  417656:	f8c9 1010 	str.w	r1, [r9, #16]
  41765a:	2d00      	cmp	r5, #0
  41765c:	d0e3      	beq.n	417626 <__d2b+0x52>
  41765e:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
  417662:	4405      	add	r5, r0
  417664:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  417668:	f8c8 5000 	str.w	r5, [r8]
  41766c:	6038      	str	r0, [r7, #0]
  41766e:	4648      	mov	r0, r9
  417670:	b003      	add	sp, #12
  417672:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  417676:	e89d 000a 	ldmia.w	sp, {r1, r3}
  41767a:	f1c0 0220 	rsb	r2, r0, #32
  41767e:	fa03 f202 	lsl.w	r2, r3, r2
  417682:	430a      	orrs	r2, r1
  417684:	40c3      	lsrs	r3, r0
  417686:	9301      	str	r3, [sp, #4]
  417688:	f8c9 2014 	str.w	r2, [r9, #20]
  41768c:	e7c2      	b.n	417614 <__d2b+0x40>
  41768e:	bf00      	nop

00417690 <_sbrk_r>:
  417690:	b538      	push	{r3, r4, r5, lr}
  417692:	4c07      	ldr	r4, [pc, #28]	; (4176b0 <_sbrk_r+0x20>)
  417694:	2300      	movs	r3, #0
  417696:	4605      	mov	r5, r0
  417698:	4608      	mov	r0, r1
  41769a:	6023      	str	r3, [r4, #0]
  41769c:	f7ed f89c 	bl	4047d8 <_sbrk>
  4176a0:	1c43      	adds	r3, r0, #1
  4176a2:	d000      	beq.n	4176a6 <_sbrk_r+0x16>
  4176a4:	bd38      	pop	{r3, r4, r5, pc}
  4176a6:	6823      	ldr	r3, [r4, #0]
  4176a8:	2b00      	cmp	r3, #0
  4176aa:	d0fb      	beq.n	4176a4 <_sbrk_r+0x14>
  4176ac:	602b      	str	r3, [r5, #0]
  4176ae:	bd38      	pop	{r3, r4, r5, pc}
  4176b0:	20001fa8 	.word	0x20001fa8
	...

004176c0 <strlen>:
  4176c0:	f890 f000 	pld	[r0]
  4176c4:	e96d 4502 	strd	r4, r5, [sp, #-8]!
  4176c8:	f020 0107 	bic.w	r1, r0, #7
  4176cc:	f06f 0c00 	mvn.w	ip, #0
  4176d0:	f010 0407 	ands.w	r4, r0, #7
  4176d4:	f891 f020 	pld	[r1, #32]
  4176d8:	f040 8049 	bne.w	41776e <strlen+0xae>
  4176dc:	f04f 0400 	mov.w	r4, #0
  4176e0:	f06f 0007 	mvn.w	r0, #7
  4176e4:	e9d1 2300 	ldrd	r2, r3, [r1]
  4176e8:	f891 f040 	pld	[r1, #64]	; 0x40
  4176ec:	f100 0008 	add.w	r0, r0, #8
  4176f0:	fa82 f24c 	uadd8	r2, r2, ip
  4176f4:	faa4 f28c 	sel	r2, r4, ip
  4176f8:	fa83 f34c 	uadd8	r3, r3, ip
  4176fc:	faa2 f38c 	sel	r3, r2, ip
  417700:	bb4b      	cbnz	r3, 417756 <strlen+0x96>
  417702:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
  417706:	fa82 f24c 	uadd8	r2, r2, ip
  41770a:	f100 0008 	add.w	r0, r0, #8
  41770e:	faa4 f28c 	sel	r2, r4, ip
  417712:	fa83 f34c 	uadd8	r3, r3, ip
  417716:	faa2 f38c 	sel	r3, r2, ip
  41771a:	b9e3      	cbnz	r3, 417756 <strlen+0x96>
  41771c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
  417720:	fa82 f24c 	uadd8	r2, r2, ip
  417724:	f100 0008 	add.w	r0, r0, #8
  417728:	faa4 f28c 	sel	r2, r4, ip
  41772c:	fa83 f34c 	uadd8	r3, r3, ip
  417730:	faa2 f38c 	sel	r3, r2, ip
  417734:	b97b      	cbnz	r3, 417756 <strlen+0x96>
  417736:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
  41773a:	f101 0120 	add.w	r1, r1, #32
  41773e:	fa82 f24c 	uadd8	r2, r2, ip
  417742:	f100 0008 	add.w	r0, r0, #8
  417746:	faa4 f28c 	sel	r2, r4, ip
  41774a:	fa83 f34c 	uadd8	r3, r3, ip
  41774e:	faa2 f38c 	sel	r3, r2, ip
  417752:	2b00      	cmp	r3, #0
  417754:	d0c6      	beq.n	4176e4 <strlen+0x24>
  417756:	2a00      	cmp	r2, #0
  417758:	bf04      	itt	eq
  41775a:	3004      	addeq	r0, #4
  41775c:	461a      	moveq	r2, r3
  41775e:	ba12      	rev	r2, r2
  417760:	fab2 f282 	clz	r2, r2
  417764:	e8fd 4502 	ldrd	r4, r5, [sp], #8
  417768:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
  41776c:	4770      	bx	lr
  41776e:	e9d1 2300 	ldrd	r2, r3, [r1]
  417772:	f004 0503 	and.w	r5, r4, #3
  417776:	f1c4 0000 	rsb	r0, r4, #0
  41777a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
  41777e:	f014 0f04 	tst.w	r4, #4
  417782:	f891 f040 	pld	[r1, #64]	; 0x40
  417786:	fa0c f505 	lsl.w	r5, ip, r5
  41778a:	ea62 0205 	orn	r2, r2, r5
  41778e:	bf1c      	itt	ne
  417790:	ea63 0305 	ornne	r3, r3, r5
  417794:	4662      	movne	r2, ip
  417796:	f04f 0400 	mov.w	r4, #0
  41779a:	e7a9      	b.n	4176f0 <strlen+0x30>

0041779c <__ssprint_r>:
  41779c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4177a0:	6893      	ldr	r3, [r2, #8]
  4177a2:	b083      	sub	sp, #12
  4177a4:	4690      	mov	r8, r2
  4177a6:	2b00      	cmp	r3, #0
  4177a8:	d070      	beq.n	41788c <__ssprint_r+0xf0>
  4177aa:	4682      	mov	sl, r0
  4177ac:	460c      	mov	r4, r1
  4177ae:	6817      	ldr	r7, [r2, #0]
  4177b0:	688d      	ldr	r5, [r1, #8]
  4177b2:	6808      	ldr	r0, [r1, #0]
  4177b4:	e042      	b.n	41783c <__ssprint_r+0xa0>
  4177b6:	89a3      	ldrh	r3, [r4, #12]
  4177b8:	f413 6f90 	tst.w	r3, #1152	; 0x480
  4177bc:	d02e      	beq.n	41781c <__ssprint_r+0x80>
  4177be:	6965      	ldr	r5, [r4, #20]
  4177c0:	6921      	ldr	r1, [r4, #16]
  4177c2:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  4177c6:	eba0 0b01 	sub.w	fp, r0, r1
  4177ca:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
  4177ce:	f10b 0001 	add.w	r0, fp, #1
  4177d2:	106d      	asrs	r5, r5, #1
  4177d4:	4430      	add	r0, r6
  4177d6:	42a8      	cmp	r0, r5
  4177d8:	462a      	mov	r2, r5
  4177da:	bf84      	itt	hi
  4177dc:	4605      	movhi	r5, r0
  4177de:	462a      	movhi	r2, r5
  4177e0:	055b      	lsls	r3, r3, #21
  4177e2:	d538      	bpl.n	417856 <__ssprint_r+0xba>
  4177e4:	4611      	mov	r1, r2
  4177e6:	4650      	mov	r0, sl
  4177e8:	f7ff f948 	bl	416a7c <_malloc_r>
  4177ec:	2800      	cmp	r0, #0
  4177ee:	d03c      	beq.n	41786a <__ssprint_r+0xce>
  4177f0:	465a      	mov	r2, fp
  4177f2:	6921      	ldr	r1, [r4, #16]
  4177f4:	9001      	str	r0, [sp, #4]
  4177f6:	f7fc fd1d 	bl	414234 <memcpy>
  4177fa:	89a2      	ldrh	r2, [r4, #12]
  4177fc:	9b01      	ldr	r3, [sp, #4]
  4177fe:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
  417802:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  417806:	81a2      	strh	r2, [r4, #12]
  417808:	eba5 020b 	sub.w	r2, r5, fp
  41780c:	eb03 000b 	add.w	r0, r3, fp
  417810:	6165      	str	r5, [r4, #20]
  417812:	6123      	str	r3, [r4, #16]
  417814:	6020      	str	r0, [r4, #0]
  417816:	60a2      	str	r2, [r4, #8]
  417818:	4635      	mov	r5, r6
  41781a:	46b3      	mov	fp, r6
  41781c:	465a      	mov	r2, fp
  41781e:	4649      	mov	r1, r9
  417820:	f7fc fda2 	bl	414368 <memmove>
  417824:	f8d8 3008 	ldr.w	r3, [r8, #8]
  417828:	68a2      	ldr	r2, [r4, #8]
  41782a:	6820      	ldr	r0, [r4, #0]
  41782c:	1b55      	subs	r5, r2, r5
  41782e:	4458      	add	r0, fp
  417830:	1b9e      	subs	r6, r3, r6
  417832:	60a5      	str	r5, [r4, #8]
  417834:	6020      	str	r0, [r4, #0]
  417836:	f8c8 6008 	str.w	r6, [r8, #8]
  41783a:	b33e      	cbz	r6, 41788c <__ssprint_r+0xf0>
  41783c:	687e      	ldr	r6, [r7, #4]
  41783e:	463b      	mov	r3, r7
  417840:	3708      	adds	r7, #8
  417842:	2e00      	cmp	r6, #0
  417844:	d0fa      	beq.n	41783c <__ssprint_r+0xa0>
  417846:	42ae      	cmp	r6, r5
  417848:	f8d3 9000 	ldr.w	r9, [r3]
  41784c:	46ab      	mov	fp, r5
  41784e:	d2b2      	bcs.n	4177b6 <__ssprint_r+0x1a>
  417850:	4635      	mov	r5, r6
  417852:	46b3      	mov	fp, r6
  417854:	e7e2      	b.n	41781c <__ssprint_r+0x80>
  417856:	4650      	mov	r0, sl
  417858:	f000 f9fc 	bl	417c54 <_realloc_r>
  41785c:	4603      	mov	r3, r0
  41785e:	2800      	cmp	r0, #0
  417860:	d1d2      	bne.n	417808 <__ssprint_r+0x6c>
  417862:	6921      	ldr	r1, [r4, #16]
  417864:	4650      	mov	r0, sl
  417866:	f000 f8f9 	bl	417a5c <_free_r>
  41786a:	230c      	movs	r3, #12
  41786c:	f8ca 3000 	str.w	r3, [sl]
  417870:	89a3      	ldrh	r3, [r4, #12]
  417872:	2200      	movs	r2, #0
  417874:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  417878:	f04f 30ff 	mov.w	r0, #4294967295
  41787c:	81a3      	strh	r3, [r4, #12]
  41787e:	f8c8 2008 	str.w	r2, [r8, #8]
  417882:	f8c8 2004 	str.w	r2, [r8, #4]
  417886:	b003      	add	sp, #12
  417888:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41788c:	2000      	movs	r0, #0
  41788e:	f8c8 0004 	str.w	r0, [r8, #4]
  417892:	b003      	add	sp, #12
  417894:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00417898 <__register_exitproc>:
  417898:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  41789c:	4d2c      	ldr	r5, [pc, #176]	; (417950 <__register_exitproc+0xb8>)
  41789e:	4606      	mov	r6, r0
  4178a0:	6828      	ldr	r0, [r5, #0]
  4178a2:	4698      	mov	r8, r3
  4178a4:	460f      	mov	r7, r1
  4178a6:	4691      	mov	r9, r2
  4178a8:	f7ff f8e4 	bl	416a74 <__retarget_lock_acquire_recursive>
  4178ac:	4b29      	ldr	r3, [pc, #164]	; (417954 <__register_exitproc+0xbc>)
  4178ae:	681c      	ldr	r4, [r3, #0]
  4178b0:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  4178b4:	2b00      	cmp	r3, #0
  4178b6:	d03e      	beq.n	417936 <__register_exitproc+0x9e>
  4178b8:	685a      	ldr	r2, [r3, #4]
  4178ba:	2a1f      	cmp	r2, #31
  4178bc:	dc1c      	bgt.n	4178f8 <__register_exitproc+0x60>
  4178be:	f102 0e01 	add.w	lr, r2, #1
  4178c2:	b176      	cbz	r6, 4178e2 <__register_exitproc+0x4a>
  4178c4:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  4178c8:	2401      	movs	r4, #1
  4178ca:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  4178ce:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  4178d2:	4094      	lsls	r4, r2
  4178d4:	4320      	orrs	r0, r4
  4178d6:	2e02      	cmp	r6, #2
  4178d8:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  4178dc:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  4178e0:	d023      	beq.n	41792a <__register_exitproc+0x92>
  4178e2:	3202      	adds	r2, #2
  4178e4:	f8c3 e004 	str.w	lr, [r3, #4]
  4178e8:	6828      	ldr	r0, [r5, #0]
  4178ea:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  4178ee:	f7ff f8c3 	bl	416a78 <__retarget_lock_release_recursive>
  4178f2:	2000      	movs	r0, #0
  4178f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4178f8:	4b17      	ldr	r3, [pc, #92]	; (417958 <__register_exitproc+0xc0>)
  4178fa:	b30b      	cbz	r3, 417940 <__register_exitproc+0xa8>
  4178fc:	f44f 70c8 	mov.w	r0, #400	; 0x190
  417900:	f3af 8000 	nop.w
  417904:	4603      	mov	r3, r0
  417906:	b1d8      	cbz	r0, 417940 <__register_exitproc+0xa8>
  417908:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  41790c:	6002      	str	r2, [r0, #0]
  41790e:	2100      	movs	r1, #0
  417910:	6041      	str	r1, [r0, #4]
  417912:	460a      	mov	r2, r1
  417914:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  417918:	f04f 0e01 	mov.w	lr, #1
  41791c:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  417920:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  417924:	2e00      	cmp	r6, #0
  417926:	d0dc      	beq.n	4178e2 <__register_exitproc+0x4a>
  417928:	e7cc      	b.n	4178c4 <__register_exitproc+0x2c>
  41792a:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  41792e:	430c      	orrs	r4, r1
  417930:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  417934:	e7d5      	b.n	4178e2 <__register_exitproc+0x4a>
  417936:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  41793a:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  41793e:	e7bb      	b.n	4178b8 <__register_exitproc+0x20>
  417940:	6828      	ldr	r0, [r5, #0]
  417942:	f7ff f899 	bl	416a78 <__retarget_lock_release_recursive>
  417946:	f04f 30ff 	mov.w	r0, #4294967295
  41794a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41794e:	bf00      	nop
  417950:	20000788 	.word	0x20000788
  417954:	0041d800 	.word	0x0041d800
  417958:	00000000 	.word	0x00000000

0041795c <_calloc_r>:
  41795c:	b510      	push	{r4, lr}
  41795e:	fb02 f101 	mul.w	r1, r2, r1
  417962:	f7ff f88b 	bl	416a7c <_malloc_r>
  417966:	4604      	mov	r4, r0
  417968:	b1d8      	cbz	r0, 4179a2 <_calloc_r+0x46>
  41796a:	f850 2c04 	ldr.w	r2, [r0, #-4]
  41796e:	f022 0203 	bic.w	r2, r2, #3
  417972:	3a04      	subs	r2, #4
  417974:	2a24      	cmp	r2, #36	; 0x24
  417976:	d818      	bhi.n	4179aa <_calloc_r+0x4e>
  417978:	2a13      	cmp	r2, #19
  41797a:	d914      	bls.n	4179a6 <_calloc_r+0x4a>
  41797c:	2300      	movs	r3, #0
  41797e:	2a1b      	cmp	r2, #27
  417980:	6003      	str	r3, [r0, #0]
  417982:	6043      	str	r3, [r0, #4]
  417984:	d916      	bls.n	4179b4 <_calloc_r+0x58>
  417986:	2a24      	cmp	r2, #36	; 0x24
  417988:	6083      	str	r3, [r0, #8]
  41798a:	60c3      	str	r3, [r0, #12]
  41798c:	bf11      	iteee	ne
  41798e:	f100 0210 	addne.w	r2, r0, #16
  417992:	6103      	streq	r3, [r0, #16]
  417994:	6143      	streq	r3, [r0, #20]
  417996:	f100 0218 	addeq.w	r2, r0, #24
  41799a:	2300      	movs	r3, #0
  41799c:	6013      	str	r3, [r2, #0]
  41799e:	6053      	str	r3, [r2, #4]
  4179a0:	6093      	str	r3, [r2, #8]
  4179a2:	4620      	mov	r0, r4
  4179a4:	bd10      	pop	{r4, pc}
  4179a6:	4602      	mov	r2, r0
  4179a8:	e7f7      	b.n	41799a <_calloc_r+0x3e>
  4179aa:	2100      	movs	r1, #0
  4179ac:	f7fc fd40 	bl	414430 <memset>
  4179b0:	4620      	mov	r0, r4
  4179b2:	bd10      	pop	{r4, pc}
  4179b4:	f100 0208 	add.w	r2, r0, #8
  4179b8:	e7ef      	b.n	41799a <_calloc_r+0x3e>
  4179ba:	bf00      	nop

004179bc <_malloc_trim_r>:
  4179bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4179be:	4f24      	ldr	r7, [pc, #144]	; (417a50 <_malloc_trim_r+0x94>)
  4179c0:	460c      	mov	r4, r1
  4179c2:	4606      	mov	r6, r0
  4179c4:	f7ff fb5c 	bl	417080 <__malloc_lock>
  4179c8:	68bb      	ldr	r3, [r7, #8]
  4179ca:	685d      	ldr	r5, [r3, #4]
  4179cc:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
  4179d0:	310f      	adds	r1, #15
  4179d2:	f025 0503 	bic.w	r5, r5, #3
  4179d6:	4429      	add	r1, r5
  4179d8:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  4179dc:	f021 010f 	bic.w	r1, r1, #15
  4179e0:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
  4179e4:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
  4179e8:	db07      	blt.n	4179fa <_malloc_trim_r+0x3e>
  4179ea:	2100      	movs	r1, #0
  4179ec:	4630      	mov	r0, r6
  4179ee:	f7ff fe4f 	bl	417690 <_sbrk_r>
  4179f2:	68bb      	ldr	r3, [r7, #8]
  4179f4:	442b      	add	r3, r5
  4179f6:	4298      	cmp	r0, r3
  4179f8:	d004      	beq.n	417a04 <_malloc_trim_r+0x48>
  4179fa:	4630      	mov	r0, r6
  4179fc:	f7ff fb46 	bl	41708c <__malloc_unlock>
  417a00:	2000      	movs	r0, #0
  417a02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  417a04:	4261      	negs	r1, r4
  417a06:	4630      	mov	r0, r6
  417a08:	f7ff fe42 	bl	417690 <_sbrk_r>
  417a0c:	3001      	adds	r0, #1
  417a0e:	d00d      	beq.n	417a2c <_malloc_trim_r+0x70>
  417a10:	4b10      	ldr	r3, [pc, #64]	; (417a54 <_malloc_trim_r+0x98>)
  417a12:	68ba      	ldr	r2, [r7, #8]
  417a14:	6819      	ldr	r1, [r3, #0]
  417a16:	1b2d      	subs	r5, r5, r4
  417a18:	f045 0501 	orr.w	r5, r5, #1
  417a1c:	4630      	mov	r0, r6
  417a1e:	1b09      	subs	r1, r1, r4
  417a20:	6055      	str	r5, [r2, #4]
  417a22:	6019      	str	r1, [r3, #0]
  417a24:	f7ff fb32 	bl	41708c <__malloc_unlock>
  417a28:	2001      	movs	r0, #1
  417a2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  417a2c:	2100      	movs	r1, #0
  417a2e:	4630      	mov	r0, r6
  417a30:	f7ff fe2e 	bl	417690 <_sbrk_r>
  417a34:	68ba      	ldr	r2, [r7, #8]
  417a36:	1a83      	subs	r3, r0, r2
  417a38:	2b0f      	cmp	r3, #15
  417a3a:	ddde      	ble.n	4179fa <_malloc_trim_r+0x3e>
  417a3c:	4c06      	ldr	r4, [pc, #24]	; (417a58 <_malloc_trim_r+0x9c>)
  417a3e:	4905      	ldr	r1, [pc, #20]	; (417a54 <_malloc_trim_r+0x98>)
  417a40:	6824      	ldr	r4, [r4, #0]
  417a42:	f043 0301 	orr.w	r3, r3, #1
  417a46:	1b00      	subs	r0, r0, r4
  417a48:	6053      	str	r3, [r2, #4]
  417a4a:	6008      	str	r0, [r1, #0]
  417a4c:	e7d5      	b.n	4179fa <_malloc_trim_r+0x3e>
  417a4e:	bf00      	nop
  417a50:	2000078c 	.word	0x2000078c
  417a54:	20001834 	.word	0x20001834
  417a58:	20000b94 	.word	0x20000b94

00417a5c <_free_r>:
  417a5c:	2900      	cmp	r1, #0
  417a5e:	d044      	beq.n	417aea <_free_r+0x8e>
  417a60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  417a64:	460d      	mov	r5, r1
  417a66:	4680      	mov	r8, r0
  417a68:	f7ff fb0a 	bl	417080 <__malloc_lock>
  417a6c:	f855 7c04 	ldr.w	r7, [r5, #-4]
  417a70:	4969      	ldr	r1, [pc, #420]	; (417c18 <_free_r+0x1bc>)
  417a72:	f027 0301 	bic.w	r3, r7, #1
  417a76:	f1a5 0408 	sub.w	r4, r5, #8
  417a7a:	18e2      	adds	r2, r4, r3
  417a7c:	688e      	ldr	r6, [r1, #8]
  417a7e:	6850      	ldr	r0, [r2, #4]
  417a80:	42b2      	cmp	r2, r6
  417a82:	f020 0003 	bic.w	r0, r0, #3
  417a86:	d05e      	beq.n	417b46 <_free_r+0xea>
  417a88:	07fe      	lsls	r6, r7, #31
  417a8a:	6050      	str	r0, [r2, #4]
  417a8c:	d40b      	bmi.n	417aa6 <_free_r+0x4a>
  417a8e:	f855 7c08 	ldr.w	r7, [r5, #-8]
  417a92:	1be4      	subs	r4, r4, r7
  417a94:	f101 0e08 	add.w	lr, r1, #8
  417a98:	68a5      	ldr	r5, [r4, #8]
  417a9a:	4575      	cmp	r5, lr
  417a9c:	443b      	add	r3, r7
  417a9e:	d06d      	beq.n	417b7c <_free_r+0x120>
  417aa0:	68e7      	ldr	r7, [r4, #12]
  417aa2:	60ef      	str	r7, [r5, #12]
  417aa4:	60bd      	str	r5, [r7, #8]
  417aa6:	1815      	adds	r5, r2, r0
  417aa8:	686d      	ldr	r5, [r5, #4]
  417aaa:	07ed      	lsls	r5, r5, #31
  417aac:	d53e      	bpl.n	417b2c <_free_r+0xd0>
  417aae:	f043 0201 	orr.w	r2, r3, #1
  417ab2:	6062      	str	r2, [r4, #4]
  417ab4:	50e3      	str	r3, [r4, r3]
  417ab6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  417aba:	d217      	bcs.n	417aec <_free_r+0x90>
  417abc:	08db      	lsrs	r3, r3, #3
  417abe:	1c58      	adds	r0, r3, #1
  417ac0:	109a      	asrs	r2, r3, #2
  417ac2:	684d      	ldr	r5, [r1, #4]
  417ac4:	f851 7030 	ldr.w	r7, [r1, r0, lsl #3]
  417ac8:	60a7      	str	r7, [r4, #8]
  417aca:	2301      	movs	r3, #1
  417acc:	4093      	lsls	r3, r2
  417ace:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
  417ad2:	432b      	orrs	r3, r5
  417ad4:	3a08      	subs	r2, #8
  417ad6:	60e2      	str	r2, [r4, #12]
  417ad8:	604b      	str	r3, [r1, #4]
  417ada:	f841 4030 	str.w	r4, [r1, r0, lsl #3]
  417ade:	60fc      	str	r4, [r7, #12]
  417ae0:	4640      	mov	r0, r8
  417ae2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  417ae6:	f7ff bad1 	b.w	41708c <__malloc_unlock>
  417aea:	4770      	bx	lr
  417aec:	0a5a      	lsrs	r2, r3, #9
  417aee:	2a04      	cmp	r2, #4
  417af0:	d852      	bhi.n	417b98 <_free_r+0x13c>
  417af2:	099a      	lsrs	r2, r3, #6
  417af4:	f102 0739 	add.w	r7, r2, #57	; 0x39
  417af8:	00ff      	lsls	r7, r7, #3
  417afa:	f102 0538 	add.w	r5, r2, #56	; 0x38
  417afe:	19c8      	adds	r0, r1, r7
  417b00:	59ca      	ldr	r2, [r1, r7]
  417b02:	3808      	subs	r0, #8
  417b04:	4290      	cmp	r0, r2
  417b06:	d04f      	beq.n	417ba8 <_free_r+0x14c>
  417b08:	6851      	ldr	r1, [r2, #4]
  417b0a:	f021 0103 	bic.w	r1, r1, #3
  417b0e:	428b      	cmp	r3, r1
  417b10:	d232      	bcs.n	417b78 <_free_r+0x11c>
  417b12:	6892      	ldr	r2, [r2, #8]
  417b14:	4290      	cmp	r0, r2
  417b16:	d1f7      	bne.n	417b08 <_free_r+0xac>
  417b18:	68c3      	ldr	r3, [r0, #12]
  417b1a:	60a0      	str	r0, [r4, #8]
  417b1c:	60e3      	str	r3, [r4, #12]
  417b1e:	609c      	str	r4, [r3, #8]
  417b20:	60c4      	str	r4, [r0, #12]
  417b22:	4640      	mov	r0, r8
  417b24:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  417b28:	f7ff bab0 	b.w	41708c <__malloc_unlock>
  417b2c:	6895      	ldr	r5, [r2, #8]
  417b2e:	4f3b      	ldr	r7, [pc, #236]	; (417c1c <_free_r+0x1c0>)
  417b30:	42bd      	cmp	r5, r7
  417b32:	4403      	add	r3, r0
  417b34:	d040      	beq.n	417bb8 <_free_r+0x15c>
  417b36:	68d0      	ldr	r0, [r2, #12]
  417b38:	60e8      	str	r0, [r5, #12]
  417b3a:	f043 0201 	orr.w	r2, r3, #1
  417b3e:	6085      	str	r5, [r0, #8]
  417b40:	6062      	str	r2, [r4, #4]
  417b42:	50e3      	str	r3, [r4, r3]
  417b44:	e7b7      	b.n	417ab6 <_free_r+0x5a>
  417b46:	07ff      	lsls	r7, r7, #31
  417b48:	4403      	add	r3, r0
  417b4a:	d407      	bmi.n	417b5c <_free_r+0x100>
  417b4c:	f855 2c08 	ldr.w	r2, [r5, #-8]
  417b50:	1aa4      	subs	r4, r4, r2
  417b52:	4413      	add	r3, r2
  417b54:	68a0      	ldr	r0, [r4, #8]
  417b56:	68e2      	ldr	r2, [r4, #12]
  417b58:	60c2      	str	r2, [r0, #12]
  417b5a:	6090      	str	r0, [r2, #8]
  417b5c:	4a30      	ldr	r2, [pc, #192]	; (417c20 <_free_r+0x1c4>)
  417b5e:	6812      	ldr	r2, [r2, #0]
  417b60:	f043 0001 	orr.w	r0, r3, #1
  417b64:	4293      	cmp	r3, r2
  417b66:	6060      	str	r0, [r4, #4]
  417b68:	608c      	str	r4, [r1, #8]
  417b6a:	d3b9      	bcc.n	417ae0 <_free_r+0x84>
  417b6c:	4b2d      	ldr	r3, [pc, #180]	; (417c24 <_free_r+0x1c8>)
  417b6e:	4640      	mov	r0, r8
  417b70:	6819      	ldr	r1, [r3, #0]
  417b72:	f7ff ff23 	bl	4179bc <_malloc_trim_r>
  417b76:	e7b3      	b.n	417ae0 <_free_r+0x84>
  417b78:	4610      	mov	r0, r2
  417b7a:	e7cd      	b.n	417b18 <_free_r+0xbc>
  417b7c:	1811      	adds	r1, r2, r0
  417b7e:	6849      	ldr	r1, [r1, #4]
  417b80:	07c9      	lsls	r1, r1, #31
  417b82:	d444      	bmi.n	417c0e <_free_r+0x1b2>
  417b84:	6891      	ldr	r1, [r2, #8]
  417b86:	68d2      	ldr	r2, [r2, #12]
  417b88:	60ca      	str	r2, [r1, #12]
  417b8a:	4403      	add	r3, r0
  417b8c:	f043 0001 	orr.w	r0, r3, #1
  417b90:	6091      	str	r1, [r2, #8]
  417b92:	6060      	str	r0, [r4, #4]
  417b94:	50e3      	str	r3, [r4, r3]
  417b96:	e7a3      	b.n	417ae0 <_free_r+0x84>
  417b98:	2a14      	cmp	r2, #20
  417b9a:	d816      	bhi.n	417bca <_free_r+0x16e>
  417b9c:	f102 075c 	add.w	r7, r2, #92	; 0x5c
  417ba0:	00ff      	lsls	r7, r7, #3
  417ba2:	f102 055b 	add.w	r5, r2, #91	; 0x5b
  417ba6:	e7aa      	b.n	417afe <_free_r+0xa2>
  417ba8:	10aa      	asrs	r2, r5, #2
  417baa:	2301      	movs	r3, #1
  417bac:	684d      	ldr	r5, [r1, #4]
  417bae:	4093      	lsls	r3, r2
  417bb0:	432b      	orrs	r3, r5
  417bb2:	604b      	str	r3, [r1, #4]
  417bb4:	4603      	mov	r3, r0
  417bb6:	e7b0      	b.n	417b1a <_free_r+0xbe>
  417bb8:	f043 0201 	orr.w	r2, r3, #1
  417bbc:	614c      	str	r4, [r1, #20]
  417bbe:	610c      	str	r4, [r1, #16]
  417bc0:	60e5      	str	r5, [r4, #12]
  417bc2:	60a5      	str	r5, [r4, #8]
  417bc4:	6062      	str	r2, [r4, #4]
  417bc6:	50e3      	str	r3, [r4, r3]
  417bc8:	e78a      	b.n	417ae0 <_free_r+0x84>
  417bca:	2a54      	cmp	r2, #84	; 0x54
  417bcc:	d806      	bhi.n	417bdc <_free_r+0x180>
  417bce:	0b1a      	lsrs	r2, r3, #12
  417bd0:	f102 076f 	add.w	r7, r2, #111	; 0x6f
  417bd4:	00ff      	lsls	r7, r7, #3
  417bd6:	f102 056e 	add.w	r5, r2, #110	; 0x6e
  417bda:	e790      	b.n	417afe <_free_r+0xa2>
  417bdc:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  417be0:	d806      	bhi.n	417bf0 <_free_r+0x194>
  417be2:	0bda      	lsrs	r2, r3, #15
  417be4:	f102 0778 	add.w	r7, r2, #120	; 0x78
  417be8:	00ff      	lsls	r7, r7, #3
  417bea:	f102 0577 	add.w	r5, r2, #119	; 0x77
  417bee:	e786      	b.n	417afe <_free_r+0xa2>
  417bf0:	f240 5054 	movw	r0, #1364	; 0x554
  417bf4:	4282      	cmp	r2, r0
  417bf6:	d806      	bhi.n	417c06 <_free_r+0x1aa>
  417bf8:	0c9a      	lsrs	r2, r3, #18
  417bfa:	f102 077d 	add.w	r7, r2, #125	; 0x7d
  417bfe:	00ff      	lsls	r7, r7, #3
  417c00:	f102 057c 	add.w	r5, r2, #124	; 0x7c
  417c04:	e77b      	b.n	417afe <_free_r+0xa2>
  417c06:	f44f 777e 	mov.w	r7, #1016	; 0x3f8
  417c0a:	257e      	movs	r5, #126	; 0x7e
  417c0c:	e777      	b.n	417afe <_free_r+0xa2>
  417c0e:	f043 0101 	orr.w	r1, r3, #1
  417c12:	6061      	str	r1, [r4, #4]
  417c14:	6013      	str	r3, [r2, #0]
  417c16:	e763      	b.n	417ae0 <_free_r+0x84>
  417c18:	2000078c 	.word	0x2000078c
  417c1c:	20000794 	.word	0x20000794
  417c20:	20000b98 	.word	0x20000b98
  417c24:	20001864 	.word	0x20001864

00417c28 <__ascii_mbtowc>:
  417c28:	b082      	sub	sp, #8
  417c2a:	b149      	cbz	r1, 417c40 <__ascii_mbtowc+0x18>
  417c2c:	b15a      	cbz	r2, 417c46 <__ascii_mbtowc+0x1e>
  417c2e:	b16b      	cbz	r3, 417c4c <__ascii_mbtowc+0x24>
  417c30:	7813      	ldrb	r3, [r2, #0]
  417c32:	600b      	str	r3, [r1, #0]
  417c34:	7812      	ldrb	r2, [r2, #0]
  417c36:	1c10      	adds	r0, r2, #0
  417c38:	bf18      	it	ne
  417c3a:	2001      	movne	r0, #1
  417c3c:	b002      	add	sp, #8
  417c3e:	4770      	bx	lr
  417c40:	a901      	add	r1, sp, #4
  417c42:	2a00      	cmp	r2, #0
  417c44:	d1f3      	bne.n	417c2e <__ascii_mbtowc+0x6>
  417c46:	4610      	mov	r0, r2
  417c48:	b002      	add	sp, #8
  417c4a:	4770      	bx	lr
  417c4c:	f06f 0001 	mvn.w	r0, #1
  417c50:	e7f4      	b.n	417c3c <__ascii_mbtowc+0x14>
  417c52:	bf00      	nop

00417c54 <_realloc_r>:
  417c54:	2900      	cmp	r1, #0
  417c56:	f000 8095 	beq.w	417d84 <_realloc_r+0x130>
  417c5a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  417c5e:	460d      	mov	r5, r1
  417c60:	4616      	mov	r6, r2
  417c62:	b083      	sub	sp, #12
  417c64:	4680      	mov	r8, r0
  417c66:	f106 070b 	add.w	r7, r6, #11
  417c6a:	f7ff fa09 	bl	417080 <__malloc_lock>
  417c6e:	f855 ec04 	ldr.w	lr, [r5, #-4]
  417c72:	2f16      	cmp	r7, #22
  417c74:	f02e 0403 	bic.w	r4, lr, #3
  417c78:	f1a5 0908 	sub.w	r9, r5, #8
  417c7c:	d83c      	bhi.n	417cf8 <_realloc_r+0xa4>
  417c7e:	2210      	movs	r2, #16
  417c80:	4617      	mov	r7, r2
  417c82:	42be      	cmp	r6, r7
  417c84:	d83d      	bhi.n	417d02 <_realloc_r+0xae>
  417c86:	4294      	cmp	r4, r2
  417c88:	da43      	bge.n	417d12 <_realloc_r+0xbe>
  417c8a:	4bc4      	ldr	r3, [pc, #784]	; (417f9c <_realloc_r+0x348>)
  417c8c:	6899      	ldr	r1, [r3, #8]
  417c8e:	eb09 0004 	add.w	r0, r9, r4
  417c92:	4288      	cmp	r0, r1
  417c94:	f000 80b4 	beq.w	417e00 <_realloc_r+0x1ac>
  417c98:	6843      	ldr	r3, [r0, #4]
  417c9a:	f023 0101 	bic.w	r1, r3, #1
  417c9e:	4401      	add	r1, r0
  417ca0:	6849      	ldr	r1, [r1, #4]
  417ca2:	07c9      	lsls	r1, r1, #31
  417ca4:	d54c      	bpl.n	417d40 <_realloc_r+0xec>
  417ca6:	f01e 0f01 	tst.w	lr, #1
  417caa:	f000 809b 	beq.w	417de4 <_realloc_r+0x190>
  417cae:	4631      	mov	r1, r6
  417cb0:	4640      	mov	r0, r8
  417cb2:	f7fe fee3 	bl	416a7c <_malloc_r>
  417cb6:	4606      	mov	r6, r0
  417cb8:	2800      	cmp	r0, #0
  417cba:	d03a      	beq.n	417d32 <_realloc_r+0xde>
  417cbc:	f855 3c04 	ldr.w	r3, [r5, #-4]
  417cc0:	f023 0301 	bic.w	r3, r3, #1
  417cc4:	444b      	add	r3, r9
  417cc6:	f1a0 0208 	sub.w	r2, r0, #8
  417cca:	429a      	cmp	r2, r3
  417ccc:	f000 8121 	beq.w	417f12 <_realloc_r+0x2be>
  417cd0:	1f22      	subs	r2, r4, #4
  417cd2:	2a24      	cmp	r2, #36	; 0x24
  417cd4:	f200 8107 	bhi.w	417ee6 <_realloc_r+0x292>
  417cd8:	2a13      	cmp	r2, #19
  417cda:	f200 80db 	bhi.w	417e94 <_realloc_r+0x240>
  417cde:	4603      	mov	r3, r0
  417ce0:	462a      	mov	r2, r5
  417ce2:	6811      	ldr	r1, [r2, #0]
  417ce4:	6019      	str	r1, [r3, #0]
  417ce6:	6851      	ldr	r1, [r2, #4]
  417ce8:	6059      	str	r1, [r3, #4]
  417cea:	6892      	ldr	r2, [r2, #8]
  417cec:	609a      	str	r2, [r3, #8]
  417cee:	4629      	mov	r1, r5
  417cf0:	4640      	mov	r0, r8
  417cf2:	f7ff feb3 	bl	417a5c <_free_r>
  417cf6:	e01c      	b.n	417d32 <_realloc_r+0xde>
  417cf8:	f027 0707 	bic.w	r7, r7, #7
  417cfc:	2f00      	cmp	r7, #0
  417cfe:	463a      	mov	r2, r7
  417d00:	dabf      	bge.n	417c82 <_realloc_r+0x2e>
  417d02:	2600      	movs	r6, #0
  417d04:	230c      	movs	r3, #12
  417d06:	4630      	mov	r0, r6
  417d08:	f8c8 3000 	str.w	r3, [r8]
  417d0c:	b003      	add	sp, #12
  417d0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  417d12:	462e      	mov	r6, r5
  417d14:	1be3      	subs	r3, r4, r7
  417d16:	2b0f      	cmp	r3, #15
  417d18:	d81e      	bhi.n	417d58 <_realloc_r+0x104>
  417d1a:	f8d9 3004 	ldr.w	r3, [r9, #4]
  417d1e:	f003 0301 	and.w	r3, r3, #1
  417d22:	4323      	orrs	r3, r4
  417d24:	444c      	add	r4, r9
  417d26:	f8c9 3004 	str.w	r3, [r9, #4]
  417d2a:	6863      	ldr	r3, [r4, #4]
  417d2c:	f043 0301 	orr.w	r3, r3, #1
  417d30:	6063      	str	r3, [r4, #4]
  417d32:	4640      	mov	r0, r8
  417d34:	f7ff f9aa 	bl	41708c <__malloc_unlock>
  417d38:	4630      	mov	r0, r6
  417d3a:	b003      	add	sp, #12
  417d3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  417d40:	f023 0303 	bic.w	r3, r3, #3
  417d44:	18e1      	adds	r1, r4, r3
  417d46:	4291      	cmp	r1, r2
  417d48:	db1f      	blt.n	417d8a <_realloc_r+0x136>
  417d4a:	68c3      	ldr	r3, [r0, #12]
  417d4c:	6882      	ldr	r2, [r0, #8]
  417d4e:	462e      	mov	r6, r5
  417d50:	60d3      	str	r3, [r2, #12]
  417d52:	460c      	mov	r4, r1
  417d54:	609a      	str	r2, [r3, #8]
  417d56:	e7dd      	b.n	417d14 <_realloc_r+0xc0>
  417d58:	f8d9 2004 	ldr.w	r2, [r9, #4]
  417d5c:	eb09 0107 	add.w	r1, r9, r7
  417d60:	f002 0201 	and.w	r2, r2, #1
  417d64:	444c      	add	r4, r9
  417d66:	f043 0301 	orr.w	r3, r3, #1
  417d6a:	4317      	orrs	r7, r2
  417d6c:	f8c9 7004 	str.w	r7, [r9, #4]
  417d70:	604b      	str	r3, [r1, #4]
  417d72:	6863      	ldr	r3, [r4, #4]
  417d74:	f043 0301 	orr.w	r3, r3, #1
  417d78:	3108      	adds	r1, #8
  417d7a:	6063      	str	r3, [r4, #4]
  417d7c:	4640      	mov	r0, r8
  417d7e:	f7ff fe6d 	bl	417a5c <_free_r>
  417d82:	e7d6      	b.n	417d32 <_realloc_r+0xde>
  417d84:	4611      	mov	r1, r2
  417d86:	f7fe be79 	b.w	416a7c <_malloc_r>
  417d8a:	f01e 0f01 	tst.w	lr, #1
  417d8e:	d18e      	bne.n	417cae <_realloc_r+0x5a>
  417d90:	f855 1c08 	ldr.w	r1, [r5, #-8]
  417d94:	eba9 0a01 	sub.w	sl, r9, r1
  417d98:	f8da 1004 	ldr.w	r1, [sl, #4]
  417d9c:	f021 0103 	bic.w	r1, r1, #3
  417da0:	440b      	add	r3, r1
  417da2:	4423      	add	r3, r4
  417da4:	4293      	cmp	r3, r2
  417da6:	db25      	blt.n	417df4 <_realloc_r+0x1a0>
  417da8:	68c2      	ldr	r2, [r0, #12]
  417daa:	6881      	ldr	r1, [r0, #8]
  417dac:	4656      	mov	r6, sl
  417dae:	60ca      	str	r2, [r1, #12]
  417db0:	6091      	str	r1, [r2, #8]
  417db2:	f8da 100c 	ldr.w	r1, [sl, #12]
  417db6:	f856 0f08 	ldr.w	r0, [r6, #8]!
  417dba:	1f22      	subs	r2, r4, #4
  417dbc:	2a24      	cmp	r2, #36	; 0x24
  417dbe:	60c1      	str	r1, [r0, #12]
  417dc0:	6088      	str	r0, [r1, #8]
  417dc2:	f200 8094 	bhi.w	417eee <_realloc_r+0x29a>
  417dc6:	2a13      	cmp	r2, #19
  417dc8:	d96f      	bls.n	417eaa <_realloc_r+0x256>
  417dca:	6829      	ldr	r1, [r5, #0]
  417dcc:	f8ca 1008 	str.w	r1, [sl, #8]
  417dd0:	6869      	ldr	r1, [r5, #4]
  417dd2:	f8ca 100c 	str.w	r1, [sl, #12]
  417dd6:	2a1b      	cmp	r2, #27
  417dd8:	f200 80a2 	bhi.w	417f20 <_realloc_r+0x2cc>
  417ddc:	3508      	adds	r5, #8
  417dde:	f10a 0210 	add.w	r2, sl, #16
  417de2:	e063      	b.n	417eac <_realloc_r+0x258>
  417de4:	f855 3c08 	ldr.w	r3, [r5, #-8]
  417de8:	eba9 0a03 	sub.w	sl, r9, r3
  417dec:	f8da 1004 	ldr.w	r1, [sl, #4]
  417df0:	f021 0103 	bic.w	r1, r1, #3
  417df4:	1863      	adds	r3, r4, r1
  417df6:	4293      	cmp	r3, r2
  417df8:	f6ff af59 	blt.w	417cae <_realloc_r+0x5a>
  417dfc:	4656      	mov	r6, sl
  417dfe:	e7d8      	b.n	417db2 <_realloc_r+0x15e>
  417e00:	6841      	ldr	r1, [r0, #4]
  417e02:	f021 0b03 	bic.w	fp, r1, #3
  417e06:	44a3      	add	fp, r4
  417e08:	f107 0010 	add.w	r0, r7, #16
  417e0c:	4583      	cmp	fp, r0
  417e0e:	da56      	bge.n	417ebe <_realloc_r+0x26a>
  417e10:	f01e 0f01 	tst.w	lr, #1
  417e14:	f47f af4b 	bne.w	417cae <_realloc_r+0x5a>
  417e18:	f855 1c08 	ldr.w	r1, [r5, #-8]
  417e1c:	eba9 0a01 	sub.w	sl, r9, r1
  417e20:	f8da 1004 	ldr.w	r1, [sl, #4]
  417e24:	f021 0103 	bic.w	r1, r1, #3
  417e28:	448b      	add	fp, r1
  417e2a:	4558      	cmp	r0, fp
  417e2c:	dce2      	bgt.n	417df4 <_realloc_r+0x1a0>
  417e2e:	4656      	mov	r6, sl
  417e30:	f8da 100c 	ldr.w	r1, [sl, #12]
  417e34:	f856 0f08 	ldr.w	r0, [r6, #8]!
  417e38:	1f22      	subs	r2, r4, #4
  417e3a:	2a24      	cmp	r2, #36	; 0x24
  417e3c:	60c1      	str	r1, [r0, #12]
  417e3e:	6088      	str	r0, [r1, #8]
  417e40:	f200 808f 	bhi.w	417f62 <_realloc_r+0x30e>
  417e44:	2a13      	cmp	r2, #19
  417e46:	f240 808a 	bls.w	417f5e <_realloc_r+0x30a>
  417e4a:	6829      	ldr	r1, [r5, #0]
  417e4c:	f8ca 1008 	str.w	r1, [sl, #8]
  417e50:	6869      	ldr	r1, [r5, #4]
  417e52:	f8ca 100c 	str.w	r1, [sl, #12]
  417e56:	2a1b      	cmp	r2, #27
  417e58:	f200 808a 	bhi.w	417f70 <_realloc_r+0x31c>
  417e5c:	3508      	adds	r5, #8
  417e5e:	f10a 0210 	add.w	r2, sl, #16
  417e62:	6829      	ldr	r1, [r5, #0]
  417e64:	6011      	str	r1, [r2, #0]
  417e66:	6869      	ldr	r1, [r5, #4]
  417e68:	6051      	str	r1, [r2, #4]
  417e6a:	68a9      	ldr	r1, [r5, #8]
  417e6c:	6091      	str	r1, [r2, #8]
  417e6e:	eb0a 0107 	add.w	r1, sl, r7
  417e72:	ebab 0207 	sub.w	r2, fp, r7
  417e76:	f042 0201 	orr.w	r2, r2, #1
  417e7a:	6099      	str	r1, [r3, #8]
  417e7c:	604a      	str	r2, [r1, #4]
  417e7e:	f8da 3004 	ldr.w	r3, [sl, #4]
  417e82:	f003 0301 	and.w	r3, r3, #1
  417e86:	431f      	orrs	r7, r3
  417e88:	4640      	mov	r0, r8
  417e8a:	f8ca 7004 	str.w	r7, [sl, #4]
  417e8e:	f7ff f8fd 	bl	41708c <__malloc_unlock>
  417e92:	e751      	b.n	417d38 <_realloc_r+0xe4>
  417e94:	682b      	ldr	r3, [r5, #0]
  417e96:	6003      	str	r3, [r0, #0]
  417e98:	686b      	ldr	r3, [r5, #4]
  417e9a:	6043      	str	r3, [r0, #4]
  417e9c:	2a1b      	cmp	r2, #27
  417e9e:	d82d      	bhi.n	417efc <_realloc_r+0x2a8>
  417ea0:	f100 0308 	add.w	r3, r0, #8
  417ea4:	f105 0208 	add.w	r2, r5, #8
  417ea8:	e71b      	b.n	417ce2 <_realloc_r+0x8e>
  417eaa:	4632      	mov	r2, r6
  417eac:	6829      	ldr	r1, [r5, #0]
  417eae:	6011      	str	r1, [r2, #0]
  417eb0:	6869      	ldr	r1, [r5, #4]
  417eb2:	6051      	str	r1, [r2, #4]
  417eb4:	68a9      	ldr	r1, [r5, #8]
  417eb6:	6091      	str	r1, [r2, #8]
  417eb8:	461c      	mov	r4, r3
  417eba:	46d1      	mov	r9, sl
  417ebc:	e72a      	b.n	417d14 <_realloc_r+0xc0>
  417ebe:	eb09 0107 	add.w	r1, r9, r7
  417ec2:	ebab 0b07 	sub.w	fp, fp, r7
  417ec6:	f04b 0201 	orr.w	r2, fp, #1
  417eca:	6099      	str	r1, [r3, #8]
  417ecc:	604a      	str	r2, [r1, #4]
  417ece:	f855 3c04 	ldr.w	r3, [r5, #-4]
  417ed2:	f003 0301 	and.w	r3, r3, #1
  417ed6:	431f      	orrs	r7, r3
  417ed8:	4640      	mov	r0, r8
  417eda:	f845 7c04 	str.w	r7, [r5, #-4]
  417ede:	f7ff f8d5 	bl	41708c <__malloc_unlock>
  417ee2:	462e      	mov	r6, r5
  417ee4:	e728      	b.n	417d38 <_realloc_r+0xe4>
  417ee6:	4629      	mov	r1, r5
  417ee8:	f7fc fa3e 	bl	414368 <memmove>
  417eec:	e6ff      	b.n	417cee <_realloc_r+0x9a>
  417eee:	4629      	mov	r1, r5
  417ef0:	4630      	mov	r0, r6
  417ef2:	461c      	mov	r4, r3
  417ef4:	46d1      	mov	r9, sl
  417ef6:	f7fc fa37 	bl	414368 <memmove>
  417efa:	e70b      	b.n	417d14 <_realloc_r+0xc0>
  417efc:	68ab      	ldr	r3, [r5, #8]
  417efe:	6083      	str	r3, [r0, #8]
  417f00:	68eb      	ldr	r3, [r5, #12]
  417f02:	60c3      	str	r3, [r0, #12]
  417f04:	2a24      	cmp	r2, #36	; 0x24
  417f06:	d017      	beq.n	417f38 <_realloc_r+0x2e4>
  417f08:	f100 0310 	add.w	r3, r0, #16
  417f0c:	f105 0210 	add.w	r2, r5, #16
  417f10:	e6e7      	b.n	417ce2 <_realloc_r+0x8e>
  417f12:	f850 3c04 	ldr.w	r3, [r0, #-4]
  417f16:	f023 0303 	bic.w	r3, r3, #3
  417f1a:	441c      	add	r4, r3
  417f1c:	462e      	mov	r6, r5
  417f1e:	e6f9      	b.n	417d14 <_realloc_r+0xc0>
  417f20:	68a9      	ldr	r1, [r5, #8]
  417f22:	f8ca 1010 	str.w	r1, [sl, #16]
  417f26:	68e9      	ldr	r1, [r5, #12]
  417f28:	f8ca 1014 	str.w	r1, [sl, #20]
  417f2c:	2a24      	cmp	r2, #36	; 0x24
  417f2e:	d00c      	beq.n	417f4a <_realloc_r+0x2f6>
  417f30:	3510      	adds	r5, #16
  417f32:	f10a 0218 	add.w	r2, sl, #24
  417f36:	e7b9      	b.n	417eac <_realloc_r+0x258>
  417f38:	692b      	ldr	r3, [r5, #16]
  417f3a:	6103      	str	r3, [r0, #16]
  417f3c:	696b      	ldr	r3, [r5, #20]
  417f3e:	6143      	str	r3, [r0, #20]
  417f40:	f105 0218 	add.w	r2, r5, #24
  417f44:	f100 0318 	add.w	r3, r0, #24
  417f48:	e6cb      	b.n	417ce2 <_realloc_r+0x8e>
  417f4a:	692a      	ldr	r2, [r5, #16]
  417f4c:	f8ca 2018 	str.w	r2, [sl, #24]
  417f50:	696a      	ldr	r2, [r5, #20]
  417f52:	f8ca 201c 	str.w	r2, [sl, #28]
  417f56:	3518      	adds	r5, #24
  417f58:	f10a 0220 	add.w	r2, sl, #32
  417f5c:	e7a6      	b.n	417eac <_realloc_r+0x258>
  417f5e:	4632      	mov	r2, r6
  417f60:	e77f      	b.n	417e62 <_realloc_r+0x20e>
  417f62:	4629      	mov	r1, r5
  417f64:	4630      	mov	r0, r6
  417f66:	9301      	str	r3, [sp, #4]
  417f68:	f7fc f9fe 	bl	414368 <memmove>
  417f6c:	9b01      	ldr	r3, [sp, #4]
  417f6e:	e77e      	b.n	417e6e <_realloc_r+0x21a>
  417f70:	68a9      	ldr	r1, [r5, #8]
  417f72:	f8ca 1010 	str.w	r1, [sl, #16]
  417f76:	68e9      	ldr	r1, [r5, #12]
  417f78:	f8ca 1014 	str.w	r1, [sl, #20]
  417f7c:	2a24      	cmp	r2, #36	; 0x24
  417f7e:	d003      	beq.n	417f88 <_realloc_r+0x334>
  417f80:	3510      	adds	r5, #16
  417f82:	f10a 0218 	add.w	r2, sl, #24
  417f86:	e76c      	b.n	417e62 <_realloc_r+0x20e>
  417f88:	692a      	ldr	r2, [r5, #16]
  417f8a:	f8ca 2018 	str.w	r2, [sl, #24]
  417f8e:	696a      	ldr	r2, [r5, #20]
  417f90:	f8ca 201c 	str.w	r2, [sl, #28]
  417f94:	3518      	adds	r5, #24
  417f96:	f10a 0220 	add.w	r2, sl, #32
  417f9a:	e762      	b.n	417e62 <_realloc_r+0x20e>
  417f9c:	2000078c 	.word	0x2000078c

00417fa0 <__ascii_wctomb>:
  417fa0:	b121      	cbz	r1, 417fac <__ascii_wctomb+0xc>
  417fa2:	2aff      	cmp	r2, #255	; 0xff
  417fa4:	d804      	bhi.n	417fb0 <__ascii_wctomb+0x10>
  417fa6:	700a      	strb	r2, [r1, #0]
  417fa8:	2001      	movs	r0, #1
  417faa:	4770      	bx	lr
  417fac:	4608      	mov	r0, r1
  417fae:	4770      	bx	lr
  417fb0:	238a      	movs	r3, #138	; 0x8a
  417fb2:	6003      	str	r3, [r0, #0]
  417fb4:	f04f 30ff 	mov.w	r0, #4294967295
  417fb8:	4770      	bx	lr
  417fba:	bf00      	nop

00417fbc <__gedf2>:
  417fbc:	f04f 3cff 	mov.w	ip, #4294967295
  417fc0:	e006      	b.n	417fd0 <__cmpdf2+0x4>
  417fc2:	bf00      	nop

00417fc4 <__ledf2>:
  417fc4:	f04f 0c01 	mov.w	ip, #1
  417fc8:	e002      	b.n	417fd0 <__cmpdf2+0x4>
  417fca:	bf00      	nop

00417fcc <__cmpdf2>:
  417fcc:	f04f 0c01 	mov.w	ip, #1
  417fd0:	f84d cd04 	str.w	ip, [sp, #-4]!
  417fd4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  417fd8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  417fdc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  417fe0:	bf18      	it	ne
  417fe2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  417fe6:	d01b      	beq.n	418020 <__cmpdf2+0x54>
  417fe8:	b001      	add	sp, #4
  417fea:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  417fee:	bf0c      	ite	eq
  417ff0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  417ff4:	ea91 0f03 	teqne	r1, r3
  417ff8:	bf02      	ittt	eq
  417ffa:	ea90 0f02 	teqeq	r0, r2
  417ffe:	2000      	moveq	r0, #0
  418000:	4770      	bxeq	lr
  418002:	f110 0f00 	cmn.w	r0, #0
  418006:	ea91 0f03 	teq	r1, r3
  41800a:	bf58      	it	pl
  41800c:	4299      	cmppl	r1, r3
  41800e:	bf08      	it	eq
  418010:	4290      	cmpeq	r0, r2
  418012:	bf2c      	ite	cs
  418014:	17d8      	asrcs	r0, r3, #31
  418016:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  41801a:	f040 0001 	orr.w	r0, r0, #1
  41801e:	4770      	bx	lr
  418020:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  418024:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  418028:	d102      	bne.n	418030 <__cmpdf2+0x64>
  41802a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  41802e:	d107      	bne.n	418040 <__cmpdf2+0x74>
  418030:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  418034:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  418038:	d1d6      	bne.n	417fe8 <__cmpdf2+0x1c>
  41803a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  41803e:	d0d3      	beq.n	417fe8 <__cmpdf2+0x1c>
  418040:	f85d 0b04 	ldr.w	r0, [sp], #4
  418044:	4770      	bx	lr
  418046:	bf00      	nop

00418048 <__aeabi_cdrcmple>:
  418048:	4684      	mov	ip, r0
  41804a:	4610      	mov	r0, r2
  41804c:	4662      	mov	r2, ip
  41804e:	468c      	mov	ip, r1
  418050:	4619      	mov	r1, r3
  418052:	4663      	mov	r3, ip
  418054:	e000      	b.n	418058 <__aeabi_cdcmpeq>
  418056:	bf00      	nop

00418058 <__aeabi_cdcmpeq>:
  418058:	b501      	push	{r0, lr}
  41805a:	f7ff ffb7 	bl	417fcc <__cmpdf2>
  41805e:	2800      	cmp	r0, #0
  418060:	bf48      	it	mi
  418062:	f110 0f00 	cmnmi.w	r0, #0
  418066:	bd01      	pop	{r0, pc}

00418068 <__aeabi_dcmpeq>:
  418068:	f84d ed08 	str.w	lr, [sp, #-8]!
  41806c:	f7ff fff4 	bl	418058 <__aeabi_cdcmpeq>
  418070:	bf0c      	ite	eq
  418072:	2001      	moveq	r0, #1
  418074:	2000      	movne	r0, #0
  418076:	f85d fb08 	ldr.w	pc, [sp], #8
  41807a:	bf00      	nop

0041807c <__aeabi_dcmplt>:
  41807c:	f84d ed08 	str.w	lr, [sp, #-8]!
  418080:	f7ff ffea 	bl	418058 <__aeabi_cdcmpeq>
  418084:	bf34      	ite	cc
  418086:	2001      	movcc	r0, #1
  418088:	2000      	movcs	r0, #0
  41808a:	f85d fb08 	ldr.w	pc, [sp], #8
  41808e:	bf00      	nop

00418090 <__aeabi_dcmple>:
  418090:	f84d ed08 	str.w	lr, [sp, #-8]!
  418094:	f7ff ffe0 	bl	418058 <__aeabi_cdcmpeq>
  418098:	bf94      	ite	ls
  41809a:	2001      	movls	r0, #1
  41809c:	2000      	movhi	r0, #0
  41809e:	f85d fb08 	ldr.w	pc, [sp], #8
  4180a2:	bf00      	nop

004180a4 <__aeabi_dcmpge>:
  4180a4:	f84d ed08 	str.w	lr, [sp, #-8]!
  4180a8:	f7ff ffce 	bl	418048 <__aeabi_cdrcmple>
  4180ac:	bf94      	ite	ls
  4180ae:	2001      	movls	r0, #1
  4180b0:	2000      	movhi	r0, #0
  4180b2:	f85d fb08 	ldr.w	pc, [sp], #8
  4180b6:	bf00      	nop

004180b8 <__aeabi_dcmpgt>:
  4180b8:	f84d ed08 	str.w	lr, [sp, #-8]!
  4180bc:	f7ff ffc4 	bl	418048 <__aeabi_cdrcmple>
  4180c0:	bf34      	ite	cc
  4180c2:	2001      	movcc	r0, #1
  4180c4:	2000      	movcs	r0, #0
  4180c6:	f85d fb08 	ldr.w	pc, [sp], #8
  4180ca:	bf00      	nop

004180cc <__aeabi_dcmpun>:
  4180cc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  4180d0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  4180d4:	d102      	bne.n	4180dc <__aeabi_dcmpun+0x10>
  4180d6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  4180da:	d10a      	bne.n	4180f2 <__aeabi_dcmpun+0x26>
  4180dc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  4180e0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  4180e4:	d102      	bne.n	4180ec <__aeabi_dcmpun+0x20>
  4180e6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  4180ea:	d102      	bne.n	4180f2 <__aeabi_dcmpun+0x26>
  4180ec:	f04f 0000 	mov.w	r0, #0
  4180f0:	4770      	bx	lr
  4180f2:	f04f 0001 	mov.w	r0, #1
  4180f6:	4770      	bx	lr

004180f8 <__aeabi_d2iz>:
  4180f8:	ea4f 0241 	mov.w	r2, r1, lsl #1
  4180fc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  418100:	d215      	bcs.n	41812e <__aeabi_d2iz+0x36>
  418102:	d511      	bpl.n	418128 <__aeabi_d2iz+0x30>
  418104:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  418108:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  41810c:	d912      	bls.n	418134 <__aeabi_d2iz+0x3c>
  41810e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  418112:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  418116:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  41811a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  41811e:	fa23 f002 	lsr.w	r0, r3, r2
  418122:	bf18      	it	ne
  418124:	4240      	negne	r0, r0
  418126:	4770      	bx	lr
  418128:	f04f 0000 	mov.w	r0, #0
  41812c:	4770      	bx	lr
  41812e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  418132:	d105      	bne.n	418140 <__aeabi_d2iz+0x48>
  418134:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  418138:	bf08      	it	eq
  41813a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  41813e:	4770      	bx	lr
  418140:	f04f 0000 	mov.w	r0, #0
  418144:	4770      	bx	lr
  418146:	bf00      	nop
  418148:	23232323 	.word	0x23232323
  41814c:	23232323 	.word	0x23232323
  418150:	23232323 	.word	0x23232323
  418154:	23232323 	.word	0x23232323
  418158:	23232323 	.word	0x23232323
  41815c:	23232323 	.word	0x23232323
  418160:	23232323 	.word	0x23232323
  418164:	23232323 	.word	0x23232323
  418168:	00232323 	.word	0x00232323
  41816c:	20202023 	.word	0x20202023
  418170:	324d4349 	.word	0x324d4349
  418174:	38343630 	.word	0x38343630
  418178:	61786520 	.word	0x61786520
  41817c:	656c706d 	.word	0x656c706d
  418180:	20202020 	.word	0x20202020
  418184:	20202020 	.word	0x20202020
  418188:	20202020 	.word	0x20202020
  41818c:	00232020 	.word	0x00232020
  418190:	6f727245 	.word	0x6f727245
  418194:	65732072 	.word	0x65732072
  418198:	726f736e 	.word	0x726f736e
  41819c:	7465735f 	.word	0x7465735f
  4181a0:	442f7075 	.word	0x442f7075
  4181a4:	6c20504d 	.word	0x6c20504d
  4181a8:	6964616f 	.word	0x6964616f
  4181ac:	002e676e 	.word	0x002e676e
  4181b0:	6d6d6f63 	.word	0x6d6d6f63
  4181b4:	48646e61 	.word	0x48646e61
  4181b8:	6c646e61 	.word	0x6c646e61
  4181bc:	61547265 	.word	0x61547265
  4181c0:	00006b73 	.word	0x00006b73
  4181c4:	6e696c62 	.word	0x6e696c62
  4181c8:	4c72656b 	.word	0x4c72656b
  4181cc:	61546465 	.word	0x61546465
  4181d0:	00006b73 	.word	0x00006b73
  4181d4:	00007325 	.word	0x00007325
  4181d8:	00000a0d 	.word	0x00000a0d
  4181dc:	00000000 	.word	0x00000000
  4181e0:	205d455b 	.word	0x205d455b
  4181e4:	00000000 	.word	0x00000000
  4181e8:	205d575b 	.word	0x205d575b
  4181ec:	00000000 	.word	0x00000000
  4181f0:	205d495b 	.word	0x205d495b
  4181f4:	00000000 	.word	0x00000000
  4181f8:	205d565b 	.word	0x205d565b
  4181fc:	00000000 	.word	0x00000000
  418200:	205d445b 	.word	0x205d445b
  418204:	00000000 	.word	0x00000000
  418208:	004181dc 	.word	0x004181dc
  41820c:	004181e0 	.word	0x004181e0
  418210:	004181e8 	.word	0x004181e8
  418214:	004181f0 	.word	0x004181f0
  418218:	004181f8 	.word	0x004181f8
  41821c:	00418200 	.word	0x00418200

00418220 <dmp3_image>:
  418220:	00000100 00000000 00000000 00000000     ................
  418230:	00000500 00000500 01000500 ff000500     ................
  418240:	0500f7ff 05000500 05000500 05000500     ................
  418250:	00800080 00400040 00200020 00100010     ....@.@. . .....
  418260:	00080008 00040004 00020002 00010001     ................
  418270:	80008000 40004000 20002000 10001000     .....@.@. . ....
  418280:	08000800 04000400 02000200 01000100     ................
  418290:	84030000 409c0000 00000000 00000004     .......@........
  4182a0:	66666636 00000f00 f6285c13 8fc2f50c     6fff.....\(.....
	...
  4182bc:	3800f8ff e8d1ed09 00680000 c7ff0100     ...8......h.....
	...
  4182d4:	14ae4701 ec51b83e 00000f00 00000000     .G..>.Q.........
	...
  418300:	00000040 00000000 00000000 00000000     @...............
  418310:	00000040 00000000 00000000 00000000     @...............
  418320:	00000040 00000000 00010000 000c0100     @...............
	...
  418348:	55555515 aaaaaa0a 00000000 e1000000     .UUU............
  418358:	01000000 01000600 00000000 00000000     ................
  418368:	59d14800 a72eb73f 00000002 00000000     .H.Y?...........
	...
  418380:	0700178e 00000000 00000000 20030000     ............... 
  418390:	00000040 00000000 0000ff7f e9210500     @.............!.
  4183a0:	00000040 00000000 00000000 00000000     @...............
  4183b0:	30033e00 00000000 00000000 00000000     .>.0............
  4183c0:	02000000 00000000 00000000 00000000     ................
	...
  4183fc:	00000060 00000000 00000000 00000000     `...............
	...
  418428:	00000040 00000000 00000000 00000000     @...............
	...
  418444:	01000000 0a000300 ee4a2b01 11ad5406     .........+J..T..
  418454:	155c07e3 26d02b36 a4498cd0 11ad5406     ..\.6+.&..I..T..
  418464:	55b50b1e 5017ee38 033f3631 00000000     ...U8..P16?.....
	...
  418490:	01000000 00000000 01000000 00800000     ................
	...
  4184a8:	00000700 75350e00 00000000 00000000     ......5u........
  4184b8:	10000700 3c009600 00000000 00000000     .......<........
	...
  4184d0:	29aa720d 4e6c3dc9 7f4c1655 977442c4     .r.).=lNU.L..Bt.
	...
  4184f4:	00000010 00000000 08000000 00000000     ................
	...
  418510:	10000000 3d000000 00000000 00000000     .......=........
	...
  418528:	88312000 40a3e315 00000000 00000000     . 1....@........
	...
  418540:	8c4b700e be920ac5 d291965a 0de7eec1     .pK.....Z.......
	...
  41855c:	02000700 14000000 00002d00 00000000     .........-......
	...
  418590:	a3000000 02000000 3a000000 0000e803     ...........:....
	...
  4185b8:	26000000 02000000 00000000 00000000     ...&............
	...
  4185d8:	03000000 68a7c13f 00000040 00000000     ....?..h@.......
	...
  4185f8:	33333333 cdcccc0c 00ffff00 00000000     3333............
  418608:	00000000 18010000 00000000 ffffffff     ................
  418618:	00000000 00000010 00000000 00000000     ................
	...
  418630:	01000000 00000000 00000000 03000000     ................
	...
  418648:	00000010 51ed8764 00000000 00000000     ....d..Q........
  418658:	00000000 64000000 00000000 00000000     .......d........
  418668:	00000040 6af41d01 00000000 00000000     @......j........
	...
  418680:	00000200 00000800 ff7f0000 00200000     .............. .
  418690:	409c0000 cdcccc0c 80070000 00000200     ...@............
	...
  4186a8:	ec51b83e 14ae4701 5e010000 00000000     >.Q..G.....^....
  4186b8:	00000060 00000000 00800000 00000000     `...............
  4186c8:	00800000 00001000 a8610000 10000000     ..........a.....
  4186d8:	00010000 00100000 00000100 00000004     ................
  4186e8:	00004000 00000400 00000000 00200000     .@............ .
  4186f8:	e02e0000 00400600 01000000 00000000     ......@.........
	...
  418710:	00000002 00000000 00000000 00000000     ................
	...
  418728:	00000040 01000000 ffffff03 00000000     @...............
	...
  418740:	33333333 00000000 00000000 00000000     3333............
  418750:	cdcccc0c 00000000 00000000 00000000     ................
  418760:	9d000000 00000000 00000000 00000000     ................
  418770:	00000100 00000100 00000000 07000000     ................
	...
  4187a0:	01000000 00000000 00000000 00000000     ................
  4187b0:	00003200 00003200 00003200 00003200     .2...2...2...2..
	...
  418810:	00003200 00003200 00003200 00003200     .2...2...2...2..
	...
  418850:	10000000 00000000 00000000 751b4901     .............I.u
  418860:	10000000 00000000 40060000 cd0c0000     ...........@....
  418870:	00000100 00000000 00000000 00000000     ................
	...
  418890:	00500000 01000000 00160000 46000000     ..P............F
  4188a0:	00000100 00000000 00000000 00000000     ................
  4188b0:	00000100 00000000 00000000 00000000     ................
	...
  4188d0:	00008000 00008000 00008000 00008000     ................
	...
  41893c:	01000100 00000000 00000000 00000000     ................
  41894c:	c0d40100 00000000 02000000 00008000     ................
  41895c:	3c010000 00000000 00000000 00000000     ...<............
  41896c:	00000000 00000001 00000000 00000000     ................
	...
  4189c0:	28000000 983a0000 00020000 4e010000     ...(..:........N
	...
  4189ec:	00040000 00000000 00000000 00000000     ................
	...
  418a08:	14ae4701 0000404e 00000000 00000000     .G..N@..........
  418a18:	0c000000 00200000 00000000 00000000     ...... .........
	...
  418a30:	00000100 00000000 00000000 060d0000     ................
	...
  418a60:	01000000 00000000 00000010 10270000     ..............'.
  418a70:	00000000 0020404a 00000000 00000000     ....J@ .........
  418a80:	00000000 d80e0000 18010000 d0070000     ................
	...
  418aac:	10270000 00000000 00000000 00000000     ..'.............
  418abc:	1b130600 00b80b00 0fbf3c00 75ce5500     .........<...U.u
  418acc:	10270000 055bb005 faa44f3a 00000000     ..'...[.:O......
	...
  418ae8:	3c000000 3c000000 00000000 5a000000     ...<...<.......Z
  418af8:	8a201d00 69936100 3c010000 f04d0000     .. ..a.i...<..M.
  418b08:	75ce5500 76020000 66666606 99999939     .U.u...v.fff9...
  418b18:	00000010 00000030 00000000 cccccc0c     ....0...........
  418b28:	33333333 45900e00 00000000 411dd401     3333...E.......A
  418b38:	bfe22b3e bb6ff13f 00000000 00000000     >+..?.o.........
  418b48:	00879303 49922401 00000000 88130000     .....$.I........
  418b58:	80969800 003b5808 00000020 af0e0000     .....X;. .......
  418b68:	70170000 01000000 00000020 50000000     ...p.... ......P
  418b78:	00000000 01000000 00000000 00000000     ................
	...
  418b98:	00004000 00000400 0000803f 00008000     .@......?.......
  418ba8:	33333300 77fa1c00 e6396d0c a6da6fcb     .333...w.m9..o..
  418bb8:	97d3cf53 467453c4 00000000 00000000     S....StF........
	...
  418c28:	0e74da00 f28b253f 00000000 00000000     ..t.?%..........
	...
  418c40:	00000020 00000000 00000000 00000000      ...............
	...
  418c68:	01000000 4c1d0000 00000000 00000000     .......L........
  418c78:	00000038 00000008 00000000 00000000     8...............
	...
  418c90:	00000020 bfe22b3e e27a143e 00000030      ...>+..>.z.0...
	...
  418ca8:	88130000 d0070000 00000000 00000000     ................
	...
  418cc8:	88130000 84ec233c 00000020 411dd401     ....<#.. ......A
  418cd8:	1e85eb01 00000010 01000000 88130000     ................
  418ce8:	00000000 b2fc6c34 00000000 00000000     ....4l..........
	...
  418d2c:	10000000 70170000 88130000 28230000     .......p......#(
  418d3c:	26000000 2f000000 00000000 00000040     ...&.../....@...
  418d4c:	c4090000 00000000 23000000 1e85eb01     ...........#....
  418d5c:	e27a143e 00000000 2d000000 22222202     >.z........-."""
  418d6c:	dedddd3d 00000000 00000000 b8240000     =.............$.
  418d7c:	8ebad13d 00000000 00000000 00000000     =...............
	...
  418d98:	d6830000 d6830000 00000000 00000000     ................
  418da8:	0e000000 21000000 00002000 f9fc3000     .......!. ...0..
  418db8:	00000040 00800a00 00008000 00000000     @...............
	...
  418df8:	02000000 0a000000 00000000 00000000     ................
  418e08:	33333300 00000c00 00000000 00000000     .333............
  418e18:	88312000 00000700 00000000 00000000     . 1.............
  418e28:	00000000 f89adef0 00000000 00000000     ................
  418e38:	00000000 83b2900f 00000000 00000000     ................
  418e48:	00000000 00000008 00000000 00000000     ................
  418e58:	00000000 d58c21f7 00000000 00000000     .....!..........
  418e68:	00000000 95396f0c 00000000 00000000     .....o9.........
	...
  418e90:	00000040 00000000 00000000 00000000     @...............
  418ea0:	00000040 00000000 00000000 00000000     @...............
  418eb0:	00000040 00000000 00000000 00000000     @...............
	...
  418efc:	00080000 00445300 00445300 00009a01     .....SD..SD.....
  418f0c:	00009a01 46050000 46050000 15000000     .......F...F....
  418f1c:	19000000 58020000 58020000 12000000     .......X...X....
  418f2c:	03000000 32000000 96000000 2c010000     .......2.......,
  418f3c:	96000000 a450cf00 a450cf00 a4d03501     ......P...P..5..
  418f4c:	a4d03501 00000000 00000000 00800200     .5..............
  418f5c:	00800100 00800c00 00800c00 00000000     ................
  418f6c:	00800000 00800c00 00000000 00000000     ................
	...
  418f9c:	00000004 00000040 00000000 00000000     ....@...........
  418fac:	00000000 50ab7b01 48b62d01 ac160000     .....{.P.-.H....
  418fbc:	60822200 8b110000 b0cc4c04 14000000     .".`.....L......
  418fcc:	81160000 e0fe7802 b03a9403 90b41000     .....x....:.....
  418fdc:	2a030000 f6250000 00000000 00000000     ...*..%.........
  418fec:	00100020 89df5208 06958c05 41256301      ....R.......c%A
  418ffc:	00000060 00000000 00000000 00000000     `...............
  41900c:	00000000 69477b00 aedbe502 7885f106     .....{Gi.......x
  41901c:	88abdf07 00000000 00000000 00000000     ................
	...
  419098:	0a000000 00000000 00000000 00000002     ................
  4190a8:	4cfe0000 00000000 00000000 00000000     ...L............
  4190b8:	03000000 66666608 00000000 00000000     .....fff........
  4190c8:	9a999903 66666600 f4010000 01000000     .....fff........
  4190d8:	0a000000 1e000000 00000002 00000000     ................
  4190e8:	66666606 5ed40400 00000000 04000000     .fff...^........
  4190f8:	28000000 1e000000 00000000 00000000     ...(............
  419108:	66666600 00000000 02000000 00000000     .fff............
  419118:	96000000 00000000 00000000 f8ffffff     ................
	...
  419190:	b0b8dcd8 f8aaf3b4 88d9d1f9 3ef7f89a     ...............>
  4191a0:	9a8af3d8 d9d131a7 d83610f4 f9399ff3     .....1....6...9.
  4191b0:	10f4d9d1 8ff3d836 6097089f d9d1218a     ....6......`.!..
  4191c0:	da3610f4 f1d8fff1 bcbcbebe b2babdbd     ..6.............
  4191d0:	9080a0b6 bebe1832 bdbdbcbc a4b4b0b8     ....2...........
  4191e0:	f3dea5df dfd0dea8 249f84a4 f9f8a9f2     ...........$....
  4191f0:	a8dedad1 dfdfdfde 8db1f4d8 b0d0a8f3     ................
  419200:	b9f48fb4 bec7d0af d0aeb8be b2759ff3     ..............u.
  419210:	bebef486 c3d0afb9 b0b8bef1 dfdfdea3     ................
  419220:	81a3f2df c7cd80c0 b4bdbccf 938da3f1     ................
  419230:	883ffd20 8d7e766e 20a2be93 2ca031fd      .?.nv~.... .1.,
  419240:	fd3432fd 32fd3c32 8dacb9be bebeb820     .24.2<.2.... ...
  419250:	9d86a2bc bc0ffd08 82a3bcbc 83a90193     ................
  419260:	1e160e9e bcbebebe 2c998ba5 bcbc7c54     ...........,T|..
  419270:	a5ba9385 b87d552d fd2c9da5 37fd4c37     ....-U}...,.7L.7
  419280:	f537fd6c 349f85a5 bdbd7454 bab6b1bd     l.7....4Tt......
  419290:	f1a59583 b21e160e 2a9585a7 877850f0     ...........*.Px.
  4192a0:	da01f193 dfdfdfa5 dfdfa4d8 f280b0df     ................
  4192b0:	c5cbc3a4 948eb1f1 1e160ea4 a0be86b2     ................
  4192c0:	bd3c342c b896b4bd 3c342ca1 94b6bdbd     ,4<......,4<....
  4192d0:	fd2ca6be 35fd3435 bc35fd3c b8948eb2     ..,.54.5<.5.....
  4192e0:	2da6bebe a4ba7d55 b87d552d 8fa6b4b0     ...-U}..-U}.....
  4192f0:	3e362e96 bdbcbcbc f59f86a6 bc745434     ..6>........4Tt.
  419300:	fc90f1be f4d900c3 f3d8df11 bcf1dfa0     ................
  419310:	2da99186 bcbc7d55 9080a9bc 100051fc     ...-U}.......Q..
  419320:	100051fc 100051fc d904c1fc f4dfa0f2     .Q...Q..........
  419330:	f6d8df11 9080faa0 dadef338 df11f4f8     ........8.......
  419340:	95bdf1d8 d904c1fc f4bdbdbd f6d8df11     ................
  419350:	bdbcbcbc bebebebd 9284a7b5 d1f9f81a     ................
  419360:	f79384db 9687b66a daff09f3 d8bebdbc     ....j...........
  419370:	bcbcbcf1 b482b0f6 02a9b897 bcf102f7     ................
  419380:	04a79989 dfa837fd fca79887 f850003d     .....7......=.P.
  419390:	a8d9d1f9 f6d8f9df bdbcbcbc bebebdbd     ................
  4193a0:	81a7b7be 87b40b9a f9f81a9f aa81bbd1     ................
  4193b0:	12f4d9c1 b8f6d847 d9f91aa7 d84712f4     ....G.........G.
  4193c0:	aabbf38a aab3c3c0 fd1a9d8a 089ab71e     ................
  4193d0:	a5b4b0b8 d8009d85 a9b2b9f3 c4f2cd80     ................
  4193e0:	a0f3bac5 b4b1ded0 9189a7f7 47918972     ............r..G
  4193f0:	b94a97b6 fad0a9f2 f4d9d1f9 f3d87512     ..J..........u..
  419400:	dbf9a7ba b9f1d9fb c3a981b0 baf3c5f2     ................
  419410:	d8f8d0a0 a789b1f1 f2dfdfdf c5cbc3a7     ................
  419420:	b887b2f1 abbebebe bec7c5c2 a597b9b5     ................
  419430:	7048f022 6840983c 60995834 8eb3bcf1     ".Hp<.@h4X.`....
  419440:	4d25aa95 bcbcbc75 a7b4b0b8 5af79f88     ..%Mu..........Z
  419450:	a8f3daf9 d09d88f8 a7f7d87c f9529f88     ........|.....R.
  419460:	88a8f3da 60dfd09c 9d787068 78706860     .......`hpx.`hpx
  419470:	9f78709e a7f7d870 f9429f88 f3d0a0ba     .px.p.....B.....
  419480:	f8d8ded9 dab8d1f9 d09e88a8 609f6864     ............dh.`
  419490:	9884a8d8 f17ef7d0 85bab6b2 75f4a791     ......~........u
  4194a0:	c075f4a8 a79184f1 f0a875f4 200d87a2     ..u......u..... 
  4194b0:	38157059 f1a46940 3119f062 b4b1b848     Yp.8@i..b..1H...
  4194c0:	c680a6f1 f381b0f4 8fb1c6a7 f902f797     ................
  4194d0:	7f13f4da a7f7b0d8 f9529f88 7813f4d9     ..........R....x
  4194e0:	b6b2f1d8 2a9282a6 08fd50f0 9484a7f1     .......*.P......
  4194f0:	b008fd02 009786b4 81a7bab1 13f4d961     ............a...
  419500:	41f1d897 9713f4da b2b8f1d8 d8c082a6     ...A............
  419510:	86b6b0f1 fd16a792 04fd0f04 a79187ba     ................
  419520:	b2b675f4 d8c075f4 bebebef1 b2bdbdbd     .u...u..........
  419530:	c3a784ba bcb2c7c5 87b6bcbc 75f4af91     ...............u
  419540:	f18fa0a8 5920f00b 40381570 31196469     ...... Yp.8@id.1
  419550:	9080f148 04fd6eaf 8f04fd67 75f4a791     H....n..g......u
  419560:	c075f4b6 bdbcbef1 b4b0bef7 a39e88ba     ..u.............
  419570:	f0669f6a 8ab9b5b1 502ca29a 8ab9b278     j.f.......,Px...
  419580:	c5c3c0af d0ad89c7 a183c7c4 bcbac5c2     ................
  419590:	81b2bcbc c5c3c0a2 bdbcbcc7 f39c74f4     .............t..
  4195a0:	f9faa3ba 14f4d9d1 ad74d833 babebebe     ........3.t.....
  4195b0:	d0a382b1 8dd0a9c7 81a3c7c4 a6f3c3c1     ................
  4195c0:	d8bec28d bebebef1 8faab1ba c7c5c3c0     ................
  4195d0:	bcbcbcbe af88b9b2 c7c5c3c0 c0d0ad80     ................
  4195e0:	c0a189c3 a281bac3 c7c5c3c0 9c74f4bc     ..............t.
  4195f0:	f8a3baf3 f4d9d1f9 74d88414 bebebead     ...........t....
  419600:	a782b1b8 a0bac7d0 a9c7c48d f3c3c081     ................
  419610:	bec28da5 bebef1d8 a8b1babe c5c3c08f     ................
  419620:	baf3bec7 83a3b6b2 d9f90893 d80215f4     ................
  419630:	a3b0b8f0 28049485 b4f17850 d9699384     .......(Px....i.
  419640:	948da5b6 3c342c20 dfdea4b4 cc14f4f8     .... ,4<........
  419650:	f8a4f1d8 419484a3 f8dfa4d9 fc94f1d8     .......A........
  419660:	a4d904c1 c086a3fb 069e82b1 81a61efd     ................
  419670:	f0934296 f1a3b068 f5019683 a6009383     .B..h...........
  419680:	34f09686 a1f11883 81a3688d 8b19db9b     ...4.....h......
  419690:	f1d8c6a1 bcbebebe bdbdbcbc b8f7d8bd     ................
  4196a0:	9da7b0b4 bcf97288 f4d9bebd f2d8a117     .....r..........
  4196b0:	f9f8adb8 badedad1 deaedea1 81b2d8f8     ................
  4196c0:	afb9bebe bcbcc1d0 b4b1bdbd 928cacf1     ................
  4196d0:	afb5180a db419d8c ad8e119c babebec0     ......A.........
  4196e0:	c7c5c3ae c7c6a88d dea6c7c7 a5dfdfdf     ................
  4196f0:	bedfded0 acb9d8be 9c8dafdf c58cd911     ................
  419700:	afd8c1da 9ff5218f 9c8cf100 ac8fd945     .....!......E...
  419710:	aff2d8c1 dff8f8df aff8f8f8 d1599f8f     ..............Y.
  419720:	9c8cf1db af8ff231 afd8c3d0 d1399f8f     ....1.........9.
  419730:	9c8cf1db af8ff269 8fd8c5d0 a1babebe     ....i...........
  419740:	bdbcbcc6 b5b1f2bd daf9aeb9 d87417f4     ..............t.
  419750:	f1c28ef2 f59a80b2 f4d924af f5d87417     .........$...t..
  419760:	17f4d944 64f5d874 7417f4d9 b6b1f1d8     D...t..d...t....
  419770:	2daf908b 8cb57d55 160ead9f ab9d8b1e     ...-U}..........
  419780:	8d7c542c 562eaa9f aa9c8a7e 9b7c542c     ,T|....V~...,T|.
  419790:	664626ac 009d8daf 11db0d9c 16f4198f     .&Ff............
  4197a0:	7417d814 81b2f1d8 2daf90b6 8fb17d55     ...t.......-U}..
  4197b0:	f5af9fb5 f17c542c ad9f8cb2 7971db6d     ....,T|.....m.qy
  4197c0:	d84216f4 dea1baf3 a180f1f8 f4c7c5c3     ..B.............
  4197d0:	f3d85116 fc91bab6 a1da28c0 17f4d9f8     .Q.......(......
  4197e0:	b9f3d874 d1f9f8ae 17f4f8d9 baf1d874     t...........t...
  4197f0:	8ba0b5b1 7e5e3e93 c5c083ab 87a3b6b2     .....>^~........
  419800:	c7c5c3c0 c3c088a2 86a4c7c5 c7c5c3c0     ................
  419810:	c7c485a5 bec08dac bdbcbcbe b5b1b9bd     ................
  419820:	afded0ad d9419c8c d8c016f4 d1f9f8f1     ......A.........
  419830:	d916f4d9 8daff1d8 8cda319c d8c3d9c5     .........1......
  419840:	f5218faf adf1009f 9f82b0d0 d916f402     ..!.............
  419850:	8daff1d8 8cd9319c d8c3dac5 f5218faf     .....1........!.
  419860:	adf1009f 9f83b0d0 b1f1d802 bec1ad8c     ................
  419870:	babdbdbe 9c8dacb6 b2bcbc40 f8f8dea0     ........@.......
  419880:	fdf8f8f8 88aff50f 542c0098 80aff17c     ..........,T|...
  419890:	09db019f 17f41911 a1f2d813 dad1f9f8     ................
  4198a0:	d8deacf1 f8deaef3 d88e1af4 c083a7f1     ................
  4198b0:	a8c7c5c3 c5c3c082 c084a6c7 a5c7c5c3     ................
  4198c0:	c3c0d085 39af9d8d 7417f4d9 b583f1d8     .......9...t....
  4198d0:	fd34ae9e 0afd540a f20afd74 f8f8dea1     ..4..T..t.......
  4198e0:	bebef1f8 bdbdbcbc 8cb5b1b9 9cafc0ad     ................
  4198f0:	c0aed911 8eb2bcbc bcc7c5c3 bebed8bc     ................
  419900:	bdbdbcbc b2baf2d8 9781afb5 a7b9d101     ................
  419910:	17f4dac0 baf2d88c d1f9f8ae bebef3da     ................
  419920:	bcbcbcbe b8bdbdbd 85a5b4b0 bcbe089c     ................
  419930:	bcf7d8bd bdbdbcbc b0b4bbbd 62889eaf     ...............b
  419940:	d9bdbcf9 d8e719f4 bcbcbcf1 b5ba85b1     ................
  419950:	260698a0 b3b9bc46 81aff1b6 7d552d90     ...&F........-U}
  419960:	8fafb5b1 542cf59f afbbf17c db699f86     ......,T|.....i.
  419970:	f3da7971 f1f8dfa0 f8f2dea1 f1b7b3d8     qy..............
  419980:	19af9b8c f3deacd9 d8f8dfa0 699080af     ...............i
  419990:	f1faa0d9 c3a180b2 a0f2c7c5 f4f8dfd0     ................
  4199a0:	f2d8d119 f1dfd0a0 b1bcbcbc 269e8aad     ...............&
  4199b0:	b3bc6646 f8dea2f3 d8171af4 c18daaf1     Ff..............
  4199c0:	f9f8a1f2 18f4dad1 aff1d85c 8f219a8a     ........\.....!.
  4199d0:	da10f590 d85c18f4 c0fc91f1 18f4d904     ......\.........
  4199e0:	a1f3d8a3 dfa0f8de d119f4f8 c0fc91f3     ................
  4199f0:	18f4d907 aff1d8a3 019c84b1 9780b5b3     ................
  419a00:	b921f3db f4f8d9a7 f3d8a318 f8dea7b9     ..!.............
  419a10:	87a3f1bb c7c5c3c0 c3c088a4 89a5c7c5     ................
  419a20:	c7c5c3c0 c7c486a6 c5c382a1 dea1f3c7     ................
  419a30:	d8e719f4 b7b3bbf1 d1f9f8a1 d0a0f2da     ................
  419a40:	f1d8f8df a8b6b1b9 552d9087 a8b5f57d     ..........-U}...
  419a50:	542c9888 86aff17c 31db2998 e719f439     ..,T|....).19...
  419a60:	b6b3f1d8 4c908aa7 a0ba5c54 552d9081     .......LT\....-U
  419a70:	a2f2bb7d dad1f9f8 e719f4de b0baf1d8     }...............
  419a80:	c7c08fab c083a3b3 a2c7c5c3 c5c3c084     ................
  419a90:	c085a4c7 a5c7c5c3 acc3c086 aef3c28c     ................
  419aa0:	f4f8f8de f1d88e1a 83a3bbb2 c7c5c3c0     ................
  419ab0:	c3c082a4 84a5c7c5 c7c5c3c0 c3c085a6     ................
  419ac0:	b3c48cac 9585afb7 860ffd56 0ffd0696     ........V.......
  419ad0:	af9f84f0 0ffd704c 2e9686f1 9f840ffd     ....Lp..........
  419ae0:	df0ffd72 7c542caf db698caf 9c8b7971     r....,T|..i.qy..
  419af0:	6719f461 d8e719da 9183abf1 5405fd28     a..g........(..T
  419b00:	fd7c05fd bdbdb805 8ba3b5bd 552d0595     ..|...........-U
  419b10:	adbbb4bd 160e938e a2f3b71e f4f8f8de     ................
  419b20:	f2d8171a d1f9f8a1 8daff1d9 8ff5019a     ................
  419b30:	f400db90 f1dae719 aec08daa c5c3c18b     ................
  419b40:	83a7dea1 c7c5c3c0 c3c084a8 85a9c7c5     ................
  419b50:	c7c5c3c0 c0d086a6 c381a2c3 19f4c7c5     ................
  419b60:	b3bbf1e7 dfdfdea3 c48ca4df a5c5c5c5     ................
  419b70:	dfdfdfde d8dfdea6 dfaeb9f3 bbdeaeba     ................
  419b80:	bcbedea2 afb7bdb3 d1019c8e aed9c0ac     ................
  419b90:	b1f1d8de d0a7b983 deaeb8c4 bbbebebe     ................
  419ba0:	b3bcbcbc d8bdbdbd f9f8a2f3 1af4d9d1     ................
  419bb0:	adf5d88c 542c9d8d 49aff17c d9c5c3da     ......,T|..I....
  419bc0:	afd8c3c5 dad0699f c38fd9c7 d8c7af8d     .....i..........
  419bd0:	9f8fa9b9 f17854f0 b1a60ffd afb3c289     .....Tx.........
  419be0:	fd2e9f8f a9b5b111 f32c9f89 f8f8dfae     ..........,.....
  419bf0:	d8431cf4 9986adf1 df10fd06 ad0ffdf8     ..C.............
  419c00:	bb4c9d8d 9d8fadb3 b70ffd2a 04c0fc92     ..L.....*.......
  419c10:	2b18f4d9 08c0fcd8 9219f4d9 f3d8f1d8     ...+............
  419c20:	aeb6b2ba d9d1f9f8 d8411cf4 f9deaff1     ..........A.....
  419c30:	90800ffd a07c542c 7850f02a a2f10ffd     ....,T|.*.Px....
  419c40:	24009c82 8fa96444 fd04f094 fd300c0f     ...$Dd........0.
  419c50:	20951c0f f10ffd48 542cc199 9982aa7c     ... H.....,T|...
  419c60:	2e0ffd02 fd560ffd 0ffd7e0f f09f83ac     ......V..~......
  419c70:	78502804 908c0ffd 8cf521f1 aff12c9c     .(Px.....!...,..
  419c80:	af89f1de 00c0fc9f c18ac1d9 fcd8c182     ................
  419c90:	c3d904c0 c382c38a 08c0fcd8 c58ac5d9     ................
  419ca0:	fcd8c582 c7d90cc0 c782c78a 10c0fcd8     ................
  419cb0:	fb1bf4d9 ab8bf1d8 2e9fc0d0 dea00ffd     ................
  419cc0:	6590d0ab 4a9f8fa0 8bab0ffd a9b90090     ...e...J........
  419cd0:	dfaef3c1 431cf4f8 b1baf1d8 c1ab89b6     .......C........
  419ce0:	8bd0afb2 0ffd3e9f 9f0ffd5a d900c0fc     .....>..Z.......
  419cf0:	c6a28ff1 04c0fcd8 c7a28fd9 c0d0ab84     ................
  419d00:	1e9b8aaf fd360ffd 308fa40f d8409aaa     ......6....0..@.
  419d10:	08c0fc9f d0a28fd9 d0ab84c6 9b8aafc2     ................
  419d20:	560ffd1e 8fa40ffd 409aaa34 c4d0ab84     ...V....4..@....
  419d30:	3e9b8aaf fd560ffd 8fd0a40f 4c9aaa30     ...>..V.....0..L
  419d40:	c0fc9fd8 a28fd90c ab84c7d0 8aafc6d0     ................
  419d50:	0ffd1e9b a40ffd76 aa348fd0 ab85409a     ....v.....4..@..
  419d60:	8aafc0d0 0ffd3e9b a50ffd76 9aaa308f     .....>..v....0..
  419d70:	d0ab854c 9b8aafc2 760ffd5e 8fa50ffd     L.......^..v....
  419d80:	9ad0aa34 f8afd850 f1f11af4 af9c8bd8     4...P...........
  419d90:	8a0ffd2a 02afb99f fd260ffd 0ffd460f     *.........&..F..
  419da0:	830ffd66 a3ba9fb5 7c542c00 a09282b6     f........,T|....
  419db0:	c3add931 d8c5adda da39a08d d8c7ad82     1.........9.....
  419dc0:	c0fc9ef3 17f4d904 c0fcd81b 19f4d908     ................
  419dd0:	d8f1d816 b5b1b9f1 89f8dea9 d931af99     ..............1.
  419de0:	d8971cf4 29af85f1 c2a984d9 49af85d8     .......).......I
  419df0:	c4a984d9 69af85d8 c6a984d9 39af89d8     .......i.......9
  419e00:	50a98eda d8971cf4 7caa89f1 689a02fd     ...P.......|...h
  419e10:	fbaaf1d8 af9989da 8f0ffd26 9f892595     ........&....%..
  419e20:	0ffd12a9 d8801cf4 c1fc9ef3 1bf4d904     ................
  419e30:	c1fcd848 1af4d908 bef1d863 bdbcbcbc     H.......c.......
  419e40:	b0b4b8f3 f9c0a88f f59784ac f9f8f11a     ................
  419e50:	dea8dad1 c1fc95d8 dea8d903 f1bcbcd8     ................
  419e60:	1cc0fc98 c0fc95db a4dea503 88acd8de     ................
  419e70:	d9d10095 a4d8f8a5 880480fc 08fca495     ................
  419e80:	bcf72004 b5bdbdbc f69f84ac d1f9f802     . ..............
  419e90:	f79384db f3d9f96a 88a8bcbc bcbc1892     ....j...........
  419ea0:	b4bcbcd8 089e88a8 a1bebef4 f7bcbcd0     ................
  419eb0:	acb5bebe f96a9384 d9b4bdbd 978cacf2     ......j.........
  419ec0:	9c84f618 dbf9f802 dfa5f1d1 bebef7d8     ................
  419ed0:	9da7bdbd d9f97a88 d8e11ef4 acbebef1     .....z..........
  419ee0:	88acdfde 565af79f bdbcbcf1 c0fc95bd     ......ZV........
  419ef0:	1ef4da07 fcf1d87c 9cdb00c0 f400c1fc     ....|...........
  419f00:	f1d8a11e c0fc95ac 1df4da08 82f1d8be     ................
  419f10:	552d7990 049c8cf5 f1542cac 80bcbcbc     .y-U.....,T.....
  419f20:	5149db5d 9c1dbcf4 781ebcda 9886f5d8     ].IQ.......x....
  419f30:	82f1d938 acd82d90 f59886d0 82f1d95c     8....-......\...
  419f40:	acd85590 00009c8c f4f8dfa5 f1d8c91d     .U..............
  419f50:	552d9682 349c8c7d 95acf118 f4d91cf5     ..-U}..4........
  419f60:	f1d8781e 459083ac acf8a0d9 d2069c8c     .x.....E........
  419f70:	2c0091a1 a1f0d681 289c8cd0 a7d487d3     ...,.......(....
  419f80:	f1d3208c 2c9084a4 acd87c54 d9459083     . .....,T|....E.
  419f90:	d8a11ef4 9181acf1 8514fd02 881dfd66     ............f...
  419fa0:	871bfd4e ad54fdd4 81f04e8d fdd6ab9c     N.....T..N......
  419fb0:	8c318d06 01011010 8bac3901 d908f598     ..1......9......
  419fc0:	d8781ef4 9682a9f1 c1fc9501 1ef4da00     ..x.............
  419fd0:	acf1db50 18f59389 f8dfa5f1 7c1ef4d8     P..............|
  419fe0:	84a4f1d8 05fd3495 7405fd54 94a905fd     .....4..T..t....
  419ff0:	7c542cf5 9987acf1 5951db49 c5c3ab84     .,T|....I.QY....
  41a000:	c0a682c7 f8dfaaf3 dfa5f1d8 dea0f1d8     ................
  41a010:	dfdfdea1 dfdea7df dfdfdfa4 c0fc95a2     ................
  41a020:	c380d901 83a8c7c5 c386dac1 83a8c7c5     ................
  41a030:	9af1d8c3 d904c1fc 019682ac f8deaaf3     ................
  41a040:	f5dbf8f8 189a8cac d8f9aaf3 419a8aac     ...............A
  41a050:	c0d0aad1 85acf2d9 d1db419a bdbdbcbc     .........A......
  41a060:	1ef4bebe bcf3d8e1 bebdbdbc 9c85a5be     ................
  41a070:	b8f1d810 88a7b4b0 f97af79e 1820f4d9     ..........z... .
  41a080:	bebef1d8 f9a2bbbe 20f4beda bcf1d818     ........... ....
  41a090:	80b3bcbc d0deafc6 84b2bcdf b7bdbdbd     ................
  41a0a0:	bc60a09f 85b3bcbc 9f01af90 0ea28f46     ..`.........F...
  41a0b0:	d0af9285 a5529f29 fba03408 29af9586     ....).R..4.....)
  41a0c0:	f4dea6da f1d84c1f daf9faa0 1ff4dea6     .....L..........
  41a0d0:	a6f1d84c 19af96f8 f8dea3d9 9485f1d8     L...............
  41a0e0:	a3d931af 80f8f8de 85d8c5a0 d931af96     .1............1.
  41a0f0:	f8f8dea3 c0a580f8 a8d8c386 85dea1df     ................
  41a100:	0d0caf91 af9f8ff5 97f1542c db04c0fc     ........,T......
  41a110:	a851af8f 98d8f8df d908c0fc d8b41ff4     ..Q.............
  41a120:	0cc0fcf1 dd1ff4d9 fc93f1d8 a4d909c0     ................
  41a130:	f8dea8de c0fcd8f8 a185d904 f8dea7c1     ................
  41a140:	f61ff4d8 f8a4f1d8 31af9182 92719fdb     ...........1..q.
  41a150:	d8dea741 19af9484 f8dea8d9 dfa3f8f8     A...............
  41a160:	c0fc93d8 dea8d90a 1ff4d8f8 a4f1d8f6     ................
  41a170:	f9faa3f8 9488dbd1 a18841af fc93d8c2     .........A......
  41a180:	a8d90ac0 f1d8f8de 04c0fc91 a3faa7d9     ................
  41a190:	dfd0affa afd8f8f8 d1f9fad0 bdb4bcb0     ................
  41a1a0:	f3dabeb8 089d85a5 a7f1f1d8 9f84f7de     ................
  41a1b0:	d4f1876a d9f93efd d84820f4 88a7f7f0     j....>... H.....
  41a1c0:	d9f9529f d84820f4 f9a0bbf2 4820f4da     .R... H....... H
  41a1d0:	80b3f2d8 dc75f4c4 b5b1f0d8 a79a8aba     ......u.........
  41a1e0:	78502cf0 f8dea5f2 b2b5f1f8 219087a7     .,Px...........!
  41a1f0:	80b1b6db f2d92997 bbd8f8a5 a1beb6b2     .....)..........
  41a200:	bed1f9f8 dababebe a7d8dea5 d1659582     ..............e.
  41a210:	c1d0a285 86a7b5d9 d1db3193 d89820f4     .........1... ..
  41a220:	b4b0b8f3 189c85a5 b2baf1d8 a19681b6     ................
  41a230:	a6b9f9f8 c7c5c3da 6d4d2dd9 aa8abad8     .........-Mm....
  41a240:	aeb9f9f8 c7c5c3da 6d4d2dd9 a888bad8     .........-Mm....
  41a250:	daa7f9f8 d9c7c5c3 d86d4d2d a3b9b0f2     ........-Mm.....
  41a260:	dad1f9fa c0a78fb8 9387b5f9 b4f20af6     ................
  41a270:	249784a4 3c9e84a4 bebef3d8 f9f8aebb     ...$...<........
  41a280:	b0bebed1 a5dab8b4 d8009e85 bdbcbcf1     ................
  41a290:	a79e8ebd bcbcd159 85dabdbd d808a59e     ....Y...........
  41a2a0:	8ebcbcf1 d0aebebe bebcbcc5 b0b9f7be     ................
  41a2b0:	9588a6b5 f1daf95a b8d8f8ab fc98f3b4     ....Z...........
  41a2c0:	f4da04c0 f2d88621 89f8d0a9 d951a79b     ....!.........Q.
  41a2d0:	a4ded0a9 d82c9e84 9a88faa8 a8d929a7     ......,......)..
  41a2e0:	9d84a4df d0a8d834 a79a88f8 d0a8d951     ....4.......Q...
  41a2f0:	9d84a4de d0a8d82c a79a88fa d0a8d979     ....,.......y...
  41a300:	9d84a4df a9f3d824 9b89f8d0 a9d951a7     ....$........Q..
  41a310:	84a4ded0 f7d82c9c 529f88a7 21f4d9f9     .....,.....R...!
  41a320:	b9f1d8b6 b8f3faa2 89fad0a9 d979a79b     ..............y.
  41a330:	a4dfd0a9 d8249c84 88f8a8f2 d901a79a     ......$.........
  41a340:	84a4dea8 f7d83c9d 429f88a7 21f4d9f9     .....<.....B...!
  41a350:	a9f3d8fd a79b89f8 dea9d901 3c9c84a4     ...............<
  41a360:	89faa9d8 d929a79b 84a4dfa9 f2d8349c     ......)......4..
  41a370:	9b89faa9 a9d929a7 9e84a4df d0a9d834     .....)......4...
  41a380:	a79b89fa d0a9d979 9e84a4df a7f1d824     ....y.......$...
  41a390:	ca84f2de a524a497 f70af694 f9f80285     ......$.........
  41a3a0:	9bf6d9d1 b1a7d802 f8629582 f4d9d1f9     ..........b.....
  41a3b0:	f0d8f223 d0a485b0 c0f2ddc0 9fa7f6dc     #...............
  41a3c0:	f3d9f902 f0dadea5 dcc8f2dd a59585d8     ................
  41a3d0:	f086d900 cccaf2dd 85d8dcce f080d900     ................
  41a3e0:	c6ccf2dd ccca85ce 85d8dcce 89b1d900     ................
  41a3f0:	c2f2ddf0 d8dcc4ca d90085b0 f2ddf081     ................
  41a400:	c082cec6 85d8dcc8 86d9b100 c2f1ddf0     ................
  41a410:	d8dcc6c4 0085f2b0 f087b2d9 c4c2f1dd     ................
  41a420:	b0bcf2c6 bcdcc081 b0d8bcbc d9b10085     ................
  41a430:	f2ddf08f dcc6c4c2 0085b0d8 f08eb1d9     ................
  41a440:	c4c2f1dd b0bcf2c6 bcdcc081 b0d8bcbc     ................
  41a450:	82d90085 c2f2ddf0 d8dcc4ca f2d80085     ................
  41a460:	b1d90085 f1ddf08a dcc6c4c2 85f2b0d8     ................
  41a470:	f0b1d900 c482f1dd f3b0d8dc d1f9f8a5     ................
  41a480:	7423f4d9 9585f3d8 d90000a5 aebaf2be     ..#t............
  41a490:	bebebede f081b2bc dcc8f3dd d8bcbcbc     ................
  41a4a0:	a585b8b0 bef2d900 bedeaabe 8abcbcbe     ................
  41a4b0:	c0f3ddf0 d8bcbcdc d900a585 d0a3f2b9     ................
  41a4c0:	f085b2de dcc8f3dd b885b0d8 b3d900a5     ................
  41a4d0:	f3ddf08a b0d8dcc0 8fd90085 c4f3ddf0     ................
  41a4e0:	0085d8dc bcd90000 f08eb3bc f1c0f3dd     ................
  41a4f0:	bcbcdcc2 85b0f3d8 bcbcd900 f3ddf08e     ................
  41a500:	bcbcdcc4 8eb0f3d8 d0a7b8f4 f387d8c0     ................
  41a510:	a6c6a2b9 8eb5f7c4 f9f80696 23f4dad1     ...............#
  41a520:	8ef3d87d 86b1f9c0 df0af796 08fd30f3     }............0..
  41a530:	f01082a2 c082f3dd a3b9f2dc 8cb1f4df     ................
  41a540:	c3c1aff3 9db48faf b51efd3e 39a6309f     ........>....0.9
  41a550:	ec23f4d9 b0b8f7d8 9d84a7b4 f4d9f91a     ..#.............
  41a560:	f1d8df23 a6b5b1b9 d9619b83 d8f223f4     #.........a..#..
  41a570:	b4b0b8f6 5a9484a7 dad1f9f8 b9f1e2f0     .......Z........
  41a580:	f2d8deab afb986b1 b8c7c5c3 88a7b4b0     ................
  41a590:	f96af79c 72d8ffd9 dff1abb9 f8f362f7     ..j....r.....b..
  41a5a0:	f1dad1f9 f7d8f8de 9d7aafbb 9f769e66     ..........z.f.v.
  41a5b0:	dfa1f176 ded0a6ba f9a0f3bb b3d8ffda     v...............
  41a5c0:	d0afc480 dad1f9fa f4bcbcbc f1d8ba25     ............%...
  41a5d0:	aebebeb8 84b0ded0 c1a7beba 9db488f7     ................
  41a5e0:	bcb2f96e bdbdbcbc 24f4dabd b8f1d88f     n..........$....
  41a5f0:	aebebebe c0fc91d0 95b6db00 d904c1fc     ................
  41a600:	f8f8f8f8 fc91b4d8 b6db04c0 00c1fc95     ................
  41a610:	f8f8f8d9 f8f8f8f8 bebad8f8 d8f624f4     .............$..
  41a620:	c0fc91f1 95b6db00 f504c1fc 3aa79587     ...............:
  41a630:	afd9f9f1 bebe8fde f1c1f4a1 f1c1f4a2     ................
  41a640:	b4d8bebe 04c0fc91 fc95b6db afd900c1     ................
  41a650:	07fdf8de df10958f a7f8f8f8 07fdf8de     ................
  41a660:	06fdf8df 04fdf8df d0af978f 504840de     .............@HP
  41a670:	8f60f8df d0a0bebe a1f1c1f4 f1c5c2f4     ..`.............
  41a680:	f1c7f4a2 f1d8bebe c1a581b0 beb884bc     ................
  41a690:	f7c1a9be 9dbdb488 bdbcf96e 4325f4da     ........n.....%C
  41a6a0:	dea9f1d8 df04fdf8 bc05fdf8 d0aebe8e     ................
  41a6b0:	00c0fc9a c0fc9bdb 4099d904 c0fc9ad8     ...........@....
  41a6c0:	fc9bdb04 99d900c0 bcbcd848 bebebebc     ........H.......
  41a6d0:	d8ad25f4 c0fc9af1 fc9bdb00 89f504c0     .%..............
  41a6e0:	d9f932a9 fdf8def1 fdf8df02 fdf8df07     .2..............
  41a6f0:	89dff807 c0f4a0ba d0a18bf1 89f1c3f4     ................
  41a700:	c5c2f4a2 f4a3f1c7 d8b8f1c7 04c0fc9a     ................
  41a710:	c0fc9bdb dea9d900 df02fdf8 df07fdf8     ................
  41a720:	f807fdf8 04fdf8df a0ba89f9 8bf1c0f4     ................
  41a730:	c3f4d0a1 f4a289f1 f1c7c5c2 8af1d8b8     ................
  41a740:	bcbcc0ab bebdbdbd f1d8bebe a7ba80b2     ................
  41a750:	8bb2bcc4 8f7575f4 75f49cb6 75f4af81     .....uu....u...u
  41a760:	75f48b87 9db68e75 ae8175f4 b38775f4     ...uu....u...u..
  41a770:	7575f481 75f49485 f4a5bb81 ba808775     ..uu...u....u...
  41a780:	b37575f4 75f49b8e f4aebb81 83b38775     .uu....u....u...
  41a790:	9375f4a3 b68fb2f1 b9bebe9f 9e8e7aaf     ..u..........z..
  41a7a0:	85b3f57e 8e7c95b7 bcf17c9e b1bdbdbc     ~.....|..|......
  41a7b0:	af9f8fb5 af8258d0 86552d01 764e42af     .....X...-U..BNv
  41a7c0:	2c00a282 b6bd8454 bd51af90 9fb5bdbd     ...,T.....Q.....
  41a7d0:	48d0a406 0ad0af8f d0a47484 af93803e     ...H.....t..>...
  41a7e0:	d9abd139 d8dfdafa 83faadba db69a79b     9.............i.
  41a7f0:	9db68db2 6d26f469 deadf1d8 bcf0d8df     ....i.&m........
  41a800:	b6bd81b2 3ca6bb91 2c580c11 bcbcf150     .......<..X,P...
  41a810:	bd86b3bc 96b7bdbd 7c542ca6 a597719b     .........,T|.q..
  41a820:	50f02ad0 b8d8f178 f5f8deac 93b78cb0     .*.Px...........
  41a830:	aff9f106 ded9f8da bab6b3d8 f4c2a786     ................
  41a840:	f0939b75 84607171 8175f492 75f4a4f1     u...qq`...u....u
  41a850:	f4a38387 86b39375 75f4c4a7 71f0959b     ....u......u...q
  41a860:	92866071 a68175f4 858775f4 9375f4a5     q`...u...u....u.
  41a870:	c6a786b3 9f9b75f4 607171f0 75f49288     .....u...qq`...u
  41a880:	75f4a881 f4af8f87 b2f59375 afb99484     ...u....u.......
  41a890:	7c96867c f17c9888 9fb58fb1 188530a5     |..|..|......0..
  41a8a0:	993c9af0 bcbcf118 afb984b2 bac7c5c3     ..<.............
  41a8b0:	a7bcbcb6 2d9fb58b a7f57d55 2c97b687     .......-U}.....,
  41a8c0:	acf07c54 970c9c81 97149c28 971c9c30     T|......(...0...
  41a8d0:	8fb1f138 c7c5c3ab 9c81b2a7 aa51db59     8...........Y.Q.
  41a8e0:	6a27f4de b1acf1d8 fd489c8e 028bb202     ..'j......H.....
  41a8f0:	8ca7deaa da19db11 f1d8f8aa 9bbdbdb5     ................
  41a900:	bd03c1fc 28f4d9bd b2f1d8ea b884bcbc     .......(........
  41a910:	c5c3aebe bcbcb0c7 f0bdb4bc 6caf9e8a     ...............l
  41a920:	198a6199 6999749e 7c9e398a 598a7199     .a...t.i.9.|.q.Y
  41a930:	aa9f8ff1 5401fd28 fd7c01fd c2a98e01     ....(..T..|.....
  41a940:	8af0c7c5 2804a79a 9787f150 b58f09af     .......(P.......
  41a950:	9bbdbdbd 97bdb41e ba8b20a7 c5c3c1a7     ......... ......
  41a960:	fc90b6bd bdbd00c2 28f4d9bd b2f1d877     ...........(w...
  41a970:	a797b686 75f4994a 75f49aa1 f4aa8a81     ....J..u...u....
  41a980:	86f19375 9b52a797 9ca175f4 8c8175f4     u.....R..u...u..
  41a990:	9375f4ac a79786f1 75f49d5a 75f49ea1     ..u.....Z..u...u
  41a9a0:	f4ae8e81 89f19375 c7c5c2a9 ab8bc387     ....u...........
  41a9b0:	87c7c5c2 c2ad8dc5 c787c7c5 8adeaeb8     ................
  41a9c0:	fd649eb4 fd648c01 fd648e01 8df0b001     ..d...d...d.....
  41a9d0:	9c6caf9e 9e198d61 8d699c74 9c7c9e39     ..l.a...t.i.9.|.
  41a9e0:	f1598d71 28ad9f8f fd5401fd 01fd7c01     q.Y....(..T..|..
  41a9f0:	c5c2ac8e 9d8df0c7 502804a8 af9888f1     ..........(P....
  41aa00:	1e9b8f09 d820a898 b4b1b8f1 84bcbcbc     ...... .........
  41aa10:	c187c7af bcc183b3 af9f8fb0 28f4da49     ............I..(
  41aa20:	91f5d8a7 fc9ff17a 90db03c0 d900c0fc     ....z...........
  41aa30:	d8f8dea1 d8b728f4 f17291f5 03c0fc9f     .....(....r.....
  41aa40:	dfdea1d9 d8dfdea0 f9f8a1f1 f8daa0d1     ................
  41aa50:	80d8fad9 db11af90 fc91dea1 a1d904c1     ................
  41aa60:	dea0dff8 af9080d8 dea0d939 d8dfa1df     ........9.......
  41aa70:	bcbcbcf1 bebdbdbd f1d8bebe a6b9b5b1     ................
  41aa80:	a4bb8af8 b9c5a0c3 21af9686 3130f4d9     ...........!..01
  41aa90:	dea6f1d8 dfdfdea1 dfdfdea0 acdeabdf     ................
  41aaa0:	bb8cb3de a0c4d0a4 beb8c6d0 a983bebe     ................
  41aab0:	bcbcf2c1 c581c382 bcb0f1f8 fc9bbdbd     ................
  41aac0:	bdb403c1 8429f4d9 deaaf1d8 00c1fc99     ......).........
  41aad0:	dbfaaad9 39a99a8a d8f8deaa 9289a2f5     .......9........
  41aae0:	fc92f13a dfda03c0 82a2fad9 aadf31db     :............1..
  41aaf0:	99d8f8de d903c1fc f2d8dfaa 71a99989     ...............q
  41ab00:	f141dedb d8f8deaa 04c0fc9a 98dea8db     ..A.............
  41ab10:	f800c1fc bcb1f1d8 beb9bdb5 19af9487     ................
  41ab20:	c6a183d9 d87a2cf4 af9f82f1 03fd28df     .....,z......(..
  41ab30:	04fd30df 82349f8f dea91d38 f4daf8d9     .0....4.8.......
  41ab40:	f1d8eb2a 51af9782 c7a083d9 c2d0a783     *......Q........
  41ab50:	d81c2af4 af9282f1 2af4da59 b3f5d81c     .*......Y..*....
  41ab60:	1a99b783 d1f9f8f1 f4b5b1da f5d81c2a     ............*...
  41ab70:	f9f8f13a b5b1dad1 d81c2af4 bcbcb0f1     :........*......
  41ab80:	c1af88bc c7c589f2 bcb1f9f9 8ff2b9b5     ................
  41ab90:	d971af9f c6a083f1 a4bb8cb3 d0a0c4d0     ..q.............
  41aba0:	d8b9b1c6 c6ac83f1 c4d0a783 bcbcf1d8     ................
  41abb0:	f3c3af81 b3f2c38b c581c282 bcb1f1f9     ................
  41abc0:	af9f83bc 9e8fdb09 c7a18331 ded0dfa0     ........1.......
  41abd0:	01c2fc9f deaff2d9 8ff8f8f8 f1d941db     .............A..
  41abe0:	bb91b78e fd5cd0a2 d8b9b53f 21af938f     ......\.?......!
  41abf0:	c7a083db dfa1ded0 01c2fc9f deaff2d9     ................
  41ac00:	8ff8f8f8 f1d941db bb91b78e fd5cd0a2     .....A........\.
  41ac10:	d8b9b53f c2fc9ff1 2af4d901 bcf3d8ba     ?..........*....
  41ac20:	b1d0afbc b0f1c48c c5af8abc 9380bcb1     ................
  41ac30:	d9d139af f9f8d0f3 9ff1d1db f204c1fc     .9..............
  41ac40:	59af9f8f 83dfa0f1 f1d8c6d0 83ded0a1     ...Y............
  41ac50:	db69af90 2af46991 8ff2d8d4 f1d9719f     ..i..i.*.....q..
  41ac60:	c6d0a183 9380f1d8 d9d119af d85a2bf4     .............+Z.
  41ac70:	d9d179f1 d85a2bf4 d8bb2cf4 af9d82f1     .y...+Z..,......
  41ac80:	2bf4da31 83f1d81c b6c7d0a0 04c2fc9d     1..+............
  41ac90:	deadbad9 8ab3d8f8 afbb92b7 a488b119     ................
  41aca0:	c7a0c5d9 c3a0c1da 5a2bf4d8 f8a1f1d8     ..........+Z....
  41acb0:	f4dad1f9 f1d85a2b f9f8adba b983d9d1     ....+Z..........
  41acc0:	c6abc6a0 a4bb8db3 d0a0c4d0 5a2bf4c6     ..............+Z
  41acd0:	b983f1d8 b3c7d0a0 bb92b78a a4b119af     ................
  41ace0:	a0c389d9 c188dac5 f1d8c3a0 beba85b1     ................
  41acf0:	c784c2af b2c3c182 a7bdb6bc 928fdfdf     ................
  41ad00:	f4d901a7 f1d89c2b 2bf4d909 faf1d883     ....+......+....
  41ad10:	d8cb2bf4 f4d951f1 f1d8902b cb2bf4fa     .+...Q..+.....+.
  41ad20:	d919f1d8 fadaf8d0 cb2bf4d8 2193f1d8     ..........+....!
  41ad30:	b02bf4d9 d909f1d8 fadaf8d0 cb2bf4d8     ..+...........+.
  41ad40:	d971f1d8 2bf4f8d0 59f1d8cb f4f8d0d9     ..q....+...Y....
  41ad50:	f1d8cb2b d0d90194 d8fadaf8 bcbcb0f1     +...............
  41ad60:	b1c0a788 c1d089bc c5d0af82 bdb5bcb2     ................
  41ad70:	00c1fc9b bdbdbdb6 c3fc97db 00c0fc04     ................
  41ad80:	d904c2fc dff8dfa7 948ff1d8 f4d971a7     .............q..
  41ad90:	f1d8142c f4d94195 f1d8142c 39db0994     ,....A..,......9
  41ada0:	f8dfdfd9 fc97f1d8 bcb104c1 b983bcbc     ................
  41adb0:	a0bebebe dedac6d9 04c2fcd8 dac7d9d0     ................
  41adc0:	b58ed8df 4caf9bbd fc9fbdbd f4d900c1     .......L........
  41add0:	f0d8bb2c 9ab686b3 502cabbb aabaf178     ,.........,Px...
  41ade0:	b8c7c5c3 d1f9f8ad 8eb3deda d8c7abbb     ................
  41adf0:	9bb78eb3 d969a7ba 90b583b1 b9d1db79     ......i.....y...
  41ae00:	a1dfd0a0 f4d8c6d0 f1d8bb2c b981bcb0     ........,.......
  41ae10:	88b0c0af b1c187c1 b5bcbcbc fc9bbdbd     ................
  41ae20:	bdbd00c1 c0fc9fdb 2d9e8f04 d9319f8d     ...........-..1.
  41ae30:	a083dea1 f8deafc6 f59f83b3 fcdbf106     ................
  41ae40:	b8d904c1 f8dfa1be d8bebebe b789b3f5     ................
  41ae50:	66a9bb93 f102af8b 03c0fc9f d0a98fd9     ...f............
  41ae60:	9989d8c0 deaf34a3 9f83f5f8 c1fcf106     .....4..........
  41ae70:	7195db04 d8ded0a2 a1b98db0 b48fc7d0     ...q............
  41ae80:	d911af9f d8c7d0a1 bb89b3f1 f5f9c6af     ................
  41ae90:	0693b78f c1fc9ff1 a983db03 dea3d8c0     ................
  41aea0:	ded0a0b9 f9f8aaba 2df4dad1 b9f1d88e     ...........-....
  41aeb0:	83afb5b1 69db6190 f4699179 f1d8852d     .....a.iy.i.-...
  41aec0:	faa0f8df afd9d1f9 8cafd8df dfd96995     .............i..
  41aed0:	9c85afd8 fc9fdb31 f4da00c1 f1d8622d     ....1.......-b..
  41aee0:	c6d0a083 119e8aaf d0a0d9f8 d8489c80     ..............H.
  41aef0:	f1d8deaa 95b785b3 b5b171af ded0a0d9     .........q......
  41af00:	af83f1d8 948ff8c6 fc90db1d d0a000c0     ................
  41af10:	2df4d8de 61f1d88e ded9aad1 f1d8f8da     ...-...a........
  41af20:	a4bb88b1 d0a0c5d0 fc90b5c7 b2d900c2     ................
  41af30:	d0a4c68e deaebac5 d8bd2df4 9fb484f1     .........-......
  41af40:	da69a7ba 2df4f8ae aef1d8bd b1f1d8de     ..i....-........
  41af50:	bb9eb581 94b702af b581b326 b702a19d     ........&.......
  41af60:	918f2690 b12c00a1 12af9480 b36e5e26     .&....,.....&^n.
  41af70:	42a29280 8f3e760e 542c00a2 f8deaf7c     ...B.v>...,T|...
  41af80:	af998ff5 fc9ff106 8ad903c1 83d8c4aa     ................
  41af90:	d951af92 d84b2ef4 ded0a2f1 c0fc9eb6     ..Q...K.........
  41afa0:	c1fcdb09 aeb8d90a deaebade f4bbb7fa     ................
  41afb0:	f1d84b2e f8deaeb8 f3dfaeba bdbdbcbc     .K..............
  41afc0:	b4b0bebe dafbafbb 8dd0a4b8 e2f11d94     ................
  41afd0:	bcbcf1d8 bebebdbd d8bbb7b3 af928af1     ................
  41afe0:	2ef4d919 bcf3d88f c38bb1bc f8b3bcbc     ................
  41aff0:	f4d9d1f9 f1d87d2e d941918e d87d2ef4     .....}....A...}.
  41b000:	a39389f1 a28160c6 2ff4c7d0 a3f1d80a     .....`...../....
  41b010:	f8f8f8de f8f8f8f8 c6aa8bf8 d80a2ff4     ............./..
  41b020:	c6aa81f1 b160609a af93b581 d1b7b359     .....``.....Y...
  41b030:	0a2ff4d9 928af1d8 a3da21af d8deadf8     ../......!......
  41b040:	85c5aa81 d921af91 d8e52ef4 a2dfa1f1     ......!.........
  41b050:	9581dfdf 8968c7a5 60c6a393 deaff8ad     ......h....`....
  41b060:	9f89f5f8 c1fcf106 9d8ddb03 dea321af     .............!..
  41b070:	2ff4d8f8 81f1d80a af92c5a5 f8a3da49     .../........I...
  41b080:	af91d8f8 f8a3da49 d8f8f8f8 f9f8a3f1     ....I...........
  41b090:	83b1d9d1 c6d0a1b9 f5d8bbb3 1aaf9a83     ................
  41b0a0:	aeb8bef1 9eb589c1 bc3ffd74 348bb1bc     ........t.?....4
  41b0b0:	c0fc9fb7 bcbcbc00 d9b4bdb0 d8642ff4     ............./d.
  41b0c0:	86f8a6f1 d911ae96 be88dfa6 c4d0a9bb     ................
  41b0d0:	c6d0a1f2 bec6d0a2 f1dbbebe 01c3fc9e     ................
  41b0e0:	a1bef2d9 f8f8f8d0 f8f8d0a2 bebebef8     ................
  41b0f0:	a22ff4d8 fc9ef1d8 f5d901c3 f132ae8e     ../...........2.
  41b100:	01c0fcdb a9bbbe88 a1f2c4d0 d0a2c6d0     ................
  41b110:	bebebec6 d8a22ff4 86faa6f1 d939ae96     ...../........9.
  41b120:	be87dea6 c4d0a9bb c6d0a1f2 bec6d0a2     ................
  41b130:	f1d8bebe b3bcbcbc b7bdbdbd bbbebebe     ................
  41b140:	d1f9f8a5 c3a786da dea5c7c5 c6d0a585     ................
  41b150:	af9585d8 2ff4da71 89f1d8e2 f360a393     ....q../......`.
  41b160:	f8afbebe f3dad1f9 bef1d8e2 c3a786be     ................
  41b170:	f1d8c7c5 89f9dfaf 0d832d9f 1aaf99f5     .........-......
  41b180:	a89f7e8f f12e9912 dfafdfdf 4d9f89f9     .~.............M
  41b190:	9bf50d83 668f02af c0fc9ff1 a8f5d903     .......f........
  41b1a0:	369912d0 9888f1d8 38a710a6 deaf9f86     ...6.......8....
  41b1b0:	8708fd00 aef38f00 bcbcf1c0 bcc382b1     ................
  41b1c0:	bcf3d8bc bebdbdbc b7b3bbbe f8f2f8a2     ................
  41b1d0:	ad9d80f1 a2f27cd0 f1d1f9fa ded9acb9     .....|..........
  41b1e0:	f5d8f8da a7babebe 8e789585 bcbc7c9e     ..........x..|..
  41b1f0:	b6b2bdbd 9989a9f1 4097f062 48976c99     ........b..@.l.H
  41b200:	f1b5b1b9 289180af 83009f8c 30f4d965     .......(....e..0
  41b210:	9df1d894 af04c3fc c3d989b2 c3c1dac1     ................
  41b220:	5575f4d8 bebef2d8 bdbdbcbc a6b7b3b9     ..uU............
  41b230:	f9499281 8cb1f1db d9219cb5 b785b3f5     ..I.......!.....
  41b240:	9e8e7895 8db1f17c 1aad9db5 9d4096f0     .x..|.........@.
  41b250:	d848963c b581b1f1 0aa6b99d d905968d     <.H.............
  41b260:	d8fb30f4 b781b3f2 49afbb92 f1dbf9f9     .0.........I....
  41b270:	9cb58cb1 f421a6b9 f1d8fb30 a8bb8eb3     ......!.0.......
  41b280:	f3c7c4d0 ded0acb9 d80c31f4 bb85b3f1     .........1......
  41b290:	c7c4d0a8 d0acb9f3 f8dff8de 9cb5f3d8     ................
  41b2a0:	db04c3fc d900c2fc ded0acf2 afbbf2d8     ................
  41b2b0:	82b392b7 dfa2db19 acc4d0a1 a7f3c5d0     ................
  41b2c0:	b9f1dfd0 dfa1deaa c1fc9bb5 a7beb800     ................
  41b2d0:	bebeded0 bbf1d8be 98b789af d980a919     ................
  41b2e0:	89afd838 da80a939 f8a1d83c f9dad1f9     8...9...<.......
  41b2f0:	75f4f8df d8fff13d f5882eaf d8ffda75     ...u=.......u...
  41b300:	fff1da71 f3a782d8 c280f2c1 498697f1     q..............I
  41b310:	50d0a62e 75af8696 d0a288d9 f1c3c0f3     ...P...u........
  41b320:	a2968fda c3c2f3d0 709bb682 b7d8f170     ...........pp...
  41b330:	89f9dfaf 8010af99 2eda219f af9989d8     .........!......
  41b340:	d8dfda31 f39282af dff1d941 f382afd8     1.......A.......
  41b350:	dff1d919 9089f1d8 8f09d0af db51af99     ..............Q.
  41b360:	82f33189 b1f21992 719cb58c f9dff1d9     .1.........q....
  41b370:	d0acb9f2 dff3f8f8 bbb7b3d8 c0f3ac82     ................
  41b380:	f12280a2 9f2622a9 acda29af a2d8ffde     ..".."&..)......
  41b390:	a9f1def2 b882f2df 81c3a9be f1bcb0c5     ................
  41b3a0:	c1fc9bb5 d9bdb403 d83332f4 a99989f2     .........23.....
  41b3b0:	32f4da49 9af1d833 a704c0fc 9788d9d0     I..23...........
  41b3c0:	d8deda30 80b1bcf1 bebebebb c18cc2af     0...............
  41b3d0:	c783c381 8fb3bcbc bdbdbdb7 61a7ba9f     ...............a
  41b3e0:	ff7169db adbbf1d8 b1f8ded0 ba96b684     .iq.............
  41b3f0:	b77ed0a7 b201a796 db059d87 97b68db3     ..~.............
  41b400:	8cb1f379 bbf14996 d8f8d0ad d0acb9f3     y....I..........
  41b410:	d9d1f9f8 d0adbbf1 b7b3d8f8 af8c97bb     ................
  41b420:	f4d979f3 f1d8a632 349d81a1 508ad0aa     .y..2......4...P
  41b430:	f43d75f4 f3d8c632 b5fad0a7 07c2fc9c     .u=.2...........
  41b440:	b7d8f8d9 79af8c97 9187f1da d0aa6ca1     .......y.....l..
  41b450:	f4bb709a f1d83d75 0ac1fc91 0733f4d9     .p..u=........3.
  41b460:	a181f1d8 f8dff9c2 a6ba9d80 31fd38d0     .............8.1
  41b470:	f3deafbb 8ff1ce82 0ffd0890 d9659f8d     ..............e.
  41b480:	d80733f4 f2deaff1 82f2ce8c f1d9259f     .3...........%..
  41b490:	ded0a6ba d8ce8df3 fc9bb5f1 bcd903c1     ................
  41b4a0:	33f4bebd b8f1d83b ded0aabe b781b3f2     ...3;...........
  41b4b0:	d949a992 33f4bdbc bcf1d83b 8db4b0bd     ..I....3;.......
  41b4c0:	f9f93197 d9f9f9f9 d8f8d0aa bdbcbcf1     .1..............
  41b4d0:	b0bebebd c3a5b884 a483c7c5 f0c7c5c3     ................
  41b4e0:	91b681b2 0c113ca3 f1502c58 93b483b0     .....<..X,P.....
  41b4f0:	7c542ca3 95f07192 78502cae aab9be8e     .,T|.q...,Px....
  41b500:	d8bdbcc2 b7b3bbf2 31af9182 df33f4da     ...........1..3.
  41b510:	b78df1d8 40a6bb96 0c9c8cac 9d8dba30     .......@....0...
  41b520:	f3db39a7 96b68cb1 84f1d949 a4b994b5     .9......I.......
  41b530:	b7f05ed0 f1d8389d a7ba8db3 fc9cb5c6     .^...8..........
  41b540:	b1d904c2 a797b681 816e8b25 da34a1b9     ........%.n...4.
  41b550:	97b687b2 b13efd00 4e8b2581 34a1b981     ......>..%.N...4
  41b560:	aabbf1d8 deacdfd0 d0added0 d8fff1df     ................
  41b570:	afb7b3f2 db399c82 099086f1 9d8ad0aa     ......9.........
  41b580:	33f474d9 aaf1dafa f3d8dfd0 f8d0acb9     .t.3............
  41b590:	f2d9d1f9 f8faa2bb a2bbf2da b3f2d8fa     ................
  41b5a0:	bb9bb682 f1db31af 619ab589 d0a1f2d9     .....1.....a....
  41b5b0:	f2d8f8f8 f8c4af82 8ff8f8f8 da1591b7     ................
  41b5c0:	d8c0d0a1 f9c2af82 b9f1d9d1 deaddeac     ................
  41b5d0:	dfa1b9df dfd0adbb 9182f2d8 f1da31af     .............1..
  41b5e0:	b99d81b1 f2d83ca1 9182bbb3 d9d131af     .....<.......1..
  41b5f0:	b581b1f1 3ea1b99b 8cb3f1d8 acbb9cb7     .......>........
  41b600:	deac10d0 92dfd0ad caf1af82 f13591f2     ..............5.
  41b610:	d9a68f96 8aafdb00 a6d96d90 8a01968f     .........m......
  41b620:	dfd0aa60 d0ac81f2 fff1d8c5 b1b9f0d8     `...............
  41b630:	928dafb6 6854714c 7944605c baf1d8e0     ....LqTh\`Dy....
  41b640:	c08fa4b1 b9c7c5c3 82aaf1b5 adf32590     .............%..
  41b650:	f8f8d9df 81a1f1d8 8234f091 2daaf138     ..........4.8..-
  41b660:	30908af5 faadf3d9 8faaf0d8 5128049f     ...0..........(Q
  41b670:	14301d79 bcbcbc38 9a8ad0a2 7850502c     y.0.8.......,PPx
  41b680:	9082bc78 f37cf5aa d8faadd9 82aeb8f1     x.....|.........
  41b690:	81a1b9c6 92810a90 81d0a218 fbadf3c1     ................
  41b6a0:	a2daf1f9 a2d8dfd0 d1f9fad0 9d82aada     ................
  41b6b0:	8aad767e f05c31d0 549d8daa f17ffd78     ~v...1\....Tx...
  41b6c0:	9d55928a 7e72d0ad 9c74f4d8 b1f1d8e0     ..U...r~..t.....
  41b6d0:	d0a282b9 faa3f2c2 f8a7b8f3 f2dad1f9     ................
  41b6e0:	b3bbd8e2 afb1f1e0 85319f8f c6dad0a5     ..........1.....
  41b6f0:	d87235f4 d1f9f8f1 adf5c6d9 7f9e8dd0     .5r.............
  41b700:	f1d8f9da 97b6f1e0 93b766a7 607171f0     .........f...qq`
  41b710:	2901f0e0 f1e07951 b2c7c5c2 2c97b687     ...)Qy.........,
  41b720:	f1e001fd b2c7c5c2 f1e0c187 669781b2     ...............f
  41b730:	1038f0e0 e0884028 597024f0 64386944     ..8.(@...$pYDi8d
  41b740:	512d3148 24f0e079 34403d58 e0512d49     H1-Qy..$X=@4I-Q.
  41b750:	00a187f1 f07c542c 2804a781 7ffd7850     ....,T|....(Px..
  41b760:	9687a7f1 02a19159 e01e160e bebef0d8     ....Y...........
  41b770:	bcbcbcbe b3bdbdbd f4ac8cbb ad8d5978     ............xY..
  41b780:	8e5978f4 5978f4ae ba80b0bc dfdef1af     .xY...xY........
  41b790:	c2f2d0df bcbcc5cb d08fb2bc f19eb5bd     ................
  41b7a0:	2603fd02 fd4603fd bdbdbd03 afbb90b5     ...&..F.........
  41b7b0:	5028f002 f0911ef1 16f14820 409238f0     ..(P.... H...8.@
  41b7c0:	f28fb7b3 c2adc0ac a9f1c4ae d9d1f9fa     ................
  41b7d0:	d84a36f4 f4faa9f1 f0d81c38 ba9c8cb7     .6J.....8.......
  41b7e0:	f12878f4 9d8db3c1 2878f4ba 8eb31cf1     .x(.......x(....
  41b7f0:	78f4ba9e b31cf128 3efdd78f 8ec18df2     ...x(......>....
  41b800:	d58ff1c1 d0d430fd d0f170fd 00f0d22a     .....0...p..*...
  41b810:	8fdea9d2 f5af97b5 a9f2d940 af97d8f8     ........@.......
  41b820:	f3d948f5 f2d8f8a9 d4f8deaf 8fb70cfd     .H..............
  41b830:	f4da059d f2d8c336 f8de97b5 0efd37d0     ....6........7..
  41b840:	8d0efd3f 05d09fb7 d8f8a9d9 a9d90daf     ?...............
  41b850:	d8d8f8f3 f8deaff2 8f0cfdd4 f4da059e     ................
  41b860:	f2d8ee36 f8de97b5 0efd37d0 8e0efd3f     6........7..?...
  41b870:	05d09fb7 d8f8a9d9 a9d90daf f1d8f8f3     ................
  41b880:	f2deaf8c d4f08fc0 f59f30fd 0488b100     .........0......
  41b890:	f8f2a9d9 24aff5d8 f8f3a9d9 b3aff0d8     .......$........
  41b8a0:	8fc7c489 40fdd4d0 b140fdd5 44f5d088     .......@..@....D
  41b8b0:	f8f2a9d9 6cf5afd8 f8f3a9d9 b58fb3d8     .......l........
  41b8c0:	60aff599 f4f8aad9 f1d84537 9fb78ab1     ...`....7E......
  41b8d0:	aad959af b3f5d8de af99b58f faaad968     .Y..........h...
  41b8e0:	d8dfaada d4af8af1 fdd500fd f5d08f40     ............@...
  41b8f0:	d9d0a914 d8f8dade d0a93caf fadadfd9     .........<......
  41b900:	af8af1d8 d700fdd6 9a8f40fd a904f5d0     .........@......
  41b910:	d8f8f2d9 a92cf5af d8f8f3d9 c0f2af8c     ......,.........
  41b920:	fdd48ff1 029fb730 10d01efd f8f8deaf     ....0...........
  41b930:	f8f8f8f8 93bdbdbd bdf102f5 dad1f9f8     ................
  41b940:	d8bd37f4 9f8ab1f1 37f4da59 b1f1d8d3     .7......Y..7....
  41b950:	51af9f8b d337f4da 9bb5f1d8 d9418fb3     ...Q..7.......A.
  41b960:	d8f8f2a9 9fb7aff1 da798ab1 d8f237f4     ..........y..7..
  41b970:	da718bf1 d8f237f4 b39bb5f1 a9d9498f     ..q..7.......I..
  41b980:	f0d8f8f3 f9f9f2a9 f9f9f9f9 f0d0aaf9     ................
  41b990:	e2f5deda d8f8d9f0 f9f9f3a9 f9f9f9f9     ................
  41b9a0:	f0d0aaf9 e2f6dfda d8fad9f0 b0bcf0d8     ................
  41b9b0:	90b4bd80 e0a0b8be 11f2aff0 3d15f33d     ............=..=
  41b9c0:	d08fb2f2 dff3cfcd f1dfdfdf d570fdd4     ..............p.
  41b9d0:	fdd670fd 70fdd770 100c9fb6 b500f518     .p..p..p........
  41b9e0:	bb18f596 9fb7d0af f3d0f0e0 d0ccf2cf     ................
  41b9f0:	caf2cdf3 f2cbf3d0 c9f3d0c8 000000e0     ................

0041ba00 <cfg_mounting_matrix>:
  41ba00:	3f800000 00000000 00000000 00000000     ...?............
  41ba10:	3f800000 00000000 00000000 00000000     ...?............
  41ba20:	3f800000                                ...?

0041ba24 <cfg_mag_mounting_matrix>:
  41ba24:	3f800000 00000000 00000000 00000000     ...?............
  41ba34:	3f800000 00000000 00000000 00000000     ...?............
  41ba44:	3f800000 64616f4c 504d4420 6d692033     ...?Load DMP3 im
  41ba54:	00656761 324d4349 38343630 4f485720     age.ICM20648 WHO
  41ba64:	3d494d41 30257830 00007832 20646142     AMI=0x%02x..Bad 
  41ba74:	414f4857 7620494d 65756c61 6f47202e     WHOAMI value. Go
  41ba84:	78302074 78323025 0000002e 74747550     t 0x%02x....Putt
  41ba94:	20676e69 326d6349 38343630 206e6920     ing Icm20648 in 
  41baa4:	65656c73 6f6d2070 2e2e6564 0000002e     sleep mode......
  41bab4:	74696e49 696c6169 6974617a 66206e6f     Initialization f
  41bac4:	656c6961 45202e64 726f7272 616f6c20     ailed. Error loa
  41bad4:	676e6964 504d4420 2e2e2e33 00000000     ding DMP3.......
  41bae4:	746f6f42 20676e69 69207075 30326d63     Booting up icm20
  41baf4:	2e383436 00002e2e 72276557 6f672065     648.....We're go
  41bb04:	7420646f 6f67206f 00002120 203a7325     od to go !..%s: 
  41bb14:	6f727265 64252072 73252820 00000029     error %d (%s)...
  41bb24:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bb34:	6e75203a 65707865 64657463 63617020     : unexpected pac
  41bb44:	2074656b 65636572 64657669 6749202e     ket received. Ig
  41bb54:	65726f6e 00002e64 77646469 70706172     nored...iddwrapp
  41bb64:	705f7265 6f746f72 5f6c6f63 6e657665     er_protocol_even
  41bb74:	62635f74 6e65203a 65646f63 72726520     t_cb: encode err
  41bb84:	202c726f 70736572 65736e6f 6f726420     or, response dro
  41bb94:	64657070 00000000 4f525245 76652052     pped....ERROR ev
  41bba4:	20746e65 68746977 6c617620 25206575     ent with value %
  41bbb4:	65722064 76696563 66206465 206d6f72     d received from 
  41bbc4:	57646449 70706172 74207265 736e6172     IddWrapper trans
  41bbd4:	74726f70 00000000 506e7944 6f746f72     port....DynProto
  41bbe4:	5f6c6f63 636f7270 50737365 7942746b     col_processPktBy
  41bbf4:	25286574 29783230 74657220 656e7275     te(%02x) returne
  41bc04:	64252064 00000000 736e6573 655f726f     d %d....sensor_e
  41bc14:	746e6576 3a62635f 636e6520 2065646f     vent_cb: encode 
  41bc24:	6f727265 66202c72 656d6172 6f726420     error, frame dro
  41bc34:	64657070 00000000 69766544 6d456563     pped....DeviceEm
  41bc44:	61725764 72657070 6572203a 76696563     dWrapper: receiv
  41bc54:	63206465 616d6d6f 7320646e 70757465     ed command setup
  41bc64:	00000000 69766544 6d456563 61725764     ....DeviceEmdWra
  41bc74:	72657070 6572203a 76696563 63206465     pper: received c
  41bc84:	616d6d6f 7220646e 74657365 00000000     ommand reset....
  41bc94:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bca4:	6572203a 76696563 63206465 616d6d6f     : received comma
  41bcb4:	7020646e 28676e69 00297325 69766544     nd ping(%s).Devi
  41bcc4:	6d456563 61725764 72657070 6572203a     ceEmdWrapper: re
  41bcd4:	76696563 63206465 616d6d6f 7320646e     ceived command s
  41bce4:	5f666c65 74736574 29732528 00000000     elf_test(%s)....
  41bcf4:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bd04:	6572203a 76696563 63206465 616d6d6f     : received comma
  41bd14:	7320646e 74726174 29732528 00000000     nd start(%s)....
  41bd24:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bd34:	6572203a 76696563 63206465 616d6d6f     : received comma
  41bd44:	7320646e 28706f74 00297325 69766544     nd stop(%s).Devi
  41bd54:	6d456563 61725764 72657070 6572203a     ceEmdWrapper: re
  41bd64:	76696563 63206465 616d6d6f 7320646e     ceived command s
  41bd74:	705f7465 6f697265 64252864 29737520     et_period(%d us)
  41bd84:	00000000 69766544 6d456563 61725764     ....DeviceEmdWra
  41bd94:	72657070 6572203a 76696563 63206465     pper: received c
  41bda4:	616d6d6f 7320646e 735f7465 6f736e65     ommand set_senso
  41bdb4:	6f635f72 6769666e 29732528 00000000     r_config(%s)....
  41bdc4:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bdd4:	6572203a 76696563 63206465 616d6d6f     : received comma
  41bde4:	6320646e 6e61656c 00007075 666c6553     nd cleanup..Self
  41bdf4:	7365742d 61682074 6c612073 64616572     -test has alread
  41be04:	75722079 53202e6e 7070696b 2e676e69     y run. Skipping.
  41be14:	00000000 6e6e7552 20676e69 666c6573     ....Running self
  41be24:	7365742d 2e2e2e74 00000000 666c6553     -test.......Self
  41be34:	7365742d 61662074 72756c69 00212065     -test failure !.
  41be44:	20525947 73616962 53462820 3035323d     GYR bias (FS=250
  41be54:	29737064 70642820 203a2973 66253d78     dps) (dps): x=%f
  41be64:	3d79202c 202c6625 66253d7a 00000000     , y=%f, z=%f....
  41be74:	20434341 73616962 53462820 2967323d     ACC bias (FS=2g)
  41be84:	29672820 3d78203a 202c6625 66253d79      (g): x=%f, y=%f
  41be94:	3d7a202c 00006625 000e1000 000000c0     , z=%f..........
  41bea4:	00000800 00000000 001e8480 000000c0     ................
  41beb4:	00000800 00000000                       ........

0041bebc <AKM8975_ST_Lower>:
  41bebc:	ff9cff9c 0000fc18                       ........

0041bec4 <AKM8975_ST_Upper>:
  41bec4:	00640064 0000fed4                       d.d.....

0041becc <AKM8972_ST_Lower>:
  41becc:	ffceffce 0000fe0c                       ........

0041bed4 <AKM8972_ST_Upper>:
  41bed4:	00320032 0000ff9c                       2.2.....

0041bedc <AKM8963_ST_Lower>:
  41bedc:	ff38ff38 0000f380                       8.8.....

0041bee4 <AKM8963_ST_Upper>:
  41bee4:	00c800c8 0000fce0                       ........

0041beec <AK09911_ST_Lower>:
  41beec:	ffe2ffe2 0000fe70                       ....p...

0041bef4 <AK09911_ST_Upper>:
  41bef4:	001e001e 0000ffce                       ........

0041befc <AK09912_ST_Lower>:
  41befc:	ff38ff38 0000f9c0                       8.8.....

0041bf04 <AK09912_ST_Upper>:
  41bf04:	00c800c8 0000fe70                       ....p...

0041bf0c <AK09916_ST_Lower>:
  41bf0c:	ff38ff38 0000fc18                       8.8.....

0041bf14 <AK09916_ST_Upper>:
  41bf14:	00c800c8 0000ff38                       ....8...

0041bf1c <sSelfTestEquation>:
  41bf1c:	0a560a3c 0a8b0a70 0ac10aa6 0af80add     <.V.p...........
  41bf2c:	0b310b15 0b6b0b4e 0ba50b88 0be10bc3     ..1.N.k.........
  41bf3c:	0c1e0c00 0c5d0c3d 0c9c0c7c 0cdd0cbd     ....=.].|.......
  41bf4c:	0d1f0cfe 0d630d41 0da80d85 0dee0dcb     ....A.c.........
  41bf5c:	0e360e12 0e7f0e5a 0eca0ea4 0f160eef     ..6.Z...........
  41bf6c:	0f630f3c 0fb30f8b 10030fdb 1056102c     <.c.........,.V.
  41bf7c:	10aa1080 110010d4 1157112b 11b01183     ........+.W.....
  41bf8c:	120b11de 12681239 12c71297 132712f7     ....9.h.......'.
  41bf9c:	138a1359 13ef13bc 14551422 14be1489     Y.......".U.....
  41bfac:	152914f3 1595155f 160415cd 1676163d     ..)._.......=.v.
  41bfbc:	16e916af 175f1724 17d8179b 18521815     ....$._.......R.
  41bfcc:	18cf1891 194f190f 19d11990 1a561a13     ......O.......V.
  41bfdc:	1ade1a9a 1b681b22 1bf51bae 1c851c3d     ....".h.....=...
  41bfec:	1d181cce 1dad1d62 1e461df9 1ee21e94     ....b.....F.....
  41bffc:	1f811f31 20231fd1 20c82075 2171211c     1.....# u . .!q!
  41c00c:	221d21c7 22cd2274 23802326 243623da     .!."t"."&#.#.#6$
  41c01c:	24f12493 25af254f 2671260f 273626d3     .$.$O%.%.&q&.&6'
  41c02c:	2800279b 28ce2867 29a02936 2a762a0b     .'.(g(.(6).).*v*
  41c03c:	2b512ae3 2c302bc0 2d132ca1 2dfb2d86     .*Q+.+0,.,.-.-.-
  41c04c:	2ee82e71 2fd92f60 30cf3053 31ca314c     q...`/./S0.0L1.1
  41c05c:	32ca324a 33d0334c 34da3454 35ea3562     J2.2L3.3T4.4b5.5
  41c06c:	37003674 381b378d 393c38aa 3a6239ce     t6.7.7.8.8<9.9b:
  41c07c:	3b8f3af8 3cc13c27 3dfa3d5d 3f383e98     .:.;'<.<]=.=.>8?
  41c08c:	407e3fda 41ca4123 431c4272 447643c8     .?~@#A.ArB.C.CvD
  41c09c:	45d64525 473d4689 48ac47f4 4a224966     %E.E.F=G.G.HfI"J
  41c0ac:	4b9f4adf 4d244c61 4eb14dea 50464f7b     .J.KaL$M.M.N{OFP
  41c0bc:	51e35114 538952b5 5536545e 56ed5611     .Q.Q.R.S^T6U.V.V
  41c0cc:	58ac57cb 5a74598f 5c465b5c 5e215d32     .W.X.YtZ\[F\2]!^
  41c0dc:	60055f12 61f360fb 63eb62ee 65ed64eb     ._.`.`.a.b.c.d.e
  41c0ec:	67fa66f2 6a116904 6c336b20 6e5f6d48     .f.g.i.j k3lHm_n
  41c0fc:	70976f7a 72db71b8 752a7401 77857656     zo.p.q.r.t*uVv.w
  41c10c:	79ec78b7 7c5f7b24 7edf7d9d 00008024     .x.y${_|.}.~$...
  41c11c:	02020101 04080304 05100620 00000000     ........ .......
  41c12c:	534e4553 525f524f 52455345 00444556     SENSOR_RESERVED.
  41c13c:	534e4553 525f524f 52455345 5f444556     SENSOR_RESERVED_
  41c14c:	00005557 534e4553 415f524f 4c454343     WU..SENSOR_ACCEL
  41c15c:	4d4f5245 52455445 00000000 534e4553     EROMETER....SENS
  41c16c:	415f524f 4c454343 4d4f5245 52455445     OR_ACCELEROMETER
  41c17c:	0055575f 534e4553 4d5f524f 454e4741     _WU.SENSOR_MAGNE
  41c18c:	454d4f54 00524554 534e4553 4d5f524f     TOMETER.SENSOR_M
  41c19c:	454e4741 454d4f54 5f524554 00005557     AGNETOMETER_WU..
  41c1ac:	534e4553 4f5f524f 4e454952 49544154     SENSOR_ORIENTATI
  41c1bc:	00004e4f 534e4553 4f5f524f 4e454952     ON..SENSOR_ORIEN
  41c1cc:	49544154 575f4e4f 00000055 534e4553     TATION_WU...SENS
  41c1dc:	475f524f 534f5259 45504f43 00000000     OR_GYROSCOPE....
  41c1ec:	534e4553 475f524f 534f5259 45504f43     SENSOR_GYROSCOPE
  41c1fc:	0055575f 534e4553 4c5f524f 54484749     _WU.SENSOR_LIGHT
  41c20c:	00000000 534e4553 4c5f524f 54484749     ....SENSOR_LIGHT
  41c21c:	0055575f 534e4553 505f524f 53534552     _WU.SENSOR_PRESS
  41c22c:	00455255 534e4553 505f524f 53534552     URE.SENSOR_PRESS
  41c23c:	5f455255 00005557 534e4553 545f524f     URE_WU..SENSOR_T
  41c24c:	45504d45 55544152 00004552 534e4553     EMPERATURE..SENS
  41c25c:	545f524f 45504d45 55544152 575f4552     OR_TEMPERATURE_W
  41c26c:	00000055 534e4553 505f524f 49584f52     U...SENSOR_PROXI
  41c27c:	5954494d 00000000 534e4553 505f524f     MITY....SENSOR_P
  41c28c:	49584f52 5954494d 0055575f 534e4553     ROXIMITY_WU.SENS
  41c29c:	475f524f 49564152 00005954 534e4553     OR_GRAVITY..SENS
  41c2ac:	475f524f 49564152 575f5954 00000055     OR_GRAVITY_WU...
  41c2bc:	534e4553 4c5f524f 41454e49 43415f52     SENSOR_LINEAR_AC
  41c2cc:	454c4543 49544152 00004e4f 534e4553     CELERATION..SENS
  41c2dc:	4c5f524f 41454e49 43415f52 454c4543     OR_LINEAR_ACCELE
  41c2ec:	49544152 575f4e4f 00000055 534e4553     RATION_WU...SENS
  41c2fc:	525f524f 5441544f 5f4e4f49 54434556     OR_ROTATION_VECT
  41c30c:	0000524f 534e4553 525f524f 5441544f     OR..SENSOR_ROTAT
  41c31c:	5f4e4f49 54434556 575f524f 00000055     ION_VECTOR_WU...
  41c32c:	534e4553 485f524f 44494d55 00595449     SENSOR_HUMIDITY.
  41c33c:	534e4553 485f524f 44494d55 5f595449     SENSOR_HUMIDITY_
  41c34c:	00005557 534e4553 415f524f 4549424d     WU..SENSOR_AMBIE
  41c35c:	545f544e 45504d45 55544152 00004552     NT_TEMPERATURE..
  41c36c:	534e4553 415f524f 4549424d 545f544e     SENSOR_AMBIENT_T
  41c37c:	45504d45 55544152 575f4552 00000055     EMPERATURE_WU...
  41c38c:	534e4553 555f524f 4c41434e 47414d5f     SENSOR_UNCAL_MAG
  41c39c:	4f54454e 4554454d 00000052 534e4553     NETOMETER...SENS
  41c3ac:	555f524f 4c41434e 47414d5f 4f54454e     OR_UNCAL_MAGNETO
  41c3bc:	4554454d 55575f52 00000000 534e4553     METER_WU....SENS
  41c3cc:	475f524f 5f454d41 41544f52 4e4f4954     OR_GAME_ROTATION
  41c3dc:	4345565f 00524f54 534e4553 475f524f     _VECTOR.SENSOR_G
  41c3ec:	5f454d41 41544f52 4e4f4954 4345565f     AME_ROTATION_VEC
  41c3fc:	5f524f54 00005557 534e4553 555f524f     TOR_WU..SENSOR_U
  41c40c:	4c41434e 5259475f 4f43534f 00004550     NCAL_GYROSCOPE..
  41c41c:	534e4553 555f524f 4c41434e 5259475f     SENSOR_UNCAL_GYR
  41c42c:	4f43534f 575f4550 00000055 534e4553     OSCOPE_WU...SENS
  41c43c:	535f524f 0000444d 534e4553 535f524f     OR_SMD..SENSOR_S
  41c44c:	575f444d 00000055 534e4553 535f524f     MD_WU...SENSOR_S
  41c45c:	5f504554 45544544 524f5443 00000000     TEP_DETECTOR....
  41c46c:	534e4553 535f524f 5f504554 45544544     SENSOR_STEP_DETE
  41c47c:	524f5443 0055575f 534e4553 535f524f     CTOR_WU.SENSOR_S
  41c48c:	5f504554 4e554f43 00524554 534e4553     TEP_COUNTER.SENS
  41c49c:	535f524f 5f504554 4e554f43 5f524554     OR_STEP_COUNTER_
  41c4ac:	00005557 534e4553 475f524f 414d4f45     WU..SENSOR_GEOMA
  41c4bc:	4f525f47 49544154 565f4e4f 4f544345     G_ROTATION_VECTO
  41c4cc:	00000052 534e4553 475f524f 414d4f45     R...SENSOR_GEOMA
  41c4dc:	4f525f47 49544154 565f4e4f 4f544345     G_ROTATION_VECTO
  41c4ec:	55575f52 00000000 534e4553 485f524f     R_WU....SENSOR_H
  41c4fc:	54524145 5441525f 00000045 534e4553     EART_RATE...SENS
  41c50c:	485f524f 54524145 5441525f 55575f45     OR_HEART_RATE_WU
  41c51c:	00000000 534e4553 545f524f 5f544c49     ....SENSOR_TILT_
  41c52c:	45544544 524f5443 00000000 534e4553     DETECTOR....SENS
  41c53c:	545f524f 5f544c49 45544544 524f5443     OR_TILT_DETECTOR
  41c54c:	0055575f 534e4553 575f524f 5f454b41     _WU.SENSOR_WAKE_
  41c55c:	54534547 00455255 534e4553 575f524f     GESTURE.SENSOR_W
  41c56c:	5f454b41 54534547 5f455255 00005557     AKE_GESTURE_WU..
  41c57c:	534e4553 475f524f 434e414c 45475f45     SENSOR_GLANCE_GE
  41c58c:	52555453 00000045 534e4553 475f524f     STURE...SENSOR_G
  41c59c:	434e414c 45475f45 52555453 55575f45     LANCE_GESTURE_WU
  41c5ac:	00000000 534e4553 505f524f 5f4b4349     ....SENSOR_PICK_
  41c5bc:	475f5055 55545345 00004552 534e4553     UP_GESTURE..SENS
  41c5cc:	505f524f 5f4b4349 475f5055 55545345     OR_PICK_UP_GESTU
  41c5dc:	575f4552 00000055 534e4553 425f524f     RE_WU...SENSOR_B
  41c5ec:	00004341 534e4553 425f524f 575f4341     AC..SENSOR_BAC_W
  41c5fc:	00000055 534e4553 505f524f 00005244     U...SENSOR_PDR..
  41c60c:	534e4553 505f524f 575f5244 00000055     SENSOR_PDR_WU...
  41c61c:	534e4553 425f524f 00005332 534e4553     SENSOR_B2S..SENS
  41c62c:	425f524f 575f5332 00000055 534e4553     OR_B2S_WU...SENS
  41c63c:	335f524f 53495841 00000000 534e4553     OR_3AXIS....SENS
  41c64c:	335f524f 53495841 0055575f 534e4553     OR_3AXIS_WU.SENS
  41c65c:	455f524f 00005349 534e4553 455f524f     OR_EIS..SENSOR_E
  41c66c:	575f5349 00000055 534e4553 4f5f524f     IS_WU...SENSOR_O
  41c67c:	305f5349 00000000 534e4553 4f5f524f     IS_0....SENSOR_O
  41c68c:	305f5349 0055575f 534e4553 525f524f     IS_0_WU.SENSOR_R
  41c69c:	415f5741 4c454343 4d4f5245 52455445     AW_ACCELEROMETER
  41c6ac:	00000000 534e4553 525f524f 415f5741     ....SENSOR_RAW_A
  41c6bc:	4c454343 4d4f5245 52455445 0055575f     CCELEROMETER_WU.
  41c6cc:	534e4553 525f524f 475f5741 534f5259     SENSOR_RAW_GYROS
  41c6dc:	45504f43 00000000 534e4553 525f524f     COPE....SENSOR_R
  41c6ec:	475f5741 534f5259 45504f43 0055575f     AW_GYROSCOPE_WU.
  41c6fc:	534e4553 525f524f 4d5f5741 454e4741     SENSOR_RAW_MAGNE
  41c70c:	454d4f54 00524554 534e4553 525f524f     TOMETER.SENSOR_R
  41c71c:	4d5f5741 454e4741 454d4f54 5f524554     AW_MAGNETOMETER_
  41c72c:	00005557 534e4553 525f524f 545f5741     WU..SENSOR_RAW_T
  41c73c:	45504d45 55544152 00004552 534e4553     EMPERATURE..SENS
  41c74c:	525f524f 545f5741 45504d45 55544152     OR_RAW_TEMPERATU
  41c75c:	575f4552 00000055 534e4553 435f524f     RE_WU...SENSOR_C
  41c76c:	4f545355 52505f4d 55535345 00004552     USTOM_PRESSURE..
  41c77c:	534e4553 435f524f 4f545355 52505f4d     SENSOR_CUSTOM_PR
  41c78c:	55535345 575f4552 00000055 534e4553     ESSURE_WU...SENS
  41c79c:	4d5f524f 00004349 534e4553 4d5f524f     OR_MIC..SENSOR_M
  41c7ac:	575f4349 00000055 534e4553 545f524f     IC_WU...SENSOR_T
  41c7bc:	554d4953 00000000 534e4553 545f524f     SIMU....SENSOR_T
  41c7cc:	554d4953 0055575f 534e4553 525f524f     SIMU_WU.SENSOR_R
  41c7dc:	505f5741 00004750 534e4553 525f524f     AW_PPG..SENSOR_R
  41c7ec:	505f5741 575f4750 00000055 534e4553     AW_PPG_WU...SENS
  41c7fc:	485f524f 00005652 534e4553 485f524f     OR_HRV..SENSOR_H
  41c80c:	575f5652 00000055 534e4553 535f524f     RV_WU...SENSOR_S
  41c81c:	5045454c 414e415f 4953594c 00000053     LEEP_ANALYSIS...
  41c82c:	534e4553 535f524f 5045454c 414e415f     SENSOR_SLEEP_ANA
  41c83c:	4953594c 55575f53 00000000 534e4553     LYSIS_WU....SENS
  41c84c:	425f524f 455f4341 4e455458 00444544     OR_BAC_EXTENDED.
  41c85c:	534e4553 425f524f 455f4341 4e455458     SENSOR_BAC_EXTEN
  41c86c:	5f444544 00005557 534e4553 425f524f     DED_WU..SENSOR_B
  41c87c:	535f4341 49544154 43495453 00000053     AC_STATISTICS...
  41c88c:	534e4553 425f524f 535f4341 49544154     SENSOR_BAC_STATI
  41c89c:	43495453 55575f53 00000000 534e4553     STICS_WU....SENS
  41c8ac:	465f524f 524f4f4c 494c435f 435f424d     OR_FLOOR_CLIMB_C
  41c8bc:	544e554f 00005245 534e4553 465f524f     OUNTER..SENSOR_F
  41c8cc:	524f4f4c 494c435f 435f424d 544e554f     LOOR_CLIMB_COUNT
  41c8dc:	575f5245 00000055 534e4553 455f524f     ER_WU...SENSOR_E
  41c8ec:	4752454e 58455f59 444e4550 52555449     NERGY_EXPENDITUR
  41c8fc:	00000045 534e4553 455f524f 4752454e     E...SENSOR_ENERG
  41c90c:	58455f59 444e4550 52555449 55575f45     Y_EXPENDITURE_WU
  41c91c:	00000000 534e4553 445f524f 41545349     ....SENSOR_DISTA
  41c92c:	0045434e 534e4553 445f524f 41545349     NCE.SENSOR_DISTA
  41c93c:	5f45434e 00005557 534e4553 535f524f     NCE_WU..SENSOR_S
  41c94c:	454b4148 00000000 534e4553 535f524f     HAKE....SENSOR_S
  41c95c:	454b4148 0055575f 534e4553 445f524f     HAKE_WU.SENSOR_D
  41c96c:	4c42554f 41545f45 00000050 534e4553     OUBLE_TAP...SENS
  41c97c:	435f524f 4f545355 0000304d 534e4553     OR_CUSTOM0..SENS
  41c98c:	435f524f 4f545355 575f304d 00000055     OR_CUSTOM0_WU...
  41c99c:	534e4553 435f524f 4f545355 0000314d     SENSOR_CUSTOM1..
  41c9ac:	534e4553 435f524f 4f545355 575f314d     SENSOR_CUSTOM1_W
  41c9bc:	00000055 534e4553 435f524f 4f545355     U...SENSOR_CUSTO
  41c9cc:	0000324d 534e4553 435f524f 4f545355     M2..SENSOR_CUSTO
  41c9dc:	575f324d 00000055 534e4553 435f524f     M2_WU...SENSOR_C
  41c9ec:	4f545355 0000334d 534e4553 435f524f     USTOM3..SENSOR_C
  41c9fc:	4f545355 575f334d 00000055 534e4553     USTOM3_WU...SENS
  41ca0c:	435f524f 4f545355 0000344d 534e4553     OR_CUSTOM4..SENS
  41ca1c:	435f524f 4f545355 575f344d 00000055     OR_CUSTOM4_WU...
  41ca2c:	534e4553 435f524f 4f545355 0000354d     SENSOR_CUSTOM5..
  41ca3c:	534e4553 435f524f 4f545355 575f354d     SENSOR_CUSTOM5_W
  41ca4c:	00000055 534e4553 435f524f 4f545355     U...SENSOR_CUSTO
  41ca5c:	0000364d 534e4553 435f524f 4f545355     M6..SENSOR_CUSTO
  41ca6c:	575f364d 00000055 534e4553 435f524f     M6_WU...SENSOR_C
  41ca7c:	4f545355 0000374d 534e4553 435f524f     USTOM7..SENSOR_C
  41ca8c:	4f545355 575f374d 00000055 534e4553     USTOM7_WU...SENS
  41ca9c:	575f524f 00004d4f 534e4553 575f524f     OR_WOM..SENSOR_W
  41caac:	575f4d4f 00000055 534e4553 535f524f     OM_WU...SENSOR_S
  41cabc:	4e454445 59524154 4d45525f 00444e49     EDENTARY_REMIND.
  41cacc:	534e4553 535f524f 4e454445 59524154     SENSOR_SEDENTARY
  41cadc:	4d45525f 5f444e49 00005557 534e4553     _REMIND_WU..SENS
  41caec:	445f524f 5f415441 52434e45 49545059     OR_DATA_ENCRYPTI
  41cafc:	00004e4f 534e4553 445f524f 5f415441     ON..SENSOR_DATA_
  41cb0c:	52434e45 49545059 575f4e4f 00000055     ENCRYPTION_WU...
  41cb1c:	534e4553 465f524f 434e5953 4556455f     SENSOR_FSYNC_EVE
  41cb2c:	0000544e 534e4553 465f524f 434e5953     NT..SENSOR_FSYNC
  41cb3c:	4556455f 575f544e 00000055 534e4553     _EVENT_WU...SENS
  41cb4c:	485f524f 5f484749 45544152 5259475f     OR_HIGH_RATE_GYR
  41cb5c:	0000004f 534e4553 485f524f 5f484749     O...SENSOR_HIGH_
  41cb6c:	45544152 5259475f 55575f4f 00000000     RATE_GYRO_WU....
  41cb7c:	534e4553 435f524f 4f545355 41425f4d     SENSOR_CUSTOM_BA
  41cb8c:	43535f43 5f45455f 54534944 00000000     C_SC_EE_DIST....
  41cb9c:	534e4553 435f524f 4f545355 41425f4d     SENSOR_CUSTOM_BA
  41cbac:	43535f43 5f45455f 54534944 0055575f     C_SC_EE_DIST_WU.
  41cbbc:	534e4553 485f524f 4c5f4d52 4547474f     SENSOR_HRM_LOGGE
  41cbcc:	00000052 534e4553 485f524f 4c5f4d52     R...SENSOR_HRM_L
  41cbdc:	4547474f 55575f52 00000000 534e4553     OGGER_WU....SENS
  41cbec:	505f524f 5f444552 54415551 0000305f     OR_PRED_QUAT_0..
  41cbfc:	534e4553 505f524f 5f444552 54415551     SENSOR_PRED_QUAT
  41cc0c:	575f305f 00000055 534e4553 505f524f     _0_WU...SENSOR_P
  41cc1c:	5f444552 54415551 0000315f 534e4553     RED_QUAT_1..SENS
  41cc2c:	505f524f 5f444552 54415551 575f315f     OR_PRED_QUAT_1_W
  41cc3c:	00000055 534e4553 4f5f524f 315f5349     U...SENSOR_OIS_1
  41cc4c:	00000000 534e4553 4f5f524f 315f5349     ....SENSOR_OIS_1
  41cc5c:	0055575f 506e7944 6f746f72 3a6c6f63     _WU.DynProtocol:
  41cc6c:	74657220 656e7275 61702064 616f6c79      returned payloa
  41cc7c:	73692064 00312d20 506e7944 6f746f72     d is -1.DynProto
  41cc8c:	3a6c6f63 656e5520 63657078 20646574     col: Unexpected 
  41cc9c:	6b636170 74207465 00657079 506e7944     packet type.DynP
  41ccac:	6f746f72 3a6c6f63 656e5520 63657078     rotocol: Unexpec
  41ccbc:	20646574 6b636170 72207465 69656365     ted packet recei
  41cccc:	2e646576 00000000 506e7944 6f746f72     ved.....DynProto
  41ccdc:	3a6c6f63 6b6e5520 6e776f6e 61726620     col: Unknown fra
  41ccec:	0000656d 506e7944 6f746f72 3a6c6f63     me..DynProtocol:
  41ccfc:	61724620 7320656d 20657a69 6f727265      Frame size erro
  41cd0c:	73202e72 3d657a69 20426425 70786528     r. size=%dB (exp
  41cd1c:	65746365 64252064 00002942 506e7944     ected %dB)..DynP
  41cd2c:	6f746f72 3a6c6f63 766e4920 64696c61     rotocol: Invalid
  41cd3c:	6f726720 49207075 00000044 506e7944      group ID...DynP
  41cd4c:	6f746f72 3a6c6f63 746e6920 616e7265     rotocol: interna
  41cd5c:	7562206c 72656666 7a697320 75662065     l buffer size fu
  41cd6c:	00006c6c 506e7944 6f746f72 3a6c6f63     ll..DynProtocol:
  41cd7c:	656e5520 63657078 20646574 75677261      Unexpected argu
  41cd8c:	746e656d 726f6620 636e6520 5f65646f     ment for encode_
  41cd9c:	6d6d6f63 28646e61 00000029 506e7944     command()...DynP
  41cdac:	6f746f72 3a6c6f63 74756f20 20747570     rotocol: output 
  41cdbc:	66667562 73207265 20657a69 206f6f74     buffer size too 
  41cdcc:	6c616d73 0000006c 506e7944 6f746f72     small...DynProto
  41cddc:	3a6c6f63 656e5520 63657078 20646574     col: Unexpected 
  41cdec:	75677261 746e656d 726f6620 6e794420     argument for Dyn
  41cdfc:	746f7250 6c6f636f 636e655f 5265646f     Protocol_encodeR
  41ce0c:	6f707365 2865736e 00000029 506e7944     esponse()...DynP
  41ce1c:	6f746f72 3a6c6f63 656e5520 63657078     rotocol: Unexpec
  41ce2c:	20646574 75677261 746e656d 726f6620     ted argument for
  41ce3c:	636e6520 5f65646f 6e797361 00292863      encode_async().
  41ce4c:	45534552 44455652 00000000 45434341     RESERVED....ACCE
  41ce5c:	4f52454c 4554454d 00000052 4e47414d     LEROMETER...MAGN
  41ce6c:	4d4f5445 52455445 00000000 4549524f     ETOMETER....ORIE
  41ce7c:	5441544e 004e4f49 4f525947 504f4353     NTATION.GYROSCOP
  41ce8c:	00000045 4847494c 00000054 53455250     E...LIGHT...PRES
  41ce9c:	45525553 00000000 504d4554 54415245     SURE....TEMPERAT
  41ceac:	00455255 584f5250 54494d49 00000059     URE.PROXIMITY...
  41cebc:	56415247 00595449 454e494c 415f5241     GRAVITY.LINEAR_A
  41cecc:	4c454343 54415245 004e4f49 41544f52     CCELERATION.ROTA
  41cedc:	4e4f4954 4345565f 00524f54 494d5548     TION_VECTOR.HUMI
  41ceec:	59544944 00000000 49424d41 5f544e45     DITY....AMBIENT_
  41cefc:	504d4554 54415245 00455255 41434e55     TEMPERATURE.UNCA
  41cf0c:	414d5f4c 54454e47 54454d4f 00005245     L_MAGNETOMETER..
  41cf1c:	454d4147 544f525f 4f495441 45565f4e     GAME_ROTATION_VE
  41cf2c:	524f5443 00000000 41434e55 59475f4c     CTOR....UNCAL_GY
  41cf3c:	43534f52 0045504f 00444d53 50455453     ROSCOPE.SMD.STEP
  41cf4c:	5445445f 4f544345 00000052 50455453     _DETECTOR...STEP
  41cf5c:	554f435f 5245544e 00000000 4d4f4547     _COUNTER....GEOM
  41cf6c:	525f4741 5441544f 5f4e4f49 54434556     AG_ROTATION_VECT
  41cf7c:	0000524f 52414548 41525f54 00004554     OR..HEART_RATE..
  41cf8c:	544c4954 5445445f 4f544345 00000052     TILT_DETECTOR...
  41cf9c:	454b4157 5345475f 45525554 00000000     WAKE_GESTURE....
  41cfac:	4e414c47 475f4543 55545345 00004552     GLANCE_GESTURE..
  41cfbc:	4b434950 5f50555f 54534547 00455255     PICK_UP_GESTURE.
  41cfcc:	00434142 00524450 00533242 49584133     BAC.PDR.B2S.3AXI
  41cfdc:	00000053 00534945 0053494f 5f574152     S...EIS.OIS.RAW_
  41cfec:	45434341 4f52454c 4554454d 00000052     ACCELEROMETER...
  41cffc:	5f574152 4f525947 504f4353 00000045     RAW_GYROSCOPE...
  41d00c:	5f574152 4e47414d 4d4f5445 52455445     RAW_MAGNETOMETER
  41d01c:	00000000 5f574152 504d4554 54415245     ....RAW_TEMPERAT
  41d02c:	00455255 54535543 505f4d4f 53534552     URE.CUSTOM_PRESS
  41d03c:	00455255 0043494d 4d495354 00000055     URE.MIC.TSIMU...
  41d04c:	5f574152 00475050 00565248 45454c53     RAW_PPG.HRV.SLEE
  41d05c:	4e415f50 53594c41 00005349 5f434142     P_ANALYSIS..BAC_
  41d06c:	45545845 4445444e 00000000 5f434142     EXTENDED....BAC_
  41d07c:	54415453 49545349 00005343 4f4f4c46     STATISTICS..FLOO
  41d08c:	4c435f52 5f424d49 4e554f43 00524554     R_CLIMB_COUNTER.
  41d09c:	52454e45 455f5947 4e455058 55544944     ENERGY_EXPENDITU
  41d0ac:	00004552 54534944 45434e41 00000000     RE..DISTANCE....
  41d0bc:	4b414853 00000045 42554f44 545f454c     SHAKE...DOUBLE_T
  41d0cc:	00005041 54535543 00304d4f 54535543     AP..CUSTOM0.CUST
  41d0dc:	00314d4f 54535543 00324d4f 54535543     OM1.CUSTOM2.CUST
  41d0ec:	00334d4f 54535543 00344d4f 54535543     OM3.CUSTOM4.CUST
  41d0fc:	00354d4f 54535543 00364d4f 54535543     OM5.CUSTOM6.CUST
  41d10c:	00374d4f 004d4f57 45444553 5241544e     OM7.WOM.SEDENTAR
  41d11c:	45525f59 444e494d 00000000 4e595346     Y_REMIND....FSYN
  41d12c:	56455f43 00544e45 44455250 4155515f     C_EVENT.PRED_QUA
  41d13c:	00305f54 44455250 4155515f 00315f54     T_0.PRED_QUAT_1.
  41d14c:	00000000 506e7944 72546f72 70736e61     ....DynProTransp
  41d15c:	5574726f 3a747261 656e7520 63657078     ortUart: unexpec
  41d16c:	20646574 434e5953 79622030 25206574     ted SYNC0 byte %
  41d17c:	65722078 69766563 00006465 506e7944     x recevied..DynP
  41d18c:	72546f72 70736e61 5574726f 3a747261     roTransportUart:
  41d19c:	656e7520 63657078 20646574 434e5953      unexpected SYNC
  41d1ac:	79622031 25206574 65722078 69766563     1 byte %x recevi
  41d1bc:	00006465 63637553 00737365 70736e55     ed..Success.Unsp
  41d1cc:	66696365 20646569 6f727265 00000072     ecified error...
  41d1dc:	20746f4e 6c706d69 6e656d65 00646574     Not implemented.
  41d1ec:	6e617254 726f7073 72652074 00726f72     Transport error.
  41d1fc:	656d6954 2c74756f 74636120 206e6f69     Timeout, action 
  41d20c:	20646964 20746f6e 706d6f63 6574656c     did not complete
  41d21c:	206e6920 656d6974 00000000 6e6f7257      in time....Wron
  41d22c:	69732067 6520657a 726f7272 00000000     g size error....
  41d23c:	7265704f 6e697461 79732067 6d657473     Operating system
  41d24c:	69616620 6572756c 00000000 75706e49      failure....Inpu
  41d25c:	754f2f74 74757074 72726520 0000726f     t/Output error..
  41d26c:	20646142 6f6c6c61 69746163 00006e6f     Bad allocation..
  41d27c:	64726148 65726177 72726520 0000726f     Hardware error..
  41d28c:	61766e49 2064696c 75677261 746e656d     Invalid argument
  41d29c:	00000073 78656e55 74636570 65206465     s...Unexpected e
  41d2ac:	726f7272 00000000 61766e49 2064696c     rror....Invalid 
  41d2bc:	656c6966 726f6620 0074616d 61766e49     file format.Inva
  41d2cc:	2064696c 656c6966 74617020 00000068     lid file path...
  41d2dc:	6e6b6e55 206e776f 67616d69 79742065     Unknown image ty
  41d2ec:	00006570 63746157 676f6468 72726520     pe..Watchdog err
  41d2fc:	0000726f 4f464946 65766f20 6f6c6672     or..FIFO overflo
  41d30c:	72652077 00726f72 6e6b6e55 206e776f     w error.Unknown 
  41d31c:	6f727265 00000072 002a0001 07141417     error.....*.....
  41d32c:	0c121a27 1f250c13 1f111f26 10092029     '.....%.&...) ..
  41d33c:	100a100f 2123211d 1103211e 2219110b     .....!#!.!....."
  41d34c:	0000221f 15240110 012b0a04 05091d1a     ."....$...+.....
  41d35c:	050a050f 1823181d 0603181e 1919060b     ......#.........
  41d36c:	0000191f 1622030e 1e180b02 13031214     ......".........
  41d37c:	2327130b 241f2419 1c1c0906 14170001     ..'#.$.$........
  41d38c:	100a002a 0000211e 1a270714 0c130c12     *....!....'.....
  41d39c:	1f261f25 00001f11 15240110 012b0a04     %.&.......$...+.
  41d3ac:	00001d1a 1d1a0a04 050f0509 181d050a     ................
  41d3bc:	181e1823 060b0603 191f1919 1622030e     #.............".
  41d3cc:	1e180b02 8008ffff 04080028 10084048     ........(...H@..
  41d3dc:	ffff0088 0808ffff 04088808 ffffffff     ................
  41d3ec:	08082008 00004008 00100018 ffff0108     . ...@..........
  41d3fc:	8008ffff 04080028 10084048 08080088     ....(...H@......
  41d40c:	04088808 ffffffff 08082008 00184008     ......... ...@..
  41d41c:	01080010 0000ffff 40488008 74727173     ..........H@sqrt
  41d42c:	00000066                                f...

0041d430 <npio2_hw>:
  41d430:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
  41d440:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
  41d450:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
  41d460:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
  41d470:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
  41d480:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
  41d490:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
  41d4a0:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

0041d4b0 <two_over_pi>:
  41d4b0:	000000a2 000000f9 00000083 0000006e     ............n...
  41d4c0:	0000004e 00000044 00000015 00000029     N...D.......)...
  41d4d0:	000000fc 00000027 00000057 000000d1     ....'...W.......
  41d4e0:	000000f5 00000034 000000dd 000000c0     ....4...........
  41d4f0:	000000db 00000062 00000095 00000099     ....b...........
  41d500:	0000003c 00000043 00000090 00000041     <...C.......A...
  41d510:	000000fe 00000051 00000063 000000ab     ....Q...c.......
  41d520:	000000de 000000bb 000000c5 00000061     ............a...
  41d530:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
  41d540:	00000042 0000004d 000000d2 000000e0     B...M...........
  41d550:	00000006 00000049 0000002e 000000ea     ....I...........
  41d560:	00000009 000000d1 00000092 0000001c     ................
  41d570:	000000fe 0000001d 000000eb 0000001c     ................
  41d580:	000000b1 00000029 000000a7 0000003e     ....).......>...
  41d590:	000000e8 00000082 00000035 000000f5     ........5.......
  41d5a0:	0000002e 000000bb 00000044 00000084     ........D.......
  41d5b0:	000000e9 0000009c 00000070 00000026     ........p...&...
  41d5c0:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
  41d5d0:	00000039 00000091 000000d6 00000039     9...........9...
  41d5e0:	00000083 00000053 00000039 000000f4     ....S...9.......
  41d5f0:	0000009c 00000084 0000005f 0000008b     ........_.......
  41d600:	000000bd 000000f9 00000028 0000003b     ........(...;...
  41d610:	0000001f 000000f8 00000097 000000ff     ................
  41d620:	000000de 00000005 00000098 0000000f     ................
  41d630:	000000ef 0000002f 00000011 0000008b     ..../...........
  41d640:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
  41d650:	0000006d 00000036 0000007e 000000cf     m...6...~.......
  41d660:	00000027 000000cb 00000009 000000b7     '...............
  41d670:	0000004f 00000046 0000003f 00000066     O...F...?...f...
  41d680:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
  41d690:	00000075 00000027 000000ba 000000c7     u...'...........
  41d6a0:	000000eb 000000e5 000000f1 0000007b     ............{...
  41d6b0:	0000003d 00000007 00000039 000000f7     =.......9.......
  41d6c0:	0000008a 00000052 00000092 000000ea     ....R...........
  41d6d0:	0000006b 000000fb 0000005f 000000b1     k......._.......
  41d6e0:	0000001f 0000008d 0000005d 00000008     ........].......
  41d6f0:	00000056 00000003 00000030 00000046     V.......0...F...
  41d700:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
  41d710:	000000f0 000000cf 000000bc 00000020     ............ ...
  41d720:	0000009a 000000f4 00000036 0000001d     ........6.......
  41d730:	000000a9 000000e3 00000091 00000061     ............a...
  41d740:	0000005e 000000e6 0000001b 00000008     ^...............
  41d750:	00000065 00000099 00000085 0000005f     e..........._...
  41d760:	00000014 000000a0 00000068 00000040     ........h...@...
  41d770:	0000008d 000000ff 000000d8 00000080     ................
  41d780:	0000004d 00000073 00000027 00000031     M...s...'...1...
  41d790:	00000006 00000006 00000015 00000056     ............V...
  41d7a0:	000000ca 00000073 000000a8 000000c9     ....s...........
  41d7b0:	00000060 000000e2 0000007b 000000c0     `.......{.......
  41d7c0:	0000008c 0000006b                       ....k...

0041d7c8 <PIo2>:
  41d7c8:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
  41d7d8:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
  41d7e8:	1fc40000 1bc60000 17440000              ..........D.

0041d7f4 <init_jk>:
  41d7f4:	00000004 00000007 00000009              ............

0041d800 <_global_impure_ptr>:
  41d800:	20000360 00464e49 00666e69 004e414e     `.. INF.inf.NAN.
  41d810:	006e616e 33323130 37363534 42413938     nan.0123456789AB
  41d820:	46454443 00000000 33323130 37363534     CDEF....01234567
  41d830:	62613938 66656463 00000000 6c756e28     89abcdef....(nul
  41d840:	0000296c 00000030                       l)..0...

0041d848 <blanks.8346>:
  41d848:	20202020 20202020 20202020 20202020                     

0041d858 <zeroes.8347>:
  41d858:	30303030 30303030 30303030 30303030     0000000000000000
  41d868:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.

0041d878 <__mprec_bigtens>:
  41d878:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
  41d888:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
  41d898:	7f73bf3c 75154fdd                       <.s..O.u

0041d8a0 <__mprec_tens>:
  41d8a0:	00000000 3ff00000 00000000 40240000     .......?......$@
  41d8b0:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  41d8c0:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  41d8d0:	00000000 412e8480 00000000 416312d0     .......A......cA
  41d8e0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
  41d8f0:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
  41d900:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
  41d910:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
  41d920:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
  41d930:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
  41d940:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
  41d950:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
  41d960:	79d99db4 44ea7843                       ...yCx.D

0041d968 <p05.7178>:
  41d968:	00000005 00000019 0000007d 00000043     ........}...C...
  41d978:	49534f50 00000058 0000002e              POSIX.......

0041d984 <_ctype_>:
  41d984:	20202000 20202020 28282020 20282828     .         ((((( 
  41d994:	20202020 20202020 20202020 20202020                     
  41d9a4:	10108820 10101010 10101010 10101010      ...............
  41d9b4:	04040410 04040404 10040404 10101010     ................
  41d9c4:	41411010 41414141 01010101 01010101     ..AAAAAA........
  41d9d4:	01010101 01010101 01010101 10101010     ................
  41d9e4:	42421010 42424242 02020202 02020202     ..BBBBBB........
  41d9f4:	02020202 02020202 02020202 10101010     ................
  41da04:	00000020 00000000 00000000 00000000      ...............
	...

0041da88 <_init>:
  41da88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41da8a:	bf00      	nop
  41da8c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41da8e:	bc08      	pop	{r3}
  41da90:	469e      	mov	lr, r3
  41da92:	4770      	bx	lr

0041da94 <__init_array_start>:
  41da94:	00415a91 	.word	0x00415a91

0041da98 <__frame_dummy_init_array_entry>:
  41da98:	0040016d                                m.@.

0041da9c <_fini>:
  41da9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41da9e:	bf00      	nop
  41daa0:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41daa2:	bc08      	pop	{r3}
  41daa4:	469e      	mov	lr, r3
  41daa6:	4770      	bx	lr

0041daa8 <__fini_array_start>:
  41daa8:	00400149 	.word	0x00400149

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr

2000000a <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
2000000a:	b480      	push	{r7}
2000000c:	b089      	sub	sp, #36	; 0x24
2000000e:	af00      	add	r7, sp, #0
20000010:	60f8      	str	r0, [r7, #12]
20000012:	60b9      	str	r1, [r7, #8]
20000014:	607a      	str	r2, [r7, #4]
20000016:	603b      	str	r3, [r7, #0]
	uint32_t *p_ul_data =
			(uint32_t *) ((p_efc == EFC0) ?
			READ_BUFF_ADDR0 : READ_BUFF_ADDR1);
#elif (SAM3S || SAM4S || SAM3N || SAM3U || SAM4E || SAM4N || SAM4C || SAMG || \
	   SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAMS70 || SAME70)
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
20000018:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2000001c:	61bb      	str	r3, [r7, #24]
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
2000001e:	683b      	ldr	r3, [r7, #0]
20000020:	2b00      	cmp	r3, #0
20000022:	d101      	bne.n	20000028 <efc_perform_read_sequence+0x1e>
		return EFC_RC_INVALID;
20000024:	2302      	movs	r3, #2
20000026:	e03c      	b.n	200000a2 <efc_perform_read_sequence+0x98>
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000028:	68fb      	ldr	r3, [r7, #12]
2000002a:	681b      	ldr	r3, [r3, #0]
2000002c:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
20000030:	68fb      	ldr	r3, [r7, #12]
20000032:	601a      	str	r2, [r3, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
20000034:	68bb      	ldr	r3, [r7, #8]
20000036:	b2db      	uxtb	r3, r3
20000038:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
2000003c:	68fb      	ldr	r3, [r7, #12]
2000003e:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	68fb      	ldr	r3, [r7, #12]
20000042:	689b      	ldr	r3, [r3, #8]
20000044:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
20000046:	697b      	ldr	r3, [r7, #20]
20000048:	f003 0301 	and.w	r3, r3, #1
2000004c:	2b01      	cmp	r3, #1
2000004e:	d0f7      	beq.n	20000040 <efc_perform_read_sequence+0x36>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000050:	2300      	movs	r3, #0
20000052:	61fb      	str	r3, [r7, #28]
20000054:	e00c      	b.n	20000070 <efc_perform_read_sequence+0x66>
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
20000056:	69fb      	ldr	r3, [r7, #28]
20000058:	009b      	lsls	r3, r3, #2
2000005a:	683a      	ldr	r2, [r7, #0]
2000005c:	4413      	add	r3, r2
2000005e:	69fa      	ldr	r2, [r7, #28]
20000060:	0092      	lsls	r2, r2, #2
20000062:	69b9      	ldr	r1, [r7, #24]
20000064:	440a      	add	r2, r1
20000066:	6812      	ldr	r2, [r2, #0]
20000068:	601a      	str	r2, [r3, #0]
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
2000006a:	69fb      	ldr	r3, [r7, #28]
2000006c:	3301      	adds	r3, #1
2000006e:	61fb      	str	r3, [r7, #28]
20000070:	69fa      	ldr	r2, [r7, #28]
20000072:	6abb      	ldr	r3, [r7, #40]	; 0x28
20000074:	429a      	cmp	r2, r3
20000076:	d3ee      	bcc.n	20000056 <efc_perform_read_sequence+0x4c>
	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000078:	687b      	ldr	r3, [r7, #4]
2000007a:	b2db      	uxtb	r3, r3
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000007c:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR =
20000080:	68fb      	ldr	r3, [r7, #12]
20000082:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000084:	68fb      	ldr	r3, [r7, #12]
20000086:	689b      	ldr	r3, [r3, #8]
20000088:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
2000008a:	697b      	ldr	r3, [r7, #20]
2000008c:	f003 0301 	and.w	r3, r3, #1
20000090:	2b01      	cmp	r3, #1
20000092:	d1f7      	bne.n	20000084 <efc_perform_read_sequence+0x7a>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
20000094:	68fb      	ldr	r3, [r7, #12]
20000096:	681b      	ldr	r3, [r3, #0]
20000098:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
2000009c:	68fb      	ldr	r3, [r7, #12]
2000009e:	601a      	str	r2, [r3, #0]

	return EFC_RC_OK;
200000a0:	2300      	movs	r3, #0
}
200000a2:	4618      	mov	r0, r3
200000a4:	3724      	adds	r7, #36	; 0x24
200000a6:	46bd      	mov	sp, r7
200000a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200000ac:	4770      	bx	lr

200000ae <efc_write_fmr>:
 * \param ul_fmr Value of mode register
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
200000ae:	b480      	push	{r7}
200000b0:	b083      	sub	sp, #12
200000b2:	af00      	add	r7, sp, #0
200000b4:	6078      	str	r0, [r7, #4]
200000b6:	6039      	str	r1, [r7, #0]
	p_efc->EEFC_FMR = ul_fmr;
200000b8:	687b      	ldr	r3, [r7, #4]
200000ba:	683a      	ldr	r2, [r7, #0]
200000bc:	601a      	str	r2, [r3, #0]
}
200000be:	bf00      	nop
200000c0:	370c      	adds	r7, #12
200000c2:	46bd      	mov	sp, r7
200000c4:	f85d 7b04 	ldr.w	r7, [sp], #4
200000c8:	4770      	bx	lr

200000ca <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
200000ca:	b480      	push	{r7}
200000cc:	b085      	sub	sp, #20
200000ce:	af00      	add	r7, sp, #0
200000d0:	6078      	str	r0, [r7, #4]
200000d2:	6039      	str	r1, [r7, #0]
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
200000d4:	687b      	ldr	r3, [r7, #4]
200000d6:	683a      	ldr	r2, [r7, #0]
200000d8:	605a      	str	r2, [r3, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
200000da:	687b      	ldr	r3, [r7, #4]
200000dc:	689b      	ldr	r3, [r3, #8]
200000de:	60fb      	str	r3, [r7, #12]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
200000e0:	68fb      	ldr	r3, [r7, #12]
200000e2:	f003 0301 	and.w	r3, r3, #1
200000e6:	2b01      	cmp	r3, #1
200000e8:	d1f7      	bne.n	200000da <efc_perform_fcr+0x10>

	return (ul_status & EEFC_ERROR_FLAGS);
200000ea:	68fb      	ldr	r3, [r7, #12]
200000ec:	f003 030e 	and.w	r3, r3, #14
}
200000f0:	4618      	mov	r0, r3
200000f2:	3714      	adds	r7, #20
200000f4:	46bd      	mov	sp, r7
200000f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200000fa:	4770      	bx	lr

200000fc <cfg_acc_fsr>:
200000fc:	0004 0000                                   ....

20000100 <cfg_gyr_fsr>:
20000100:	07d0 0000                                   ....

20000104 <convert_to_generic_ids>:
20000104:	0401 2120 100e 121a 0f13 140b 1102 1619     .. !............
20000114:	0a09 1c03                                   ....

20000118 <I2C_Address>:
20000118:	0169                                             i

20000119 <g_interrupt_enabled>:
20000119:	0001 0000                                        ...

2000011c <SystemCoreClock>:
2000011c:	1200 007a                                   ..z.

20000120 <constA7.6583>:
20000120:	7fe4 0000 d6f9 ffff 128f 0000 fb1a ffff     ................

20000130 <PI15.6584>:
20000130:	9220 0001                                    ...

20000134 <sensor_str.5457>:
20000134:	c12c 0041 c13c 0041 c150 0041 c168 0041     ,.A.<.A.P.A.h.A.
20000144:	c180 0041 c194 0041 c1ac 0041 c1c0 0041     ..A...A...A...A.
20000154:	c1d8 0041 c1ec 0041 c200 0041 c210 0041     ..A...A...A...A.
20000164:	c220 0041 c230 0041 c244 0041 c258 0041      .A.0.A.D.A.X.A.
20000174:	c270 0041 c284 0041 c298 0041 c2a8 0041     p.A...A...A...A.
20000184:	c2bc 0041 c2d8 0041 c2f8 0041 c310 0041     ..A...A...A...A.
20000194:	c32c 0041 c33c 0041 c350 0041 c36c 0041     ,.A.<.A.P.A.l.A.
200001a4:	c38c 0041 c3a8 0041 c3c8 0041 c3e4 0041     ..A...A...A...A.
200001b4:	c404 0041 c41c 0041 c438 0041 c444 0041     ..A...A.8.A.D.A.
200001c4:	c454 0041 c46c 0041 c484 0041 c498 0041     T.A.l.A...A...A.
200001d4:	c4b0 0041 c4d0 0041 c4f4 0041 c508 0041     ..A...A...A...A.
200001e4:	c520 0041 c538 0041 c550 0041 c564 0041      .A.8.A.P.A.d.A.
200001f4:	c57c 0041 c594 0041 c5b0 0041 c5c8 0041     |.A...A...A...A.
20000204:	c5e4 0041 c5f0 0041 c600 0041 c60c 0041     ..A...A...A...A.
20000214:	c61c 0041 c628 0041 c638 0041 c648 0041     ..A.(.A.8.A.H.A.
20000224:	c658 0041 c664 0041 c674 0041 c684 0041     X.A.d.A.t.A...A.
20000234:	c694 0041 c6b0 0041 c6cc 0041 c6e4 0041     ..A...A...A...A.
20000244:	c6fc 0041 c714 0041 c730 0041 c748 0041     ..A...A.0.A.H.A.
20000254:	c764 0041 c77c 0041 c798 0041 c7a4 0041     d.A.|.A...A...A.
20000264:	c7b4 0041 c7c4 0041 c7d4 0041 c7e4 0041     ..A...A...A...A.
20000274:	c7f8 0041 c804 0041 c814 0041 c82c 0041     ..A...A...A.,.A.
20000284:	c848 0041 c85c 0041 c874 0041 c88c 0041     H.A.\.A.t.A...A.
20000294:	c8a8 0041 c8c4 0041 c8e4 0041 c900 0041     ..A...A...A...A.
200002a4:	c920 0041 c930 0041 c944 0041 c954 0041      .A.0.A.D.A.T.A.
200002b4:	c964 0041 c964 0041 c978 0041 c988 0041     d.A.d.A.x.A...A.
200002c4:	c99c 0041 c9ac 0041 c9c0 0041 c9d0 0041     ..A...A...A...A.
200002d4:	c9e4 0041 c9f4 0041 ca08 0041 ca18 0041     ..A...A...A...A.
200002e4:	ca2c 0041 ca3c 0041 ca50 0041 ca60 0041     ,.A.<.A.P.A.`.A.
200002f4:	ca74 0041 ca84 0041 ca98 0041 caa4 0041     t.A...A...A...A.
20000304:	cab4 0041 cacc 0041 cae8 0041 cb00 0041     ..A...A...A...A.
20000314:	cb1c 0041 cb30 0041 cb48 0041 cb60 0041     ..A.0.A.H.A.`.A.
20000324:	cb7c 0041 cb9c 0041 cbbc 0041 cbd0 0041     |.A...A...A...A.
20000334:	cbe8 0041 cbfc 0041 cc14 0041 cc28 0041     ..A...A...A.(.A.
20000344:	cc40 0041 cc50 0041 0000 0000 0000 0000     @.A.P.A.........

20000354 <__fdlib_version>:
20000354:	0001 0000                                   ....

20000358 <_impure_ptr>:
20000358:	0360 2000 0000 0000                         `.. ....

20000360 <impure_data>:
20000360:	0000 0000 064c 2000 06b4 2000 071c 2000     ....L.. ... ... 
	...
20000408:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20000418:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000788 <__atexit_recursive_mutex>:
20000788:	1f84 2000                                   ... 

2000078c <__malloc_av_>:
	...
20000794:	078c 2000 078c 2000 0794 2000 0794 2000     ... ... ... ... 
200007a4:	079c 2000 079c 2000 07a4 2000 07a4 2000     ... ... ... ... 
200007b4:	07ac 2000 07ac 2000 07b4 2000 07b4 2000     ... ... ... ... 
200007c4:	07bc 2000 07bc 2000 07c4 2000 07c4 2000     ... ... ... ... 
200007d4:	07cc 2000 07cc 2000 07d4 2000 07d4 2000     ... ... ... ... 
200007e4:	07dc 2000 07dc 2000 07e4 2000 07e4 2000     ... ... ... ... 
200007f4:	07ec 2000 07ec 2000 07f4 2000 07f4 2000     ... ... ... ... 
20000804:	07fc 2000 07fc 2000 0804 2000 0804 2000     ... ... ... ... 
20000814:	080c 2000 080c 2000 0814 2000 0814 2000     ... ... ... ... 
20000824:	081c 2000 081c 2000 0824 2000 0824 2000     ... ... $.. $.. 
20000834:	082c 2000 082c 2000 0834 2000 0834 2000     ,.. ,.. 4.. 4.. 
20000844:	083c 2000 083c 2000 0844 2000 0844 2000     <.. <.. D.. D.. 
20000854:	084c 2000 084c 2000 0854 2000 0854 2000     L.. L.. T.. T.. 
20000864:	085c 2000 085c 2000 0864 2000 0864 2000     \.. \.. d.. d.. 
20000874:	086c 2000 086c 2000 0874 2000 0874 2000     l.. l.. t.. t.. 
20000884:	087c 2000 087c 2000 0884 2000 0884 2000     |.. |.. ... ... 
20000894:	088c 2000 088c 2000 0894 2000 0894 2000     ... ... ... ... 
200008a4:	089c 2000 089c 2000 08a4 2000 08a4 2000     ... ... ... ... 
200008b4:	08ac 2000 08ac 2000 08b4 2000 08b4 2000     ... ... ... ... 
200008c4:	08bc 2000 08bc 2000 08c4 2000 08c4 2000     ... ... ... ... 
200008d4:	08cc 2000 08cc 2000 08d4 2000 08d4 2000     ... ... ... ... 
200008e4:	08dc 2000 08dc 2000 08e4 2000 08e4 2000     ... ... ... ... 
200008f4:	08ec 2000 08ec 2000 08f4 2000 08f4 2000     ... ... ... ... 
20000904:	08fc 2000 08fc 2000 0904 2000 0904 2000     ... ... ... ... 
20000914:	090c 2000 090c 2000 0914 2000 0914 2000     ... ... ... ... 
20000924:	091c 2000 091c 2000 0924 2000 0924 2000     ... ... $.. $.. 
20000934:	092c 2000 092c 2000 0934 2000 0934 2000     ,.. ,.. 4.. 4.. 
20000944:	093c 2000 093c 2000 0944 2000 0944 2000     <.. <.. D.. D.. 
20000954:	094c 2000 094c 2000 0954 2000 0954 2000     L.. L.. T.. T.. 
20000964:	095c 2000 095c 2000 0964 2000 0964 2000     \.. \.. d.. d.. 
20000974:	096c 2000 096c 2000 0974 2000 0974 2000     l.. l.. t.. t.. 
20000984:	097c 2000 097c 2000 0984 2000 0984 2000     |.. |.. ... ... 
20000994:	098c 2000 098c 2000 0994 2000 0994 2000     ... ... ... ... 
200009a4:	099c 2000 099c 2000 09a4 2000 09a4 2000     ... ... ... ... 
200009b4:	09ac 2000 09ac 2000 09b4 2000 09b4 2000     ... ... ... ... 
200009c4:	09bc 2000 09bc 2000 09c4 2000 09c4 2000     ... ... ... ... 
200009d4:	09cc 2000 09cc 2000 09d4 2000 09d4 2000     ... ... ... ... 
200009e4:	09dc 2000 09dc 2000 09e4 2000 09e4 2000     ... ... ... ... 
200009f4:	09ec 2000 09ec 2000 09f4 2000 09f4 2000     ... ... ... ... 
20000a04:	09fc 2000 09fc 2000 0a04 2000 0a04 2000     ... ... ... ... 
20000a14:	0a0c 2000 0a0c 2000 0a14 2000 0a14 2000     ... ... ... ... 
20000a24:	0a1c 2000 0a1c 2000 0a24 2000 0a24 2000     ... ... $.. $.. 
20000a34:	0a2c 2000 0a2c 2000 0a34 2000 0a34 2000     ,.. ,.. 4.. 4.. 
20000a44:	0a3c 2000 0a3c 2000 0a44 2000 0a44 2000     <.. <.. D.. D.. 
20000a54:	0a4c 2000 0a4c 2000 0a54 2000 0a54 2000     L.. L.. T.. T.. 
20000a64:	0a5c 2000 0a5c 2000 0a64 2000 0a64 2000     \.. \.. d.. d.. 
20000a74:	0a6c 2000 0a6c 2000 0a74 2000 0a74 2000     l.. l.. t.. t.. 
20000a84:	0a7c 2000 0a7c 2000 0a84 2000 0a84 2000     |.. |.. ... ... 
20000a94:	0a8c 2000 0a8c 2000 0a94 2000 0a94 2000     ... ... ... ... 
20000aa4:	0a9c 2000 0a9c 2000 0aa4 2000 0aa4 2000     ... ... ... ... 
20000ab4:	0aac 2000 0aac 2000 0ab4 2000 0ab4 2000     ... ... ... ... 
20000ac4:	0abc 2000 0abc 2000 0ac4 2000 0ac4 2000     ... ... ... ... 
20000ad4:	0acc 2000 0acc 2000 0ad4 2000 0ad4 2000     ... ... ... ... 
20000ae4:	0adc 2000 0adc 2000 0ae4 2000 0ae4 2000     ... ... ... ... 
20000af4:	0aec 2000 0aec 2000 0af4 2000 0af4 2000     ... ... ... ... 
20000b04:	0afc 2000 0afc 2000 0b04 2000 0b04 2000     ... ... ... ... 
20000b14:	0b0c 2000 0b0c 2000 0b14 2000 0b14 2000     ... ... ... ... 
20000b24:	0b1c 2000 0b1c 2000 0b24 2000 0b24 2000     ... ... $.. $.. 
20000b34:	0b2c 2000 0b2c 2000 0b34 2000 0b34 2000     ,.. ,.. 4.. 4.. 
20000b44:	0b3c 2000 0b3c 2000 0b44 2000 0b44 2000     <.. <.. D.. D.. 
20000b54:	0b4c 2000 0b4c 2000 0b54 2000 0b54 2000     L.. L.. T.. T.. 
20000b64:	0b5c 2000 0b5c 2000 0b64 2000 0b64 2000     \.. \.. d.. d.. 
20000b74:	0b6c 2000 0b6c 2000 0b74 2000 0b74 2000     l.. l.. t.. t.. 
20000b84:	0b7c 2000 0b7c 2000 0b84 2000 0b84 2000     |.. |.. ... ... 

20000b94 <__malloc_sbrk_base>:
20000b94:	ffff ffff                                   ....

20000b98 <__malloc_trim_threshold>:
20000b98:	0000 0002                                   ....

20000b9c <__global_locale>:
20000b9c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000bbc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000bdc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000bfc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c1c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c3c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c5c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c7c:	7fa1 0041 7c29 0041 0000 0000 d984 0041     ..A.)|A.......A.
20000c8c:	d980 0041 d824 0041 d824 0041 d824 0041     ..A.$.A.$.A.$.A.
20000c9c:	d824 0041 d824 0041 d824 0041 d824 0041     $.A.$.A.$.A.$.A.
20000cac:	d824 0041 d824 0041 ffff ffff ffff ffff     $.A.$.A.........
20000cbc:	ffff ffff ffff 0000 0001 5341 4943 0049     ..........ASCII.
	...
20000ce4:	0000 5341 4943 0049 0000 0000 0000 0000     ..ASCII.........
	...
